; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Dell\Desktop\vlmcsd\src\helpers.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5nume@ ; `string'
PUBLIC	??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@ ; `string'
PUBLIC	??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@	; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_C@_02LIELOMNJ@on?$AA@			; `string'
PUBLIC	??_C@_03ICICOMAL@yes?$AA@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_03MCADLMAF@off?$AA@			; `string'
PUBLIC	??_C@_02KAJCLHKP@no?$AA@			; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@ ; `string'
PUBLIC	??_C@_0M@OPCADLF@?2vlmcsd?4kmd?$AA@		; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0BH@GJJJGOK@Read?5KMS?5data?5file?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0DG@EIKFJMME@Warning?3?5Legacy?5database?3?5Some?5p@ ; `string'
PUBLIC	??_C@_03HOPJGLEN@KMD?$AA@			; `string'
PUBLIC	??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level?5@ ; `string'
EXTRN	__imp__exit:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__realloc:PROC
EXTRN	__imp__GetModuleHandleA@4:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__ftell:PROC
EXTRN	__imp__toupper:PROC
EXTRN	__imp__strrchr:PROC
EXTRN	__imp___strdup:PROC
EXTRN	__imp__srand:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__PathRemoveFileSpecA@4:PROC
EXTRN	__imp__strncpy:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__FormatMessageA@28:PROC
EXTRN	__imp__strchr:PROC
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp___strtoi64:PROC
EXTRN	__imp__strerror:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp___strnicmp:PROC
EXTRN	__imp__strncat:PROC
COMM	?buff@?1??gai_strerrorW@@9@9:WORD:0401H							; `gai_strerrorW'::`2'::buff
COMM	?buff@?1??gai_strerrorA@@9@9:BYTE:0401H							; `gai_strerrorA'::`2'::buff
_DATA	ENDS
;	COMDAT ??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level?5@
CONST	SEGMENT
??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level?5@ DB 'Fatal: Exi'
	DB	'ting on warning level %i or greater', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HOPJGLEN@KMD?$AA@
CONST	SEGMENT
??_C@_03HOPJGLEN@KMD?$AA@ DB 'KMD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EIKFJMME@Warning?3?5Legacy?5database?3?5Some?5p@
CONST	SEGMENT
??_C@_0DG@EIKFJMME@Warning?3?5Legacy?5database?3?5Some?5p@ DB 'Warning: L'
	DB	'egacy database: Some products are missing.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJJJGOK@Read?5KMS?5data?5file?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@GJJJGOK@Read?5KMS?5data?5file?5?$CFs?6?$AA@ DB 'Read KMS data f'
	DB	'ile %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OPCADLF@?2vlmcsd?4kmd?$AA@
CONST	SEGMENT
??_C@_0M@OPCADLF@?2vlmcsd?4kmd?$AA@ DB '\vlmcsd.kmd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@
CONST	SEGMENT
??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@ DB 'Fatal'
	DB	': %s is not a KMS data file', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6?$AA@ DB 'F'
	DB	'atal: Could not read %s: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAJCLHKP@no?$AA@
CONST	SEGMENT
??_C@_02KAJCLHKP@no?$AA@ DB 'no', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCADLMAF@off?$AA@
CONST	SEGMENT
??_C@_03MCADLMAF@off?$AA@ DB 'off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICICOMAL@yes?$AA@
CONST	SEGMENT
??_C@_03ICICOMAL@yes?$AA@ DB 'yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LIELOMNJ@on?$AA@
CONST	SEGMENT
??_C@_02LIELOMNJ@on?$AA@ DB 'on', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@
CONST	SEGMENT
??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@ DB '0123456789ABCDEF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@ DB 'Fatal: Out of memory'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5nume@
CONST	SEGMENT
??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5nume@ DB 'F'
	DB	'atal: Option "-%c" must be numeric between %u and %u.', 0aH, 00H ; `string'
?hexdigits@?1??hex2bin@@9@9 DD FLAT:??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@ ; `hex2bin'::`2'::hexdigits
PUBLIC	_exitOnWarningLevel
PUBLIC	_loadKmsData
PUBLIC	_getExeName
PUBLIC	_getArgumentBool
PUBLIC	_hex2bin
PUBLIC	_vlmcsd_strdup
PUBLIC	_vlmcsd_malloc
PUBLIC	_OutOfMemory
PUBLIC	_randomNumberInit
PUBLIC	_parseAddress
PUBLIC	_win_strerror
PUBLIC	_optReset
PUBLIC	_getOptionArgumentInt
PUBLIC	_timeSpanString2Seconds
PUBLIC	_stringToInt
PUBLIC	_ucs2_to_utf8
PUBLIC	_utf8_to_ucs2
PUBLIC	_ucs2_to_utf8_char
PUBLIC	_utf8_to_ucs2_char
?buffer@?1??win_strerror@@9@9 DB 0100H DUP (?)		; `win_strerror'::`2'::buffer
_BSS	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _utf8_to_ucs2_char
_TEXT	SEGMENT
tv166 = -1						; size = 1
_utf8_to_ucs2_char PROC					; COMDAT
; _input$ = ecx
; _end_ptr$ = edx

; 63   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 64   : 	*end_ptr = input;
; 65   : 	if (input[0] == 0)

  00005	8a 19		 mov	 bl, BYTE PTR [ecx]
  00007	89 0a		 mov	 DWORD PTR [edx], ecx
  00009	84 db		 test	 bl, bl
  0000b	74 6b		 je	 SHORT $LN2@utf8_to_uc

; 66   : 		return (WCHAR)~0;
; 67   : 
; 68   : 	if (input[0] < 0x80) {

  0000d	80 fb 80	 cmp	 bl, 128			; 00000080H
  00010	73 0a		 jae	 SHORT $LN6@utf8_to_uc

; 69   : 		*end_ptr = input + 1;

  00012	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00015	89 02		 mov	 DWORD PTR [edx], eax

; 70   : 		return LE16(input[0]);

  00017	0f b6 c3	 movzx	 eax, bl
  0001a	eb 61		 jmp	 SHORT $LN8@utf8_to_uc
$LN6@utf8_to_uc:

; 71   : 	}
; 72   : 
; 73   : 	if ((input[0] & 0xE0) == 0xE0) {

  0001c	8a c3		 mov	 al, bl
  0001e	24 e0		 and	 al, 224			; 000000e0H
  00020	3c e0		 cmp	 al, 224			; 000000e0H
  00022	75 2d		 jne	 SHORT $LN5@utf8_to_uc

; 74   : 
; 75   : 		if (input[1] == 0 || input[2] == 0)

  00024	8a 79 01	 mov	 bh, BYTE PTR [ecx+1]
  00027	84 ff		 test	 bh, bh
  00029	74 4d		 je	 SHORT $LN2@utf8_to_uc
  0002b	8a 41 02	 mov	 al, BYTE PTR [ecx+2]
  0002e	88 45 ff	 mov	 BYTE PTR tv166[ebp], al
  00031	84 c0		 test	 al, al
  00033	74 43		 je	 SHORT $LN2@utf8_to_uc

; 76   : 			return (WCHAR)~0;
; 77   : 
; 78   : 		*end_ptr = input + 3;

  00035	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]

; 79   : 
; 80   : 		return
; 81   : 			LE16((input[0] & 0x0F) << 12 |
; 82   : 			(input[1] & 0x3F) << 6 |
; 83   : 				(input[2] & 0x3F));

  00038	0f b6 cf	 movzx	 ecx, bh
  0003b	89 02		 mov	 DWORD PTR [edx], eax
  0003d	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00040	0f b6 c3	 movzx	 eax, bl
  00043	83 e0 0f	 and	 eax, 15			; 0000000fH
  00046	c1 e0 06	 shl	 eax, 6
  00049	0b c1		 or	 eax, ecx
  0004b	0f b6 4d ff	 movzx	 ecx, BYTE PTR tv166[ebp]
  0004f	eb 1d		 jmp	 SHORT $LN10@utf8_to_uc
$LN5@utf8_to_uc:

; 84   : 	}
; 85   : 
; 86   : 	if ((input[0] & 0xC0) == 0xC0) {

  00051	8a c3		 mov	 al, bl
  00053	24 c0		 and	 al, 192			; 000000c0H
  00055	3c c0		 cmp	 al, 192			; 000000c0H
  00057	75 1f		 jne	 SHORT $LN2@utf8_to_uc

; 87   : 		if (input[1] == 0)

  00059	8a 79 01	 mov	 bh, BYTE PTR [ecx+1]
  0005c	84 ff		 test	 bh, bh
  0005e	74 18		 je	 SHORT $LN2@utf8_to_uc

; 88   : 			return (WCHAR)~0;
; 89   : 
; 90   : 		*end_ptr = input + 2;

  00060	8d 41 02	 lea	 eax, DWORD PTR [ecx+2]

; 91   : 
; 92   : 		return
; 93   : 			LE16((input[0] & 0x1F) << 6 |
; 94   : 			(input[1] & 0x3F));

  00063	0f b6 cf	 movzx	 ecx, bh
  00066	89 02		 mov	 DWORD PTR [edx], eax
  00068	0f b6 c3	 movzx	 eax, bl
  0006b	83 e0 1f	 and	 eax, 31			; 0000001fH
$LN10@utf8_to_uc:
  0006e	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00071	c1 e0 06	 shl	 eax, 6
  00074	0b c1		 or	 eax, ecx
  00076	eb 05		 jmp	 SHORT $LN8@utf8_to_uc
$LN2@utf8_to_uc:

; 95   : 	}
; 96   : 	return (WCHAR)~0;

  00078	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
$LN8@utf8_to_uc:
  0007d	5b		 pop	 ebx

; 97   : }

  0007e	8b e5		 mov	 esp, ebp
  00080	5d		 pop	 ebp
  00081	c3		 ret	 0
_utf8_to_ucs2_char ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _ucs2_to_utf8_char
_TEXT	SEGMENT
_ucs2_to_utf8_char PROC					; COMDAT
; _ucs2_le$ = ecx
; _utf8$ = edx

; 104  : 	const WCHAR ucs2 = LE16(ucs2_le);
; 105  : 
; 106  : 	if (ucs2 < 0x80) {

  00000	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00005	66 3b c8	 cmp	 cx, ax
  00008	73 0a		 jae	 SHORT $LN8@ucs2_to_ut

; 107  : 		utf8[0] = (char)ucs2;
; 108  : 		utf8[1] = '\0';
; 109  : 		return 1;

  0000a	33 c0		 xor	 eax, eax
  0000c	88 0a		 mov	 BYTE PTR [edx], cl
  0000e	c6 42 01 00	 mov	 BYTE PTR [edx+1], 0
  00012	40		 inc	 eax

; 134  : }

  00013	c3		 ret	 0
$LN8@ucs2_to_ut:

; 110  : 	}
; 111  : 
; 112  : 	if (ucs2 >= 0x80 && ucs2 < 0x800) {

  00014	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  00019	66 3b c8	 cmp	 cx, ax
  0001c	73 1a		 jae	 SHORT $LN7@ucs2_to_ut

; 113  : 		utf8[0] = (char)((ucs2 >> 6) | 0xC0);

  0001e	8b c1		 mov	 eax, ecx

; 114  : 		utf8[1] = (char)((ucs2 & 0x3F) | 0x80);
; 115  : 		utf8[2] = '\0';

  00020	c6 42 02 00	 mov	 BYTE PTR [edx+2], 0
  00024	c1 e8 06	 shr	 eax, 6
  00027	80 e1 3f	 and	 cl, 63			; 0000003fH
  0002a	0c c0		 or	 al, -64			; ffffffc0H
  0002c	80 c9 80	 or	 cl, -128		; ffffff80H

; 116  : 		return 2;

  0002f	6a 02		 push	 2
  00031	88 02		 mov	 BYTE PTR [edx], al
  00033	88 4a 01	 mov	 BYTE PTR [edx+1], cl
  00036	58		 pop	 eax

; 134  : }

  00037	c3		 ret	 0
$LN7@ucs2_to_ut:

; 117  : 	}
; 118  : 
; 119  : 	if (ucs2 >= 0x800 && ucs2 < 0xFFFF) {

  00038	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0003d	66 3b c8	 cmp	 cx, ax
  00040	73 3a		 jae	 SHORT $LN2@ucs2_to_ut

; 120  : 
; 121  : 		if (ucs2 >= 0xD800 && ucs2 <= 0xDFFF) {

  00042	56		 push	 esi
  00043	be ff 07 00 00	 mov	 esi, 2047		; 000007ffH
  00048	8d 81 00 28 00
	00		 lea	 eax, DWORD PTR [ecx+10240]
  0004e	66 3b c6	 cmp	 ax, si
  00051	5e		 pop	 esi
  00052	76 28		 jbe	 SHORT $LN2@ucs2_to_ut

; 122  : 			/* Ill-formed (UTF-16 ouside of BMP) */
; 123  : 			return -1;
; 124  : 		}
; 125  : 
; 126  : 		utf8[0] = ((ucs2 >> 12)) | 0xE0;

  00054	66 8b c1	 mov	 ax, cx

; 127  : 		utf8[1] = ((ucs2 >> 6) & 0x3F) | 0x80;
; 128  : 		utf8[2] = ((ucs2) & 0x3F) | 0x80;
; 129  : 		utf8[3] = '\0';

  00057	c6 42 03 00	 mov	 BYTE PTR [edx+3], 0
  0005b	66 c1 e8 0c	 shr	 ax, 12			; 0000000cH
  0005f	0c e0		 or	 al, -32			; ffffffe0H
  00061	88 02		 mov	 BYTE PTR [edx], al
  00063	8b c1		 mov	 eax, ecx
  00065	c1 e8 06	 shr	 eax, 6
  00068	80 e1 3f	 and	 cl, 63			; 0000003fH
  0006b	24 3f		 and	 al, 63			; 0000003fH
  0006d	0c 80		 or	 al, -128		; ffffff80H
  0006f	80 c9 80	 or	 cl, -128		; ffffff80H

; 130  : 		return 3;

  00072	6a 03		 push	 3
  00074	88 42 01	 mov	 BYTE PTR [edx+1], al
  00077	88 4a 02	 mov	 BYTE PTR [edx+2], cl
  0007a	58		 pop	 eax

; 134  : }

  0007b	c3		 ret	 0
$LN2@ucs2_to_ut:

; 131  : 	}
; 132  : 
; 133  : 	return -1;

  0007c	83 c8 ff	 or	 eax, -1

; 134  : }

  0007f	c3		 ret	 0
_ucs2_to_utf8_char ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _utf8_to_ucs2
_TEXT	SEGMENT
_current_utf8$ = -8					; size = 4
tv220 = -4						; size = 4
_maxucs2$dead$ = 8					; size = 4
_maxutf8$dead$ = 12					; size = 4
_utf8_to_ucs2 PROC					; COMDAT
; _ucs2_le$ = ecx
; _utf8$ = edx

; 139  : {

  00000	51		 push	 ecx
  00001	51		 push	 ecx
  00002	53		 push	 ebx
  00003	55		 push	 ebp
  00004	56		 push	 esi
  00005	8b ea		 mov	 ebp, edx
  00007	57		 push	 edi
  00008	8b f9		 mov	 edi, ecx

; 140  : 	const unsigned char* current_utf8 = (unsigned char*)utf8;

  0000a	8b cd		 mov	 ecx, ebp
  0000c	89 4c 24 10	 mov	 DWORD PTR _current_utf8$[esp+24], ecx

; 141  : 	WCHAR* current_ucs2_le = ucs2_le;

  00010	8b f7		 mov	 esi, edi

; 142  : 
; 143  : 	for (; *current_utf8; current_ucs2_le++)

  00012	80 7d 00 00	 cmp	 BYTE PTR [ebp], 0
  00016	74 6e		 je	 SHORT $LN6@utf8_to_uc

; 140  : 	const unsigned char* current_utf8 = (unsigned char*)utf8;

  00018	6a fe		 push	 -2			; fffffffeH
  0001a	58		 pop	 eax
  0001b	2b c7		 sub	 eax, edi
  0001d	89 44 24 14	 mov	 DWORD PTR tv220[esp+24], eax
$LL8@utf8_to_uc:

; 144  : 	{
; 145  : 		size_t size = (char*)current_utf8 - utf8;

  00021	8b d1		 mov	 edx, ecx
  00023	2b d5		 sub	 edx, ebp

; 146  : 
; 147  : 		if (size >= maxutf8) return (size_t)-1;

  00025	81 fa c0 00 00
	00		 cmp	 edx, 192		; 000000c0H
  0002b	73 66		 jae	 SHORT $LN12@utf8_to_uc

; 148  : 		if (((*current_utf8 & 0xc0) == 0xc0) && (size >= maxutf8 - 1)) return (size_t)-1;

  0002d	8a 19		 mov	 bl, BYTE PTR [ecx]
  0002f	8a c3		 mov	 al, bl
  00031	24 c0		 and	 al, 192			; 000000c0H
  00033	3c c0		 cmp	 al, 192			; 000000c0H
  00035	75 08		 jne	 SHORT $LN4@utf8_to_uc
  00037	81 fa bf 00 00
	00		 cmp	 edx, 191		; 000000bfH
  0003d	73 54		 jae	 SHORT $LN12@utf8_to_uc
$LN4@utf8_to_uc:

; 149  : 		if (((*current_utf8 & 0xe0) == 0xe0) && (size >= maxutf8 - 2)) return (size_t)-1;

  0003f	80 e3 e0	 and	 bl, 224			; 000000e0H
  00042	80 fb e0	 cmp	 bl, 224			; 000000e0H
  00045	75 08		 jne	 SHORT $LN3@utf8_to_uc
  00047	81 fa be 00 00
	00		 cmp	 edx, 190		; 000000beH
  0004d	73 44		 jae	 SHORT $LN12@utf8_to_uc
$LN3@utf8_to_uc:

; 150  : 		if (current_ucs2_le - ucs2_le >= (intptr_t)maxucs2 - 1) return (size_t)-1;

  0004f	8b 44 24 14	 mov	 eax, DWORD PTR tv220[esp+24]
  00053	8d 5e 02	 lea	 ebx, DWORD PTR [esi+2]
  00056	03 c3		 add	 eax, ebx
  00058	83 e0 fe	 and	 eax, -2			; fffffffeH
  0005b	83 f8 7e	 cmp	 eax, 126		; 0000007eH
  0005e	7d 33		 jge	 SHORT $LN12@utf8_to_uc

; 151  : 
; 152  : 		*current_ucs2_le = utf8_to_ucs2_char(current_utf8, &current_utf8);

  00060	8d 54 24 10	 lea	 edx, DWORD PTR _current_utf8$[esp+24]
  00064	e8 00 00 00 00	 call	 _utf8_to_ucs2_char
  00069	66 89 06	 mov	 WORD PTR [esi], ax

; 153  : 		current_ucs2_le[1] = 0;

  0006c	33 c0		 xor	 eax, eax
  0006e	66 89 03	 mov	 WORD PTR [ebx], ax

; 154  : 
; 155  : 		if (*current_ucs2_le == (WCHAR)-1) return (size_t)-1;

  00071	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00076	66 39 06	 cmp	 WORD PTR [esi], ax
  00079	74 18		 je	 SHORT $LN12@utf8_to_uc

; 142  : 
; 143  : 	for (; *current_utf8; current_ucs2_le++)

  0007b	8b 4c 24 10	 mov	 ecx, DWORD PTR _current_utf8$[esp+24]
  0007f	8b f3		 mov	 esi, ebx
  00081	80 39 00	 cmp	 BYTE PTR [ecx], 0
  00084	75 9b		 jne	 SHORT $LL8@utf8_to_uc
$LN6@utf8_to_uc:

; 156  : 	}
; 157  : 	return current_ucs2_le - ucs2_le;

  00086	2b f7		 sub	 esi, edi
  00088	d1 fe		 sar	 esi, 1
  0008a	8b c6		 mov	 eax, esi
$LN9@utf8_to_uc:
  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5d		 pop	 ebp
  0008f	5b		 pop	 ebx

; 158  : }

  00090	59		 pop	 ecx
  00091	59		 pop	 ecx
  00092	c3		 ret	 0
$LN12@utf8_to_uc:

; 146  : 
; 147  : 		if (size >= maxutf8) return (size_t)-1;

  00093	83 c8 ff	 or	 eax, -1
  00096	eb f4		 jmp	 SHORT $LN9@utf8_to_uc
_utf8_to_ucs2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _ucs2_to_utf8
_TEXT	SEGMENT
_utf8_char$ = -4					; size = 4
_maxucs2$dead$ = 8					; size = 4
_maxutf8$ = 12						; size = 4
_ucs2_to_utf8 PROC					; COMDAT
; _ucs2_le$ = ecx
; _utf8$ = edx

; 162  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	8b da		 mov	 ebx, edx
  00006	8b f1		 mov	 esi, ecx

; 165  : 	unsigned int index_utf8 = 0;

  00008	33 c0		 xor	 eax, eax
  0000a	57		 push	 edi
  0000b	8b e8		 mov	 ebp, eax

; 166  : 
; 167  : 	for (*utf8 = 0; *current_ucs2; current_ucs2++)

  0000d	88 03		 mov	 BYTE PTR [ebx], al
  0000f	66 39 06	 cmp	 WORD PTR [esi], ax
  00012	74 3d		 je	 SHORT $LN3@ucs2_to_ut

; 163  : 	char utf8_char[4];
; 164  : 	const WCHAR* current_ucs2 = ucs2_le;

  00014	8b f8		 mov	 edi, eax
$LL5@ucs2_to_ut:

; 168  : 	{
; 169  : 		if (current_ucs2 - ucs2_le > (intptr_t)maxucs2) return FALSE;

  00016	8b c7		 mov	 eax, edi
  00018	83 e0 fe	 and	 eax, -2			; fffffffeH
  0001b	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00020	7f 38		 jg	 SHORT $LN9@ucs2_to_ut

; 170  : 		int len = ucs2_to_utf8_char(*current_ucs2, utf8_char);

  00022	66 8b 0e	 mov	 cx, WORD PTR [esi]
  00025	8d 54 24 10	 lea	 edx, DWORD PTR _utf8_char$[esp+20]
  00029	e8 00 00 00 00	 call	 _ucs2_to_utf8_char

; 171  : 		if (index_utf8 + len > maxutf8) return FALSE;

  0002e	03 e8		 add	 ebp, eax
  00030	3b 6c 24 1c	 cmp	 ebp, DWORD PTR _maxutf8$[esp+16]
  00034	77 24		 ja	 SHORT $LN9@ucs2_to_ut

; 172  : 		strncat(utf8, utf8_char, len);

  00036	50		 push	 eax
  00037	8b c2		 mov	 eax, edx
  00039	50		 push	 eax
  0003a	53		 push	 ebx
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncat
  00041	83 c6 02	 add	 esi, 2
  00044	33 c0		 xor	 eax, eax
  00046	83 c4 0c	 add	 esp, 12			; 0000000cH
  00049	83 c7 02	 add	 edi, 2
  0004c	66 39 06	 cmp	 WORD PTR [esi], ax
  0004f	75 c5		 jne	 SHORT $LL5@ucs2_to_ut
$LN3@ucs2_to_ut:

; 173  : 		index_utf8 += len;
; 174  : 	}
; 175  : 
; 176  : 	return TRUE;

  00051	33 c0		 xor	 eax, eax
  00053	40		 inc	 eax
$LN6@ucs2_to_ut:
  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5d		 pop	 ebp
  00057	5b		 pop	 ebx

; 177  : }

  00058	59		 pop	 ecx
  00059	c3		 ret	 0
$LN9@ucs2_to_ut:

; 168  : 	{
; 169  : 		if (current_ucs2 - ucs2_le > (intptr_t)maxucs2) return FALSE;

  0005a	33 c0		 xor	 eax, eax
  0005c	eb f6		 jmp	 SHORT $LN6@ucs2_to_ut
_ucs2_to_utf8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _stringToInt
_TEXT	SEGMENT
_nextchar$ = -4						; size = 4
_max$ = 8						; size = 4
_value$ = 12						; size = 4
_stringToInt PROC					; COMDAT
; _szValue$ = ecx
; _min$ = edx

; 184  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	8b ea		 mov	 ebp, edx
  00006	8b f1		 mov	 esi, ecx

; 185  : 	char *nextchar;
; 186  : 
; 187  : 	errno = 0;

  00008	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno

; 188  : 	long long result = vlmcsd_strtoll(szValue, &nextchar, 10);

  0000e	6a 0a		 push	 10			; 0000000aH
  00010	83 20 00	 and	 DWORD PTR [eax], 0
  00013	8d 44 24 10	 lea	 eax, DWORD PTR _nextchar$[esp+20]
  00017	50		 push	 eax
  00018	56		 push	 esi
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strtoi64
  0001f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00022	8b f0		 mov	 esi, eax
  00024	8b da		 mov	 ebx, edx

; 189  : 
; 190  : 	if (errno || result < (long long)min || result >(long long)max || *nextchar)

  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0002c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002f	75 2a		 jne	 SHORT $LN1@stringToIn
  00031	85 db		 test	 ebx, ebx
  00033	7c 26		 jl	 SHORT $LN1@stringToIn
  00035	7f 24		 jg	 SHORT $LN1@stringToIn
  00037	3b f5		 cmp	 esi, ebp
  00039	72 20		 jb	 SHORT $LN1@stringToIn
  0003b	85 db		 test	 ebx, ebx
  0003d	7f 1c		 jg	 SHORT $LN1@stringToIn
  0003f	7c 06		 jl	 SHORT $LN6@stringToIn
  00041	3b 74 24 14	 cmp	 esi, DWORD PTR _max$[esp+12]
  00045	77 14		 ja	 SHORT $LN1@stringToIn
$LN6@stringToIn:
  00047	8b 44 24 0c	 mov	 eax, DWORD PTR _nextchar$[esp+16]
  0004b	80 38 00	 cmp	 BYTE PTR [eax], 0
  0004e	75 0b		 jne	 SHORT $LN1@stringToIn

; 193  : 	}
; 194  : 
; 195  : 	*value = (unsigned int)result;

  00050	8b 44 24 18	 mov	 eax, DWORD PTR _value$[esp+12]
  00054	89 30		 mov	 DWORD PTR [eax], esi

; 196  : 	return TRUE;

  00056	33 c0		 xor	 eax, eax
  00058	40		 inc	 eax
  00059	eb 02		 jmp	 SHORT $LN3@stringToIn
$LN1@stringToIn:

; 191  : 	{
; 192  : 		return FALSE;

  0005b	33 c0		 xor	 eax, eax
$LN3@stringToIn:
  0005d	5e		 pop	 esi
  0005e	5d		 pop	 ebp
  0005f	5b		 pop	 ebx

; 197  : }

  00060	59		 pop	 ecx
  00061	c3		 ret	 0
_stringToInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _timeSpanString2Seconds
_TEXT	SEGMENT
_val$ = -8						; size = 8
_unitId$ = -4						; size = 4
_timeSpanString2Seconds PROC				; COMDAT
; _argument$ = ecx

; 234  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi

; 235  : 	char *unitId;
; 236  : 
; 237  : 	long long val = vlmcsd_strtoll(argument, &unitId, 10);

  00008	6a 0a		 push	 10			; 0000000aH
  0000a	8d 45 fc	 lea	 eax, DWORD PTR _unitId$[ebp]
  0000d	50		 push	 eax
  0000e	51		 push	 ecx
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strtoi64

; 238  : 
; 239  : 	switch (toupper((int)*unitId))

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _unitId$[ebp]
  00018	8b f0		 mov	 esi, eax
  0001a	8b fa		 mov	 edi, edx
  0001c	0f be 09	 movsx	 ecx, BYTE PTR [ecx]
  0001f	51		 push	 ecx
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  00026	83 c4 10	 add	 esp, 16			; 00000010H
  00029	33 db		 xor	 ebx, ebx
  0002b	85 c0		 test	 eax, eax
  0002d	74 47		 je	 SHORT $LN5@timeSpanSt
  0002f	83 f8 44	 cmp	 eax, 68			; 00000044H
  00032	74 26		 je	 SHORT $LN7@timeSpanSt
  00034	83 f8 48	 cmp	 eax, 72			; 00000048H
  00037	74 2f		 je	 SHORT $LN6@timeSpanSt
  00039	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  0003c	74 38		 je	 SHORT $LN5@timeSpanSt
  0003e	83 f8 53	 cmp	 eax, 83			; 00000053H
  00041	74 41		 je	 SHORT $LN4@timeSpanSt
  00043	83 f8 57	 cmp	 eax, 87			; 00000057H
  00046	74 04		 je	 SHORT $LN8@timeSpanSt
$LN14@timeSpanSt:

; 250  : 	case 'S':
; 251  : 		break;
; 252  : 	default:
; 253  : 		return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	eb 57		 jmp	 SHORT $LN11@timeSpanSt
$LN8@timeSpanSt:

; 240  : 	{
; 241  : 	case 'W':
; 242  : 		val *= 7;

  0004c	53		 push	 ebx
  0004d	6a 07		 push	 7
  0004f	57		 push	 edi
  00050	56		 push	 esi
  00051	e8 00 00 00 00	 call	 __allmul
  00056	8b f0		 mov	 esi, eax
  00058	8b fa		 mov	 edi, edx
$LN7@timeSpanSt:

; 243  : 	case 'D':
; 244  : 		val *= 24;

  0005a	53		 push	 ebx
  0005b	6a 18		 push	 24			; 00000018H
  0005d	57		 push	 edi
  0005e	56		 push	 esi
  0005f	e8 00 00 00 00	 call	 __allmul
  00064	8b f0		 mov	 esi, eax
  00066	8b fa		 mov	 edi, edx
$LN6@timeSpanSt:

; 245  : 	case 'H':
; 246  : 		val *= 60;

  00068	53		 push	 ebx
  00069	6a 3c		 push	 60			; 0000003cH
  0006b	57		 push	 edi
  0006c	56		 push	 esi
  0006d	e8 00 00 00 00	 call	 __allmul
  00072	8b f0		 mov	 esi, eax
  00074	8b fa		 mov	 edi, edx
$LN5@timeSpanSt:

; 247  : 	case 0:
; 248  : 	case 'M':
; 249  : 		val *= 60;

  00076	53		 push	 ebx
  00077	6a 3c		 push	 60			; 0000003cH
  00079	57		 push	 edi
  0007a	56		 push	 esi
  0007b	e8 00 00 00 00	 call	 __allmul
  00080	8b f0		 mov	 esi, eax
  00082	8b fa		 mov	 edi, edx
$LN4@timeSpanSt:

; 254  : 	}
; 255  : 
; 256  : 	if (*unitId && unitId[1]) return 0;

  00084	8b 45 fc	 mov	 eax, DWORD PTR _unitId$[ebp]
  00087	38 18		 cmp	 BYTE PTR [eax], bl
  00089	74 05		 je	 SHORT $LN2@timeSpanSt
  0008b	38 58 01	 cmp	 BYTE PTR [eax+1], bl
  0008e	75 b8		 jne	 SHORT $LN14@timeSpanSt
$LN2@timeSpanSt:

; 257  : 	if (val < 1) val = 1;

  00090	3b fb		 cmp	 edi, ebx
  00092	7f 0d		 jg	 SHORT $LN1@timeSpanSt
  00094	7c 05		 jl	 SHORT $LN13@timeSpanSt
  00096	83 fe 01	 cmp	 esi, 1
  00099	73 06		 jae	 SHORT $LN1@timeSpanSt
$LN13@timeSpanSt:
  0009b	33 f6		 xor	 esi, esi
  0009d	89 5d fc	 mov	 DWORD PTR _val$[ebp+4], ebx
  000a0	46		 inc	 esi
$LN1@timeSpanSt:

; 258  : 	return (DWORD)(val & UINT_MAX);

  000a1	8b c6		 mov	 eax, esi
$LN11@timeSpanSt:

; 259  : }

  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
_timeSpanString2Seconds ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _getOptionArgumentInt
_TEXT	SEGMENT
_result$ = -4						; size = 4
_max$ = 8						; size = 4
_getOptionArgumentInt PROC				; COMDAT
; _o$ = cl
; _min$ = edx

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi

; 266  : 	unsigned int result;
; 267  : 
; 268  : 	if (!stringToInt(optarg, min, max, &result))

  00006	8d 45 fc	 lea	 eax, DWORD PTR _result$[ebp]
  00009	8a d9		 mov	 bl, cl
  0000b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optarg
  00011	8b f2		 mov	 esi, edx
  00013	50		 push	 eax
  00014	ff 75 08	 push	 DWORD PTR _max$[ebp]
  00017	e8 00 00 00 00	 call	 _stringToInt
  0001c	59		 pop	 ecx
  0001d	59		 pop	 ecx
  0001e	85 c0		 test	 eax, eax
  00020	75 1d		 jne	 SHORT $LN1@getOptionA

; 269  : 	{
; 270  : 		printerrorf("Fatal: Option \"-%c\" must be numeric between %u and %u.\n", o, min, max);

  00022	ff 75 08	 push	 DWORD PTR _max$[ebp]
  00025	0f be c3	 movsx	 eax, bl
  00028	56		 push	 esi
  00029	50		 push	 eax
  0002a	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5nume@
  0002f	e8 00 00 00 00	 call	 _printerrorf
  00034	83 c4 10	 add	 esp, 16			; 00000010H

; 271  : 		exit(VLMCSD_EINVAL);

  00037	6a 57		 push	 87			; 00000057H
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN6@getOptionA:
$LN1@getOptionA:

; 272  : 	}
; 273  : 
; 274  : 	return result;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _result$[ebp]
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx

; 275  : }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
$LN5@getOptionA:
_getOptionArgumentInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _optReset
_TEXT	SEGMENT
_optReset PROC						; COMDAT

; 280  : #if __minix__ || defined(__BSD__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__OpenBSD__)
; 281  : 	optind = 1;
; 282  : 	optreset = 1; // Makes newer BSD getopt happy
; 283  : #elif defined(__UCLIBC__) // uClibc headers also define __GLIBC__ so be careful here
; 284  : 	optind = 0; // uClibc seeks compatibility with GLIBC
; 285  : #elif defined(__GLIBC__)
; 286  : 	optind = 0; // Makes GLIBC getopt happy
; 287  : #else // Standard for most systems
; 288  : 	optind = 1;

  00000	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _optind, 1

; 289  : #endif
; 290  : }

  0000a	c3		 ret	 0
_optReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _win_strerror
_TEXT	SEGMENT
_win_strerror PROC					; COMDAT
; _message$ = ecx

; 297  : {

  00000	56		 push	 esi

; 298  : #define STRERROR_BUFFER_SIZE 256
; 299  : 	static char buffer[STRERROR_BUFFER_SIZE];
; 300  : 
; 301  : 	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK, NULL, message, 0, buffer, STRERROR_BUFFER_SIZE, NULL);

  00001	33 d2		 xor	 edx, edx
  00003	be 00 00 00 00	 mov	 esi, OFFSET ?buffer@?1??win_strerror@@9@9
  00008	52		 push	 edx
  00009	68 00 01 00 00	 push	 256			; 00000100H
  0000e	56		 push	 esi
  0000f	52		 push	 edx
  00010	51		 push	 ecx
  00011	52		 push	 edx
  00012	68 ff 12 00 00	 push	 4863			; 000012ffH
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28

; 302  : 	return buffer;

  0001d	8b c6		 mov	 eax, esi
  0001f	5e		 pop	 esi

; 303  : }

  00020	c3		 ret	 0
_win_strerror ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _parseAddress
_TEXT	SEGMENT
_lastcolon$1$ = -4					; size = 4
_szPort$ = 8						; size = 4
_parseAddress PROC					; COMDAT
; _addr$ = ecx
; _szHost$ = edx

; 313  : {

  00000	51		 push	 ecx

; 314  : 	*szHost = addr;
; 315  : 
; 316  : #	ifndef NO_SOCKETS
; 317  : 	*szPort = (char*)defaultport;

  00001	a1 00 00 00 00	 mov	 eax, DWORD PTR _defaultport
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	57		 push	 edi
  00009	8b f9		 mov	 edi, ecx
  0000b	8b ea		 mov	 ebp, edx
  0000d	8b 4c 24 14	 mov	 ecx, DWORD PTR _szPort$[esp+12]

; 318  : #	else // NO_SOCKETS
; 319  : 	*szPort = "1688";
; 320  : #	endif // NO_SOCKETS
; 321  : 
; 322  : 	char *lastcolon = strrchr(addr, ':');

  00011	6a 3a		 push	 58			; 0000003aH
  00013	57		 push	 edi
  00014	89 7d 00	 mov	 DWORD PTR [ebp], edi
  00017	89 01		 mov	 DWORD PTR [ecx], eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strrchr

; 323  : 	char *firstcolon = strchr(addr, ':');

  0001f	6a 3a		 push	 58			; 0000003aH
  00021	57		 push	 edi
  00022	89 44 24 1c	 mov	 DWORD PTR _lastcolon$1$[esp+32], eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr

; 324  : 	char *closingbracket = strrchr(addr, ']');

  0002c	6a 5d		 push	 93			; 0000005dH
  0002e	57		 push	 edi
  0002f	8b d8		 mov	 ebx, eax
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strrchr
  00037	83 c4 18	 add	 esp, 24			; 00000018H

; 325  : 
; 326  : 	if (*addr == '[' && closingbracket) //Address in brackets

  0003a	80 3f 5b	 cmp	 BYTE PTR [edi], 91	; 0000005bH
  0003d	75 15		 jne	 SHORT $LN4@parseAddre
  0003f	85 c0		 test	 eax, eax
  00041	74 11		 je	 SHORT $LN4@parseAddre

; 327  : 	{
; 328  : 		*closingbracket = 0;
; 329  : 		(*szHost)++;

  00043	ff 45 00	 inc	 DWORD PTR [ebp]
  00046	c6 00 00	 mov	 BYTE PTR [eax], 0

; 330  : 
; 331  : 		if (closingbracket[1] == ':')

  00049	80 78 01 3a	 cmp	 BYTE PTR [eax+1], 58	; 0000003aH
  0004d	75 1b		 jne	 SHORT $LN1@parseAddre

; 332  : 			*szPort = closingbracket + 2;

  0004f	83 c0 02	 add	 eax, 2

; 333  : 	}
; 334  : 	else if (firstcolon && firstcolon == lastcolon) //IPv4 address or hostname with port

  00052	eb 10		 jmp	 SHORT $LN7@parseAddre
$LN4@parseAddre:
  00054	85 db		 test	 ebx, ebx
  00056	74 12		 je	 SHORT $LN1@parseAddre
  00058	3b 5c 24 0c	 cmp	 ebx, DWORD PTR _lastcolon$1$[esp+16]
  0005c	75 0c		 jne	 SHORT $LN1@parseAddre

; 335  : 	{
; 336  : 		*firstcolon = 0;

  0005e	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 337  : 		*szPort = firstcolon + 1;

  00061	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
$LN7@parseAddre:
  00064	8b 4c 24 14	 mov	 ecx, DWORD PTR _szPort$[esp+12]
  00068	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@parseAddre:
  0006a	5f		 pop	 edi
  0006b	5d		 pop	 ebp
  0006c	5b		 pop	 ebx

; 338  : 	}
; 339  : }

  0006d	59		 pop	 ecx
  0006e	c3		 ret	 0
_parseAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _randomNumberInit
_TEXT	SEGMENT
_randomNumberInit PROC					; COMDAT

; 345  : #	if _MSC_VER
; 346  : 	srand(GetTickCount());

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  00006	50		 push	 eax
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand
  0000d	59		 pop	 ecx

; 347  : #	else
; 348  : 	struct timeval tv;
; 349  : 	gettimeofday(&tv, NULL);
; 350  : 	srand((unsigned int)(tv.tv_sec ^ tv.tv_usec));
; 351  : #	endif
; 352  : }

  0000e	c3		 ret	 0
_randomNumberInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _OutOfMemory
_TEXT	SEGMENT
_OutOfMemory PROC					; COMDAT

; 358  : 	errorout("Fatal: Out of memory");

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  00005	e8 00 00 00 00	 call	 _errorout
  0000a	59		 pop	 ecx

; 359  : 	exit(VLMCSD_ENOMEM);

  0000b	6a 0e		 push	 14			; 0000000eH
  0000d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN4@OutOfMemor:
$LN3@OutOfMemor:
  00013	cc		 int	 3
_OutOfMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _vlmcsd_malloc
_TEXT	SEGMENT
_vlmcsd_malloc PROC					; COMDAT

; 365  : 	void* buf = malloc(len);
; 366  : 	if (!buf) OutOfMemory();

  00000	e9 00 00 00 00	 jmp	 _OutOfMemory
_vlmcsd_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _vlmcsd_strdup
_TEXT	SEGMENT
_vlmcsd_strdup PROC					; COMDAT

; 372  : #	if _MSC_VER
; 373  : 	char* dst = _strdup(src);
; 374  : #	else // !_MSC_VER
; 375  : 	char* dst = strdup(src);
; 376  : #	endif
; 377  : 
; 378  : 	if (!dst) OutOfMemory();

  00000	e9 00 00 00 00	 jmp	 _OutOfMemory
_vlmcsd_strdup ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _hex2bin
_TEXT	SEGMENT
_nextchar$ = -12					; size = 4
tv168 = -8						; size = 4
_pos$1$ = -4						; size = 4
_maxbin$dead$ = 8					; size = 4
_hex2bin PROC						; COMDAT
; _bin$ = ecx
; _hex$ = edx

; 388  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b fa		 mov	 edi, edx

; 389  : 	static const char *const hexdigits = "0123456789ABCDEF";
; 390  : 	char* nextchar;
; 391  : 	size_t i;
; 392  : 
; 393  : 	for (i = 0; (i < 16) && utf8_to_ucs2_char((const unsigned char*)hex, (const unsigned char**)&nextchar) != (WCHAR)-1; hex = nextchar)

  0000b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv168[ebp], OFFSET ??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@
  00012	8b d9		 mov	 ebx, ecx
  00014	33 f6		 xor	 esi, esi
$LL7@hex2bin:
  00016	8d 55 f4	 lea	 edx, DWORD PTR _nextchar$[ebp]
  00019	8b cf		 mov	 ecx, edi
  0001b	e8 00 00 00 00	 call	 _utf8_to_ucs2_char
  00020	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00025	66 3b c1	 cmp	 ax, cx
  00028	74 5d		 je	 SHORT $LN11@hex2bin

; 394  : 	{
; 395  : 		const char* pos = strchr(hexdigits, toupper((int)*hex));

  0002a	0f be 07	 movsx	 eax, BYTE PTR [edi]
  0002d	50		 push	 eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__toupper
  00034	50		 push	 eax
  00035	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  00041	8b c8		 mov	 ecx, eax
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	89 4d fc	 mov	 DWORD PTR _pos$1$[ebp], ecx

; 396  : 		if (!pos) continue;

  00049	85 c9		 test	 ecx, ecx
  0004b	74 32		 je	 SHORT $LN6@hex2bin

; 397  : 
; 398  : 		if (!(i & 1)) bin[i >> 1] = 0;

  0004d	8b d6		 mov	 edx, esi
  0004f	83 e2 01	 and	 edx, 1
  00052	75 09		 jne	 SHORT $LN3@hex2bin
  00054	8b ce		 mov	 ecx, esi
  00056	d1 e9		 shr	 ecx, 1
  00058	88 14 19	 mov	 BYTE PTR [ecx+ebx], dl
  0005b	8b c8		 mov	 ecx, eax
$LN3@hex2bin:

; 399  : 		bin[i >> 1] |= (char)(pos - hexdigits);

  0005d	2a 4d f8	 sub	 cl, BYTE PTR tv168[ebp]
  00060	8b c6		 mov	 eax, esi
  00062	d1 e8		 shr	 eax, 1
  00064	08 0c 18	 or	 BYTE PTR [eax+ebx], cl
  00067	8a 0c 18	 mov	 cl, BYTE PTR [eax+ebx]

; 400  : 		if (!(i & 1)) bin[i >> 1] <<= 4;

  0006a	85 d2		 test	 edx, edx
  0006c	75 06		 jne	 SHORT $LN2@hex2bin
  0006e	c0 e1 04	 shl	 cl, 4
  00071	88 0c 18	 mov	 BYTE PTR [eax+ebx], cl
$LN2@hex2bin:

; 401  : 		i++;

  00074	46		 inc	 esi

; 402  : 		if (i >> 1 > maxbin) break;

  00075	8b c6		 mov	 eax, esi
  00077	83 e0 fe	 and	 eax, -2			; fffffffeH
  0007a	83 f8 10	 cmp	 eax, 16			; 00000010H
  0007d	77 08		 ja	 SHORT $LN11@hex2bin
$LN6@hex2bin:

; 389  : 	static const char *const hexdigits = "0123456789ABCDEF";
; 390  : 	char* nextchar;
; 391  : 	size_t i;
; 392  : 
; 393  : 	for (i = 0; (i < 16) && utf8_to_ucs2_char((const unsigned char*)hex, (const unsigned char**)&nextchar) != (WCHAR)-1; hex = nextchar)

  0007f	8b 7d f4	 mov	 edi, DWORD PTR _nextchar$[ebp]
  00082	83 fe 10	 cmp	 esi, 16			; 00000010H
  00085	72 8f		 jb	 SHORT $LL7@hex2bin
$LN11@hex2bin:
  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx

; 403  : 	}
; 404  : }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_hex2bin ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _getArgumentBool
_TEXT	SEGMENT
_getArgumentBool PROC					; COMDAT
; _result$ = ecx
; _argument$ = edx

; 408  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 409  : 	if (
; 410  : 		!strncasecmp(argument, "true", 4) ||
; 411  : 		!strncasecmp(argument, "on", 2) ||
; 412  : 		!strncasecmp(argument, "yes", 3) ||
; 413  : 		!strncasecmp(argument, "1", 1)
; 414  : 		)

  00003	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp___strnicmp
  00009	8b f2		 mov	 esi, edx
  0000b	6a 04		 push	 4
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_04LOAJBDKD@true?$AA@
  00012	56		 push	 esi
  00013	8b d9		 mov	 ebx, ecx
  00015	ff d7		 call	 edi
  00017	83 c4 0c	 add	 esp, 12			; 0000000cH
  0001a	85 c0		 test	 eax, eax
  0001c	0f 84 80 00 00
	00		 je	 $LN4@getArgumen
  00022	6a 02		 push	 2
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_02LIELOMNJ@on?$AA@
  00029	56		 push	 esi
  0002a	ff d7		 call	 edi
  0002c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002f	85 c0		 test	 eax, eax
  00031	74 6f		 je	 SHORT $LN4@getArgumen
  00033	6a 03		 push	 3
  00035	68 00 00 00 00	 push	 OFFSET ??_C@_03ICICOMAL@yes?$AA@
  0003a	56		 push	 esi
  0003b	ff d7		 call	 edi
  0003d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00040	85 c0		 test	 eax, eax
  00042	74 5e		 je	 SHORT $LN4@getArgumen
  00044	6a 01		 push	 1
  00046	68 00 00 00 00	 push	 OFFSET ??_C@_01HIHLOKLC@1?$AA@
  0004b	56		 push	 esi
  0004c	ff d7		 call	 edi
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	85 c0		 test	 eax, eax
  00053	74 4d		 je	 SHORT $LN4@getArgumen

; 418  : 	}
; 419  : 	else if (
; 420  : 		!strncasecmp(argument, "false", 5) ||
; 421  : 		!strncasecmp(argument, "off", 3) ||
; 422  : 		!strncasecmp(argument, "no", 2) ||
; 423  : 		!strncasecmp(argument, "0", 1)
; 424  : 		)

  00055	6a 05		 push	 5
  00057	68 00 00 00 00	 push	 OFFSET ??_C@_05LAPONLG@false?$AA@
  0005c	56		 push	 esi
  0005d	ff d7		 call	 edi
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	85 c0		 test	 eax, eax
  00064	74 37		 je	 SHORT $LN1@getArgumen
  00066	6a 03		 push	 3
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_03MCADLMAF@off?$AA@
  0006d	56		 push	 esi
  0006e	ff d7		 call	 edi
  00070	83 c4 0c	 add	 esp, 12			; 0000000cH
  00073	85 c0		 test	 eax, eax
  00075	74 26		 je	 SHORT $LN1@getArgumen
  00077	6a 02		 push	 2
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_02KAJCLHKP@no?$AA@
  0007e	56		 push	 esi
  0007f	ff d7		 call	 edi
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH
  00084	85 c0		 test	 eax, eax
  00086	74 15		 je	 SHORT $LN1@getArgumen
  00088	6a 01		 push	 1
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_01GBGANLPD@0?$AA@
  0008f	56		 push	 esi
  00090	ff d7		 call	 edi
  00092	83 c4 0c	 add	 esp, 12			; 0000000cH
  00095	85 c0		 test	 eax, eax
  00097	74 04		 je	 SHORT $LN1@getArgumen

; 428  : 	}
; 429  : 
; 430  : 	return FALSE;

  00099	33 c0		 xor	 eax, eax
  0009b	eb 0b		 jmp	 SHORT $LN6@getArgumen
$LN1@getArgumen:

; 425  : 	{
; 426  : 		*result = FALSE;

  0009d	c6 03 00	 mov	 BYTE PTR [ebx], 0

; 427  : 		return TRUE;

  000a0	eb 03		 jmp	 SHORT $LN8@getArgumen
$LN4@getArgumen:

; 415  : 	{
; 416  : 		*result = TRUE;

  000a2	c6 03 01	 mov	 BYTE PTR [ebx], 1
$LN8@getArgumen:

; 417  : 		return TRUE;

  000a5	33 c0		 xor	 eax, eax
  000a7	40		 inc	 eax
$LN6@getArgumen:

; 431  : }

  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx
  000ab	c3		 ret	 0
_getArgumentBool ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _dataFileReadError
_TEXT	SEGMENT
_dataFileReadError PROC					; COMDAT

; 436  : {

  00000	56		 push	 esi

; 437  : 	int error = errno;

  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00007	8b 30		 mov	 esi, DWORD PTR [eax]

; 438  : 	errorout("Fatal: Could not read %s: %s\n", fn_data, strerror(error));

  00009	56		 push	 esi
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  00010	50		 push	 eax
  00011	ff 35 00 00 00
	00		 push	 DWORD PTR _fn_data
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6?$AA@
  0001c	e8 00 00 00 00	 call	 _errorout
  00021	83 c4 10	 add	 esp, 16			; 00000010H

; 439  : 	exit(error);

  00024	56		 push	 esi
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0002b	5e		 pop	 esi
$LN4@dataFileRe:
$LN3@dataFileRe:
_dataFileReadError ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _dataFileFormatError
_TEXT	SEGMENT
_dataFileFormatError PROC				; COMDAT

; 444  : 	errorout("Fatal: %s is not a KMS data file\n", fn_data);

  00000	ff 35 00 00 00
	00		 push	 DWORD PTR _fn_data
  00006	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@
  0000b	e8 00 00 00 00	 call	 _errorout
  00010	59		 pop	 ecx
  00011	59		 pop	 ecx

; 445  : 	exit(VLMCSD_EINVAL);

  00012	6a 57		 push	 87			; 00000057H
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN4@dataFileFo:
$LN3@dataFileFo:
  0001a	cc		 int	 3
_dataFileFormatError ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _getExeName
_TEXT	SEGMENT
_path$ = -512						; size = 512
_getExeName PROC					; COMDAT

; 451  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 00 02 00
	00		 sub	 esp, 512		; 00000200H

; 452  : 	if (fn_exe != NULL) return;

  00009	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _fn_exe, 0
  00010	75 36		 jne	 SHORT $LN2@getExeName

; 453  : 
; 454  : #	if (__GLIBC__ || __linux__) && defined(USE_AUXV)
; 455  : 
; 456  : 	fn_exe = (char*)getauxval(AT_EXECFN);
; 457  : 
; 458  : #	elif (__ANDROID__ && __ANDROID_API__ < 16) || (__UCLIBC__ && __UCLIBC_MAJOR__ < 1 && !defined(NO_PROCFS)) // Workaround for older uclibc
; 459  : 
; 460  : 	char temp[PATH_MAX + 1];
; 461  : 
; 462  : 	if (realpath("/proc/self/exe", temp) == temp)
; 463  : 	{
; 464  : 		fn_exe = vlmcsd_strdup(temp);
; 465  : 	}
; 466  : 
; 467  : #	elif (__linux__ || __CYGWIN__) && !defined(NO_PROCFS)
; 468  : 
; 469  : 	fn_exe = realpath("/proc/self/exe", NULL);
; 470  : 
; 471  : #	elif (__FreeBSD__ || __FreeBSD_kernel__)
; 472  : 
; 473  : 	int mib[4];
; 474  : 	mib[0] = CTL_KERN;
; 475  : 	mib[1] = KERN_PROC;
; 476  : 	mib[2] = KERN_PROC_PATHNAME;
; 477  : 	mib[3] = -1;
; 478  : 	char path[PATH_MAX + 1];
; 479  : 	size_t cb = sizeof(path);
; 480  : 
; 481  : 	if (!sysctl(mib, 4, path, &cb, NULL, 0))
; 482  : 	{
; 483  : 		fn_exe = vlmcsd_strdup(path);
; 484  : 	}
; 485  : 
; 486  : #	elif (__DragonFly__) && !defined(NO_PROCFS)
; 487  : 
; 488  : 	fn_exe = realpath("/proc/curproc/file", NULL);
; 489  : 
; 490  : #	elif __NetBSD__ && !defined(NO_PROCFS)
; 491  : 
; 492  : 	fn_exe = realpath("/proc/curproc/exe", NULL);
; 493  : 
; 494  : #	elif __sun__
; 495  : 
; 496  : 	fn_exe = getexecname();
; 497  : 
; 498  : #	elif __APPLE__
; 499  : 
; 500  : 	char path[PATH_MAX + 1];
; 501  : 	uint32_t size = sizeof(path);
; 502  : 
; 503  : 	if (_NSGetExecutablePath(path, &size) == 0)
; 504  : 	{
; 505  : 		fn_exe = vlmcsd_strdup(path);
; 506  : 	}
; 507  : 
; 508  : #	elif _WIN32
; 509  : 
; 510  : 	char path[512];
; 511  : 	GetModuleFileName(GetModuleHandle(NULL), path, 512);

  00012	68 00 02 00 00	 push	 512			; 00000200H
  00017	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  0001d	50		 push	 eax
  0001e	6a 00		 push	 0
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12

; 512  : 	path[511] = 0;
; 513  : 	fn_exe = vlmcsd_strdup(path);

  0002d	8d 85 00 fe ff
	ff		 lea	 eax, DWORD PTR _path$[ebp]
  00033	c6 45 ff 00	 mov	 BYTE PTR _path$[ebp+511], 0
  00037	50		 push	 eax
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  0003e	59		 pop	 ecx
  0003f	85 c0		 test	 eax, eax
  00041	74 09		 je	 SHORT $LN9@getExeName
  00043	a3 00 00 00 00	 mov	 DWORD PTR _fn_exe, eax
$LN2@getExeName:

; 514  : 
; 515  : #	else
; 516  : 	// Sorry no exe detection
; 517  : #	endif
; 518  : }

  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c3		 ret	 0
$LN9@getExeName:

; 512  : 	path[511] = 0;
; 513  : 	fn_exe = vlmcsd_strdup(path);

  0004c	e8 00 00 00 00	 call	 _OutOfMemory
$LN11@getExeName:
$LN8@getExeName:
  00051	cc		 int	 3
_getExeName ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _getDefaultDataFile
_TEXT	SEGMENT
_path$1 = -772						; size = 512
_fileName$ = -260					; size = 260
_getDefaultDataFile PROC				; COMDAT

; 524  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 525  : 	char fileName[MAX_PATH];
; 526  : 	getExeName();

  00003	a1 00 00 00 00	 mov	 eax, DWORD PTR _fn_exe
  00008	81 ec 04 03 00
	00		 sub	 esp, 772		; 00000304H
  0000e	85 c0		 test	 eax, eax
  00010	75 39		 jne	 SHORT $LN4@getDefault
  00012	68 00 02 00 00	 push	 512			; 00000200H
  00017	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _path$1[ebp]
  0001d	50		 push	 eax
  0001e	6a 00		 push	 0
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleA@4
  00026	50		 push	 eax
  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12
  0002d	8d 85 fc fc ff
	ff		 lea	 eax, DWORD PTR _path$1[ebp]
  00033	c6 85 fb fe ff
	ff 00		 mov	 BYTE PTR _path$1[ebp+511], 0
  0003a	50		 push	 eax
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  00041	59		 pop	 ecx
  00042	85 c0		 test	 eax, eax
  00044	74 5b		 je	 SHORT $LN16@getDefault
  00046	a3 00 00 00 00	 mov	 DWORD PTR _fn_exe, eax
$LN4@getDefault:

; 527  : 	strncpy(fileName, fn_exe, MAX_PATH);

  0004b	57		 push	 edi
  0004c	bf 04 01 00 00	 mov	 edi, 260		; 00000104H
  00051	57		 push	 edi
  00052	50		 push	 eax
  00053	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  00059	50		 push	 eax
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH

; 528  : 	PathRemoveFileSpec(fileName);

  00063	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  00069	50		 push	 eax
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__PathRemoveFileSpecA@4

; 529  : 	strncat(fileName, "\\vlmcsd.kmd", MAX_PATH);

  00070	57		 push	 edi
  00071	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OPCADLF@?2vlmcsd?4kmd?$AA@
  0007c	50		 push	 eax
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncat

; 530  : 	fn_data = vlmcsd_strdup(fileName);

  00083	8d 85 fc fe ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp]
  00089	50		 push	 eax
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  00090	83 c4 10	 add	 esp, 16			; 00000010H
  00093	5f		 pop	 edi
  00094	85 c0		 test	 eax, eax
  00096	74 09		 je	 SHORT $LN16@getDefault
  00098	a3 00 00 00 00	 mov	 DWORD PTR _fn_data, eax

; 531  : }

  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c3		 ret	 0
$LN16@getDefault:

; 525  : 	char fileName[MAX_PATH];
; 526  : 	getExeName();

  000a1	e8 00 00 00 00	 call	 _OutOfMemory
$LN18@getDefault:
$LN14@getDefault:
  000a6	cc		 int	 3
_getDefaultDataFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _loadKmsData
_TEXT	SEGMENT
tv596 = -4						; size = 4
_loadKmsData PROC					; COMDAT

; 554  : {

  00000	51		 push	 ecx

; 555  : #	ifndef NO_INTERNAL_DATA
; 556  : 	KmsData = (PVlmcsdHeader_t)DefaultKmsData;
; 557  : #	endif // NO_INTERNAL_DATA
; 558  : 
; 559  : #	ifndef NO_EXTERNAL_DATA
; 560  : 	long size;
; 561  : #	ifndef NO_INTERNAL_DATA
; 562  : 	size = (long)getDefaultKmsDataSize();
; 563  : #	endif // NO_INTERNAL_DATA
; 564  : 
; 565  : #	ifndef DATA_FILE
; 566  : 	if (!fn_data) getDefaultDataFile();

  00001	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fn_data
  00007	53		 push	 ebx
  00008	bb 4a 05 00 00	 mov	 ebx, 1354		; 0000054aH
  0000d	55		 push	 ebp
  0000e	56		 push	 esi
  0000f	be 00 00 00 00	 mov	 esi, OFFSET _DefaultKmsData
  00014	89 35 00 00 00
	00		 mov	 DWORD PTR _KmsData, esi
  0001a	57		 push	 edi
  0001b	85 c9		 test	 ecx, ecx
  0001d	75 11		 jne	 SHORT $LN30@loadKmsDat
  0001f	e8 00 00 00 00	 call	 _getDefaultDataFile
  00024	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _KmsData
  0002a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _fn_data
$LN30@loadKmsDat:

; 567  : #	endif // DATA_FILE
; 568  : 
; 569  : 	if (strcmp(fn_data, "-"))

  00030	33 ff		 xor	 edi, edi
  00032	80 39 2d	 cmp	 BYTE PTR [ecx], 45	; 0000002dH
  00035	75 0c		 jne	 SHORT $LN54@loadKmsDat
  00037	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  0003b	84 c0		 test	 al, al
  0003d	0f 84 cf 00 00
	00		 je	 $LN20@loadKmsDat
$LN54@loadKmsDat:

; 570  : 	{
; 571  : 		FILE *file = fopen(fn_data, "rb");

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_02JDPG@rb?$AA@
  00048	51		 push	 ecx
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0004f	8b f0		 mov	 esi, eax
  00051	59		 pop	 ecx
  00052	59		 pop	 ecx

; 572  : 
; 573  : 		if (!file)

  00053	85 f6		 test	 esi, esi
  00055	75 11		 jne	 SHORT $LN28@loadKmsDat

; 574  : 		{
; 575  : #			ifndef NO_INTERNAL_DATA
; 576  : 			if (ExplicitDataLoad)

  00057	38 05 00 00 00
	00		 cmp	 BYTE PTR _ExplicitDataLoad, al
  0005d	0f 84 92 00 00
	00		 je	 $LN21@loadKmsDat
  00063	e9 a5 01 00 00	 jmp	 $LN59@loadKmsDat
$LN28@loadKmsDat:

; 580  : 			}
; 581  : 		}
; 582  : 		else
; 583  : 		{
; 584  : 			if (fseek(file, 0, SEEK_END)) dataFileReadError();

  00068	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__fseek
  0006e	6a 02		 push	 2
  00070	57		 push	 edi
  00071	56		 push	 esi
  00072	ff d5		 call	 ebp
  00074	83 c4 0c	 add	 esp, 12			; 0000000cH
  00077	85 c0		 test	 eax, eax
  00079	0f 85 8e 01 00
	00		 jne	 $LN59@loadKmsDat

; 585  : 			size = ftell(file);

  0007f	56		 push	 esi
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  00086	8b d8		 mov	 ebx, eax
  00088	59		 pop	 ecx

; 586  : 			if (size == -1L) dataFileReadError();

  00089	83 fb ff	 cmp	 ebx, -1
  0008c	0f 84 7b 01 00
	00		 je	 $LN59@loadKmsDat

; 587  : 
; 588  : 			KmsData = (PVlmcsdHeader_t)vlmcsd_malloc(size);

  00092	53		 push	 ebx
  00093	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00099	59		 pop	 ecx
  0009a	85 c0		 test	 eax, eax
  0009c	0f 84 70 01 00
	00		 je	 $LN61@loadKmsDat

; 589  : 			if (fseek(file, 0, SEEK_SET)) dataFileReadError();

  000a2	57		 push	 edi
  000a3	57		 push	 edi
  000a4	56		 push	 esi
  000a5	a3 00 00 00 00	 mov	 DWORD PTR _KmsData, eax
  000aa	ff d5		 call	 ebp
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH
  000af	85 c0		 test	 eax, eax
  000b1	0f 85 56 01 00
	00		 jne	 $LN59@loadKmsDat

; 590  : 
; 591  : 			size_t bytesRead = fread(KmsData, 1, size, file);

  000b7	56		 push	 esi
  000b8	53		 push	 ebx
  000b9	6a 01		 push	 1
  000bb	ff 35 00 00 00
	00		 push	 DWORD PTR _KmsData
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  000c7	83 c4 10	 add	 esp, 16			; 00000010H

; 592  : 			if ((long)bytesRead != size) dataFileReadError();

  000ca	3b c3		 cmp	 eax, ebx
  000cc	0f 85 3b 01 00
	00		 jne	 $LN59@loadKmsDat

; 593  : 			fclose(file);

  000d2	56		 push	 esi
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose

; 594  : 
; 595  : #			if !defined(NO_LOG) && !defined(NO_SOCKETS)
; 596  : 			if (!InetdMode) logger("Read KMS data file %s\n", fn_data);

  000d9	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  000e0	59		 pop	 ecx
  000e1	75 12		 jne	 SHORT $LN21@loadKmsDat
  000e3	ff 35 00 00 00
	00		 push	 DWORD PTR _fn_data
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GJJJGOK@Read?5KMS?5data?5file?5?$CFs?6?$AA@
  000ee	e8 00 00 00 00	 call	 _logger
  000f3	59		 pop	 ecx
  000f4	59		 pop	 ecx
$LN21@loadKmsDat:

; 597  : #			endif // NO_LOG
; 598  : 		}
; 599  : 
; 600  : 		if (KmsData->CsvlkCount < MIN_CSVLK)

  000f5	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _KmsData
  000fb	80 7e 08 05	 cmp	 BYTE PTR [esi+8], 5
  000ff	73 11		 jae	 SHORT $LN20@loadKmsDat

; 601  : 		{
; 602  : 			printerrorf("Warning: Legacy database: Some products are missing.\n");

  00101	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@EIKFJMME@Warning?3?5Legacy?5database?3?5Some?5p@
  00106	e8 00 00 00 00	 call	 _printerrorf
  0010b	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _KmsData
  00111	59		 pop	 ecx
$LN20@loadKmsDat:

; 603  : 		}
; 604  : 	}
; 605  : 
; 606  : 
; 607  : #	endif // NO_EXTERNAL_DATA
; 608  : 
; 609  : #	if !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 610  : 
; 611  : 	if (KmsData->CsvlkCount > MIN_CSVLK)

  00112	8a 46 08	 mov	 al, BYTE PTR [esi+8]
  00115	3c 05		 cmp	 al, 5
  00117	76 3d		 jbe	 SHORT $LN19@loadKmsDat

; 612  : 	{
; 613  : 		KmsResponseParameters = (KmsResponseParam_t*)realloc(KmsResponseParameters, KmsData->CsvlkCount * sizeof(KmsResponseParam_t));

  00119	0f b6 c0	 movzx	 eax, al
  0011c	6b c0 0c	 imul	 eax, eax, 12
  0011f	50		 push	 eax
  00120	ff 35 00 00 00
	00		 push	 DWORD PTR _KmsResponseParameters
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__realloc
  0012c	59		 pop	 ecx
  0012d	59		 pop	 ecx
  0012e	8b c8		 mov	 ecx, eax
  00130	89 0d 00 00 00
	00		 mov	 DWORD PTR _KmsResponseParameters, ecx

; 614  : 		if (!KmsResponseParameters) OutOfMemory();

  00136	85 c9		 test	 ecx, ecx
  00138	0f 84 d4 00 00
	00		 je	 $LN61@loadKmsDat

; 615  : 		memset(KmsResponseParameters + MIN_CSVLK, 0, (KmsData->CsvlkCount - MIN_CSVLK) * sizeof(KmsResponseParam_t));

  0013e	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  00142	83 e8 05	 sub	 eax, 5
  00145	6b c0 0c	 imul	 eax, eax, 12
  00148	50		 push	 eax
  00149	8d 41 3c	 lea	 eax, DWORD PTR [ecx+60]
  0014c	57		 push	 edi
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 _memset
  00153	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@loadKmsDat:

; 616  : 	}
; 617  : 
; 618  : #	endif // !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 619  : 
; 620  : #	ifndef UNSAFE_DATA_LOAD
; 621  : 	if (((BYTE*)KmsData)[size - 1] != 0) dataFileFormatError();

  00156	8d 2c 1e	 lea	 ebp, DWORD PTR [esi+ebx]
  00159	80 7d ff 00	 cmp	 BYTE PTR [ebp-1], 0
  0015d	89 6c 24 10	 mov	 DWORD PTR tv596[esp+20], ebp
  00161	0f 85 b0 00 00
	00		 jne	 $LN62@loadKmsDat

; 622  : #	endif // UNSAFE_DATA_LOAD
; 623  : 
; 624  : 	KmsData->MajorVer = LE16(KmsData->MajorVer);
; 625  : 	KmsData->MinorVer = LE16(KmsData->MinorVer);
; 626  : 	KmsData->AppItemCount = LE32(KmsData->AppItemCount);
; 627  : 	KmsData->KmsItemCount = LE32(KmsData->KmsItemCount);
; 628  : 	KmsData->SkuItemCount = LE32(KmsData->SkuItemCount);
; 629  : 
; 630  : 	uint32_t i;
; 631  : 
; 632  : 	for (i = 0; i < vlmcsd_countof(KmsData->Datapointers); i++)

  00167	8b cf		 mov	 ecx, edi
  00169	8d 46 18	 lea	 eax, DWORD PTR [esi+24]
$LL16@loadKmsDat:

; 633  : 	{
; 634  : 		KmsData->Datapointers[i].Pointer = (BYTE*)KmsData + LE64(KmsData->Datapointers[i].Offset);

  0016c	01 30		 add	 DWORD PTR [eax], esi

; 635  : #		ifndef UNSAFE_DATA_LOAD
; 636  : 		if ((BYTE*)KmsData->Datapointers[i].Pointer > (BYTE*)KmsData + size) dataFileFormatError();

  0016e	39 28		 cmp	 DWORD PTR [eax], ebp
  00170	0f 87 a1 00 00
	00		 ja	 $LN62@loadKmsDat

; 622  : #	endif // UNSAFE_DATA_LOAD
; 623  : 
; 624  : 	KmsData->MajorVer = LE16(KmsData->MajorVer);
; 625  : 	KmsData->MinorVer = LE16(KmsData->MinorVer);
; 626  : 	KmsData->AppItemCount = LE32(KmsData->AppItemCount);
; 627  : 	KmsData->KmsItemCount = LE32(KmsData->KmsItemCount);
; 628  : 	KmsData->SkuItemCount = LE32(KmsData->SkuItemCount);
; 629  : 
; 630  : 	uint32_t i;
; 631  : 
; 632  : 	for (i = 0; i < vlmcsd_countof(KmsData->Datapointers); i++)

  00176	41		 inc	 ecx
  00177	83 c0 08	 add	 eax, 8
  0017a	83 f9 03	 cmp	 ecx, 3
  0017d	72 ed		 jb	 SHORT $LL16@loadKmsDat

; 637  : #		endif // UNSAFE_DATA_LOAD
; 638  : 	}
; 639  : 
; 640  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  0017f	8b d7		 mov	 edx, edi
  00181	38 56 08	 cmp	 BYTE PTR [esi+8], dl
  00184	76 1b		 jbe	 SHORT $LN10@loadKmsDat
  00186	8d 4e 3c	 lea	 ecx, DWORD PTR [esi+60]
$LL12@loadKmsDat:

; 641  : 	{
; 642  : 		PCsvlkData_t csvlkData = &KmsData->CsvlkData[i];
; 643  : 		csvlkData->EPid = (char*)KmsData + LE64(csvlkData->EPidOffset);

  00189	01 71 f4	 add	 DWORD PTR [ecx-12], esi

; 644  : #		ifndef UNSAFE_DATA_LOAD
; 645  : 		if (csvlkData->EPid > (char*)KmsData + size) dataFileFormatError();

  0018c	39 69 f4	 cmp	 DWORD PTR [ecx-12], ebp
  0018f	0f 87 82 00 00
	00		 ja	 $LN62@loadKmsDat

; 637  : #		endif // UNSAFE_DATA_LOAD
; 638  : 	}
; 639  : 
; 640  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  00195	0f b6 46 08	 movzx	 eax, BYTE PTR [esi+8]
  00199	42		 inc	 edx
  0019a	83 c1 18	 add	 ecx, 24			; 00000018H
  0019d	3b d0		 cmp	 edx, eax
  0019f	72 e8		 jb	 SHORT $LL12@loadKmsDat
$LN10@loadKmsDat:

; 646  : #		endif // UNSAFE_DATA_LOAD
; 647  : 
; 648  : #		ifndef NO_RANDOM_EPID
; 649  : 		csvlkData->GroupId = LE32(csvlkData->GroupId);
; 650  : 		csvlkData->MinKeyId = LE32(csvlkData->MinKeyId);
; 651  : 		csvlkData->MaxKeyId = LE32(csvlkData->MaxKeyId);
; 652  : #		endif // NO_RANDOM_EPID
; 653  : 	}
; 654  : 
; 655  : 	uint32_t totalItemCount = KmsData->AppItemCount + KmsData->KmsItemCount + KmsData->SkuItemCount;

  001a1	8b 6e 0c	 mov	 ebp, DWORD PTR [esi+12]
  001a4	03 6e 10	 add	 ebp, DWORD PTR [esi+16]
  001a7	03 6e 14	 add	 ebp, DWORD PTR [esi+20]

; 656  : 
; 657  : #	ifndef NO_EXTERNAL_DATA
; 658  : 	if (
; 659  : 		memcmp(KmsData->Magic, "KMD", sizeof(KmsData->Magic)) ||
; 660  : 		KmsData->MajorVer != 1
; 661  : #		ifndef UNSAFE_DATA_LOAD
; 662  : 		||
; 663  : 		sizeof(VlmcsdHeader_t) + totalItemCount * sizeof(VlmcsdData_t) >= ((uint64_t)size)
; 664  : #		endif //UNSAFE_DATA_LOAD
; 665  : 		)

  001aa	81 3e 4b 4d 44
	00		 cmp	 DWORD PTR [esi], 4476235 ; 00444d4bH
  001b0	75 65		 jne	 SHORT $LN62@loadKmsDat
  001b2	33 c0		 xor	 eax, eax
  001b4	40		 inc	 eax
  001b5	66 39 46 06	 cmp	 WORD PTR [esi+6], ax
  001b9	75 5c		 jne	 SHORT $LN62@loadKmsDat
  001bb	8b cd		 mov	 ecx, ebp
  001bd	8b c3		 mov	 eax, ebx
  001bf	c1 e1 05	 shl	 ecx, 5
  001c2	99		 cdq
  001c3	83 c1 48	 add	 ecx, 72			; 00000048H
  001c6	3b fa		 cmp	 edi, edx
  001c8	77 4d		 ja	 SHORT $LN62@loadKmsDat
  001ca	72 04		 jb	 SHORT $LN55@loadKmsDat
  001cc	3b c8		 cmp	 ecx, eax
  001ce	73 47		 jae	 SHORT $LN62@loadKmsDat
$LN55@loadKmsDat:

; 666  : 	{
; 667  : 		dataFileFormatError();
; 668  : 	}
; 669  : #	endif // NO_EXTERNAL_DATA
; 670  : 
; 671  : 	for (i = 0; i < totalItemCount; i++)

  001d0	85 ed		 test	 ebp, ebp
  001d2	74 33		 je	 SHORT $LN4@loadKmsDat
  001d4	8b 5c 24 10	 mov	 ebx, DWORD PTR tv596[esp+20]
  001d8	8b d7		 mov	 edx, edi
$LL6@loadKmsDat:
  001da	8b 4e 18	 mov	 ecx, DWORD PTR [esi+24]
  001dd	03 ca		 add	 ecx, edx

; 672  : 	{
; 673  : 		PVlmcsdData_t item = &KmsData->AppItemList[i];
; 674  : 		item->Name = (char*)KmsData + LE64(item->NameOffset);

  001df	01 71 10	 add	 DWORD PTR [ecx+16], esi

; 675  : 
; 676  : #		ifndef UNSAFE_DATA_LOAD
; 677  : 		if (
; 678  : 			item->Name >= (char*)KmsData + (uint64_t)size ||
; 679  : 			(KmsData->AppItemCount && item->AppIndex >= KmsData->AppItemCount) ||
; 680  : 			item->KmsIndex >= KmsData->KmsItemCount
; 681  : 			)

  001e2	39 59 10	 cmp	 DWORD PTR [ecx+16], ebx
  001e5	73 30		 jae	 SHORT $LN62@loadKmsDat
  001e7	83 7e 0c 00	 cmp	 DWORD PTR [esi+12], 0
  001eb	74 09		 je	 SHORT $LN1@loadKmsDat
  001ed	0f b6 41 18	 movzx	 eax, BYTE PTR [ecx+24]
  001f1	3b 46 0c	 cmp	 eax, DWORD PTR [esi+12]
  001f4	7d 21		 jge	 SHORT $LN62@loadKmsDat
$LN1@loadKmsDat:
  001f6	0f b6 41 19	 movzx	 eax, BYTE PTR [ecx+25]
  001fa	3b 46 10	 cmp	 eax, DWORD PTR [esi+16]
  001fd	7d 18		 jge	 SHORT $LN62@loadKmsDat

; 666  : 	{
; 667  : 		dataFileFormatError();
; 668  : 	}
; 669  : #	endif // NO_EXTERNAL_DATA
; 670  : 
; 671  : 	for (i = 0; i < totalItemCount; i++)

  001ff	47		 inc	 edi
  00200	83 c2 20	 add	 edx, 32			; 00000020H
  00203	3b fd		 cmp	 edi, ebp
  00205	72 d3		 jb	 SHORT $LL6@loadKmsDat
$LN4@loadKmsDat:
  00207	5f		 pop	 edi
  00208	5e		 pop	 esi
  00209	5d		 pop	 ebp
  0020a	5b		 pop	 ebx

; 682  : 		{
; 683  : 			dataFileFormatError();
; 684  : 		}
; 685  : #		endif // UNSAFE_DATA_LOAD
; 686  : 	}
; 687  : }

  0020b	59		 pop	 ecx
  0020c	c3		 ret	 0
$LN59@loadKmsDat:

; 577  : #			endif // NO_INTERNAL_DATA
; 578  : 			{
; 579  : 				dataFileReadError();

  0020d	e8 00 00 00 00	 call	 _dataFileReadError
$LN63@loadKmsDat:
$LN61@loadKmsDat:

; 587  : 
; 588  : 			KmsData = (PVlmcsdHeader_t)vlmcsd_malloc(size);

  00212	e8 00 00 00 00	 call	 _OutOfMemory
$LN64@loadKmsDat:
$LN62@loadKmsDat:

; 616  : 	}
; 617  : 
; 618  : #	endif // !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 619  : 
; 620  : #	ifndef UNSAFE_DATA_LOAD
; 621  : 	if (((BYTE*)KmsData)[size - 1] != 0) dataFileFormatError();

  00217	e8 00 00 00 00	 call	 _dataFileFormatError
$LN65@loadKmsDat:
$LN56@loadKmsDat:
  0021c	cc		 int	 3
_loadKmsData ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\helpers.c
;	COMDAT _exitOnWarningLevel
_TEXT	SEGMENT
_exitOnWarningLevel PROC				; COMDAT
; _level$dead$ = cl

; 692  : 	if (ExitLevel >= level)

  00000	a0 00 00 00 00	 mov	 al, BYTE PTR _ExitLevel
  00005	3c 01		 cmp	 al, 1
  00007	7c 18		 jl	 SHORT $LN1@exitOnWarn

; 693  : 	{
; 694  : 		printerrorf("Fatal: Exiting on warning level %i or greater\n", (int)ExitLevel);

  00009	0f be c0	 movsx	 eax, al
  0000c	50		 push	 eax
  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level?5@
  00012	e8 00 00 00 00	 call	 _printerrorf
  00017	59		 pop	 ecx
  00018	59		 pop	 ecx

; 695  : 		exit(-1);

  00019	6a ff		 push	 -1
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN6@exitOnWarn:
$LN1@exitOnWarn:

; 696  : 	}
; 697  : }

  00021	c3		 ret	 0
$LN5@exitOnWarn:
_exitOnWarningLevel ENDP
_TEXT	ENDS
END
