; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Dell\Desktop\vlmcsd\src\output.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_01MCMALHOG@a?$AA@				; `string'
PUBLIC	??_C@_0O@LNENHMIM@?$CFY?9?$CFm?9?$CFd?5?$CFX?3?5?$AA@ ; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0L@NFCOGLDB@Unlicensed?$AA@		; `string'
PUBLIC	??_C@_08BMJGAJHF@Licensed?$AA@			; `string'
PUBLIC	??_C@_09JBIIANMO@OOB?5grace?$AA@		; `string'
PUBLIC	??_C@_09CLFMDFGC@OOT?5grace?$AA@		; `string'
PUBLIC	??_C@_0M@MHDDAGNF@Non?9Genuine?$AA@		; `string'
PUBLIC	??_C@_0N@OFINCEFP@Notification?$AA@		; `string'
PUBLIC	??_C@_0P@NCPOCFCF@Extended?5grace?$AA@		; `string'
PUBLIC	??_C@_0BN@LENFACPA@?$CF08x?9?$CF04x?9?$CF04x?9?$CF04x?9?$CF012I64x?$AA@ ; `string'
PUBLIC	??_C@_0CJ@KEHOAAGG@Protocol?5version?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_03CCLAEDDF@Yes?$AA@			; `string'
PUBLIC	??_C@_02JINPPBEP@No?$AA@			; `string'
PUBLIC	??_C@_0CG@CIJPHHEF@Client?5is?5a?5virtual?5machine?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CL@NILKFNNP@Licensing?5status?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CO@GGDJLANK@Remaining?5time?5?$CI0?5?$DN?5forever?$CJ?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CL@KHCLANPB@Application?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CL@LLNJLCF@SKU?5ID?5?$CIaka?5Activation?5ID?$CJ?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CL@MNFHGDHP@KMS?5ID?5?$CIaka?5KMS?5counted?5ID?$CJ?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CG@NAJADCGN@Client?5machine?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CG@KNAHJFGH@Previous?5client?5machine?5ID?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0M@EHAPGNAC@?$CFY?9?$CFm?9?$CFd?5?$CFX?$AA@ ; `string'
PUBLIC	??_C@_0CG@CCLOIHMC@Client?5request?5timestamp?5?$CIUTC?$CJ?5?5@ ; `string'
PUBLIC	??_C@_0CG@NJMNAEGJ@Workstation?5name?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CG@KONHMDAE@N?5count?5policy?5?$CIminimum?5clients?$CJ@ ; `string'
PUBLIC	??_C@_0CG@CKMBAHPA@KMS?5host?5extended?5PID?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CM@BGLDHKHD@KMS?5host?5Hardware?5ID?5?5?5?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CG@CKOEJNCP@KMS?5host?5current?5active?5clients?5@ ; `string'
PUBLIC	??_C@_0CG@HGDBGCN@Renewal?5interval?5policy?5?5?5?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CG@EIDEKNCG@Activation?5interval?5policy?5?5?5?5?5?5@ ; `string'
PUBLIC	??_C@_0CD@FAKKKCEM@Compiler?3?5VC?$CL?$CL?5?$CF02i?4?$CF02i?5build?5?$CF@ ; `string'
PUBLIC	??_C@_0O@KEGGAHLA@little?9endian?$AA@		; `string'
PUBLIC	??_C@_0L@JIMEFGOI@big?9endian?$AA@		; `string'
PUBLIC	??_C@_0BF@KAHIDINA@?5Intel?5x86?5Windows32?$AA@	; `string'
PUBLIC	??_C@_0BJ@MBJNOFCM@Intended?5platform?3?$CFs?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BB@NGPJLHEC@?5_CRYPTO_WINDOWS?$AA@	; `string'
PUBLIC	??_C@_0BB@NGBEHLG@Common?5flags?3?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0P@JPKAPDJG@?5DNS_PARSER?$DNOS?$AA@	; `string'
PUBLIC	??_C@_0BA@KMEDHNGP@vlmcs?5flags?3?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0CO@DNHMBJJK@?5NO_SIGHUP?5THREADS?$DN1?5SUPPORT_WIN@ ; `string'
PUBLIC	??_C@_0BB@OGOEBGIP@vlmcsd?5flags?3?$CFs?6?$AA@	; `string'
EXTRN	__imp___localtime64:PROC
EXTRN	__imp__vfprintf:PROC
EXTRN	__imp__strftime:PROC
EXTRN	__imp___vsnprintf:PROC
EXTRN	__imp__fprintf:PROC
;	COMDAT ??_C@_0BB@OGOEBGIP@vlmcsd?5flags?3?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@OGOEBGIP@vlmcsd?5flags?3?$CFs?6?$AA@ DB 'vlmcsd flags:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@DNHMBJJK@?5NO_SIGHUP?5THREADS?$DN1?5SUPPORT_WIN@
CONST	SEGMENT
??_C@_0CO@DNHMBJJK@?5NO_SIGHUP?5THREADS?$DN1?5SUPPORT_WIN@ DB ' NO_SIGHUP'
	DB	' THREADS=1 SUPPORT_WINE NO_FREEBIND', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KMEDHNGP@vlmcs?5flags?3?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BA@KMEDHNGP@vlmcs?5flags?3?$CFs?6?$AA@ DB 'vlmcs flags:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@JPKAPDJG@?5DNS_PARSER?$DNOS?$AA@
CONST	SEGMENT
??_C@_0P@JPKAPDJG@?5DNS_PARSER?$DNOS?$AA@ DB ' DNS_PARSER=OS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NGBEHLG@Common?5flags?3?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@NGBEHLG@Common?5flags?3?$CFs?6?$AA@ DB 'Common flags:%s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NGPJLHEC@?5_CRYPTO_WINDOWS?$AA@
CONST	SEGMENT
??_C@_0BB@NGPJLHEC@?5_CRYPTO_WINDOWS?$AA@ DB ' _CRYPTO_WINDOWS', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MBJNOFCM@Intended?5platform?3?$CFs?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MBJNOFCM@Intended?5platform?3?$CFs?5?$CFs?6?$AA@ DB 'Intended p'
	DB	'latform:%s %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@KAHIDINA@?5Intel?5x86?5Windows32?$AA@
CONST	SEGMENT
??_C@_0BF@KAHIDINA@?5Intel?5x86?5Windows32?$AA@ DB ' Intel x86 Windows32', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JIMEFGOI@big?9endian?$AA@
CONST	SEGMENT
??_C@_0L@JIMEFGOI@big?9endian?$AA@ DB 'big-endian', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@KEGGAHLA@little?9endian?$AA@
CONST	SEGMENT
??_C@_0O@KEGGAHLA@little?9endian?$AA@ DB 'little-endian', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@FAKKKCEM@Compiler?3?5VC?$CL?$CL?5?$CF02i?4?$CF02i?5build?5?$CF@
CONST	SEGMENT
??_C@_0CD@FAKKKCEM@Compiler?3?5VC?$CL?$CL?5?$CF02i?4?$CF02i?5build?5?$CF@ DB 'C'
	DB	'ompiler: VC++ %02i.%02i build %i', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@EIDEKNCG@Activation?5interval?5policy?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@EIDEKNCG@Activation?5interval?5policy?5?5?5?5?5?5@ DB 'Activati'
	DB	'on interval policy      : %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@HGDBGCN@Renewal?5interval?5policy?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@HGDBGCN@Renewal?5interval?5policy?5?5?5?5?5?5?5?5?5@ DB 'Renewa'
	DB	'l interval policy         : %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CKOEJNCP@KMS?5host?5current?5active?5clients?5@
CONST	SEGMENT
??_C@_0CG@CKOEJNCP@KMS?5host?5current?5active?5clients?5@ DB 'KMS host cu'
	DB	'rrent active clients : %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BGLDHKHD@KMS?5host?5Hardware?5ID?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CM@BGLDHKHD@KMS?5host?5Hardware?5ID?5?5?5?5?5?5?5?5?5?5?5?5@ DB 'K'
	DB	'MS host Hardware ID            : %016I64X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CKMBAHPA@KMS?5host?5extended?5PID?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@CKMBAHPA@KMS?5host?5extended?5PID?5?5?5?5?5?5?5?5?5?5?5@ DB 'KM'
	DB	'S host extended PID           : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KONHMDAE@N?5count?5policy?5?$CIminimum?5clients?$CJ@
CONST	SEGMENT
??_C@_0CG@KONHMDAE@N?5count?5policy?5?$CIminimum?5clients?$CJ@ DB 'N coun'
	DB	't policy (minimum clients): %u', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NJMNAEGJ@Workstation?5name?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@NJMNAEGJ@Workstation?5name?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 'W'
	DB	'orkstation name                : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CCLOIHMC@Client?5request?5timestamp?5?$CIUTC?$CJ?5?5@
CONST	SEGMENT
??_C@_0CG@CCLOIHMC@Client?5request?5timestamp?5?$CIUTC?$CJ?5?5@ DB 'Clien'
	DB	't request timestamp (UTC)  : %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@EHAPGNAC@?$CFY?9?$CFm?9?$CFd?5?$CFX?$AA@
CONST	SEGMENT
??_C@_0M@EHAPGNAC@?$CFY?9?$CFm?9?$CFd?5?$CFX?$AA@ DB '%Y-%m-%d %X', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KNAHJFGH@Previous?5client?5machine?5ID?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@KNAHJFGH@Previous?5client?5machine?5ID?5?5?5?5?5?5@ DB 'Previou'
	DB	's client machine ID      : %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@NAJADCGN@Client?5machine?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@NAJADCGN@Client?5machine?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 'C'
	DB	'lient machine ID               : %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@MNFHGDHP@KMS?5ID?5?$CIaka?5KMS?5counted?5ID?$CJ?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CL@MNFHGDHP@KMS?5ID?5?$CIaka?5KMS?5counted?5ID?$CJ?5?5?5?5?5@ DB 'K'
	DB	'MS ID (aka KMS counted ID)     : %s (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LLNJLCF@SKU?5ID?5?$CIaka?5Activation?5ID?$CJ?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CL@LLNJLCF@SKU?5ID?5?$CIaka?5Activation?5ID?$CJ?5?5?5?5?5?5@ DB 'S'
	DB	'KU ID (aka Activation ID)      : %s (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KHCLANPB@Application?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CL@KHCLANPB@Application?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 'A'
	DB	'pplication ID                  : %s (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GGDJLANK@Remaining?5time?5?$CI0?5?$DN?5forever?$CJ?5?5?5?5@
CONST	SEGMENT
??_C@_0CO@GGDJLANK@Remaining?5time?5?$CI0?5?$DN?5forever?$CJ?5?5?5?5@ DB 'R'
	DB	'emaining time (0 = forever)    : %i minutes', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@NILKFNNP@Licensing?5status?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CL@NILKFNNP@Licensing?5status?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 'L'
	DB	'icensing status                : %u (%s)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@CIJPHHEF@Client?5is?5a?5virtual?5machine?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CG@CIJPHHEF@Client?5is?5a?5virtual?5machine?5?5?5?5?5@ DB 'Client '
	DB	'is a virtual machine     : %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02JINPPBEP@No?$AA@
CONST	SEGMENT
??_C@_02JINPPBEP@No?$AA@ DB 'No', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03CCLAEDDF@Yes?$AA@
CONST	SEGMENT
??_C@_03CCLAEDDF@Yes?$AA@ DB 'Yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KEHOAAGG@Protocol?5version?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
CONST	SEGMENT
??_C@_0CJ@KEHOAAGG@Protocol?5version?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@ DB 'P'
	DB	'rotocol version                : %u.%u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LENFACPA@?$CF08x?9?$CF04x?9?$CF04x?9?$CF04x?9?$CF012I64x?$AA@
CONST	SEGMENT
??_C@_0BN@LENFACPA@?$CF08x?9?$CF04x?9?$CF04x?9?$CF04x?9?$CF012I64x?$AA@ DB '%'
	DB	'08x-%04x-%04x-%04x-%012I64x', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NCPOCFCF@Extended?5grace?$AA@
CONST	SEGMENT
??_C@_0P@NCPOCFCF@Extended?5grace?$AA@ DB 'Extended grace', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@OFINCEFP@Notification?$AA@
CONST	SEGMENT
??_C@_0N@OFINCEFP@Notification?$AA@ DB 'Notification', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@MHDDAGNF@Non?9Genuine?$AA@
CONST	SEGMENT
??_C@_0M@MHDDAGNF@Non?9Genuine?$AA@ DB 'Non-Genuine', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CLFMDFGC@OOT?5grace?$AA@
CONST	SEGMENT
??_C@_09CLFMDFGC@OOT?5grace?$AA@ DB 'OOT grace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09JBIIANMO@OOB?5grace?$AA@
CONST	SEGMENT
??_C@_09JBIIANMO@OOB?5grace?$AA@ DB 'OOB grace', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08BMJGAJHF@Licensed?$AA@
CONST	SEGMENT
??_C@_08BMJGAJHF@Licensed?$AA@ DB 'Licensed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NFCOGLDB@Unlicensed?$AA@
CONST	SEGMENT
??_C@_0L@NFCOGLDB@Unlicensed?$AA@ DB 'Unlicensed', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LNENHMIM@?$CFY?9?$CFm?9?$CFd?5?$CFX?3?5?$AA@
CONST	SEGMENT
??_C@_0O@LNENHMIM@?$CFY?9?$CFm?9?$CFd?5?$CFX?3?5?$AA@ DB '%Y-%m-%d %X: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01MCMALHOG@a?$AA@
CONST	SEGMENT
??_C@_01MCMALHOG@a?$AA@ DB 'a', 00H			; `string'
_LicenseStatusText DD FLAT:??_C@_0L@NFCOGLDB@Unlicensed?$AA@
	DD	FLAT:??_C@_08BMJGAJHF@Licensed?$AA@
	DD	FLAT:??_C@_09JBIIANMO@OOB?5grace?$AA@
	DD	FLAT:??_C@_09CLFMDFGC@OOT?5grace?$AA@
	DD	FLAT:??_C@_0M@MHDDAGNF@Non?9Genuine?$AA@
	DD	FLAT:??_C@_0N@OFINCEFP@Notification?$AA@
	DD	FLAT:??_C@_0P@NCPOCFCF@Extended?5grace?$AA@
PUBLIC	_printServerFlags
PUBLIC	_printCommonFlags
PUBLIC	_printPlatform
PUBLIC	_logResponseVerbose
PUBLIC	_uuid2StringLE
PUBLIC	_logRequestVerbose
PUBLIC	_logger
PUBLIC	_errorout
PUBLIC	_printerrorf
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\output.c
;	COMDAT _printerrorf
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_printerrorf PROC					; COMDAT

; 109  : {

  00000	53		 push	 ebx

; 110  : 	int error = errno;

  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno

; 111  : 	va_list arglist;
; 112  : 
; 113  : 	va_start(arglist, fmt);
; 114  : 
; 115  : #	ifdef IS_LIBRARY
; 116  : 
; 117  : 	size_t len = strlen(ErrorMessage);
; 118  : 	vlmcsd_vsnprintf(ErrorMessage + len, MESSAGE_BUFFER_SIZE - len - 1, fmt, arglist);
; 119  : 
; 120  : #	else // !IS_LIBRARY
; 121  : 
; 122  : #	ifndef NO_LOG
; 123  : #	ifdef _NTSERVICE
; 124  : 	if (InetdMode || IsNTService)

  00007	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  0000e	8b 18		 mov	 ebx, DWORD PTR [eax]
  00010	75 37		 jne	 SHORT $LN2@printerror
  00012	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _IsNTService, 0
  00019	75 2e		 jne	 SHORT $LN2@printerror

; 129  : 	else
; 130  : #	endif //NO_LOG
; 131  : 
; 132  : #	endif // IS_LIBRARY
; 133  : 	{
; 134  : 		vfprintf(stderr, fmt, arglist);

  0001b	8d 44 24 0c	 lea	 eax, DWORD PTR _fmt$[esp+4]
  0001f	50		 push	 eax
  00020	ff 74 24 0c	 push	 DWORD PTR _fmt$[esp+4]
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0002a	83 c0 40	 add	 eax, 64			; 00000040H
  0002d	50		 push	 eax
  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vfprintf

; 135  : 		fflush(stderr);

  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  0003a	83 c0 40	 add	 eax, 64			; 00000040H
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  00044	83 c4 10	 add	 esp, 16			; 00000010H
  00047	eb 0d		 jmp	 SHORT $LN1@printerror
$LN2@printerror:

; 125  : #	else // !_NTSERVICE
; 126  : 	if (InetdMode)
; 127  : #	endif // NTSERVIICE
; 128  : 		vlogger(fmt, arglist);

  00049	8b 4c 24 08	 mov	 ecx, DWORD PTR _fmt$[esp]
  0004d	8d 54 24 0c	 lea	 edx, DWORD PTR _fmt$[esp+4]
  00051	e8 00 00 00 00	 call	 _vlogger
$LN1@printerror:

; 136  : 	}
; 137  : 
; 138  : 	va_end(arglist);
; 139  : 	errno = error;

  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0005c	89 18		 mov	 DWORD PTR [eax], ebx

; 140  : 	return 0;

  0005e	33 c0		 xor	 eax, eax
  00060	5b		 pop	 ebx

; 141  : }

  00061	c3		 ret	 0
_printerrorf ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\output.c
;	COMDAT _errorout
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_errorout PROC						; COMDAT

; 146  : {

  00000	56		 push	 esi

; 147  : 	va_list args;
; 148  : 
; 149  : 	va_start(args, fmt);
; 150  : 	int i = vfprintf(stderr, fmt, args);

  00001	8d 44 24 0c	 lea	 eax, DWORD PTR _fmt$[esp+4]
  00005	50		 push	 eax
  00006	ff 74 24 0c	 push	 DWORD PTR _fmt$[esp+4]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00010	83 c0 40	 add	 eax, 64			; 00000040H
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__vfprintf
  0001a	8b f0		 mov	 esi, eax

; 151  : 	va_end(args);
; 152  : 	fflush(stderr);

  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00022	83 c0 40	 add	 eax, 64			; 00000040H
  00025	50		 push	 eax
  00026	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  0002c	83 c4 10	 add	 esp, 16			; 00000010H

; 153  : 
; 154  : 	return i;

  0002f	8b c6		 mov	 eax, esi
  00031	5e		 pop	 esi

; 155  : }

  00032	c3		 ret	 0
_errorout ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\output.c
;	COMDAT _logger
_TEXT	SEGMENT
_fmt$ = 8						; size = 4
_logger	PROC						; COMDAT

; 96   : 	va_list args;
; 97   : 
; 98   : 	va_start(args, fmt);
; 99   : 	vlogger(fmt, args);

  00000	8b 4c 24 04	 mov	 ecx, DWORD PTR _fmt$[esp-4]
  00004	8d 54 24 08	 lea	 edx, DWORD PTR _fmt$[esp]
  00008	e8 00 00 00 00	 call	 _vlogger

; 100  : 	va_end(args);
; 101  : 	return 0;

  0000d	33 c0		 xor	 eax, eax

; 102  : }

  0000f	c3		 ret	 0
_logger	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\output.c
;	COMDAT _logRequestVerbose
_TEXT	SEGMENT
_WorkstationBuffer$ = -312				; size = 192
_mbstr$ = -120						; size = 64
_guidBuffer$ = -56					; size = 37
_st$ = -16						; size = 8
_productName$ = -4					; size = 4
_logRequestVerbose PROC					; COMDAT
; _Request$ = ecx
; _p$dead$ = edx

; 184  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 3c 01 00
	00		 sub	 esp, 316		; 0000013cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b f9		 mov	 edi, ecx

; 185  : 	char guidBuffer[GUID_STRING_LENGTH + 1];
; 186  : 	char WorkstationBuffer[3 * WORKSTATION_NAME_BUFFER];
; 187  : 	char* productName;
; 188  : 
; 189  : 	p("Protocol version                : %u.%u\n", LE16(Request->MajorVer), LE16(Request->MinorVer));

  0000e	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00011	50		 push	 eax
  00012	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]
  00016	50		 push	 eax
  00017	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@KEHOAAGG@Protocol?5version?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
  0001c	e8 00 00 00 00	 call	 _logger
  00021	83 c4 0c	 add	 esp, 12			; 0000000cH

; 190  : 	p("Client is a virtual machine     : %s\n", LE32(Request->VMInfo) ? "Yes" : "No");

  00024	33 db		 xor	 ebx, ebx
  00026	39 5f 04	 cmp	 DWORD PTR [edi+4], ebx
  00029	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02JINPPBEP@No?$AA@
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_03CCLAEDDF@Yes?$AA@
  00033	0f 44 c1	 cmove	 eax, ecx
  00036	50		 push	 eax
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CIJPHHEF@Client?5is?5a?5virtual?5machine?5?5?5?5?5@
  0003c	e8 00 00 00 00	 call	 _logger

; 191  : 	p("Licensing status                : %u (%s)\n", (uint32_t)LE32(Request->LicenseStatus), LE32(Request->LicenseStatus) < vlmcsd_countof(LicenseStatusText) ? LicenseStatusText[LE32(Request->LicenseStatus)] : "Unknown");

  00041	8b 47 08	 mov	 eax, DWORD PTR [edi+8]
  00044	59		 pop	 ecx
  00045	59		 pop	 ecx
  00046	83 f8 07	 cmp	 eax, 7
  00049	73 09		 jae	 SHORT $LN3@logRequest
  0004b	8b 0c 85 00 00
	00 00		 mov	 ecx, DWORD PTR _LicenseStatusText[eax*4]
  00052	eb 05		 jmp	 SHORT $LN4@logRequest
$LN3@logRequest:
  00054	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
$LN4@logRequest:
  00059	51		 push	 ecx
  0005a	50		 push	 eax
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@NILKFNNP@Licensing?5status?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
  00060	e8 00 00 00 00	 call	 _logger
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH

; 192  : 	p("Remaining time (0 = forever)    : %i minutes\n", (uint32_t)LE32(Request->BindingExpiration));

  00068	ff 77 0c	 push	 DWORD PTR [edi+12]
  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@GGDJLANK@Remaining?5time?5?$CI0?5?$DN?5forever?$CJ?5?5?5?5@
  00070	e8 00 00 00 00	 call	 _logger

; 193  : 
; 194  : 	uuid2StringLE(&Request->AppID, guidBuffer);

  00075	8d 55 c8	 lea	 edx, DWORD PTR _guidBuffer$[ebp]
  00078	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0007b	e8 00 00 00 00	 call	 _uuid2StringLE

; 195  : 	getProductIndex(&Request->AppID, KmsData->AppItemList, KmsData->AppItemCount, &productName, NULL);

  00080	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KmsData
  00086	8d 45 fc	 lea	 eax, DWORD PTR _productName$[ebp]
  00089	53		 push	 ebx
  0008a	50		 push	 eax
  0008b	8d 4f 10	 lea	 ecx, DWORD PTR [edi+16]
  0008e	ff 72 0c	 push	 DWORD PTR [edx+12]
  00091	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00094	e8 00 00 00 00	 call	 _getProductIndex
  00099	83 c4 14	 add	 esp, 20			; 00000014H

; 196  : 	p("Application ID                  : %s (%s)\n", guidBuffer, productName);

  0009c	8d 45 c8	 lea	 eax, DWORD PTR _guidBuffer$[ebp]
  0009f	ff 75 fc	 push	 DWORD PTR _productName$[ebp]
  000a2	50		 push	 eax
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@KHCLANPB@Application?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
  000a8	e8 00 00 00 00	 call	 _logger
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH

; 197  : 
; 198  : 	uuid2StringLE(&Request->ActID, guidBuffer);

  000b0	8d 55 c8	 lea	 edx, DWORD PTR _guidBuffer$[ebp]
  000b3	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  000b6	e8 00 00 00 00	 call	 _uuid2StringLE

; 199  : 	getProductIndex(&Request->ActID, KmsData->SkuItemList, KmsData->SkuItemCount, &productName, NULL);

  000bb	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KmsData
  000c1	8d 45 fc	 lea	 eax, DWORD PTR _productName$[ebp]
  000c4	53		 push	 ebx
  000c5	50		 push	 eax
  000c6	8d 4f 20	 lea	 ecx, DWORD PTR [edi+32]
  000c9	ff 72 14	 push	 DWORD PTR [edx+20]
  000cc	8b 52 28	 mov	 edx, DWORD PTR [edx+40]
  000cf	e8 00 00 00 00	 call	 _getProductIndex
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 200  : 	p("SKU ID (aka Activation ID)      : %s (%s)\n", guidBuffer, productName);

  000d7	8d 45 c8	 lea	 eax, DWORD PTR _guidBuffer$[ebp]
  000da	ff 75 fc	 push	 DWORD PTR _productName$[ebp]
  000dd	50		 push	 eax
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LLNJLCF@SKU?5ID?5?$CIaka?5Activation?5ID?$CJ?5?5?5?5?5?5@
  000e3	e8 00 00 00 00	 call	 _logger
  000e8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 201  : 
; 202  : 	uuid2StringLE(&Request->KMSID, guidBuffer);

  000eb	8d 55 c8	 lea	 edx, DWORD PTR _guidBuffer$[ebp]
  000ee	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  000f1	e8 00 00 00 00	 call	 _uuid2StringLE

; 203  : 	getProductIndex(&Request->KMSID, KmsData->KmsItemList, KmsData->KmsItemCount, &productName, NULL);

  000f6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KmsData
  000fc	8d 45 fc	 lea	 eax, DWORD PTR _productName$[ebp]
  000ff	53		 push	 ebx
  00100	50		 push	 eax
  00101	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  00104	ff 72 10	 push	 DWORD PTR [edx+16]
  00107	8b 52 20	 mov	 edx, DWORD PTR [edx+32]
  0010a	e8 00 00 00 00	 call	 _getProductIndex
  0010f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  : 	p("KMS ID (aka KMS counted ID)     : %s (%s)\n", guidBuffer, productName);

  00112	8d 45 c8	 lea	 eax, DWORD PTR _guidBuffer$[ebp]
  00115	ff 75 fc	 push	 DWORD PTR _productName$[ebp]
  00118	50		 push	 eax
  00119	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@MNFHGDHP@KMS?5ID?5?$CIaka?5KMS?5counted?5ID?$CJ?5?5?5?5?5@
  0011e	e8 00 00 00 00	 call	 _logger
  00123	83 c4 0c	 add	 esp, 12			; 0000000cH

; 205  : 
; 206  : 	uuid2StringLE(&Request->CMID, guidBuffer);

  00126	8d 4f 40	 lea	 ecx, DWORD PTR [edi+64]
  00129	8d 55 c8	 lea	 edx, DWORD PTR _guidBuffer$[ebp]
  0012c	e8 00 00 00 00	 call	 _uuid2StringLE

; 207  : 	p("Client machine ID               : %s\n", guidBuffer);

  00131	8d 45 c8	 lea	 eax, DWORD PTR _guidBuffer$[ebp]
  00134	50		 push	 eax
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NAJADCGN@Client?5machine?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
  0013a	e8 00 00 00 00	 call	 _logger

; 208  : 
; 209  : 	uuid2StringLE(&Request->CMID_prev, guidBuffer);

  0013f	8d 4f 5c	 lea	 ecx, DWORD PTR [edi+92]
  00142	8d 55 c8	 lea	 edx, DWORD PTR _guidBuffer$[ebp]
  00145	e8 00 00 00 00	 call	 _uuid2StringLE

; 210  : 	p("Previous client machine ID      : %s\n", guidBuffer);

  0014a	8d 45 c8	 lea	 eax, DWORD PTR _guidBuffer$[ebp]
  0014d	50		 push	 eax
  0014e	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KNAHJFGH@Previous?5client?5machine?5ID?5?5?5?5?5?5@
  00153	e8 00 00 00 00	 call	 _logger
  00158	83 c4 10	 add	 esp, 16			; 00000010H

; 211  : 
; 212  : 
; 213  : 	char mbstr[64];
; 214  : 	time_t st;
; 215  : 	st = fileTimeToUnixTime(&Request->ClientTime);

  0015b	53		 push	 ebx
  0015c	68 80 96 98 00	 push	 10000000		; 00989680H
  00161	ff 77 58	 push	 DWORD PTR [edi+88]
  00164	ff 77 54	 push	 DWORD PTR [edi+84]
  00167	e8 00 00 00 00	 call	 __aulldiv
  0016c	2d 00 91 10 b6	 sub	 eax, -1240428288	; b6109100H
  00171	89 45 f0	 mov	 DWORD PTR _st$[ebp], eax

; 216  : 	strftime(mbstr, sizeof(mbstr), "%Y-%m-%d %X", gmtime(&st));

  00174	8d 45 f0	 lea	 eax, DWORD PTR _st$[ebp]
  00177	83 da 02	 sbb	 edx, 2
  0017a	50		 push	 eax
  0017b	89 55 f4	 mov	 DWORD PTR _st$[ebp+4], edx
  0017e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___gmtime64
  00184	59		 pop	 ecx
  00185	50		 push	 eax
  00186	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EHAPGNAC@?$CFY?9?$CFm?9?$CFd?5?$CFX?$AA@
  0018b	8d 45 88	 lea	 eax, DWORD PTR _mbstr$[ebp]
  0018e	6a 40		 push	 64			; 00000040H
  00190	50		 push	 eax
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strftime

; 217  : 	p("Client request timestamp (UTC)  : %s\n", mbstr);

  00197	8d 45 88	 lea	 eax, DWORD PTR _mbstr$[ebp]
  0019a	50		 push	 eax
  0019b	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CCLOIHMC@Client?5request?5timestamp?5?$CIUTC?$CJ?5?5@
  001a0	e8 00 00 00 00	 call	 _logger
  001a5	83 c4 18	 add	 esp, 24			; 00000018H

; 218  : 
; 219  : 	ucs2_to_utf8(Request->WorkstationName, WorkstationBuffer, WORKSTATION_NAME_BUFFER, sizeof(WorkstationBuffer));

  001a8	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR _WorkstationBuffer$[ebp]
  001ae	68 c0 00 00 00	 push	 192			; 000000c0H
  001b3	51		 push	 ecx
  001b4	8d 4f 6c	 lea	 ecx, DWORD PTR [edi+108]
  001b7	e8 00 00 00 00	 call	 _ucs2_to_utf8

; 220  : 
; 221  : 	p("Workstation name                : %s\n", WorkstationBuffer);

  001bc	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR _WorkstationBuffer$[ebp]
  001c2	50		 push	 eax
  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NJMNAEGJ@Workstation?5name?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
  001c8	e8 00 00 00 00	 call	 _logger

; 222  : 	p("N count policy (minimum clients): %u\n", (uint32_t)LE32(Request->N_Policy));

  001cd	ff 77 50	 push	 DWORD PTR [edi+80]
  001d0	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@KONHMDAE@N?5count?5policy?5?$CIminimum?5clients?$CJ@
  001d5	e8 00 00 00 00	 call	 _logger
  001da	83 c4 18	 add	 esp, 24			; 00000018H

; 223  : }

  001dd	5f		 pop	 edi
  001de	5e		 pop	 esi
  001df	5b		 pop	 ebx
  001e0	8b e5		 mov	 esp, ebp
  001e2	5d		 pop	 ebp
  001e3	c3		 ret	 0
_logRequestVerbose ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\output.c
;	COMDAT _uuid2StringLE
_TEXT	SEGMENT
_uuid2StringLE PROC					; COMDAT
; _guid$ = ecx
; _string$ = edx

; 167  : {

  00000	56		 push	 esi
  00001	57		 push	 edi
  00002	8b f9		 mov	 edi, ecx

; 168  : 	sprintf(string,
; 169  : #		ifdef _WIN32
; 170  : 		"%08x-%04x-%04x-%04x-%012I64x",
; 171  : #		else
; 172  : 		"%08x-%04x-%04x-%04x-%012llx",
; 173  : #		endif
; 174  : 		(unsigned int)LE32(guid->Data1),
; 175  : 		(unsigned int)LE16(guid->Data2),
; 176  : 		(unsigned int)LE16(guid->Data3),
; 177  : 		(unsigned int)BE16(*(uint16_t*)guid->Data4),
; 178  : 		(unsigned long long)BE64(*(uint64_t*)(guid->Data4)) & 0xffffffffffffLL
; 179  : 	);

  00004	8b 77 08	 mov	 esi, DWORD PTR [edi+8]
  00007	8b 47 0c	 mov	 eax, DWORD PTR [edi+12]
  0000a	0f c8		 bswap	 eax
  0000c	0f ce		 bswap	 esi
  0000e	81 e6 ff ff 00
	00		 and	 esi, 65535		; 0000ffffH
  00014	56		 push	 esi
  00015	50		 push	 eax
  00016	66 8b 47 08	 mov	 ax, WORD PTR [edi+8]
  0001a	8a e8		 mov	 ch, al
  0001c	8a cc		 mov	 cl, ah
  0001e	0f b7 c1	 movzx	 eax, cx
  00021	50		 push	 eax
  00022	0f b7 47 06	 movzx	 eax, WORD PTR [edi+6]
  00026	50		 push	 eax
  00027	0f b7 47 04	 movzx	 eax, WORD PTR [edi+4]
  0002b	50		 push	 eax
  0002c	ff 37		 push	 DWORD PTR [edi]
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_0BN@LENFACPA@?$CF08x?9?$CF04x?9?$CF04x?9?$CF04x?9?$CF012I64x?$AA@
  00033	52		 push	 edx
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  0003a	83 c4 20	 add	 esp, 32			; 00000020H

; 180  : }

  0003d	5f		 pop	 edi
  0003e	5e		 pop	 esi
  0003f	c3		 ret	 0
_uuid2StringLE ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\output.c
;	COMDAT _logResponseVerbose
_TEXT	SEGMENT
_mbstr$ = -112						; size = 64
_guidBuffer$ = -48					; size = 37
_st$ = -8						; size = 8
_response$ = 8						; size = 4
_p$dead$ = 12						; size = 4
_logResponseVerbose PROC				; COMDAT
; _ePID$ = ecx
; _hwid$ = edx

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 74	 sub	 esp, 116		; 00000074H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 227  : 	char guidBuffer[GUID_STRING_LENGTH + 1];
; 228  : 
; 229  : 	p("Protocol version                : %u.%u\n", (uint32_t)LE16(response->MajorVer), (uint32_t)LE16(response->MinorVer));

  00009	8b 7d 08	 mov	 edi, DWORD PTR _response$[ebp]
  0000c	8b da		 mov	 ebx, edx
  0000e	8b f1		 mov	 esi, ecx
  00010	0f b7 07	 movzx	 eax, WORD PTR [edi]
  00013	50		 push	 eax
  00014	0f b7 47 02	 movzx	 eax, WORD PTR [edi+2]
  00018	50		 push	 eax
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@KEHOAAGG@Protocol?5version?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
  0001e	e8 00 00 00 00	 call	 _logger
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 230  : 	p("KMS host extended PID           : %s\n", ePID);

  00026	56		 push	 esi
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CKMBAHPA@KMS?5host?5extended?5PID?5?5?5?5?5?5?5?5?5?5?5@
  0002c	e8 00 00 00 00	 call	 _logger

; 231  : 	if (LE16(response->MajorVer) > 5)

  00031	66 83 7f 02 05	 cmp	 WORD PTR [edi+2], 5
  00036	59		 pop	 ecx
  00037	59		 pop	 ecx
  00038	76 18		 jbe	 SHORT $LN1@logRespons

; 232  : #	ifndef _WIN32
; 233  : 		p("KMS host Hardware ID            : %016llX\n", (unsigned long long)BE64(*(uint64_t*)hwid));
; 234  : #	else // _WIN32
; 235  : 		p("KMS host Hardware ID            : %016I64X\n", (unsigned long long)BE64(*(uint64_t*)hwid));

  0003a	8b 03		 mov	 eax, DWORD PTR [ebx]
  0003c	8b 4b 04	 mov	 ecx, DWORD PTR [ebx+4]
  0003f	0f c8		 bswap	 eax
  00041	50		 push	 eax
  00042	0f c9		 bswap	 ecx
  00044	51		 push	 ecx
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_0CM@BGLDHKHD@KMS?5host?5Hardware?5ID?5?5?5?5?5?5?5?5?5?5?5?5@
  0004a	e8 00 00 00 00	 call	 _logger
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@logRespons:

; 236  : #	endif // WIN32
; 237  : 
; 238  : 	uuid2StringLE(&response->CMID, guidBuffer);

  00052	8d 8f 88 00 00
	00		 lea	 ecx, DWORD PTR [edi+136]
  00058	8d 55 d0	 lea	 edx, DWORD PTR _guidBuffer$[ebp]
  0005b	e8 00 00 00 00	 call	 _uuid2StringLE

; 239  : 	p("Client machine ID               : %s\n", guidBuffer);

  00060	8d 45 d0	 lea	 eax, DWORD PTR _guidBuffer$[ebp]
  00063	50		 push	 eax
  00064	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@NAJADCGN@Client?5machine?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
  00069	e8 00 00 00 00	 call	 _logger
  0006e	59		 pop	 ecx
  0006f	59		 pop	 ecx

; 240  : 
; 241  : 	char mbstr[64];
; 242  : 	time_t st;
; 243  : 
; 244  : 	st = fileTimeToUnixTime(&response->ClientTime);

  00070	6a 00		 push	 0
  00072	68 80 96 98 00	 push	 10000000		; 00989680H
  00077	ff b7 9c 00 00
	00		 push	 DWORD PTR [edi+156]
  0007d	ff b7 98 00 00
	00		 push	 DWORD PTR [edi+152]
  00083	e8 00 00 00 00	 call	 __aulldiv
  00088	2d 00 91 10 b6	 sub	 eax, -1240428288	; b6109100H
  0008d	89 45 f8	 mov	 DWORD PTR _st$[ebp], eax

; 245  : 	strftime(mbstr, sizeof(mbstr), "%Y-%m-%d %X", gmtime(&st));

  00090	8d 45 f8	 lea	 eax, DWORD PTR _st$[ebp]
  00093	83 da 02	 sbb	 edx, 2
  00096	50		 push	 eax
  00097	89 55 fc	 mov	 DWORD PTR _st$[ebp+4], edx
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___gmtime64
  000a0	59		 pop	 ecx
  000a1	50		 push	 eax
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_0M@EHAPGNAC@?$CFY?9?$CFm?9?$CFd?5?$CFX?$AA@
  000a7	8d 45 90	 lea	 eax, DWORD PTR _mbstr$[ebp]
  000aa	6a 40		 push	 64			; 00000040H
  000ac	50		 push	 eax
  000ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strftime

; 246  : 	p("Client request timestamp (UTC)  : %s\n", mbstr);

  000b3	8d 45 90	 lea	 eax, DWORD PTR _mbstr$[ebp]
  000b6	50		 push	 eax
  000b7	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CCLOIHMC@Client?5request?5timestamp?5?$CIUTC?$CJ?5?5@
  000bc	e8 00 00 00 00	 call	 _logger

; 247  : 
; 248  : 	p("KMS host current active clients : %u\n", (uint32_t)LE32(response->Count));

  000c1	ff b7 a0 00 00
	00		 push	 DWORD PTR [edi+160]
  000c7	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@CKOEJNCP@KMS?5host?5current?5active?5clients?5@
  000cc	e8 00 00 00 00	 call	 _logger

; 249  : 	p("Renewal interval policy         : %u\n", (uint32_t)LE32(response->VLRenewalInterval));

  000d1	ff b7 a8 00 00
	00		 push	 DWORD PTR [edi+168]
  000d7	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@HGDBGCN@Renewal?5interval?5policy?5?5?5?5?5?5?5?5?5@
  000dc	e8 00 00 00 00	 call	 _logger

; 250  : 	p("Activation interval policy      : %u\n", (uint32_t)LE32(response->VLActivationInterval));

  000e1	ff b7 a4 00 00
	00		 push	 DWORD PTR [edi+164]
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@EIDEKNCG@Activation?5interval?5policy?5?5?5?5?5?5@
  000ec	e8 00 00 00 00	 call	 _logger
  000f1	83 c4 30	 add	 esp, 48			; 00000030H

; 251  : }

  000f4	5f		 pop	 edi
  000f5	5e		 pop	 esi
  000f6	5b		 pop	 ebx
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
_logResponseVerbose ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
;	COMDAT _gmtime
_TEXT	SEGMENT
_gmtime	PROC						; COMDAT
; __Time$ = ecx

; 101  : #pragma warning( push )
; 102  : #pragma warning( disable : 4996 )
; 103  :     return _gmtime64(_Time);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___gmtime64
  00007	59		 pop	 ecx

; 104  : #pragma warning( pop )
; 105  : }

  00008	c3		 ret	 0
_gmtime	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
;	COMDAT _localtime
_TEXT	SEGMENT
_localtime PROC						; COMDAT
; __Time$ = ecx

; 114  : #pragma warning( push )
; 115  : #pragma warning( disable : 4996 )
; 116  :     return _localtime64(_Time);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
  00007	59		 pop	 ecx

; 117  : #pragma warning( pop )
; 118  : }

  00008	c3		 ret	 0
_localtime ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$dead$ = ecx

; 133  :     return _time64(_Time);

  00000	6a 00		 push	 0
  00002	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00008	59		 pop	 ecx

; 134  : }

  00009	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\output.c
;	COMDAT _vlogger
_TEXT	SEGMENT
_message$1$ = -2060					; size = 4
_now$ = -2056						; size = 8
_mbstr$ = -2048						; size = 2048
_vlogger PROC						; COMDAT
; _message$ = ecx
; _args$ = edx

; 23   : {

  00000	81 ec 0c 08 00
	00		 sub	 esp, 2060		; 0000080cH

; 24   : 	FILE *log;
; 25   : 
; 26   : #	ifdef _NTSERVICE
; 27   : 	if (!IsNTService && logstdout) log = stdout;

  00006	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _IsNTService, 0
  0000d	55		 push	 ebp
  0000e	56		 push	 esi
  0000f	8b ea		 mov	 ebp, edx
  00011	89 4c 24 08	 mov	 DWORD PTR _message$1$[esp+2068], ecx
  00015	75 14		 jne	 SHORT $LN7@vlogger
  00017	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _logstdout, 0
  0001e	74 0b		 je	 SHORT $LN7@vlogger
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00026	8d 70 20	 lea	 esi, DWORD PTR [eax+32]

; 28   : #	else
; 29   : 	if (logstdout) log = stdout;
; 30   : #	endif
; 31   : 	else

  00029	eb 25		 jmp	 SHORT $LN4@vlogger
$LN7@vlogger:

; 32   : 	{
; 33   : 		if (fn_log == NULL) return;

  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR _fn_log
  00030	85 c0		 test	 eax, eax
  00032	0f 84 b5 00 00
	00		 je	 $LN1@vlogger

; 34   : 
; 35   : #		ifndef _WIN32
; 36   : 		if (!strcmp(fn_log, "syslog"))
; 37   : 		{
; 38   : 			openlog("vlmcsd", LOG_CONS | LOG_PID, LOG_USER);
; 39   : 
; 40   : 			////PORTABILITY: vsyslog is not in Posix but virtually all Unixes have it
; 41   : 			vsyslog(LOG_INFO, message, args);
; 42   : 
; 43   : 			closelog();
; 44   : 			return;
; 45   : 		}
; 46   : #		endif // _WIN32
; 47   : 
; 48   : 		log = fopen(fn_log, "a");

  00038	68 00 00 00 00	 push	 OFFSET ??_C@_01MCMALHOG@a?$AA@
  0003d	50		 push	 eax
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  00044	8b f0		 mov	 esi, eax
  00046	59		 pop	 ecx
  00047	59		 pop	 ecx

; 49   : 		if (!log) return;

  00048	85 f6		 test	 esi, esi
  0004a	0f 84 9d 00 00
	00		 je	 $LN1@vlogger
$LN4@vlogger:
  00050	57		 push	 edi

; 50   : 	}
; 51   : 
; 52   : 	time_t now = time(0);

  00051	6a 00		 push	 0
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64

; 53   : 
; 54   : #	ifdef USE_THREADS
; 55   : 	char mbstr[2048];
; 56   : #	else
; 57   : 	char mbstr[24];
; 58   : #	endif
; 59   : 
; 60   : 	if (LogDateAndTime)

  00059	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _LogDateAndTime, 0
  00060	bf 00 08 00 00	 mov	 edi, 2048		; 00000800H
  00065	59		 pop	 ecx
  00066	89 44 24 10	 mov	 DWORD PTR _now$[esp+2072], eax
  0006a	89 54 24 14	 mov	 DWORD PTR _now$[esp+2076], edx
  0006e	74 22		 je	 SHORT $LN3@vlogger

; 61   : 		strftime(mbstr, sizeof(mbstr), "%Y-%m-%d %X: ", localtime(&now));

  00070	8d 44 24 10	 lea	 eax, DWORD PTR _now$[esp+2072]
  00074	50		 push	 eax
  00075	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___localtime64
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LNENHMIM@?$CFY?9?$CFm?9?$CFd?5?$CFX?3?5?$AA@
  00081	8d 44 24 24	 lea	 eax, DWORD PTR _mbstr$[esp+2084]
  00085	57		 push	 edi
  00086	50		 push	 eax
  00087	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strftime
  0008d	83 c4 14	 add	 esp, 20			; 00000014H

; 62   : 	else

  00090	eb 05		 jmp	 SHORT $LN2@vlogger
$LN3@vlogger:

; 63   : 		*mbstr = 0;

  00092	c6 44 24 18 00	 mov	 BYTE PTR _mbstr$[esp+2072], 0
$LN2@vlogger:

; 64   : 
; 65   : #	ifndef USE_THREADS
; 66   : 
; 67   : 	fprintf(log, "%s", mbstr);
; 68   : 	vfprintf(log, message, args);
; 69   : 	fflush(log);
; 70   : 
; 71   : #	else // USE_THREADS
; 72   : 
; 73   : 	// We write everything to a string before we really log inside the critical section
; 74   : 	// so formatting the output can be concurrent
; 75   : 	int len = (int)strlen(mbstr);

  00097	8d 4c 24 18	 lea	 ecx, DWORD PTR _mbstr$[esp+2072]
  0009b	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL14@vlogger:
  0009e	8a 01		 mov	 al, BYTE PTR [ecx]
  000a0	41		 inc	 ecx
  000a1	84 c0		 test	 al, al
  000a3	75 f9		 jne	 SHORT $LL14@vlogger

; 76   : 	//#	if !_MSC_VER
; 77   : 
; 78   : 	vlmcsd_vsnprintf(mbstr + len, sizeof(mbstr) - len, message, args);

  000a5	55		 push	 ebp
  000a6	ff 74 24 10	 push	 DWORD PTR _message$1$[esp+2076]
  000aa	2b ca		 sub	 ecx, edx
  000ac	8d 44 24 20	 lea	 eax, DWORD PTR _mbstr$[esp+2080]
  000b0	2b f9		 sub	 edi, ecx
  000b2	03 c1		 add	 eax, ecx
  000b4	57		 push	 edi
  000b5	50		 push	 eax
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnprintf

; 79   : 	//#	else
; 80   : 	//	wvsprintf(mbstr + len, message, args);
; 81   : 	//#	endif
; 82   : 
; 83   : 	lock_mutex(&logmutex);
; 84   : 	fprintf(log, "%s", mbstr);

  000bc	8d 44 24 28	 lea	 eax, DWORD PTR _mbstr$[esp+2088]
  000c0	50		 push	 eax
  000c1	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  000c6	56		 push	 esi
  000c7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf

; 85   : 	fflush(log);

  000cd	56		 push	 esi
  000ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  000d4	83 c4 20	 add	 esp, 32			; 00000020H

; 86   : 	unlock_mutex(&logmutex);
; 87   : 
; 88   : #	endif // USE_THREADS
; 89   : 	if (log != stdout) fclose(log);

  000d7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  000dd	83 c0 20	 add	 eax, 32			; 00000020H
  000e0	5f		 pop	 edi
  000e1	3b f0		 cmp	 esi, eax
  000e3	74 08		 je	 SHORT $LN1@vlogger
  000e5	56		 push	 esi
  000e6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  000ec	59		 pop	 ecx
$LN1@vlogger:
  000ed	5e		 pop	 esi
  000ee	5d		 pop	 ebp

; 90   : }

  000ef	81 c4 0c 08 00
	00		 add	 esp, 2060		; 0000080cH
  000f5	c3		 ret	 0
_vlogger ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\output.c
;	COMDAT _printPlatform
_TEXT	SEGMENT
_printPlatform PROC					; COMDAT

; 258  : 	int testNumber = 0x1234;
; 259  : 
; 260  : #	if _MSC_VER
; 261  : 	printf("Compiler: VC++ %02i.%02i build %i\n", _MSC_VER / 100, _MSC_VER % 100, _MSC_FULL_VER % 100000);

  00000	68 b5 9e 00 00	 push	 40629			; 00009eb5H
  00005	6a 00		 push	 0
  00007	6a 12		 push	 18			; 00000012H
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FAKKKCEM@Compiler?3?5VC?$CL?$CL?5?$CF02i?4?$CF02i?5build?5?$CF@
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf

; 262  : #	elif defined(VLMCSD_COMPILER)
; 263  : 	printf
; 264  : 	(
; 265  : 		"Compiler: %s\n", VLMCSD_COMPILER
; 266  : #		ifdef __VERSION__
; 267  : 		" " __VERSION__
; 268  : #		endif // __VERSION__
; 269  : 	);
; 270  : #	endif // VLMCSD_COMPILER
; 271  : 
; 272  : 	printf
; 273  : 	(
; 274  : 		"Intended platform:%s %s\n", ""
; 275  : 
; 276  : #		if __i386__ || _M_IX86
; 277  : 		" Intel x86"
; 278  : #		endif
; 279  : 
; 280  : #		if __x86_64__ || __amd64__ || _M_X64 || _M_AMD64
; 281  : 		" Intel x86_64"
; 282  : #		endif
; 283  : 
; 284  : #		if _M_ARM || __arm__
; 285  : 		" ARM"
; 286  : #		endif
; 287  : 
; 288  : #		if __thumb__
; 289  : 		" thumb"
; 290  : #		endif
; 291  : 
; 292  : #		if __aarch64__
; 293  : 		" ARM64"
; 294  : #		endif
; 295  : 
; 296  : #		if __hppa__
; 297  : 		" HP/PA RISC"
; 298  : #		endif
; 299  : 
; 300  : #		if __ia64__
; 301  : 		" Intel Itanium"
; 302  : #		endif
; 303  : 
; 304  : #		if __mips__
; 305  : 		" MIPS"
; 306  : #		endif
; 307  : 
; 308  : #		if defined(_MIPS_ARCH)
; 309  : 		" " _MIPS_ARCH
; 310  : #		endif
; 311  : 
; 312  : #		if __mips16
; 313  : 		" mips16"
; 314  : #		endif
; 315  : 
; 316  : #		if __mips_micromips
; 317  : 		" micromips"
; 318  : #		endif
; 319  : 
; 320  : #		if __ppc__ || __powerpc__
; 321  : 		" PowerPC"
; 322  : #		endif
; 323  : 
; 324  : #		if __powerpc64__ || __ppc64__
; 325  : 		" PowerPC64"
; 326  : #		endif
; 327  : 
; 328  : #		if __sparc__
; 329  : 		" SPARC"
; 330  : #		endif
; 331  : 
; 332  : #		if defined(__s390__) && !defined(__zarch__) && !defined(__s390x__)
; 333  : 		" IBM S/390"
; 334  : #		endif
; 335  : 
; 336  : #		if __zarch__ || __s390x__
; 337  : 		" IBM z/Arch (S/390x)"
; 338  : #		endif
; 339  : 
; 340  : #		if __m68k__
; 341  : 		" Motorola 68k"
; 342  : #		endif
; 343  : 
; 344  : #		if __ANDROID__
; 345  : 		" Android"
; 346  : #		endif
; 347  : 
; 348  : #		if __ANDROID_API__
; 349  : 		" (API level " ANDROID_API_LEVEL ")"
; 350  : #		endif
; 351  : 
; 352  : #		if __FreeBSD__ || __FreeBSD_kernel__
; 353  : 		" FreeBSD"
; 354  : #		endif
; 355  : 
; 356  : #		if __NetBSD__
; 357  : 		" NetBSD"
; 358  : #		endif
; 359  : 
; 360  : #		if __OpenBSD__
; 361  : 		" OpenBSD"
; 362  : #		endif
; 363  : 
; 364  : #		if __DragonFly__
; 365  : 		" DragonFly BSD"
; 366  : #		endif
; 367  : 
; 368  : #		if defined(__CYGWIN__) && !defined(_WIN64)
; 369  : 		" Cygwin32"
; 370  : #		endif
; 371  : 
; 372  : #		if defined(__CYGWIN__) && defined(_WIN64)
; 373  : 		" Cygwin64"
; 374  : #		endif
; 375  : 
; 376  : #		if __GNU__
; 377  : 		" GNU"
; 378  : #		endif
; 379  : 
; 380  : #		if __gnu_hurd__
; 381  : 		" Hurd"
; 382  : #		endif
; 383  : 
; 384  : #		if __MACH__
; 385  : 		" Mach"
; 386  : #		endif
; 387  : 
; 388  : #		if __linux__
; 389  : 		" Linux"
; 390  : #		endif
; 391  : 
; 392  : #		if __APPLE__ && __MACH__
; 393  : 		" Darwin"
; 394  : #		endif
; 395  : 
; 396  : #		if  __minix__
; 397  : 		" Minix"
; 398  : #		endif
; 399  : 
; 400  : #		if __QNX__
; 401  : 		" QNX"
; 402  : #		endif
; 403  : 
; 404  : #		if __svr4__ || __SVR4
; 405  : 		" SYSV R4"
; 406  : #		endif	
; 407  : 
; 408  : #		if (defined(__sun__) || defined(sun) || defined(__sun)) && (defined(__SVR4) || defined(__svr4__))
; 409  : 		" Solaris"
; 410  : #		endif
; 411  : 
; 412  : #		if (defined(__sun__) || defined(sun) || defined(__sun)) && !defined(__SVR4) && !defined(__svr4__)
; 413  : 		" SunOS"
; 414  : #		endif
; 415  : 
; 416  : #		if defined(_WIN32) && !defined(_WIN64)
; 417  : 		" Windows32"
; 418  : #		endif
; 419  : 
; 420  : #		if defined(_WIN32) && defined(_WIN64)
; 421  : 		" Windows64"
; 422  : #		endif
; 423  : 
; 424  : #		if __MVS__ || __TOS_MVS__
; 425  : 		" z/OS"
; 426  : #		endif
; 427  : 
; 428  : #		if defined(__GLIBC__) && !defined(__UCLIBC__)
; 429  : 		" glibc"
; 430  : #		endif
; 431  : 
; 432  : #		if __UCLIBC__
; 433  : 		" uclibc"
; 434  : #		endif
; 435  : 
; 436  : #		if defined(__linux__) && !defined(__GLIBC__) && !defined(__UCLIBC__) && !defined(__ANDROID__) && !defined(__BIONIC__)
; 437  : 		" musl"
; 438  : #		endif
; 439  : 
; 440  : 		//#		if _MIPSEL || __MIPSEL__ || __ARMEL__ || __THUMBEL__
; 441  : 		//		" little-endian"
; 442  : 		//#		endif
; 443  : 		//
; 444  : 		//#		if _MIPSEB || __MIPSEB__ || __ARMEB__ || __THUMBEB__
; 445  : 		//		" big-endian"
; 446  : 		//#		endif
; 447  : 
; 448  : #		if __PIE__ || __pie__
; 449  : 		" PIE"
; 450  : #		endif
; 451  : 		,
; 452  : 		*((uint8_t*)&testNumber) == 0x34 ? "little-endian" : "big-endian"
; 453  : 	);

  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KEGGAHLA@little?9endian?$AA@
  00019	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KAHIDINA@?5Intel?5x86?5Windows32?$AA@
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@MBJNOFCM@Intended?5platform?3?$CFs?5?$CFs?6?$AA@
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00029	83 c4 1c	 add	 esp, 28			; 0000001cH

; 454  : 
; 455  : }

  0002c	c3		 ret	 0
_printPlatform ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\output.c
;	COMDAT _printCommonFlags
_TEXT	SEGMENT
_printCommonFlags PROC					; COMDAT

; 460  : 	printf
; 461  : 	(
; 462  : 		"Common flags:%s\n", ""
; 463  : 
; 464  : #		ifdef NO_EXTERNAL_DATA
; 465  : 		" NO_EXTERNAL_DATA"
; 466  : #		endif // NO_EXTERNAL_DATA
; 467  : 
; 468  : #		ifdef NO_INTERNAL_DATA
; 469  : 		" NO_INTERNAL_DATA"
; 470  : #		endif // NO_INTERNAL_DATA
; 471  : 
; 472  : #		if !defined(NO_EXTERNAL_DATA)
; 473  : 
; 474  : #		ifdef DATA_FILE
; 475  : 		" DATA=" DATA_FILE
; 476  : #		endif // DATA_FILE
; 477  : 
; 478  : #		ifdef UNSAFE_DATA_LOAD
; 479  : 		" UNSAFE_DATA_LOAD"
; 480  : #		endif // UNSAFE_DATA_LOAD
; 481  : 
; 482  : #		endif // !defined(NO_EXTERNAL_DATA)
; 483  : 
; 484  : #		ifdef USE_MSRPC
; 485  : 		" USE_MSRPC"
; 486  : #		endif // USE_MSRPC
; 487  : 
; 488  : #		ifdef _CRYPTO_OPENSSL
; 489  : 		" _CRYPTO_OPENSSL"
; 490  : #		endif // _CRYPTO_OPENSSL
; 491  : 
; 492  : #		ifdef _CRYPTO_POLARSSL
; 493  : 		" _CRYPTO_POLARSSL"
; 494  : #		endif // _CRYPTO_POLARSSL
; 495  : 
; 496  : #		ifdef _CRYPTO_WINDOWS
; 497  : 		" _CRYPTO_WINDOWS"
; 498  : #		endif // _CRYPTO_WINDOWS
; 499  : 
; 500  : #		if defined(_OPENSSL_SOFTWARE) && defined(_CRYPTO_OPENSSL)
; 501  : 		" _OPENSSL_SOFTWARE"
; 502  : #		endif // _OPENSSL_SOFTWARE
; 503  : 
; 504  : #		if defined(_USE_AES_FROM_OPENSSL) && defined(_CRYPTO_OPENSSL)
; 505  : 		" _USE_AES_FROM_OPENSSL"
; 506  : #		endif // _USE_AES_FROM_OPENSSL
; 507  : 
; 508  : #		if defined(_OPENSSL_NO_HMAC) && defined(_CRYPTO_OPENSSL)
; 509  : 		" OPENSSL_HMAC=0"
; 510  : #		endif // _OPENSSL_NO_HMAC
; 511  : 
; 512  : #		ifdef _PEDANTIC
; 513  : 		" _PEDANTIC"
; 514  : #		endif // _PEDANTIC
; 515  : 
; 516  : #		ifdef INCLUDE_BETAS
; 517  : 		" INCLUDE_BETAS"
; 518  : #		endif // INCLUDE_BETAS
; 519  : 
; 520  : #		if __minix__ || defined(NO_TIMEOUT)
; 521  : 		" NO_TIMEOUT=1"
; 522  : #		endif // __minix__ || defined(NO_TIMEOUT)
; 523  : 	);

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NGPJLHEC@?5_CRYPTO_WINDOWS?$AA@
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NGBEHLG@Common?5flags?3?$CFs?6?$AA@
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00010	59		 pop	 ecx
  00011	59		 pop	 ecx

; 524  : }

  00012	c3		 ret	 0
_printCommonFlags ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\output.c
;	COMDAT _printServerFlags
_TEXT	SEGMENT
_printServerFlags PROC					; COMDAT

; 554  : 	printf
; 555  : 	(
; 556  : 		"vlmcsd flags:%s\n", ""
; 557  : 
; 558  : #		ifdef NO_LOG
; 559  : 		" NO_LOG"
; 560  : #		endif // NO_LOG
; 561  : 
; 562  : #		ifdef NO_RANDOM_EPID
; 563  : 		" NO_RANDOM_EPID"
; 564  : #		endif // NO_RANDOM_EPID
; 565  : 
; 566  : #		ifdef NO_INI_FILE
; 567  : 		" NO_INI_FILE"
; 568  : #		endif // NO_INI_FILE
; 569  : 
; 570  : #		if !defined(NO_INI_FILE) && defined(INI_FILE)
; 571  : 		" INI=" INI_FILE
; 572  : #		endif // !defined(NO_INI_FILE)
; 573  : 
; 574  : #		ifdef NO_PID_FILE
; 575  : 		" NO_PID_FILE"
; 576  : #		endif // NO_PID_FILE
; 577  : 
; 578  : #		ifdef NO_USER_SWITCH
; 579  : 		" NO_USER_SWITCH"
; 580  : #		endif // NO_USER_SWITCH
; 581  : 
; 582  : #		ifdef NO_HELP
; 583  : 		" NO_HELP"
; 584  : #		endif // NO_HELP
; 585  : 
; 586  : #		ifdef NO_STRICT_MODES
; 587  : 		" NO_STRICT_MODES"
; 588  : #		endif // NO_STRICT_MODES
; 589  : 
; 590  : #		ifdef NO_CUSTOM_INTERVALS
; 591  : 		" NO_CUSTOM_INTERVALS"
; 592  : #		endif // NO_CUSTOM_INTERVALS
; 593  : 
; 594  : #		ifdef NO_SOCKETS
; 595  : 		" NO_SOCKETS"
; 596  : #		endif // NO_SOCKETS
; 597  : 
; 598  : #		ifdef NO_CL_PIDS
; 599  : 		" NO_CL_PIDS"
; 600  : #		endif // NO_CL_PIDS
; 601  : 
; 602  : #		ifdef NO_LIMIT
; 603  : 		" NO_LIMIT"
; 604  : #		endif // NO_LIMIT
; 605  : 
; 606  : #		ifdef NO_SIGHUP
; 607  : 		" NO_SIGHUP"
; 608  : #		endif // NO_SIGHUP
; 609  : 
; 610  : #		ifdef NO_PROCFS
; 611  : 		" NOPROCFS=1"
; 612  : #		endif // NO_PROCFS
; 613  : 
; 614  : #		ifdef USE_THREADS
; 615  : 		" THREADS=1"
; 616  : #		endif // USE_THREADS
; 617  : 
; 618  : #		ifdef USE_AUXV
; 619  : 		" AUXV=1"
; 620  : #		endif // USE_AUXV
; 621  : 
; 622  : #		if defined(CHILD_HANDLER) || __minix__
; 623  : 		" CHILD_HANDLER=1"
; 624  : #		endif // defined(CHILD_HANDLER) || __minix__
; 625  : 
; 626  : #		if !defined(NO_SOCKETS) && defined(SIMPLE_SOCKETS)
; 627  : 		" SIMPLE_SOCKETS"
; 628  : #		endif // !defined(NO_SOCKETS) && defined(SIMPLE_SOCKETS)
; 629  : 
; 630  : #		ifdef SIMPLE_RPC
; 631  : 		" SIMPLE_RPC"
; 632  : #		endif // SIMPLE_RPC
; 633  : 
; 634  : #		ifdef NO_STRICT_MODES
; 635  : 		" NO_STRICT_MODES"
; 636  : #		endif // NO_STRICT_MODES
; 637  : 
; 638  : #		ifdef NO_CLIENT_LIST
; 639  : 		" NO_CLIENT_LIST"
; 640  : #		endif // NO_CLIENT_LIST
; 641  : 
; 642  : #		if (_WIN32 || __CYGWIN__) && (!defined(USE_MSRPC) || defined(SUPPORT_WINE))
; 643  : 		" SUPPORT_WINE"
; 644  : #		endif // (_WIN32 || __CYGWIN__) && (!defined(USE_MSRPC) || defined(SUPPORT_WINE))
; 645  : 
; 646  : #		if (_WIN32 || __CYGWIN__) && defined(NO_TAP)
; 647  : 		" NO_TAP"
; 648  : #		endif // (_WIN32 || __CYGWIN__) && defined(NO_TAP)
; 649  : 
; 650  : #		if !HAVE_FREEBIND
; 651  : 		" NO_FREEBIND"
; 652  : #		endif //!HAVE_FREEBIND
; 653  : 
; 654  : #		if !HAVE_GETIFADDR
; 655  : 		" !HAVE_GETIFADDR"
; 656  : #		endif // !HAVE_GETIFADDR
; 657  : 
; 658  : #		if HAVE_GETIFADDR && defined(GETIFADDRS_MUSL)
; 659  : 		" GETIFADDRS=musl"
; 660  : #		endif // HAVE_GETIFADDR && defined(GETIFADDRS_MUSL)
; 661  : 
; 662  : #		if defined(NO_PRIVATE_IP_DETECT)
; 663  : 		" NO_PRIVATE_IP_DETECT"
; 664  : #		endif // defined(NO_PRIVATE_IP_DETECT)
; 665  : 	);

  00000	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@DNHMBJJK@?5NO_SIGHUP?5THREADS?$DN1?5SUPPORT_WIN@
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OGOEBGIP@vlmcsd?5flags?3?$CFs?6?$AA@
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00010	59		 pop	 ecx
  00011	59		 pop	 ecx

; 666  : }

  00012	c3		 ret	 0
_printServerFlags ENDP
_TEXT	ENDS
END
