; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Dell\Desktop\vlmcsd\src\ntservice.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_03HLHKOPNL@KMS?$AA@			; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_0BD@FKPFFKIB@?N?$NO?$LH?$KI?$LA?$LC?W?$LA?$LH?$PO?N?q?5?$CI?$CFd?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_02DEDJNJGL@?9s?$AA@			; `string'
PUBLIC	??_C@_02MFNBDIMN@?9W?$AA@			; `string'
PUBLIC	??_C@_02PHOHFKEP@?9U?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_0BD@KBOGNFMA@?$LH?$PO?N?q?I?$LO?$LD?$PN?J?$KH?$LA?$NM?5?$CI?$CFd?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_02PKOHADJL@?1l?$AA@			; `string'
PUBLIC	??_C@_0BK@PHAGCFFB@NT?5AUTHORITY?2LocalService?$AA@ ; `string'
PUBLIC	??_C@_02MINBGBBJ@?1n?$AA@			; `string'
PUBLIC	??_C@_0BM@PDMNECKP@NT?5AUTHORITY?2NetworkService?$AA@ ; `string'
PUBLIC	??_C@_02CEGDFPFP@?4?2?$AA@			; `string'
PUBLIC	??_C@_06BPNJJJFL@tcpip?$AA?$AA@			; `string'
PUBLIC	??_C@_0BG@JPMCODEK@Key?5Management?5Server?$AA@	; `string'
PUBLIC	??_C@_0BD@DCFFOBGC@?$LE?$LE?$LN?$KI?$LH?$PO?N?q?J?$KH?$LA?$NM?5?$CI?$CFu?$CJ?6?$AA@ ; `string'
PUBLIC	??_C@_0O@IJHOBBJB@?$LH?$PO?N?q?$LA?$LC?W?$LA?$LD?I?$LJ?$KG?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@HFGHGIOK@Restarting?5KMS?5service?5?$DN?$DO?5?$AA@ ; `string'
PUBLIC	??_C@_08GKHOLFG@Success?6?$AA@			; `string'
PUBLIC	??_C@_0BL@MMELEJAD@Not?5ready?5within?5a?5second?6?$AA@ ; `string'
PUBLIC	??_C@_06HPIHNGNL@Error?6?$AA@			; `string'
PUBLIC	??_C@_09JBCKIECM@Error?5?$CFu?6?$AA@		; `string'
PUBLIC	??_C@_0BL@KECMPHCB@Error?5removing?5service?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@KAHEFAHB@Service?5?$CFs?5removed?5successfully?6@ ; `string'
PUBLIC	??_C@_0BM@GDAJEGHF@Service?5?$CFs?5does?5not?5exist?4?6?$AA@ ; `string'
PUBLIC	_NTServiceDispatchTable
EXTRN	__imp__ControlService@12:PROC
EXTRN	__imp__OpenSCManagerA@12:PROC
EXTRN	__imp__SetServiceStatus@8:PROC
EXTRN	__imp__QueryServiceStatus@8:PROC
EXTRN	__imp__StartServiceA@12:PROC
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__CreateServiceA@52:PROC
EXTRN	__imp__RegisterServiceCtrlHandlerA@8:PROC
EXTRN	__imp__DeleteService@4:PROC
EXTRN	__imp__CloseServiceHandle@4:PROC
EXTRN	__imp__OpenServiceA@12:PROC
COMM	_gSvcStatus:BYTE:01cH
COMM	_gSvcStatusHandle:DWORD
_DATA	ENDS
;	COMDAT ??_C@_0BM@GDAJEGHF@Service?5?$CFs?5does?5not?5exist?4?6?$AA@
CONST	SEGMENT
??_C@_0BM@GDAJEGHF@Service?5?$CFs?5does?5not?5exist?4?6?$AA@ DB 'Service '
	DB	'%s does not exist.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KAHEFAHB@Service?5?$CFs?5removed?5successfully?6@
CONST	SEGMENT
??_C@_0CB@KAHEFAHB@Service?5?$CFs?5removed?5successfully?6@ DB 'Service %'
	DB	's removed successfully', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@KECMPHCB@Error?5removing?5service?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BL@KECMPHCB@Error?5removing?5service?5?$CFs?6?$AA@ DB 'Error remov'
	DB	'ing service %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09JBCKIECM@Error?5?$CFu?6?$AA@
CONST	SEGMENT
??_C@_09JBCKIECM@Error?5?$CFu?6?$AA@ DB 'Error %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06HPIHNGNL@Error?6?$AA@
CONST	SEGMENT
??_C@_06HPIHNGNL@Error?6?$AA@ DB 'Error', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MMELEJAD@Not?5ready?5within?5a?5second?6?$AA@
CONST	SEGMENT
??_C@_0BL@MMELEJAD@Not?5ready?5within?5a?5second?6?$AA@ DB 'Not ready wit'
	DB	'hin a second', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_08GKHOLFG@Success?6?$AA@
CONST	SEGMENT
??_C@_08GKHOLFG@Success?6?$AA@ DB 'Success', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@HFGHGIOK@Restarting?5KMS?5service?5?$DN?$DO?5?$AA@
CONST	SEGMENT
??_C@_0BL@HFGHGIOK@Restarting?5KMS?5service?5?$DN?$DO?5?$AA@ DB 'Restarti'
	DB	'ng KMS service => ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IJHOBBJB@?$LH?$PO?N?q?$LA?$LC?W?$LA?$LD?I?$LJ?$KG?6?$AA@
CONST	SEGMENT
??_C@_0O@IJHOBBJB@?$LH?$PO?N?q?$LA?$LC?W?$LA?$LD?I?$LJ?$KG?6?$AA@ DB 0b7H
	DB	0feH, 0ceH, 0f1H, 0b0H, 0b2H, 0d7H, 0b0H, 0b3H, 0c9H, 0b9H, 0a6H
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@DCFFOBGC@?$LE?$LE?$LN?$KI?$LH?$PO?N?q?J?$KH?$LA?$NM?5?$CI?$CFu?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BD@DCFFOBGC@?$LE?$LE?$LN?$KI?$LH?$PO?N?q?J?$KH?$LA?$NM?5?$CI?$CFu?$CJ?6?$AA@ DB 0b4H
	DB	0b4H, 0bdH, 0a8H, 0b7H, 0feH, 0ceH, 0f1H, 0caH, 0a7H, 0b0H, 0dcH
	DB	' (%u)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JPMCODEK@Key?5Management?5Server?$AA@
CONST	SEGMENT
??_C@_0BG@JPMCODEK@Key?5Management?5Server?$AA@ DB 'Key Management Server'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06BPNJJJFL@tcpip?$AA?$AA@
CONST	SEGMENT
??_C@_06BPNJJJFL@tcpip?$AA?$AA@ DB 'tcpip', 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02CEGDFPFP@?4?2?$AA@
CONST	SEGMENT
??_C@_02CEGDFPFP@?4?2?$AA@ DB '.\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@PDMNECKP@NT?5AUTHORITY?2NetworkService?$AA@
CONST	SEGMENT
??_C@_0BM@PDMNECKP@NT?5AUTHORITY?2NetworkService?$AA@ DB 'NT AUTHORITY\Ne'
	DB	'tworkService', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02MINBGBBJ@?1n?$AA@
CONST	SEGMENT
??_C@_02MINBGBBJ@?1n?$AA@ DB '/n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PHAGCFFB@NT?5AUTHORITY?2LocalService?$AA@
CONST	SEGMENT
??_C@_0BK@PHAGCFFB@NT?5AUTHORITY?2LocalService?$AA@ DB 'NT AUTHORITY\Loca'
	DB	'lService', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02PKOHADJL@?1l?$AA@
CONST	SEGMENT
??_C@_02PKOHADJL@?1l?$AA@ DB '/l', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@KBOGNFMA@?$LH?$PO?N?q?I?$LO?$LD?$PN?J?$KH?$LA?$NM?5?$CI?$CFd?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BD@KBOGNFMA@?$LH?$PO?N?q?I?$LO?$LD?$PN?J?$KH?$LA?$NM?5?$CI?$CFd?$CJ?6?$AA@ DB 0b7H
	DB	0feH, 0ceH, 0f1H, 0c9H, 0beH, 0b3H, 0fdH, 0caH, 0a7H, 0b0H, 0dcH
	DB	' (%d)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PHOHFKEP@?9U?$AA@
CONST	SEGMENT
??_C@_02PHOHFKEP@?9U?$AA@ DB '-U', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MFNBDIMN@?9W?$AA@
CONST	SEGMENT
??_C@_02MFNBDIMN@?9W?$AA@ DB '-W', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DEDJNJGL@?9s?$AA@
CONST	SEGMENT
??_C@_02DEDJNJGL@?9s?$AA@ DB '-s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FKPFFKIB@?N?$NO?$LH?$KI?$LA?$LC?W?$LA?$LH?$PO?N?q?5?$CI?$CFd?$CJ?6?$AA@
CONST	SEGMENT
??_C@_0BD@FKPFFKIB@?N?$NO?$LH?$KI?$LA?$LC?W?$LA?$LH?$PO?N?q?5?$CI?$CFd?$CJ?6?$AA@ DB 0ceH
	DB	0deH, 0b7H, 0a8H, 0b0H, 0b2H, 0d7H, 0b0H, 0b7H, 0feH, 0ceH, 0f1H
	DB	' (%d)', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03HLHKOPNL@KMS?$AA@
CONST	SEGMENT
??_C@_03HLHKOPNL@KMS?$AA@ DB 'KMS', 00H			; `string'
_NTServiceDispatchTable DD FLAT:??_C@_03HLHKOPNL@KMS?$AA@
	DD	FLAT:_ServiceMain@8
	DD	00H
	DD	00H
?dwCheckPoint@?1??ReportServiceStatus@@9@9 DD 01H	; `ReportServiceStatus'::`2'::dwCheckPoint
PUBLIC	_NtServiceInstallation
PUBLIC	_ReportServiceStatus
PUBLIC	_ServiceCtrlHandler@4
PUBLIC	_RtlSecureZeroMemory
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft sdks\windows\v7.1a\include\winnt.h
;	COMDAT _RtlSecureZeroMemory
_TEXT	SEGMENT
_RtlSecureZeroMemory PROC				; COMDAT
; _ptr$ = ecx
; _cnt$ = edx

; 13070:     volatile char *vptr = (volatile char *)ptr;

  00000	8b c1		 mov	 eax, ecx

; 13071: 
; 13072: #if defined(_M_AMD64)
; 13073: 
; 13074:         __stosb((PBYTE )((DWORD64)vptr), 0, cnt);
; 13075: 
; 13076: #else
; 13077: 
; 13078:     while (cnt) {

  00002	85 d2		 test	 edx, edx
  00004	74 07		 je	 SHORT $LN1@RtlSecureZ
$LL2@RtlSecureZ:

; 13079:         *vptr = 0;

  00006	c6 00 00	 mov	 BYTE PTR [eax], 0

; 13080:         vptr++;

  00009	40		 inc	 eax

; 13081:         cnt--;

  0000a	4a		 dec	 edx
  0000b	75 f9		 jne	 SHORT $LL2@RtlSecureZ
$LN1@RtlSecureZ:

; 13082:     }
; 13083: 
; 13084: #endif
; 13085: 
; 13086:     return ptr;

  0000d	8b c1		 mov	 eax, ecx

; 13087: }

  0000f	c3		 ret	 0
_RtlSecureZeroMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\ntservice.c
;	COMDAT _ServiceCtrlHandler@4
_TEXT	SEGMENT
_dwCtrl$ = 8						; size = 4
_ServiceCtrlHandler@4 PROC				; COMDAT

; 19   : 	// Handle the requested control code.
; 20   : 	switch (dwCtrl)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwCtrl$[esp-4]
  00004	48		 dec	 eax
  00005	74 05		 je	 SHORT $LN2@ServiceCtr
  00007	83 e8 04	 sub	 eax, 4
  0000a	75 19		 jne	 SHORT $LN1@ServiceCtr
$LN2@ServiceCtr:

; 21   : 	{
; 22   : 	case SERVICE_CONTROL_STOP:
; 23   : 	case SERVICE_CONTROL_SHUTDOWN:
; 24   : 
; 25   : 		ServiceShutdown = TRUE;
; 26   : 		ReportServiceStatus(SERVICE_STOP_PENDING, NO_ERROR, 0);

  0000c	6a 00		 push	 0
  0000e	6a 03		 push	 3
  00010	33 d2		 xor	 edx, edx
  00012	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _ServiceShutdown, 1
  00019	59		 pop	 ecx
  0001a	e8 00 00 00 00	 call	 _ReportServiceStatus
  0001f	59		 pop	 ecx

; 27   : 
; 28   : 		// Remove PID file and free ressources
; 29   : 		cleanup();

  00020	e8 00 00 00 00	 call	 _cleanup
$LN1@ServiceCtr:

; 30   : #			if __CYGWIN__ || defined(USE_MSRPC)
; 31   : 		ReportServiceStatus(SERVICE_STOPPED, NO_ERROR, 0);
; 32   : #			endif // __CYGWIN__
; 33   : 
; 34   : 	default:
; 35   : 		break;
; 36   : 	}
; 37   : }

  00025	c2 04 00	 ret	 4
_ServiceCtrlHandler@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\ntservice.c
;	COMDAT _ServiceMain@8
_TEXT	SEGMENT
_argc_unused$ = 8					; size = 4
_argv_unused$ = 12					; size = 4
_ServiceMain@8 PROC					; COMDAT

; 41   : 	// Register the handler function for the service
; 42   : 	//注册该服务的处理函数
; 43   : 	if (!((gSvcStatusHandle = RegisterServiceCtrlHandler(NT_SERVICE_NAME, ServiceCtrlHandler))))

  00000	68 00 00 00 00	 push	 OFFSET _ServiceCtrlHandler@4
  00005	68 00 00 00 00	 push	 OFFSET ??_C@_03HLHKOPNL@KMS?$AA@
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegisterServiceCtrlHandlerA@8
  00010	a3 00 00 00 00	 mov	 DWORD PTR _gSvcStatusHandle, eax
  00015	85 c0		 test	 eax, eax
  00017	74 26		 je	 SHORT $LN2@ServiceMai

; 44   : 	{
; 45   : 		return;
; 46   : 	}
; 47   : 
; 48   : 	// These SERVICE_STATUS members remain as set here
; 49   : 	//这些SERVICE_STATUS成员保持不变
; 50   : 	gSvcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
; 51   : 	gSvcStatus.dwServiceSpecificExitCode = 0;

  00019	83 25 10 00 00
	00 00		 and	 DWORD PTR _gSvcStatus+16, 0

; 52   : 
; 53   : 	// Run the actual program
; 54   : 	//运行实际的程序
; 55   : 	ReportServiceStatus(SERVICE_STOPPED, newmain(), 3000);

  00020	68 b8 0b 00 00	 push	 3000			; 00000bb8H
  00025	c7 05 00 00 00
	00 10 00 00 00	 mov	 DWORD PTR _gSvcStatus, 16 ; 00000010H
  0002f	e8 00 00 00 00	 call	 _newmain
  00034	33 c9		 xor	 ecx, ecx
  00036	8b d0		 mov	 edx, eax
  00038	41		 inc	 ecx
  00039	e8 00 00 00 00	 call	 _ReportServiceStatus
  0003e	59		 pop	 ecx
$LN2@ServiceMai:

; 56   : }

  0003f	c2 08 00	 ret	 8
_ServiceMain@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\ntservice.c
;	COMDAT _ReportServiceStatus
_TEXT	SEGMENT
_dwWaitHint$ = 8					; size = 4
_ReportServiceStatus PROC				; COMDAT
; _dwCurrentState$ = ecx
; _dwWin32ExitCode$ = edx

; 71   : 	static DWORD dwCheckPoint = 1;
; 72   : 
; 73   : 	// Fill in the SERVICE_STATUS structure.
; 74   : 	//填写SERVICE_STATUS结构
; 75   : 	gSvcStatus.dwCurrentState = dwCurrentState;
; 76   : 	gSvcStatus.dwWin32ExitCode = dwWin32ExitCode;
; 77   : 	gSvcStatus.dwWaitHint = dwWaitHint;

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _dwWaitHint$[esp-4]
  00004	a3 18 00 00 00	 mov	 DWORD PTR _gSvcStatus+24, eax

; 78   : 
; 79   : 	if (dwCurrentState == SERVICE_START_PENDING)
; 80   : 		gSvcStatus.dwControlsAccepted = 0;
; 81   : 	else
; 82   : 		gSvcStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

  00009	33 c0		 xor	 eax, eax
  0000b	40		 inc	 eax
  0000c	89 0d 04 00 00
	00		 mov	 DWORD PTR _gSvcStatus+4, ecx
  00012	89 15 0c 00 00
	00		 mov	 DWORD PTR _gSvcStatus+12, edx
  00018	a3 08 00 00 00	 mov	 DWORD PTR _gSvcStatus+8, eax

; 83   : 
; 84   : 	if ((dwCurrentState == SERVICE_RUNNING) ||
; 85   : 		(dwCurrentState == SERVICE_STOPPED))

  0001d	83 f9 04	 cmp	 ecx, 4
  00020	74 16		 je	 SHORT $LN2@ReportServ
  00022	3b c8		 cmp	 ecx, eax
  00024	74 12		 je	 SHORT $LN2@ReportServ

; 87   : 	else
; 88   : 		gSvcStatus.dwCheckPoint = dwCheckPoint++;

  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwCheckPoint@?1??ReportServiceStatus@@9@9
  0002b	a3 14 00 00 00	 mov	 DWORD PTR _gSvcStatus+20, eax
  00030	40		 inc	 eax
  00031	a3 00 00 00 00	 mov	 DWORD PTR ?dwCheckPoint@?1??ReportServiceStatus@@9@9, eax
  00036	eb 07		 jmp	 SHORT $LN1@ReportServ
$LN2@ReportServ:

; 86   : 		gSvcStatus.dwCheckPoint = 0;

  00038	83 25 14 00 00
	00 00		 and	 DWORD PTR _gSvcStatus+20, 0
$LN1@ReportServ:

; 89   : 
; 90   : 	// Report the status of the service to the SCM.
; 91   : 	SetServiceStatus(gSvcStatusHandle, &gSvcStatus);

  0003f	68 00 00 00 00	 push	 OFFSET _gSvcStatus
  00044	ff 35 00 00 00
	00		 push	 DWORD PTR _gSvcStatusHandle
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetServiceStatus@8

; 92   : }

  00050	c3		 ret	 0
_ReportServiceStatus ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\ntservice.c
;	COMDAT _OpenAndRemoveService
_TEXT	SEGMENT
_status$ = -36						; size = 28
_closeManager$1$ = -8					; size = 4
_dwPreviousState$1$ = -4				; size = 4
_OpenAndRemoveService PROC				; COMDAT
; _dwPreviousState$ = ecx
; _schSCManager$ = edx

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	53		 push	 ebx
  00007	8b c1		 mov	 eax, ecx

; 128  : 	SERVICE_STATUS status;
; 129  : 	uint_fast8_t i;
; 130  : 	SC_HANDLE installedService;
; 131  : 	uint_fast8_t result = 1;
; 132  : 	BOOL closeManager = FALSE;

  00009	33 db		 xor	 ebx, ebx
  0000b	89 45 fc	 mov	 DWORD PTR _dwPreviousState$1$[ebp], eax
  0000e	89 5d f8	 mov	 DWORD PTR _closeManager$1$[ebp], ebx
  00011	56		 push	 esi
  00012	57		 push	 edi
  00013	8b fa		 mov	 edi, edx

; 133  : 
; 134  : 	// Allow NULL for both Arguments
; 135  : 	//两个参数都允许NULL
; 136  : 	if (!dwPreviousState) dwPreviousState = (DWORD*)alloca(sizeof(*dwPreviousState));

  00015	85 c0		 test	 eax, eax
  00017	75 0b		 jne	 SHORT $LN12@OpenAndRem
  00019	6a 04		 push	 4
  0001b	58		 pop	 eax
  0001c	e8 00 00 00 00	 call	 __alloca_probe
  00021	89 65 fc	 mov	 DWORD PTR _dwPreviousState$1$[ebp], esp
$LN12@OpenAndRem:

; 137  : 	if (!schSCManager)

  00024	85 ff		 test	 edi, edi
  00026	75 11		 jne	 SHORT $LN11@OpenAndRem

; 138  : 	{
; 139  : 		schSCManager = (SC_HANDLE*)alloca(sizeof(*schSCManager));

  00028	6a 04		 push	 4
  0002a	58		 pop	 eax
  0002b	e8 00 00 00 00	 call	 __alloca_probe
  00030	8b fc		 mov	 edi, esp

; 140  : 		closeManager = TRUE;

  00032	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR _closeManager$1$[ebp], 1
$LN11@OpenAndRem:

; 141  : 	}
; 142  : 
; 143  : 	*schSCManager = OpenSCManager(
; 144  : 		NULL,                    // local computer 本地计算机
; 145  : 		NULL,                    // ServicesActive database ServicesActive数据库
; 146  : 		SC_MANAGER_ALL_ACCESS);  // full access rights 完全访问权限

  00039	68 3f 00 0f 00	 push	 983103			; 000f003fH
  0003e	53		 push	 ebx
  0003f	53		 push	 ebx
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenSCManagerA@12
  00046	89 07		 mov	 DWORD PTR [edi], eax

; 147  : 
; 148  : 	if (!*schSCManager) return 0;

  00048	85 c0		 test	 eax, eax
  0004a	75 07		 jne	 SHORT $LN10@OpenAndRem
  0004c	32 c0		 xor	 al, al
  0004e	e9 8f 00 00 00	 jmp	 $LN13@OpenAndRem
$LN10@OpenAndRem:

; 149  : 
; 150  : 	if (!((installedService = OpenService(*schSCManager, NT_SERVICE_NAME, SERVICE_ALL_ACCESS))))

  00053	68 ff 01 0f 00	 push	 983551			; 000f01ffH
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_03HLHKOPNL@KMS?$AA@
  0005d	50		 push	 eax
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__OpenServiceA@12
  00064	8b f0		 mov	 esi, eax
  00066	85 f6		 test	 esi, esi
  00068	75 04		 jne	 SHORT $LN9@OpenAndRem

; 151  : 	{
; 152  : 		result = 2;

  0006a	b3 02		 mov	 bl, 2

; 153  : 	}
; 154  : 	else

  0006c	eb 64		 jmp	 SHORT $LN8@OpenAndRem
$LN9@OpenAndRem:

; 155  : 	{
; 156  : 		*dwPreviousState = SERVICE_STOPPED;

  0006e	8b 45 fc	 mov	 eax, DWORD PTR _dwPreviousState$1$[ebp]
  00071	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 157  : 		if (QueryServiceStatus(installedService, &status)) *dwPreviousState = status.dwCurrentState;

  00077	8d 45 dc	 lea	 eax, DWORD PTR _status$[ebp]
  0007a	50		 push	 eax
  0007b	56		 push	 esi
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryServiceStatus@8
  00082	85 c0		 test	 eax, eax
  00084	74 08		 je	 SHORT $LN7@OpenAndRem
  00086	8b 4d fc	 mov	 ecx, DWORD PTR _dwPreviousState$1$[ebp]
  00089	8b 45 e0	 mov	 eax, DWORD PTR _status$[ebp+4]
  0008c	89 01		 mov	 DWORD PTR [ecx], eax
$LN7@OpenAndRem:

; 158  : 
; 159  : 		ControlService(installedService, SERVICE_CONTROL_STOP, &status);

  0008e	8d 45 dc	 lea	 eax, DWORD PTR _status$[ebp]
  00091	50		 push	 eax
  00092	6a 01		 push	 1
  00094	56		 push	 esi
  00095	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ControlService@12
$LL6@OpenAndRem:

; 162  : 		{
; 163  : 			QueryServiceStatus(installedService, &status);

  0009b	8d 45 dc	 lea	 eax, DWORD PTR _status$[ebp]
  0009e	50		 push	 eax
  0009f	56		 push	 esi
  000a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryServiceStatus@8

; 164  : 			// Give it 100 ms after it reported SERVICE_STOPPED. Subsequent CreateService will fail otherwise
; 165  : 			//在报告SERVICE_STOPPED 100毫秒后给它。 否则，后续的CreateService将失败
; 166  : 			Sleep(100);

  000a6	6a 64		 push	 100			; 00000064H
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4

; 167  : 			if (status.dwCurrentState == SERVICE_STOPPED) break;

  000ae	83 7d e0 01	 cmp	 DWORD PTR _status$[ebp+4], 1
  000b2	74 07		 je	 SHORT $LN16@OpenAndRem

; 160  : 
; 161  : 		for (i = 0; i < 10; i++)

  000b4	fe c3		 inc	 bl
  000b6	80 fb 0a	 cmp	 bl, 10			; 0000000aH
  000b9	72 e0		 jb	 SHORT $LL6@OpenAndRem
$LN16@OpenAndRem:

; 168  : 		}
; 169  : 
; 170  : 		if (!DeleteService(installedService)) result = 0;

  000bb	56		 push	 esi
  000bc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteService@4
  000c2	8b d8		 mov	 ebx, eax
  000c4	f7 db		 neg	 ebx

; 171  : 		CloseServiceHandle(installedService);

  000c6	56		 push	 esi
  000c7	1a db		 sbb	 bl, bl
  000c9	80 e3 01	 and	 bl, 1
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseServiceHandle@4
$LN8@OpenAndRem:

; 172  : 	}
; 173  : 
; 174  : 	if (closeManager) CloseServiceHandle(*schSCManager);

  000d2	83 7d f8 00	 cmp	 DWORD PTR _closeManager$1$[ebp], 0
  000d6	74 08		 je	 SHORT $LN1@OpenAndRem
  000d8	ff 37		 push	 DWORD PTR [edi]
  000da	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseServiceHandle@4
$LN1@OpenAndRem:

; 175  : 	return result;

  000e0	8a c3		 mov	 al, bl
$LN13@OpenAndRem:

; 176  : }

  000e2	8d 65 d0	 lea	 esp, DWORD PTR [ebp-48]
  000e5	5f		 pop	 edi
  000e6	5e		 pop	 esi
  000e7	5b		 pop	 ebx
  000e8	8b e5		 mov	 esp, ebp
  000ea	5d		 pop	 ebp
  000eb	c3		 ret	 0
_OpenAndRemoveService ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\ntservice.c
;	COMDAT _ServiceInstaller
_TEXT	SEGMENT
_i$2$ = -304						; size = 4
_schSCManager$ = -304					; size = 4
_vptr$1$ = -300						; size = 4
_dwPreviousState$ = -296				; size = 4
_schSCManager$1$ = -292					; size = 4
_status$ = -288						; size = 28
_szPath$ = -260						; size = 260
_ServiceInstaller PROC					; COMDAT
; _ServiceUser$ = ecx
; _ServicePassword$ = edx

; 181  : {

  00000	81 ec 30 01 00
	00		 sub	 esp, 304		; 00000130H
  00006	53		 push	 ebx
  00007	55		 push	 ebp

; 182  : 	SC_HANDLE schSCManager;
; 183  : 	SC_HANDLE schService;
; 184  : 	char szPath[MAX_PATH] = "\"";

  00008	6a 22		 push	 34			; 00000022H
  0000a	58		 pop	 eax
  0000b	68 02 01 00 00	 push	 258			; 00000102H
  00010	66 89 44 24 38	 mov	 WORD PTR _szPath$[esp+316], ax
  00015	33 ed		 xor	 ebp, ebp
  00017	8d 44 24 3a	 lea	 eax, DWORD PTR _szPath$[esp+318]
  0001b	89 54 24 10	 mov	 DWORD PTR _vptr$1$[esp+316], edx
  0001f	55		 push	 ebp
  00020	50		 push	 eax
  00021	8b d9		 mov	 ebx, ecx
  00023	e8 00 00 00 00	 call	 _memset
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 185  : 	//GetModuleFileName获取模块文件名
; 186  : 	if (!GetModuleFileName(NULL, szPath + sizeof(char), MAX_PATH - 1))

  0002b	8d 44 24 35	 lea	 eax, DWORD PTR _szPath$[esp+313]
  0002f	68 03 01 00 00	 push	 259			; 00000103H
  00034	50		 push	 eax
  00035	55		 push	 ebp
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleFileNameA@12
  0003c	85 c0		 test	 eax, eax
  0003e	75 18		 jne	 SHORT $LN29@ServiceIns

; 187  : 	{
; 188  : 		errorout("无法安装服务 (%d)\n", (uint32_t)GetLastError());

  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00046	50		 push	 eax
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FKPFFKIB@?N?$NO?$LH?$KI?$LA?$LC?W?$LA?$LH?$PO?N?q?5?$CI?$CFd?$CJ?6?$AA@
  0004c	e8 00 00 00 00	 call	 _errorout
  00051	59		 pop	 ecx
  00052	59		 pop	 ecx

; 189  : 		return;

  00053	e9 48 03 00 00	 jmp	 $LN30@ServiceIns
$LN29@ServiceIns:
  00058	57		 push	 edi

; 190  : 	}
; 191  : 
; 192  : 	strcat(szPath, "\"");

  00059	8d 7c 24 38	 lea	 edi, DWORD PTR _szPath$[esp+316]
  0005d	4f		 dec	 edi
$LL53@ServiceIns:
  0005e	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00061	47		 inc	 edi
  00062	84 c0		 test	 al, al
  00064	75 f8		 jne	 SHORT $LL53@ServiceIns
  00066	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01BJJEKLCA@?$CC?$AA@
  0006c	56		 push	 esi

; 193  : 
; 194  : 	int i;
; 195  : 	for (i = 1; i < global_argc; i++)

  0006d	33 f6		 xor	 esi, esi
  0006f	66 89 07	 mov	 WORD PTR [edi], ax
  00072	46		 inc	 esi
  00073	89 74 24 10	 mov	 DWORD PTR _i$2$[esp+320], esi
  00077	39 35 00 00 00
	00		 cmp	 DWORD PTR _global_argc, esi
  0007d	0f 8e 25 01 00
	00		 jle	 $LN26@ServiceIns
  00083	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _global_argv
$LL28@ServiceIns:

; 196  : 	{
; 197  : 		// Strip unneccessary parameters, especially the password
; 198  : 		//剥去不必要的参数，特别是密码
; 199  : 		if (!strcmp(global_argv[i], "-s")) continue;

  00089	6a 03		 push	 3
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_02DEDJNJGL@?9s?$AA@
  00090	ff 34 b7	 push	 DWORD PTR [edi+esi*4]
  00093	e8 00 00 00 00	 call	 _memcmp
  00098	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009b	85 c0		 test	 eax, eax
  0009d	0f 84 f4 00 00
	00		 je	 $LN27@ServiceIns

; 200  : 
; 201  : 		if (!strcmp(global_argv[i], "-W") ||
; 202  : 			!strcmp(global_argv[i], "-U"))

  000a3	6a 03		 push	 3
  000a5	68 00 00 00 00	 push	 OFFSET ??_C@_02MFNBDIMN@?9W?$AA@
  000aa	ff 34 b7	 push	 DWORD PTR [edi+esi*4]
  000ad	e8 00 00 00 00	 call	 _memcmp
  000b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b5	85 c0		 test	 eax, eax
  000b7	0f 84 d9 00 00
	00		 je	 $LN23@ServiceIns
  000bd	6a 03		 push	 3
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_02PHOHFKEP@?9U?$AA@
  000c4	ff 34 b7	 push	 DWORD PTR [edi+esi*4]
  000c7	e8 00 00 00 00	 call	 _memcmp
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cf	85 c0		 test	 eax, eax
  000d1	0f 84 bf 00 00
	00		 je	 $LN23@ServiceIns

; 205  : 			continue;
; 206  : 		}
; 207  : 
; 208  : 		strcat(szPath, " ");

  000d7	8d 7c 24 3c	 lea	 edi, DWORD PTR _szPath$[esp+320]
  000db	4f		 dec	 edi
$LL54@ServiceIns:
  000dc	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000df	47		 inc	 edi
  000e0	84 c0		 test	 al, al
  000e2	75 f8		 jne	 SHORT $LL54@ServiceIns

; 209  : 
; 210  : 		if (strchr(global_argv[i], ' '))

  000e4	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _global_argv
  000ea	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01CLKCMJKC@?5?$AA@
  000f0	66 89 07	 mov	 WORD PTR [edi], ax
  000f3	6a 20		 push	 32			; 00000020H
  000f5	ff 34 b2	 push	 DWORD PTR [edx+esi*4]
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  000fe	59		 pop	 ecx
  000ff	59		 pop	 ecx
  00100	85 c0		 test	 eax, eax
  00102	74 57		 je	 SHORT $LN22@ServiceIns

; 211  : 		{
; 212  : 			strcat(szPath, "\"");

  00104	8d 7c 24 3c	 lea	 edi, DWORD PTR _szPath$[esp+320]
  00108	4f		 dec	 edi
$LL55@ServiceIns:
  00109	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0010c	47		 inc	 edi
  0010d	84 c0		 test	 al, al
  0010f	75 f8		 jne	 SHORT $LL55@ServiceIns

; 213  : 			strcat(szPath, global_argv[i]);

  00111	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _global_argv
  00117	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01BJJEKLCA@?$CC?$AA@
  0011d	66 89 07	 mov	 WORD PTR [edi], ax
  00120	8b 14 b2	 mov	 edx, DWORD PTR [edx+esi*4]
  00123	8b f2		 mov	 esi, edx
$LL56@ServiceIns:
  00125	8a 0a		 mov	 cl, BYTE PTR [edx]
  00127	42		 inc	 edx
  00128	84 c9		 test	 cl, cl
  0012a	75 f9		 jne	 SHORT $LL56@ServiceIns
  0012c	8d 7c 24 3c	 lea	 edi, DWORD PTR _szPath$[esp+320]
  00130	2b d6		 sub	 edx, esi
  00132	4f		 dec	 edi
$LL57@ServiceIns:
  00133	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00136	47		 inc	 edi
  00137	84 c9		 test	 cl, cl
  00139	75 f8		 jne	 SHORT $LL57@ServiceIns
  0013b	8b ca		 mov	 ecx, edx
  0013d	c1 e9 02	 shr	 ecx, 2
  00140	f3 a5		 rep movsd
  00142	8b ca		 mov	 ecx, edx
  00144	83 e1 03	 and	 ecx, 3
  00147	f3 a4		 rep movsb

; 214  : 			strcat(szPath, "\"");

  00149	8d 7c 24 3c	 lea	 edi, DWORD PTR _szPath$[esp+320]
  0014d	4f		 dec	 edi
$LL58@ServiceIns:
  0014e	8a 4f 01	 mov	 cl, BYTE PTR [edi+1]
  00151	47		 inc	 edi
  00152	84 c9		 test	 cl, cl
  00154	75 f8		 jne	 SHORT $LL58@ServiceIns
  00156	66 89 07	 mov	 WORD PTR [edi], ax

; 215  : 		}
; 216  : 		else

  00159	eb 2f		 jmp	 SHORT $LN69@ServiceIns
$LN22@ServiceIns:

; 217  : 			strcat(szPath, global_argv[i]);

  0015b	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _global_argv
  00161	8b 14 b2	 mov	 edx, DWORD PTR [edx+esi*4]
  00164	8b f2		 mov	 esi, edx
$LL59@ServiceIns:
  00166	8a 02		 mov	 al, BYTE PTR [edx]
  00168	42		 inc	 edx
  00169	84 c0		 test	 al, al
  0016b	75 f9		 jne	 SHORT $LL59@ServiceIns
  0016d	8d 7c 24 3c	 lea	 edi, DWORD PTR _szPath$[esp+320]
  00171	2b d6		 sub	 edx, esi
  00173	4f		 dec	 edi
$LL60@ServiceIns:
  00174	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00177	47		 inc	 edi
  00178	84 c0		 test	 al, al
  0017a	75 f8		 jne	 SHORT $LL60@ServiceIns
  0017c	8b ca		 mov	 ecx, edx
  0017e	c1 e9 02	 shr	 ecx, 2
  00181	f3 a5		 rep movsd
  00183	8b ca		 mov	 ecx, edx
  00185	83 e1 03	 and	 ecx, 3
  00188	f3 a4		 rep movsb
$LN69@ServiceIns:

; 218  : 	}

  0018a	8b 74 24 10	 mov	 esi, DWORD PTR _i$2$[esp+320]
  0018e	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _global_argv
  00194	eb 01		 jmp	 SHORT $LN27@ServiceIns
$LN23@ServiceIns:

; 203  : 		{
; 204  : 			i++;

  00196	46		 inc	 esi
$LN27@ServiceIns:

; 193  : 
; 194  : 	int i;
; 195  : 	for (i = 1; i < global_argc; i++)

  00197	46		 inc	 esi
  00198	89 74 24 10	 mov	 DWORD PTR _i$2$[esp+320], esi
  0019c	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _global_argc
  001a2	0f 8c e1 fe ff
	ff		 jl	 $LL28@ServiceIns
$LN26@ServiceIns:

; 219  : 
; 220  : 	// Get a handle to the SCM database.
; 221  : 	//获取SCM数据库的句柄。
; 222  : 
; 223  : 	SERVICE_STATUS status;
; 224  : 	DWORD dwPreviousState;
; 225  : 
; 226  : 	if (!OpenAndRemoveService(&dwPreviousState, &schSCManager))

  001a8	8d 54 24 10	 lea	 edx, DWORD PTR _schSCManager$[esp+320]
  001ac	8d 4c 24 18	 lea	 ecx, DWORD PTR _dwPreviousState$[esp+320]
  001b0	e8 00 00 00 00	 call	 _OpenAndRemoveService
  001b5	84 c0		 test	 al, al
  001b7	75 18		 jne	 SHORT $LN20@ServiceIns

; 227  : 	{
; 228  : 		errorout("服务删除失败 (%d)\n", (uint32_t)GetLastError());

  001b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  001bf	50		 push	 eax
  001c0	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@KBOGNFMA@?$LH?$PO?N?q?I?$LO?$LD?$PN?J?$KH?$LA?$NM?5?$CI?$CFd?$CJ?6?$AA@
  001c5	e8 00 00 00 00	 call	 _errorout
  001ca	59		 pop	 ecx
  001cb	59		 pop	 ecx

; 229  : 		return;

  001cc	e9 cd 01 00 00	 jmp	 $LN67@ServiceIns
$LN20@ServiceIns:

; 230  : 	}
; 231  : 
; 232  : 	char *tempUser = NULL;
; 233  : 
; 234  : 	if (ServiceUser)

  001d1	85 db		 test	 ebx, ebx
  001d3	0f 84 95 00 00
	00		 je	 $LN16@ServiceIns

; 235  : 	{
; 236  : 		// Shortcuts for some well known users
; 237  : 		if (!strcasecmp(ServiceUser, "/l")) ServiceUser = "NT AUTHORITY\\LocalService";

  001d9	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp___stricmp
  001df	68 00 00 00 00	 push	 OFFSET ??_C@_02PKOHADJL@?1l?$AA@
  001e4	53		 push	 ebx
  001e5	ff d6		 call	 esi
  001e7	85 c0		 test	 eax, eax
  001e9	bf 00 00 00 00	 mov	 edi, OFFSET ??_C@_0BK@PHAGCFFB@NT?5AUTHORITY?2LocalService?$AA@

; 238  : 		if (!strcasecmp(ServiceUser, "/n")) ServiceUser = "NT AUTHORITY\\NetworkService";

  001ee	68 00 00 00 00	 push	 OFFSET ??_C@_02MINBGBBJ@?1n?$AA@
  001f3	0f 45 fb	 cmovne	 edi, ebx
  001f6	57		 push	 edi
  001f7	ff d6		 call	 esi
  001f9	85 c0		 test	 eax, eax
  001fb	bb 00 00 00 00	 mov	 ebx, OFFSET ??_C@_0BM@PDMNECKP@NT?5AUTHORITY?2NetworkService?$AA@

; 239  : 
; 240  : 		// Allow Local Users without .\ , e.g. "johndoe" instead of ".\johndoe"
; 241  : 		//允许没有。\的本地用户，例如 “johndoe”而不是“。\ johndoe”
; 242  : 		if (!strchr(ServiceUser, '\\'))

  00200	6a 5c		 push	 92			; 0000005cH
  00202	0f 45 df	 cmovne	 ebx, edi
  00205	53		 push	 ebx
  00206	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  0020c	83 c4 18	 add	 esp, 24			; 00000018H
  0020f	85 c0		 test	 eax, eax
  00211	75 5b		 jne	 SHORT $LN16@ServiceIns

; 243  : 		{
; 244  : 			tempUser = (char*)vlmcsd_malloc(strlen(ServiceUser) + 3);

  00213	8b cb		 mov	 ecx, ebx
  00215	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL61@ServiceIns:
  00218	8a 01		 mov	 al, BYTE PTR [ecx]
  0021a	41		 inc	 ecx
  0021b	84 c0		 test	 al, al
  0021d	75 f9		 jne	 SHORT $LL61@ServiceIns
  0021f	2b ca		 sub	 ecx, edx
  00221	8d 41 03	 lea	 eax, DWORD PTR [ecx+3]
  00224	50		 push	 eax
  00225	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0022b	8b e8		 mov	 ebp, eax
  0022d	59		 pop	 ecx
  0022e	85 ed		 test	 ebp, ebp
  00230	0f 84 73 01 00
	00		 je	 $LN72@ServiceIns

; 245  : 			strcpy(tempUser, ".\\");

  00236	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_02CEGDFPFP@?4?2?$AA@

; 246  : 			strcat(tempUser, ServiceUser);

  0023c	8b f3		 mov	 esi, ebx
  0023e	66 89 45 00	 mov	 WORD PTR [ebp], ax
  00242	a0 02 00 00 00	 mov	 al, BYTE PTR ??_C@_02CEGDFPFP@?4?2?$AA@+2
  00247	88 45 02	 mov	 BYTE PTR [ebp+2], al
$LL62@ServiceIns:
  0024a	8a 03		 mov	 al, BYTE PTR [ebx]
  0024c	43		 inc	 ebx
  0024d	84 c0		 test	 al, al
  0024f	75 f9		 jne	 SHORT $LL62@ServiceIns
  00251	2b de		 sub	 ebx, esi
  00253	8d 7d ff	 lea	 edi, DWORD PTR [ebp-1]
$LL63@ServiceIns:
  00256	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00259	47		 inc	 edi
  0025a	84 c0		 test	 al, al
  0025c	75 f8		 jne	 SHORT $LL63@ServiceIns
  0025e	8b cb		 mov	 ecx, ebx
  00260	c1 e9 02	 shr	 ecx, 2
  00263	f3 a5		 rep movsd
  00265	8b cb		 mov	 ecx, ebx

; 247  : 			ServiceUser = tempUser;

  00267	8b dd		 mov	 ebx, ebp
  00269	83 e1 03	 and	 ecx, 3
  0026c	f3 a4		 rep movsb
$LN16@ServiceIns:

; 248  : 		}
; 249  : 	}
; 250  : 
; 251  : 	schService = CreateService(
; 252  : 		schSCManager,				// SCM database
; 253  : 		NT_SERVICE_NAME,			// name of service 服务名称
; 254  : 		NT_SERVICE_DISPLAY_NAME,	// service name to display 显示服务名称
; 255  : 		SERVICE_ALL_ACCESS,			// desired access
; 256  : 		SERVICE_WIN32_OWN_PROCESS,	// service type 服务类型
; 257  : 		SERVICE_AUTO_START,			// start type 启动类型
; 258  : 		SERVICE_ERROR_NORMAL,		// error control type 错误控制类型
; 259  : 		szPath,						// path to service's binary 服务二进制路径
; 260  : 		NULL,						// no load ordering group 空载顺序组
; 261  : 		NULL,						// no tag identifier 没有标签标识符
; 262  : 		"tcpip\0",			        // depends on TCP/IP 取决于TCP/IP
; 263  : 		ServiceUser,				// LocalSystem account LocalSystem帐户
; 264  : 		ServicePassword);			// no password 没有密码

  0026e	ff 74 24 14	 push	 DWORD PTR _vptr$1$[esp+320]
  00272	8b 74 24 14	 mov	 esi, DWORD PTR _schSCManager$[esp+324]
  00276	8d 44 24 40	 lea	 eax, DWORD PTR _szPath$[esp+324]
  0027a	53		 push	 ebx
  0027b	68 00 00 00 00	 push	 OFFSET ??_C@_06BPNJJJFL@tcpip?$AA?$AA@
  00280	33 db		 xor	 ebx, ebx
  00282	89 74 24 28	 mov	 DWORD PTR _schSCManager$1$[esp+332], esi
  00286	53		 push	 ebx
  00287	53		 push	 ebx
  00288	50		 push	 eax
  00289	6a 01		 push	 1
  0028b	6a 02		 push	 2
  0028d	6a 10		 push	 16			; 00000010H
  0028f	68 ff 01 0f 00	 push	 983551			; 000f01ffH
  00294	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@JPMCODEK@Key?5Management?5Server?$AA@
  00299	68 00 00 00 00	 push	 OFFSET ??_C@_03HLHKOPNL@KMS?$AA@
  0029e	56		 push	 esi
  0029f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateServiceA@52

; 265  : 
; 266  : #	if __clang__ && (__CYGWIN__ || __MINGW64__ )
; 267  : 	// Workaround for clang not understanding some GCC asm syntax used in <w32api/psdk_inc/intrin-impl.h>
; 268  : 	ZeroMemory((char*)ServicePassword, strlen(ServicePassword));
; 269  : #	else
; 270  : 	SecureZeroMemory((char*)ServicePassword, strlen(ServicePassword));

  002a5	8b 54 24 14	 mov	 edx, DWORD PTR _vptr$1$[esp+320]
  002a9	8b f8		 mov	 edi, eax
  002ab	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
$LL64@ServiceIns:
  002ae	8a 0a		 mov	 cl, BYTE PTR [edx]
  002b0	42		 inc	 edx
  002b1	84 c9		 test	 cl, cl
  002b3	75 f9		 jne	 SHORT $LL64@ServiceIns
  002b5	2b d0		 sub	 edx, eax
  002b7	74 0a		 je	 SHORT $LN36@ServiceIns
  002b9	8b 44 24 14	 mov	 eax, DWORD PTR _vptr$1$[esp+320]
$LL37@ServiceIns:
  002bd	88 18		 mov	 BYTE PTR [eax], bl
  002bf	40		 inc	 eax
  002c0	4a		 dec	 edx
  002c1	75 fa		 jne	 SHORT $LL37@ServiceIns
$LN36@ServiceIns:

; 271  : #	endif
; 272  : 	if (tempUser) free(tempUser);

  002c3	85 ed		 test	 ebp, ebp
  002c5	74 08		 je	 SHORT $LN15@ServiceIns
  002c7	55		 push	 ebp
  002c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  002ce	59		 pop	 ecx
$LN15@ServiceIns:

; 273  : 
; 274  : 	if (schService == NULL)

  002cf	85 ff		 test	 edi, edi
  002d1	75 1f		 jne	 SHORT $LN14@ServiceIns

; 275  : 	{
; 276  : 		errorout("创建服务失败 (%u)\n", (uint32_t)GetLastError());

  002d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  002d9	50		 push	 eax
  002da	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@DCFFOBGC@?$LE?$LE?$LN?$KI?$LH?$PO?N?q?J?$KH?$LA?$NM?5?$CI?$CFu?$CJ?6?$AA@
  002df	e8 00 00 00 00	 call	 _errorout
  002e4	59		 pop	 ecx
  002e5	59		 pop	 ecx

; 277  : 		CloseServiceHandle(schSCManager);

  002e6	56		 push	 esi
  002e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseServiceHandle@4

; 278  : 		return;

  002ed	e9 ac 00 00 00	 jmp	 $LN67@ServiceIns
$LN14@ServiceIns:

; 279  : 	}
; 280  : 	else
; 281  : 	{
; 282  : 		errorout("服务安装成功\n");

  002f2	68 00 00 00 00	 push	 OFFSET ??_C@_0O@IJHOBBJB@?$LH?$PO?N?q?$LA?$LC?W?$LA?$LD?I?$LJ?$KG?6?$AA@
  002f7	e8 00 00 00 00	 call	 _errorout

; 283  : 
; 284  : 		if (dwPreviousState == SERVICE_RUNNING)

  002fc	83 7c 24 1c 04	 cmp	 DWORD PTR _dwPreviousState$[esp+324], 4
  00301	59		 pop	 ecx
  00302	0f 85 87 00 00
	00		 jne	 $LN1@ServiceIns

; 285  : 		{
; 286  : 			printf("Restarting " NT_SERVICE_NAME " service => ");

  00308	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__printf
  0030e	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HFGHGIOK@Restarting?5KMS?5service?5?$DN?$DO?5?$AA@
  00313	ff d6		 call	 esi
  00315	59		 pop	 ecx

; 287  : 			status.dwCurrentState = SERVICE_STOPPED;
; 288  : 
; 289  : 			if (StartService(schService, 0, NULL))

  00316	53		 push	 ebx
  00317	53		 push	 ebx
  00318	57		 push	 edi
  00319	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR _status$[esp+336], 1
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StartServiceA@12
  00327	85 c0		 test	 eax, eax
  00329	74 51		 je	 SHORT $LN11@ServiceIns
$LL10@ServiceIns:

; 292  : 				{
; 293  : 					if (!QueryServiceStatus(schService, &status) || status.dwCurrentState != SERVICE_START_PENDING) break;

  0032b	8d 44 24 20	 lea	 eax, DWORD PTR _status$[esp+320]
  0032f	50		 push	 eax
  00330	57		 push	 edi
  00331	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__QueryServiceStatus@8
  00337	85 c0		 test	 eax, eax
  00339	74 17		 je	 SHORT $LN65@ServiceIns
  0033b	8b 44 24 24	 mov	 eax, DWORD PTR _status$[esp+324]
  0033f	83 f8 02	 cmp	 eax, 2
  00342	75 12		 jne	 SHORT $LN43@ServiceIns

; 294  : 					Sleep(100);

  00344	6a 64		 push	 100			; 00000064H
  00346	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  0034c	43		 inc	 ebx
  0034d	83 fb 0a	 cmp	 ebx, 10			; 0000000aH
  00350	7c d9		 jl	 SHORT $LL10@ServiceIns
$LN65@ServiceIns:

; 290  : 			{
; 291  : 				for (i = 0; i < 10; i++)

  00352	8b 44 24 24	 mov	 eax, DWORD PTR _status$[esp+324]
$LN43@ServiceIns:

; 295  : 				}
; 296  : 
; 297  : 				if (status.dwCurrentState == SERVICE_RUNNING)

  00356	83 f8 04	 cmp	 eax, 4
  00359	75 09		 jne	 SHORT $LN5@ServiceIns

; 298  : 					printf("Success\n");

  0035b	68 00 00 00 00	 push	 OFFSET ??_C@_08GKHOLFG@Success?6?$AA@
$LN71@ServiceIns:
  00360	ff d6		 call	 esi
  00362	eb 2a		 jmp	 SHORT $LN70@ServiceIns
$LN5@ServiceIns:

; 299  : 				else if (status.dwCurrentState == SERVICE_START_PENDING)

  00364	83 f8 02	 cmp	 eax, 2
  00367	75 07		 jne	 SHORT $LN3@ServiceIns

; 300  : 					printf("Not ready within a second\n");

  00369	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MMELEJAD@Not?5ready?5within?5a?5second?6?$AA@

; 301  : 				else

  0036e	eb f0		 jmp	 SHORT $LN71@ServiceIns
$LN3@ServiceIns:

; 302  : 					errorout("Error\n");

  00370	68 00 00 00 00	 push	 OFFSET ??_C@_06HPIHNGNL@Error?6?$AA@
  00375	e8 00 00 00 00	 call	 _errorout

; 303  : 			}
; 304  : 			else

  0037a	eb 12		 jmp	 SHORT $LN70@ServiceIns
$LN11@ServiceIns:

; 305  : 				errorout("Error %u\n", (uint32_t)GetLastError());

  0037c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00382	50		 push	 eax
  00383	68 00 00 00 00	 push	 OFFSET ??_C@_09JBCKIECM@Error?5?$CFu?6?$AA@
  00388	e8 00 00 00 00	 call	 _errorout
  0038d	59		 pop	 ecx
$LN70@ServiceIns:
  0038e	59		 pop	 ecx
$LN1@ServiceIns:

; 306  : 		}
; 307  : 	}
; 308  : 
; 309  : 	CloseServiceHandle(schService);

  0038f	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__CloseServiceHandle@4
  00395	57		 push	 edi
  00396	ff d6		 call	 esi

; 310  : 	CloseServiceHandle(schSCManager);

  00398	ff 74 24 1c	 push	 DWORD PTR _schSCManager$1$[esp+320]
  0039c	ff d6		 call	 esi
$LN67@ServiceIns:
  0039e	5e		 pop	 esi
  0039f	5f		 pop	 edi
$LN30@ServiceIns:
  003a0	5d		 pop	 ebp
  003a1	5b		 pop	 ebx

; 311  : }

  003a2	81 c4 30 01 00
	00		 add	 esp, 304		; 00000130H
  003a8	c3		 ret	 0
$LN72@ServiceIns:

; 243  : 		{
; 244  : 			tempUser = (char*)vlmcsd_malloc(strlen(ServiceUser) + 3);

  003a9	e8 00 00 00 00	 call	 _OutOfMemory
$LN74@ServiceIns:
$LN68@ServiceIns:
  003ae	cc		 int	 3
_ServiceInstaller ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\ntservice.c
;	COMDAT _NtServiceInstallation
_TEXT	SEGMENT
_ServicePassword$dead$ = 8				; size = 4
_NtServiceInstallation PROC				; COMDAT
; _installService$dead$ = cl
; _ServiceUser$dead$ = edx

; 315  : 	if (IsNTService) return 0;

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _IsNTService, 0
  00007	75 1a		 jne	 SHORT $LN4@NtServiceI

; 316  : 
; 317  : 	if (installService == 1) // Install

  00009	a0 00 00 00 00	 mov	 al, BYTE PTR _installService
  0000e	3c 01		 cmp	 al, 1
  00010	75 14		 jne	 SHORT $LN7@NtServiceI

; 318  : 	{
; 319  : 		ServiceInstaller(ServiceUser, ServicePassword);

  00012	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ServicePassword
  00018	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ServiceUser
  0001e	e8 00 00 00 00	 call	 _ServiceInstaller
$LN4@NtServiceI:

; 336  : 		}
; 337  : 	}
; 338  : 
; 339  : 	// Do nothing
; 340  : 
; 341  : 	return(0);

  00023	33 c0		 xor	 eax, eax

; 342  : }

  00025	c3		 ret	 0
$LN7@NtServiceI:

; 320  : 		return(0);
; 321  : 	}
; 322  : 
; 323  : 	if (installService == 2) // Remove

  00026	3c 02		 cmp	 al, 2
  00028	75 f9		 jne	 SHORT $LN4@NtServiceI

; 324  : 	{
; 325  : 		switch (OpenAndRemoveService(NULL, NULL))

  0002a	33 d2		 xor	 edx, edx
  0002c	33 c9		 xor	 ecx, ecx
  0002e	e8 00 00 00 00	 call	 _OpenAndRemoveService
  00033	0f b6 c0	 movzx	 eax, al

; 333  : 		default:
; 334  : 			errorout("Service %s does not exist.\n", NT_SERVICE_NAME);

  00036	68 00 00 00 00	 push	 OFFSET ??_C@_03HLHKOPNL@KMS?$AA@
  0003b	83 e8 00	 sub	 eax, 0
  0003e	74 19		 je	 SHORT $LN3@NtServiceI

; 324  : 	{
; 325  : 		switch (OpenAndRemoveService(NULL, NULL))

  00040	48		 dec	 eax
  00041	74 07		 je	 SHORT $LN2@NtServiceI

; 333  : 		default:
; 334  : 			errorout("Service %s does not exist.\n", NT_SERVICE_NAME);

  00043	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GDAJEGHF@Service?5?$CFs?5does?5not?5exist?4?6?$AA@

; 335  : 			return(!0);

  00048	eb 14		 jmp	 SHORT $LN11@NtServiceI
$LN2@NtServiceI:

; 330  : 		case 1:
; 331  : 			printf("Service %s removed successfully\n", NT_SERVICE_NAME);

  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@KAHEFAHB@Service?5?$CFs?5removed?5successfully?6@
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__printf
  00055	59		 pop	 ecx
  00056	59		 pop	 ecx

; 332  : 			return(0);

  00057	eb ca		 jmp	 SHORT $LN4@NtServiceI
$LN3@NtServiceI:

; 326  : 		{
; 327  : 		case 0:
; 328  : 			errorout("Error removing service %s\n", NT_SERVICE_NAME);

  00059	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@KECMPHCB@Error?5removing?5service?5?$CFs?6?$AA@
$LN11@NtServiceI:
  0005e	e8 00 00 00 00	 call	 _errorout
  00063	59		 pop	 ecx

; 329  : 			return(!0);

  00064	33 c0		 xor	 eax, eax
  00066	59		 pop	 ecx
  00067	40		 inc	 eax

; 342  : }

  00068	c3		 ret	 0
_NtServiceInstallation ENDP
_TEXT	ENDS
END
