; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Dell\Desktop\vlmcsd\src\kms.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07NBCGADJA@Unknown?$AA@			; `string'
PUBLIC	??_C@_01FGNFDNOH@?$CF?$AA@			; `string'
PUBLIC	??_C@_01OMGOGALD@u?$AA@				; `string'
PUBLIC	??_C@_04PGKABKNA@?903?9?$AA@			; `string'
PUBLIC	??_C@_06KMCAJKLF@?40000?9?$AA@			; `string'
PUBLIC	??_C@_0BM@KDKADHPB@randomized?5at?5program?5start?$AA@ ; `string'
PUBLIC	??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5?$CF@ ; `string'
PUBLIC	??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request?$AA@ ; `string'
PUBLIC	??_C@_0P@CACDFLGA@vlmcsd?5default?$AA@		; `string'
PUBLIC	??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sourc@ ; `string'
PUBLIC	??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5than@ ; `string'
PUBLIC	??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54?5@ ; `string'
PUBLIC	??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product?5@ ; `string'
PUBLIC	??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC004@ ; `string'
PUBLIC	??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect?5@ ; `string'
PUBLIC	??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients?5@ ; `string'
PUBLIC	_CreateResponseBase
EXTRN	__imp___time64:PROC
EXTRN	__imp__EnterCriticalSection@4:PROC
EXTRN	__imp__rand:PROC
EXTRN	__imp__LeaveCriticalSection@4:PROC
EXTRN	__imp__InitializeCriticalSection@4:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp___gmtime64:PROC
EXTRN	__imp__sprintf:PROC
EXTRN	__imp___stricmp:PROC
_ZeroGuid DB	010H DUP (?)
COMM	_mutex:DWORD
_DATA	ENDS
_DATA	ENDS
;	COMDAT ??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients?5@
CONST	SEGMENT
??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients?5@ DB 'Rejecting m'
	DB	'ore than 671 clients (0xC004D104)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect?5@
CONST	SEGMENT
??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect?5@ DB 'Refusing pro'
	DB	'duct with incorrect Application ID (0xC004F042)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC004@
CONST	SEGMENT
??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC004@ DB 'Refusing u'
	DB	'nknown product (0xC004F042)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product?5@
CONST	SEGMENT
??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product?5@ DB 'Refusing re'
	DB	'tail or beta product (0xC004F042)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54?5@
CONST	SEGMENT
??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54?5@ DB 'Client tim'
	DB	'e differs more than 4 hours from system time (0xC004F06C)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5than@
CONST	SEGMENT
??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5than@ DB 'Rejecting re'
	DB	'quest with more than 1000 minimum clients (0x8007000D)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sourc@
CONST	SEGMENT
??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sourc@ DB '>>'
	DB	'> Sending response, ePID source = %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6?$AA@ DB 'Sendi'
	DB	'ng ePID (%s): %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CACDFLGA@vlmcsd?5default?$AA@
CONST	SEGMENT
??_C@_0P@CACDFLGA@vlmcsd?5default?$AA@ DB 'vlmcsd default', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request?$AA@
CONST	SEGMENT
??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request?$AA@ DB 'randomized on '
	DB	'every request', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5?$CF@
CONST	SEGMENT
??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5?$CF@ DB 'K'
	DB	'MS v%i.%i request from %s for %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6?$AA@
CONST	SEGMENT
??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6?$AA@ DB '<<< In'
	DB	'coming KMS request', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KDKADHPB@randomized?5at?5program?5start?$AA@
CONST	SEGMENT
??_C@_0BM@KDKADHPB@randomized?5at?5program?5start?$AA@ DB 'randomized at '
	DB	'program start', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06KMCAJKLF@?40000?9?$AA@
CONST	SEGMENT
??_C@_06KMCAJKLF@?40000?9?$AA@ DB '.0000-', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGKABKNA@?903?9?$AA@
CONST	SEGMENT
??_C@_04PGKABKNA@?903?9?$AA@ DB '-03-', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OMGOGALD@u?$AA@
CONST	SEGMENT
??_C@_01OMGOGALD@u?$AA@ DB 'u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FGNFDNOH@?$CF?$AA@
CONST	SEGMENT
??_C@_01FGNFDNOH@?$CF?$AA@ DB '%', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown?$AA@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown?$AA@ DB 'Unknown', 00H		; `string'
?DefaultHwid@?1??CreateResponseV6@@9@9 DB 03aH		; `CreateResponseV6'::`2'::DefaultHwid
	DB	01cH
	DB	04H
	DB	096H
	DB	00H
	DB	0b6H
	DB	00H
	DB	076H
_HostOS	DW	0d701H
	DW	01772H
	DW	0d701H
	DW	01db1H
	DW	01532H
	DW	023f0H
	DW	01901H
	DW	02580H
	DW	0e1cH
	DW	03839H
_LcidList DW	0436H
	DW	041cH
	DW	0401H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01401H
	DW	01801H
	DW	01c01H
	DW	02001H
	DW	02401H
	DW	02801H
	DW	02c01H
	DW	03001H
	DW	03401H
	DW	03801H
	DW	03c01H
	DW	04001H
	DW	042bH
	DW	042cH
	DW	082cH
	DW	042dH
	DW	0423H
	DW	0445H
	DW	0141aH
	DW	0402H
	DW	0403H
	DW	0404H
	DW	0804H
	DW	0c04H
	DW	01004H
	DW	01404H
	DW	041aH
	DW	0101aH
	DW	0405H
	DW	0406H
	DW	0465H
	DW	0413H
	DW	0813H
	DW	0409H
	DW	0809H
	DW	0c09H
	DW	01009H
	DW	01409H
	DW	01809H
	DW	01c09H
	DW	02009H
	DW	02409H
	DW	02809H
	DW	02c09H
	DW	03009H
	DW	03409H
	DW	0425H
	DW	0438H
	DW	0429H
	DW	040bH
	DW	040cH
	DW	080cH
	DW	0c0cH
	DW	0100cH
	DW	0140cH
	DW	0180cH
	DW	0437H
	DW	0456H
	DW	0407H
	DW	0807H
	DW	0c07H
	DW	01007H
	DW	01407H
	DW	0408H
	DW	0447H
	DW	040dH
	DW	0439H
	DW	040eH
	DW	040fH
	DW	0421H
	DW	0410H
	DW	0810H
	DW	0411H
	DW	044bH
	DW	043fH
	DW	0457H
	DW	0412H
	DW	0440H
	DW	0426H
	DW	0427H
	DW	042fH
	DW	043eH
	DW	083eH
	DW	044cH
	DW	043aH
	DW	0481H
	DW	044eH
	DW	0450H
	DW	0414H
	DW	0814H
	DW	0415H
	DW	0416H
	DW	0816H
	DW	0446H
	DW	046bH
	DW	086bH
	DW	0c6bH
	DW	0418H
	DW	0419H
	DW	0243bH
	DW	0103bH
	DW	0143bH
	DW	0c3bH
	DW	043bH
	DW	083bH
	DW	0203bH
	DW	0183bH
	DW	01c3bH
	DW	044fH
	DW	081aH
	DW	0181aH
	DW	0c1aH
	DW	01c1aH
	DW	041bH
	DW	0424H
	DW	040aH
	DW	080aH
	DW	0c0aH
	DW	0100aH
	DW	0140aH
	DW	0180aH
	DW	01c0aH
	DW	0200aH
	DW	0240aH
	DW	0280aH
	DW	02c0aH
	DW	0300aH
	DW	0340aH
	DW	0380aH
	DW	03c0aH
	DW	0400aH
	DW	0440aH
	DW	0480aH
	DW	04c0aH
	DW	0500aH
	DW	0441H
	DW	041dH
	DW	081dH
	DW	045aH
	DW	0449H
	DW	0444H
	DW	044aH
	DW	041eH
	DW	0432H
	DW	0422H
	DW	0420H
	DW	0443H
	DW	0843H
	DW	042aH
	DW	0452H
	DW	0434H
	DW	0435H
_CreateResponseBase DD FLAT:_CreateResponseBaseCallback@16
PUBLIC	_CreateResponseV6
PUBLIC	_CreateResponseV4
PUBLIC	_get16RandomBytes
PUBLIC	_randomPidInit
PUBLIC	_InitializeClientLists
PUBLIC	_CleanUpClientLists
PUBLIC	_fileTimeToUnixTime
PUBLIC	_getProductIndex
_ClientLists DD	01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
;	COMDAT _gmtime
_TEXT	SEGMENT
_gmtime	PROC						; COMDAT
; __Time$ = ecx

; 101  : #pragma warning( push )
; 102  : #pragma warning( disable : 4996 )
; 103  :     return _gmtime64(_Time);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___gmtime64
  00007	59		 pop	 ecx

; 104  : #pragma warning( pop )
; 105  : }

  00008	c3		 ret	 0
_gmtime	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
;	COMDAT _time
_TEXT	SEGMENT
_time	PROC						; COMDAT
; __Time$ = ecx

; 133  :     return _time64(_Time);

  00000	51		 push	 ecx
  00001	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00007	59		 pop	 ecx

; 134  : }

  00008	c3		 ret	 0
_time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _getProductIndex
_TEXT	SEGMENT
_count$ = 8						; size = 4
_name$ = 12						; size = 4
_ePid$ = 16						; size = 4
_getProductIndex PROC					; COMDAT
; _guid$ = ecx
; _list$ = edx

; 47   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	53		 push	 ebx
  00004	56		 push	 esi

; 48   : 	int i;
; 49   : 
; 50   : 	for (i = count - 1; i >= 0; i--)

  00005	8b 75 08	 mov	 esi, DWORD PTR _count$[ebp]
  00008	8b d9		 mov	 ebx, ecx
  0000a	4e		 dec	 esi
  0000b	57		 push	 edi
  0000c	78 53		 js	 SHORT $LN19@getProduct
  0000e	8b fe		 mov	 edi, esi
  00010	c1 e7 05	 shl	 edi, 5
  00013	03 fa		 add	 edi, edx
$LL8@getProduct:

; 51   : 	{
; 52   : 		if (IsEqualGUID(guid, &list[i].Guid))

  00015	33 c9		 xor	 ecx, ecx
$LL16@getProduct:
  00017	8b 04 8b	 mov	 eax, DWORD PTR [ebx+ecx*4]
  0001a	3b 04 8f	 cmp	 eax, DWORD PTR [edi+ecx*4]
  0001d	75 3c		 jne	 SHORT $LN17@getProduct
  0001f	41		 inc	 ecx
  00020	83 f9 04	 cmp	 ecx, 4
  00023	75 f2		 jne	 SHORT $LL16@getProduct

; 53   : 		{
; 54   : 			if (name) *name = list[i].Name;

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _name$[ebp]
  00028	85 c9		 test	 ecx, ecx
  0002a	74 0b		 je	 SHORT $LN4@getProduct
  0002c	8b c6		 mov	 eax, esi
  0002e	c1 e0 05	 shl	 eax, 5
  00031	8b 44 10 10	 mov	 eax, DWORD PTR [eax+edx+16]
  00035	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@getProduct:

; 55   : 			if (ePid) *ePid = KmsData->CsvlkData[list[i].EPidIndex].EPid;

  00037	8b 45 10	 mov	 eax, DWORD PTR _ePid$[ebp]
  0003a	85 c0		 test	 eax, eax
  0003c	74 41		 je	 SHORT $LN1@getProduct
  0003e	8b ce		 mov	 ecx, esi
  00040	c1 e1 05	 shl	 ecx, 5
  00043	0f b6 4c 11 1e	 movzx	 ecx, BYTE PTR [ecx+edx+30]
  00048	83 c1 02	 add	 ecx, 2
  0004b	6b d1 18	 imul	 edx, ecx, 24
  0004e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KmsData
  00054	8b 0c 0a	 mov	 ecx, DWORD PTR [edx+ecx]
  00057	89 08		 mov	 DWORD PTR [eax], ecx

; 56   : 			return i;

  00059	eb 24		 jmp	 SHORT $LN1@getProduct
$LN17@getProduct:

; 48   : 	int i;
; 49   : 
; 50   : 	for (i = count - 1; i >= 0; i--)

  0005b	83 ef 20	 sub	 edi, 32			; 00000020H
  0005e	4e		 dec	 esi
  0005f	79 b4		 jns	 SHORT $LL8@getProduct
$LN19@getProduct:

; 57   : 		}
; 58   : 	}
; 59   : 
; 60   : 	if (name) *name = "Unknown";

  00061	8b 45 0c	 mov	 eax, DWORD PTR _name$[ebp]
  00064	85 c0		 test	 eax, eax
  00066	74 06		 je	 SHORT $LN2@getProduct
  00068	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
$LN2@getProduct:

; 61   : 	if (ePid) *ePid = KmsData->CsvlkData[EPID_INDEX_WINDOWS].EPid;

  0006e	8b 4d 10	 mov	 ecx, DWORD PTR _ePid$[ebp]
  00071	85 c9		 test	 ecx, ecx
  00073	74 0a		 je	 SHORT $LN1@getProduct
  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _KmsData
  0007a	8b 40 30	 mov	 eax, DWORD PTR [eax+48]
  0007d	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@getProduct:

; 62   : 	return i;

  0007f	5f		 pop	 edi
  00080	8b c6		 mov	 eax, esi
  00082	5e		 pop	 esi
  00083	5b		 pop	 ebx

; 63   : }

  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_getProductIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _fileTimeToUnixTime
_TEXT	SEGMENT
_fileTimeToUnixTime PROC				; COMDAT
; _ts$ = ecx

; 121  : 	return GET_UA64LE(ts) / 10000000LL - 11644473600LL;

  00000	6a 00		 push	 0
  00002	68 80 96 98 00	 push	 10000000		; 00989680H
  00007	ff 71 04	 push	 DWORD PTR [ecx+4]
  0000a	ff 31		 push	 DWORD PTR [ecx]
  0000c	e8 00 00 00 00	 call	 __aulldiv
  00011	05 00 6f ef 49	 add	 eax, 1240428288		; 49ef6f00H
  00016	83 d2 fd	 adc	 edx, -3			; fffffffdH

; 122  : }

  00019	c3		 ret	 0
_fileTimeToUnixTime ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _CleanUpClientLists
_TEXT	SEGMENT
_CleanUpClientLists PROC				; COMDAT

; 155  : #	ifndef USE_THREADS
; 156  : 	shmctl(shmid_clients, IPC_RMID, NULL);
; 157  : #	endif // !USE_THREADS
; 158  : }

  00000	c3		 ret	 0
_CleanUpClientLists ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _InitializeClientLists
_TEXT	SEGMENT
tv267 = -4						; size = 4
_InitializeClientLists PROC				; COMDAT

; 161  : {

  00000	51		 push	 ecx

; 162  : 	int_fast8_t i;
; 163  : 	int_fast16_t j;
; 164  : 
; 165  : #	ifndef USE_THREADS
; 166  : 	if (
; 167  : 		(shmid_clients = shmget(IPC_PRIVATE, sizeof(ClientList_t) * KmsData->AppItemCount + mutex_size, IPC_CREAT | 0600)) < 0 ||
; 168  : 		(mutex = (mutex_t*)shmat(shmid_clients, NULL, 0)) == (mutex_t*)-1
; 169  : 		)
; 170  : 	{
; 171  : 		int errno_save = errno;
; 172  : 		printerrorf("Warning: CMID lists disabled. Could not create shared memory: %s\n", vlmcsd_strerror(errno_save));
; 173  : 		if (shmid_clients >= 0) shmctl(shmid_clients, IPC_RMID, NULL);
; 174  : 		MaintainClients = FALSE;
; 175  : 		return;
; 176  : 	}
; 177  : 
; 178  : 	ClientLists = (PClientList_t)((BYTE*)mutex + mutex_size);
; 179  : 
; 180  : #	if __CYGWIN__
; 181  : 	InitializeCriticalSection(mutex);
; 182  : #	else // !__CYGWIN__
; 183  : 	pthread_mutexattr_t mutex_attr;
; 184  : 	pthread_mutexattr_init(&mutex_attr);
; 185  : 	pthread_mutexattr_setpshared(&mutex_attr, PTHREAD_PROCESS_SHARED);
; 186  : 	pthread_mutex_init(mutex, &mutex_attr);
; 187  : 
; 188  : #	endif // !__CYGWIN__
; 189  : 
; 190  : #	else // USE_THREADS
; 191  : 
; 192  : 	ClientLists = (PClientList_t)vlmcsd_malloc(sizeof(ClientList_t) * KmsData->AppItemCount);

  00001	a1 00 00 00 00	 mov	 eax, DWORD PTR _KmsData
  00006	56		 push	 esi
  00007	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__malloc
  0000d	69 40 0c fc 29
	00 00		 imul	 eax, DWORD PTR [eax+12], 10748
  00014	50		 push	 eax
  00015	ff d6		 call	 esi
  00017	59		 pop	 ecx
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 ac 00 00
	00		 je	 $LN34@Initialize

; 193  : 	mutex = (mutex_t*)vlmcsd_malloc(sizeof(mutex_t));

  00020	6a 18		 push	 24			; 00000018H
  00022	a3 00 00 00 00	 mov	 DWORD PTR _ClientLists, eax
  00027	ff d6		 call	 esi
  00029	59		 pop	 ecx
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 9a 00 00
	00		 je	 $LN34@Initialize

; 194  : 
; 195  : #	if !_WIN32 && !__CYGWIN__
; 196  : 	pthread_mutex_init(mutex, NULL);
; 197  : #	else //_WIN32 || __CYGWIN__
; 198  : 	InitializeCriticalSection(mutex);

  00032	53		 push	 ebx
  00033	57		 push	 edi
  00034	50		 push	 eax
  00035	a3 00 00 00 00	 mov	 DWORD PTR _mutex, eax
  0003a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 199  : #   endif //_WIN32 || __CYGWIN__
; 200  : 
; 201  : #	endif // USE_THREADS
; 202  : 
; 203  : 	memset(ClientLists, 0, sizeof(ClientList_t) * KmsData->AppItemCount);

  00040	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _KmsData
  00046	33 db		 xor	 ebx, ebx
  00048	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _ClientLists
  0004e	69 47 0c fc 29
	00 00		 imul	 eax, DWORD PTR [edi+12], 10748
  00055	50		 push	 eax
  00056	53		 push	 ebx
  00057	56		 push	 esi
  00058	e8 00 00 00 00	 call	 _memset
  0005d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 204  : 
; 205  : 	if (!StartEmpty)

  00060	38 1d 00 00 00
	00		 cmp	 BYTE PTR _StartEmpty, bl
  00066	75 5f		 jne	 SHORT $LN29@Initialize

; 206  : 	{
; 207  : 		for (i = 0; i < KmsData->AppItemCount; i++)

  00068	39 5f 0c	 cmp	 DWORD PTR [edi+12], ebx
  0006b	7e 5a		 jle	 SHORT $LN29@Initialize
  0006d	8b d3		 mov	 edx, ebx
  0006f	55		 push	 ebp
$LL6@Initialize:

; 208  : 		{
; 209  : 			uint8_t maxCount = KmsData->AppItemList[i].NCountPolicy;

  00070	8b 47 18	 mov	 eax, DWORD PTR [edi+24]
  00073	8b ca		 mov	 ecx, edx
  00075	c1 e1 05	 shl	 ecx, 5

; 210  : 			ClientLists[i].CurrentCount = (maxCount >> 1) - 1;

  00078	69 ea fc 29 00
	00		 imul	 ebp, edx, 10748
  0007e	8a 44 01 1b	 mov	 al, BYTE PTR [ecx+eax+27]
  00082	0f b6 c8	 movzx	 ecx, al
  00085	8b c1		 mov	 eax, ecx
  00087	d1 e8		 shr	 eax, 1
  00089	48		 dec	 eax
  0008a	89 44 24 10	 mov	 DWORD PTR tv267[esp+20], eax
  0008e	89 84 2e f0 29
	00 00		 mov	 DWORD PTR [esi+ebp+10736], eax

; 211  : 			ClientLists[i].MaxCount = maxCount;

  00095	89 8c 2e f4 29
	00 00		 mov	 DWORD PTR [esi+ebp+10740], ecx

; 212  : 
; 213  : 			for (j = 0; j < (maxCount >> 1) - 1; j++)

  0009c	85 c0		 test	 eax, eax
  0009e	7e 1c		 jle	 SHORT $LN5@Initialize
  000a0	8b f8		 mov	 edi, eax
$LL3@Initialize:

; 214  : 			{
; 215  : 				get16RandomBytes(&ClientLists[i].Guid[j]);

  000a2	8d 0c 2e	 lea	 ecx, DWORD PTR [esi+ebp]
  000a5	e8 00 00 00 00	 call	 _get16RandomBytes
  000aa	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _ClientLists
  000b0	8d 6d 10	 lea	 ebp, DWORD PTR [ebp+16]
  000b3	4f		 dec	 edi
  000b4	75 ec		 jne	 SHORT $LL3@Initialize

; 212  : 
; 213  : 			for (j = 0; j < (maxCount >> 1) - 1; j++)

  000b6	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _KmsData
$LN5@Initialize:

; 206  : 	{
; 207  : 		for (i = 0; i < KmsData->AppItemCount; i++)

  000bc	fe c3		 inc	 bl
  000be	0f be d3	 movsx	 edx, bl
  000c1	3b 57 0c	 cmp	 edx, DWORD PTR [edi+12]
  000c4	7c aa		 jl	 SHORT $LL6@Initialize
  000c6	5d		 pop	 ebp
$LN29@Initialize:
  000c7	5f		 pop	 edi
  000c8	5b		 pop	 ebx
  000c9	5e		 pop	 esi

; 216  : 			}
; 217  : 		}
; 218  : 	}
; 219  : }

  000ca	59		 pop	 ecx
  000cb	c3		 ret	 0
$LN34@Initialize:

; 162  : 	int_fast8_t i;
; 163  : 	int_fast16_t j;
; 164  : 
; 165  : #	ifndef USE_THREADS
; 166  : 	if (
; 167  : 		(shmid_clients = shmget(IPC_PRIVATE, sizeof(ClientList_t) * KmsData->AppItemCount + mutex_size, IPC_CREAT | 0600)) < 0 ||
; 168  : 		(mutex = (mutex_t*)shmat(shmid_clients, NULL, 0)) == (mutex_t*)-1
; 169  : 		)
; 170  : 	{
; 171  : 		int errno_save = errno;
; 172  : 		printerrorf("Warning: CMID lists disabled. Could not create shared memory: %s\n", vlmcsd_strerror(errno_save));
; 173  : 		if (shmid_clients >= 0) shmctl(shmid_clients, IPC_RMID, NULL);
; 174  : 		MaintainClients = FALSE;
; 175  : 		return;
; 176  : 	}
; 177  : 
; 178  : 	ClientLists = (PClientList_t)((BYTE*)mutex + mutex_size);
; 179  : 
; 180  : #	if __CYGWIN__
; 181  : 	InitializeCriticalSection(mutex);
; 182  : #	else // !__CYGWIN__
; 183  : 	pthread_mutexattr_t mutex_attr;
; 184  : 	pthread_mutexattr_init(&mutex_attr);
; 185  : 	pthread_mutexattr_setpshared(&mutex_attr, PTHREAD_PROCESS_SHARED);
; 186  : 	pthread_mutex_init(mutex, &mutex_attr);
; 187  : 
; 188  : #	endif // !__CYGWIN__
; 189  : 
; 190  : #	else // USE_THREADS
; 191  : 
; 192  : 	ClientLists = (PClientList_t)vlmcsd_malloc(sizeof(ClientList_t) * KmsData->AppItemCount);

  000cc	e8 00 00 00 00	 call	 _OutOfMemory
$LN36@Initialize:
$LN32@Initialize:
  000d1	cc		 int	 3
_InitializeClientLists ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _itoc
_TEXT	SEGMENT
_formatString$ = -8					; size = 8
_digits$ = 8						; size = 1
_itoc	PROC						; COMDAT
; _c$ = ecx
; _i$ = edx

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 227  : 	char formatString[8];
; 228  : 	if (digits > 9) digits = 0;
; 229  : 	strcpy(formatString, "%");

  00007	6a 25		 push	 37			; 00000025H
  00009	58		 pop	 eax
  0000a	66 89 45 f8	 mov	 WORD PTR _formatString$[ebp], ax
  0000e	8b f1		 mov	 esi, ecx

; 230  : 
; 231  : 	if (digits)

  00010	8a 45 08	 mov	 al, BYTE PTR _digits$[ebp]
  00013	84 c0		 test	 al, al
  00015	74 0d		 je	 SHORT $LN1@itoc

; 232  : 	{
; 233  : 		formatString[1] = '0';
; 234  : 		formatString[2] = digits | 0x30;

  00017	0c 30		 or	 al, 48			; 00000030H
  00019	c6 45 f9 30	 mov	 BYTE PTR _formatString$[ebp+1], 48 ; 00000030H
  0001d	88 45 fa	 mov	 BYTE PTR _formatString$[ebp+2], al

; 235  : 		formatString[3] = 0;

  00020	c6 45 fb 00	 mov	 BYTE PTR _formatString$[ebp+3], 0
$LN1@itoc:

; 236  : 	}
; 237  : 
; 238  : 	strcat(formatString, "u");

  00024	8d 7d f8	 lea	 edi, DWORD PTR _formatString$[ebp]
  00027	4f		 dec	 edi
$LL5@itoc:
  00028	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0002b	47		 inc	 edi
  0002c	84 c0		 test	 al, al
  0002e	75 f8		 jne	 SHORT $LL5@itoc
  00030	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01OMGOGALD@u?$AA@
  00036	66 89 07	 mov	 WORD PTR [edi], ax

; 239  : 	sprintf(c, formatString, i);

  00039	8d 45 f8	 lea	 eax, DWORD PTR _formatString$[ebp]
  0003c	52		 push	 edx
  0003d	50		 push	 eax
  0003e	56		 push	 esi
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH

; 240  : 	return c;

  00048	8b c6		 mov	 eax, esi
  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi

; 241  : }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
_itoc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _getRandomServerType
_TEXT	SEGMENT
_getRandomServerType PROC				; COMDAT

; 245  : #	if defined(USE_MSRPC) || defined(SIMPLE_RPC)
; 246  : 
; 247  : 	return rand() % (int)vlmcsd_countof(HostOS);
; 248  : 
; 249  : #	else // !defined(USE_MSRPC) && !defined(SIMPLE_RPC)
; 250  : 	if (!UseServerRpcBTFN)

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _UseServerRpcBTFN, 0
  00007	75 0f		 jne	 SHORT $LN2@getRandomS

; 251  : 	{
; 252  : 		// This isn't possible at all, e.g. KMS host on XP
; 253  : 		return rand() % (int)vlmcsd_countof(HostOS);

  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  0000f	6a 05		 push	 5
  00011	99		 cdq
  00012	59		 pop	 ecx
  00013	f7 f9		 idiv	 ecx
  00015	8b c2		 mov	 eax, edx

; 259  : 
; 260  : #	endif // !defined(USE_MSRPC) && !defined(SIMPLE_RPC)
; 261  : }

  00017	c3		 ret	 0
$LN2@getRandomS:

; 254  : 	}
; 255  : 
; 256  : 	// return 9200/9600/14393 if NDR64 is in use, otherwise 6002/7601
; 257  : 	if (UseServerRpcNDR64) return (rand() % 3) + 2;

  00018	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _UseServerRpcNDR64, 0
  0001f	74 10		 je	 SHORT $LN1@getRandomS
  00021	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00027	6a 03		 push	 3
  00029	99		 cdq
  0002a	59		 pop	 ecx
  0002b	f7 f9		 idiv	 ecx
  0002d	8d 42 02	 lea	 eax, DWORD PTR [edx+2]

; 259  : 
; 260  : #	endif // !defined(USE_MSRPC) && !defined(SIMPLE_RPC)
; 261  : }

  00030	c3		 ret	 0
$LN1@getRandomS:

; 258  : 	return (rand() % 2);

  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00037	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0003c	79 05		 jns	 SHORT $LN3@getRandomS
  0003e	48		 dec	 eax
  0003f	83 c8 fe	 or	 eax, -2			; fffffffeH
  00042	40		 inc	 eax
$LN3@getRandomS:

; 259  : 
; 260  : #	endif // !defined(USE_MSRPC) && !defined(SIMPLE_RPC)
; 261  : }

  00043	c3		 ret	 0
_getRandomServerType ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _generateRandomPid
_TEXT	SEGMENT
_maxTime$ = -32						; size = 8
_kmsTime$ = -24						; size = 8
_numberBuffer$ = -12					; size = 12
tv632 = 8						; size = 4
_csvlkData$1$ = 8					; size = 4
_serverType$ = 8					; size = 4
_lang$ = 12						; size = 2
_generateRandomPid PROC					; COMDAT
; _index$ = ecx
; _szPid$ = edx

; 268  : {

  00000	83 ec 20	 sub	 esp, 32			; 00000020H
  00003	53		 push	 ebx
  00004	55		 push	 ebp

; 269  : 	char numberBuffer[12];
; 270  : 
; 271  : 	if (serverType < 0 || serverType >= (int)vlmcsd_countof(HostOS))

  00005	8b 6c 24 2c	 mov	 ebp, DWORD PTR _serverType$[esp+36]
  00009	8b da		 mov	 ebx, edx
  0000b	56		 push	 esi
  0000c	8b f1		 mov	 esi, ecx
  0000e	57		 push	 edi
  0000f	85 ed		 test	 ebp, ebp
  00011	78 05		 js	 SHORT $LN3@generateRa
  00013	83 fd 05	 cmp	 ebp, 5
  00016	7c 07		 jl	 SHORT $LN4@generateRa
$LN3@generateRa:

; 272  : 	{
; 273  : 		serverType = getRandomServerType();

  00018	e8 00 00 00 00	 call	 _getRandomServerType
  0001d	8b e8		 mov	 ebp, eax
$LN4@generateRa:

; 274  : 	}
; 275  : 
; 276  : 	strcpy(szPid, itoc(numberBuffer, HostOS[serverType].Type, 5));

  0001f	0f b7 14 ad 00
	00 00 00	 movzx	 edx, WORD PTR _HostOS[ebp*4]
  00027	8d 4c 24 24	 lea	 ecx, DWORD PTR _numberBuffer$[esp+48]
  0002b	6a 05		 push	 5
  0002d	e8 00 00 00 00	 call	 _itoc
  00032	8b d3		 mov	 edx, ebx
  00034	59		 pop	 ecx
  00035	2b d0		 sub	 edx, eax
$LL7@generateRa:
  00037	8a 08		 mov	 cl, BYTE PTR [eax]
  00039	88 0c 02	 mov	 BYTE PTR [edx+eax], cl
  0003c	40		 inc	 eax
  0003d	84 c9		 test	 cl, cl
  0003f	75 f6		 jne	 SHORT $LL7@generateRa

; 277  : 	strcat(szPid, "-");

  00041	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL15@generateRa:
  00044	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00047	47		 inc	 edi
  00048	84 c0		 test	 al, al
  0004a	75 f8		 jne	 SHORT $LL15@generateRa
  0004c	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@

; 278  : 
; 279  : 	//if (index > 3) index = 0;
; 280  : 
; 281  : 	PCsvlkData_t csvlkData = &KmsData->CsvlkData[index];
; 282  : 	strcat(szPid, itoc(numberBuffer, csvlkData->GroupId, 5));

  00052	8d 4c 24 24	 lea	 ecx, DWORD PTR _numberBuffer$[esp+48]
  00056	66 89 07	 mov	 WORD PTR [edi], ax
  00059	8d 46 02	 lea	 eax, DWORD PTR [esi+2]
  0005c	6b c0 18	 imul	 eax, eax, 24
  0005f	6a 05		 push	 5
  00061	03 05 00 00 00
	00		 add	 eax, DWORD PTR _KmsData
  00067	89 44 24 38	 mov	 DWORD PTR _csvlkData$1$[esp+48], eax
  0006b	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  0006e	e8 00 00 00 00	 call	 _itoc
  00073	8b d0		 mov	 edx, eax
  00075	59		 pop	 ecx
  00076	8b f2		 mov	 esi, edx
$LL16@generateRa:
  00078	8a 02		 mov	 al, BYTE PTR [edx]
  0007a	42		 inc	 edx
  0007b	84 c0		 test	 al, al
  0007d	75 f9		 jne	 SHORT $LL16@generateRa
  0007f	2b d6		 sub	 edx, esi
  00081	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL17@generateRa:
  00084	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00087	47		 inc	 edi
  00088	84 c0		 test	 al, al
  0008a	75 f8		 jne	 SHORT $LL17@generateRa
  0008c	8b ca		 mov	 ecx, edx
  0008e	c1 e9 02	 shr	 ecx, 2
  00091	f3 a5		 rep movsd
  00093	8b ca		 mov	 ecx, edx
  00095	83 e1 03	 and	 ecx, 3
  00098	f3 a4		 rep movsb

; 283  : 	strcat(szPid, "-");

  0009a	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL18@generateRa:
  0009d	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  000a0	47		 inc	 edi
  000a1	84 c0		 test	 al, al
  000a3	75 f8		 jne	 SHORT $LL18@generateRa
  000a5	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@
  000ab	66 89 07	 mov	 WORD PTR [edi], ax

; 284  : 
; 285  : 	int keyId = (rand32() % (csvlkData->MaxKeyId - csvlkData->MinKeyId)) + csvlkData->MinKeyId;

  000ae	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__rand
  000b4	ff d7		 call	 edi
  000b6	8b f0		 mov	 esi, eax
  000b8	c1 e6 0f	 shl	 esi, 15			; 0000000fH
  000bb	ff d7		 call	 edi
  000bd	0b f0		 or	 esi, eax
  000bf	8b 44 24 34	 mov	 eax, DWORD PTR _csvlkData$1$[esp+44]
  000c3	c1 e6 02	 shl	 esi, 2
  000c6	8b 78 0c	 mov	 edi, DWORD PTR [eax+12]
  000c9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  000cf	8b 4c 24 34	 mov	 ecx, DWORD PTR _csvlkData$1$[esp+44]
  000d3	83 e0 03	 and	 eax, 3
  000d6	0b c6		 or	 eax, esi
  000d8	33 d2		 xor	 edx, edx

; 286  : 	strcat(szPid, itoc(numberBuffer, keyId / 1000000, 3));

  000da	6a 03		 push	 3
  000dc	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  000df	2b cf		 sub	 ecx, edi
  000e1	f7 f1		 div	 ecx
  000e3	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  000e8	8d 04 17	 lea	 eax, DWORD PTR [edi+edx]
  000eb	99		 cdq
  000ec	f7 f9		 idiv	 ecx
  000ee	8d 4c 24 28	 lea	 ecx, DWORD PTR _numberBuffer$[esp+52]
  000f2	89 54 24 38	 mov	 DWORD PTR tv632[esp+48], edx
  000f6	8b d0		 mov	 edx, eax
  000f8	e8 00 00 00 00	 call	 _itoc
  000fd	8b d0		 mov	 edx, eax
  000ff	59		 pop	 ecx
  00100	8b f2		 mov	 esi, edx
$LL19@generateRa:
  00102	8a 02		 mov	 al, BYTE PTR [edx]
  00104	42		 inc	 edx
  00105	84 c0		 test	 al, al
  00107	75 f9		 jne	 SHORT $LL19@generateRa
  00109	2b d6		 sub	 edx, esi
  0010b	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL20@generateRa:
  0010e	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00111	47		 inc	 edi
  00112	84 c0		 test	 al, al
  00114	75 f8		 jne	 SHORT $LL20@generateRa
  00116	8b ca		 mov	 ecx, edx
  00118	c1 e9 02	 shr	 ecx, 2
  0011b	f3 a5		 rep movsd
  0011d	8b ca		 mov	 ecx, edx
  0011f	83 e1 03	 and	 ecx, 3
  00122	f3 a4		 rep movsb

; 287  : 	strcat(szPid, "-");

  00124	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL21@generateRa:
  00127	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0012a	47		 inc	 edi
  0012b	84 c0		 test	 al, al
  0012d	75 f8		 jne	 SHORT $LL21@generateRa
  0012f	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@

; 288  : 	strcat(szPid, itoc(numberBuffer, keyId % 1000000, 6));

  00135	8d 4c 24 24	 lea	 ecx, DWORD PTR _numberBuffer$[esp+48]
  00139	8b 54 24 34	 mov	 edx, DWORD PTR tv632[esp+44]
  0013d	6a 06		 push	 6
  0013f	66 89 07	 mov	 WORD PTR [edi], ax
  00142	e8 00 00 00 00	 call	 _itoc
  00147	8b d0		 mov	 edx, eax
  00149	59		 pop	 ecx
  0014a	8b f2		 mov	 esi, edx
$LL22@generateRa:
  0014c	8a 02		 mov	 al, BYTE PTR [edx]
  0014e	42		 inc	 edx
  0014f	84 c0		 test	 al, al
  00151	75 f9		 jne	 SHORT $LL22@generateRa
  00153	2b d6		 sub	 edx, esi
  00155	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL23@generateRa:
  00158	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  0015b	47		 inc	 edi
  0015c	84 c0		 test	 al, al
  0015e	75 f8		 jne	 SHORT $LL23@generateRa
  00160	8b ca		 mov	 ecx, edx
  00162	c1 e9 02	 shr	 ecx, 2
  00165	f3 a5		 rep movsd
  00167	8b ca		 mov	 ecx, edx
  00169	83 e1 03	 and	 ecx, 3
  0016c	f3 a4		 rep movsb

; 289  : 	strcat(szPid, "-03-");

  0016e	8d 4b ff	 lea	 ecx, DWORD PTR [ebx-1]
$LL24@generateRa:
  00171	8a 41 01	 mov	 al, BYTE PTR [ecx+1]
  00174	41		 inc	 ecx
  00175	84 c0		 test	 al, al
  00177	75 f8		 jne	 SHORT $LL24@generateRa
  00179	a1 00 00 00 00	 mov	 eax, DWORD PTR ??_C@_04PGKABKNA@?903?9?$AA@
  0017e	89 01		 mov	 DWORD PTR [ecx], eax
  00180	a0 04 00 00 00	 mov	 al, BYTE PTR ??_C@_04PGKABKNA@?903?9?$AA@+4
  00185	88 41 04	 mov	 BYTE PTR [ecx+4], al

; 290  : 
; 291  : 	if (lang < 0) lang = LcidList[rand() % vlmcsd_countof(LcidList)];

  00188	8b 44 24 38	 mov	 eax, DWORD PTR _lang$[esp+44]
  0018c	66 85 c0	 test	 ax, ax
  0018f	79 17		 jns	 SHORT $LN2@generateRa
  00191	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00197	33 d2		 xor	 edx, edx
  00199	b9 9e 00 00 00	 mov	 ecx, 158		; 0000009eH
  0019e	f7 f1		 div	 ecx
  001a0	0f b7 04 55 00
	00 00 00	 movzx	 eax, WORD PTR _LcidList[edx*2]
$LN2@generateRa:

; 292  : 	strcat(szPid, itoc(numberBuffer, lang, 0));

  001a8	6a 00		 push	 0
  001aa	0f bf d0	 movsx	 edx, ax
  001ad	8d 4c 24 28	 lea	 ecx, DWORD PTR _numberBuffer$[esp+52]
  001b1	e8 00 00 00 00	 call	 _itoc
  001b6	8b d0		 mov	 edx, eax
  001b8	59		 pop	 ecx
  001b9	8b f2		 mov	 esi, edx
$LL25@generateRa:
  001bb	8a 02		 mov	 al, BYTE PTR [edx]
  001bd	42		 inc	 edx
  001be	84 c0		 test	 al, al
  001c0	75 f9		 jne	 SHORT $LL25@generateRa
  001c2	2b d6		 sub	 edx, esi
  001c4	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL26@generateRa:
  001c7	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  001ca	47		 inc	 edi
  001cb	84 c0		 test	 al, al
  001cd	75 f8		 jne	 SHORT $LL26@generateRa
  001cf	8b ca		 mov	 ecx, edx
  001d1	c1 e9 02	 shr	 ecx, 2
  001d4	f3 a5		 rep movsd
  001d6	8b ca		 mov	 ecx, edx
  001d8	83 e1 03	 and	 ecx, 3
  001db	f3 a4		 rep movsb

; 293  : 	strcat(szPid, "-");

  001dd	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL27@generateRa:
  001e0	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  001e3	47		 inc	 edi
  001e4	84 c0		 test	 al, al
  001e6	75 f8		 jne	 SHORT $LL27@generateRa
  001e8	66 a1 00 00 00
	00		 mov	 ax, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@

; 294  : 
; 295  : 	strcat(szPid, itoc(numberBuffer, HostOS[serverType].Build, 0));

  001ee	8d 4c 24 24	 lea	 ecx, DWORD PTR _numberBuffer$[esp+48]
  001f2	66 89 07	 mov	 WORD PTR [edi], ax
  001f5	0f b7 14 ad 02
	00 00 00	 movzx	 edx, WORD PTR _HostOS[ebp*4+2]
  001fd	6a 00		 push	 0
  001ff	e8 00 00 00 00	 call	 _itoc
  00204	8b d0		 mov	 edx, eax
  00206	59		 pop	 ecx
  00207	8b f2		 mov	 esi, edx
$LL28@generateRa:
  00209	8a 02		 mov	 al, BYTE PTR [edx]
  0020b	42		 inc	 edx
  0020c	84 c0		 test	 al, al
  0020e	75 f9		 jne	 SHORT $LL28@generateRa
  00210	2b d6		 sub	 edx, esi
  00212	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL29@generateRa:
  00215	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00218	47		 inc	 edi
  00219	84 c0		 test	 al, al
  0021b	75 f8		 jne	 SHORT $LL29@generateRa
  0021d	8b ca		 mov	 ecx, edx
  0021f	c1 e9 02	 shr	 ecx, 2
  00222	f3 a5		 rep movsd
  00224	8b ca		 mov	 ecx, edx
  00226	83 e1 03	 and	 ecx, 3
  00229	f3 a4		 rep movsb

; 296  : 	strcat(szPid, ".0000-");

  0022b	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL30@generateRa:
  0022e	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  00231	47		 inc	 edi
  00232	84 c0		 test	 al, al
  00234	75 f8		 jne	 SHORT $LL30@generateRa
  00236	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_06KMCAJKLF@?40000?9?$AA@

; 297  : 
; 298  : #	define minTime ((time_t)1470175200) /* Release Date Win 2016 */
; 299  : 
; 300  : 	time_t maxTime;
; 301  : 	time(&maxTime);

  0023b	8d 44 24 10	 lea	 eax, DWORD PTR _maxTime$[esp+48]
  0023f	50		 push	 eax
  00240	a5		 movsd
  00241	66 a5		 movsw
  00243	a4		 movsb
  00244	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64

; 302  : 
; 303  : #	ifndef BUILD_TIME
; 304  : #	define BUILD_TIME 1481079869
; 305  : #   endif
; 306  : 
; 307  : 	if (maxTime < (time_t)BUILD_TIME) // Just in case the system time is < 10/17/2013 1:00 pm

  0024a	33 ff		 xor	 edi, edi
  0024c	59		 pop	 ecx
  0024d	39 7c 24 14	 cmp	 DWORD PTR _maxTime$[esp+52], edi
  00251	7f 15		 jg	 SHORT $LN1@generateRa
  00253	b8 3d 7c 47 58	 mov	 eax, 1481079869		; 58477c3dH
  00258	7c 06		 jl	 SHORT $LN31@generateRa
  0025a	39 44 24 10	 cmp	 DWORD PTR _maxTime$[esp+48], eax
  0025e	73 08		 jae	 SHORT $LN1@generateRa
$LN31@generateRa:

; 308  : 		maxTime = (time_t)BUILD_TIME;

  00260	89 44 24 10	 mov	 DWORD PTR _maxTime$[esp+48], eax
  00264	89 7c 24 14	 mov	 DWORD PTR _maxTime$[esp+52], edi
$LN1@generateRa:

; 309  : 
; 310  : 	time_t kmsTime = (rand32() % (maxTime - minTime)) + minTime;

  00268	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__rand
  0026e	ff d5		 call	 ebp
  00270	8b f0		 mov	 esi, eax
  00272	c1 e6 0f	 shl	 esi, 15			; 0000000fH
  00275	ff d5		 call	 ebp
  00277	0b f0		 or	 esi, eax
  00279	c1 e6 02	 shl	 esi, 2
  0027c	ff d5		 call	 ebp
  0027e	8b 54 24 10	 mov	 edx, DWORD PTR _maxTime$[esp+48]
  00282	83 e0 03	 and	 eax, 3
  00285	8b 4c 24 14	 mov	 ecx, DWORD PTR _maxTime$[esp+52]
  00289	0b c6		 or	 eax, esi
  0028b	be e0 17 a1 57	 mov	 esi, 1470175200		; 57a117e0H
  00290	2b d6		 sub	 edx, esi
  00292	1b cf		 sbb	 ecx, edi
  00294	51		 push	 ecx
  00295	52		 push	 edx
  00296	57		 push	 edi
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 __allrem
  0029d	03 c6		 add	 eax, esi
  0029f	89 44 24 18	 mov	 DWORD PTR _kmsTime$[esp+48], eax

; 311  : 	struct tm *pidTime = gmtime(&kmsTime);

  002a3	8d 44 24 18	 lea	 eax, DWORD PTR _kmsTime$[esp+48]
  002a7	13 d7		 adc	 edx, edi
  002a9	50		 push	 eax
  002aa	89 54 24 20	 mov	 DWORD PTR _kmsTime$[esp+56], edx
  002ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___gmtime64
  002b4	8b e8		 mov	 ebp, eax

; 312  : 
; 313  : 	strcat(szPid, itoc(numberBuffer, pidTime->tm_yday, 3));

  002b6	8d 4c 24 28	 lea	 ecx, DWORD PTR _numberBuffer$[esp+52]
  002ba	6a 03		 push	 3
  002bc	8b 55 1c	 mov	 edx, DWORD PTR [ebp+28]
  002bf	e8 00 00 00 00	 call	 _itoc
  002c4	59		 pop	 ecx
  002c5	8b d0		 mov	 edx, eax
  002c7	59		 pop	 ecx
  002c8	8b f2		 mov	 esi, edx
$LL32@generateRa:
  002ca	8a 02		 mov	 al, BYTE PTR [edx]
  002cc	42		 inc	 edx
  002cd	84 c0		 test	 al, al
  002cf	75 f9		 jne	 SHORT $LL32@generateRa
  002d1	2b d6		 sub	 edx, esi
  002d3	8d 7b ff	 lea	 edi, DWORD PTR [ebx-1]
$LL33@generateRa:
  002d6	8a 47 01	 mov	 al, BYTE PTR [edi+1]
  002d9	47		 inc	 edi
  002da	84 c0		 test	 al, al
  002dc	75 f8		 jne	 SHORT $LL33@generateRa
  002de	8b ca		 mov	 ecx, edx
  002e0	c1 e9 02	 shr	 ecx, 2
  002e3	f3 a5		 rep movsd
  002e5	8b ca		 mov	 ecx, edx
  002e7	83 e1 03	 and	 ecx, 3
  002ea	f3 a4		 rep movsb

; 314  : 	strcat(szPid, itoc(numberBuffer, pidTime->tm_year + 1900, 4));

  002ec	8b 55 14	 mov	 edx, DWORD PTR [ebp+20]
  002ef	8d 4c 24 24	 lea	 ecx, DWORD PTR _numberBuffer$[esp+48]
  002f3	6a 04		 push	 4
  002f5	81 c2 6c 07 00
	00		 add	 edx, 1900		; 0000076cH
  002fb	e8 00 00 00 00	 call	 _itoc
  00300	8b d0		 mov	 edx, eax
  00302	59		 pop	 ecx
  00303	8b f2		 mov	 esi, edx
$LL34@generateRa:
  00305	8a 02		 mov	 al, BYTE PTR [edx]
  00307	42		 inc	 edx
  00308	84 c0		 test	 al, al
  0030a	75 f9		 jne	 SHORT $LL34@generateRa
  0030c	2b d6		 sub	 edx, esi
  0030e	4b		 dec	 ebx
$LL35@generateRa:
  0030f	8a 43 01	 mov	 al, BYTE PTR [ebx+1]
  00312	43		 inc	 ebx
  00313	84 c0		 test	 al, al
  00315	75 f8		 jne	 SHORT $LL35@generateRa
  00317	8b ca		 mov	 ecx, edx
  00319	8b fb		 mov	 edi, ebx
  0031b	c1 e9 02	 shr	 ecx, 2
  0031e	f3 a5		 rep movsd
  00320	8b ca		 mov	 ecx, edx
  00322	83 e1 03	 and	 ecx, 3
  00325	f3 a4		 rep movsb

; 315  : }

  00327	5f		 pop	 edi
  00328	5e		 pop	 esi
  00329	5d		 pop	 ebp
  0032a	5b		 pop	 ebx
  0032b	83 c4 20	 add	 esp, 32			; 00000020H
  0032e	c3		 ret	 0
_generateRandomPid ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _randomPidInit
_TEXT	SEGMENT
_Epid$1 = -68						; size = 64
_randomPidInit PROC					; COMDAT

; 323  : {

  00000	83 ec 44	 sub	 esp, 68			; 00000044H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 324  : 	uint32_t i;
; 325  : 
; 326  : 	int serverType = getRandomServerType();

  00007	e8 00 00 00 00	 call	 _getRandomServerType

; 327  : 	int16_t lang = Lcid ? Lcid : LcidList[rand() % vlmcsd_countof(LcidList)];

  0000c	66 8b 0d 00 00
	00 00		 mov	 cx, WORD PTR _Lcid
  00013	8b e8		 mov	 ebp, eax
  00015	66 85 c9	 test	 cx, cx
  00018	74 05		 je	 SHORT $LN7@randomPidI
  0001a	0f b7 d9	 movzx	 ebx, cx
  0001d	eb 17		 jmp	 SHORT $LN8@randomPidI
$LN7@randomPidI:
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__rand
  00025	33 d2		 xor	 edx, edx
  00027	b9 9e 00 00 00	 mov	 ecx, 158		; 0000009eH
  0002c	f7 f1		 div	 ecx
  0002e	0f b7 1c 55 00
	00 00 00	 movzx	 ebx, WORD PTR _LcidList[edx*2]
$LN8@randomPidI:

; 328  : 
; 329  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KmsData
  0003c	33 ff		 xor	 edi, edi
  0003e	80 79 08 00	 cmp	 BYTE PTR [ecx+8], 0
  00042	76 50		 jbe	 SHORT $LN18@randomPidI
  00044	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KmsResponseParameters
  0004a	33 f6		 xor	 esi, esi
$LL4@randomPidI:

; 330  : 	{
; 331  : 		if (KmsResponseParameters[i].Epid) continue;

  0004c	83 3c 16 00	 cmp	 DWORD PTR [esi+edx], 0
  00050	75 36		 jne	 SHORT $LN3@randomPidI

; 332  : 
; 333  : 		char Epid[PID_BUFFER_SIZE];
; 334  : 
; 335  : 		generateRandomPid(i, Epid, serverType, lang);

  00052	53		 push	 ebx
  00053	55		 push	 ebp
  00054	8d 54 24 18	 lea	 edx, DWORD PTR _Epid$1[esp+92]
  00058	8b cf		 mov	 ecx, edi
  0005a	e8 00 00 00 00	 call	 _generateRandomPid

; 336  : 		KmsResponseParameters[i].Epid = (const char*)vlmcsd_strdup(Epid);

  0005f	8d 44 24 18	 lea	 eax, DWORD PTR _Epid$1[esp+92]
  00063	50		 push	 eax
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  0006a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006d	85 c0		 test	 eax, eax
  0006f	74 2b		 je	 SHORT $LN20@randomPidI
  00071	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KmsResponseParameters

; 337  : 
; 338  : #ifndef NO_LOG
; 339  : 		KmsResponseParameters[i].EpidSource = "randomized at program start";

  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KmsData
  0007d	89 04 16	 mov	 DWORD PTR [esi+edx], eax
  00080	c7 44 16 08 00
	00 00 00	 mov	 DWORD PTR [esi+edx+8], OFFSET ??_C@_0BM@KDKADHPB@randomized?5at?5program?5start?$AA@
$LN3@randomPidI:

; 328  : 
; 329  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  00088	0f b6 41 08	 movzx	 eax, BYTE PTR [ecx+8]
  0008c	47		 inc	 edi
  0008d	83 c6 0c	 add	 esi, 12			; 0000000cH
  00090	3b f8		 cmp	 edi, eax
  00092	72 b8		 jb	 SHORT $LL4@randomPidI
$LN18@randomPidI:

; 340  : #endif // NO_LOG
; 341  : 	}
; 342  : }

  00094	5f		 pop	 edi
  00095	5e		 pop	 esi
  00096	5d		 pop	 ebp
  00097	5b		 pop	 ebx
  00098	83 c4 44	 add	 esp, 68			; 00000044H
  0009b	c3		 ret	 0
$LN20@randomPidI:

; 336  : 		KmsResponseParameters[i].Epid = (const char*)vlmcsd_strdup(Epid);

  0009c	e8 00 00 00 00	 call	 _OutOfMemory
$LN21@randomPidI:
$LN19@randomPidI:
  000a1	cc		 int	 3
_randomPidInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _getProductIndexFromAllLists
_TEXT	SEGMENT
_getProductIndexFromAllLists PROC			; COMDAT
; _guid$ = ecx
; _productName$ = edx

; 350  : 	return getProductIndex(guid, KmsData->AppItemList, KmsData->AppItemCount + KmsData->KmsItemCount + KmsData->SkuItemCount, productName, NULL);

  00000	6a 00		 push	 0
  00002	52		 push	 edx
  00003	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _KmsData
  00009	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0000c	03 42 10	 add	 eax, DWORD PTR [edx+16]
  0000f	03 42 0c	 add	 eax, DWORD PTR [edx+12]
  00012	8b 52 18	 mov	 edx, DWORD PTR [edx+24]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _getProductIndex
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 351  : }

  0001e	c3		 ret	 0
_getProductIndexFromAllLists ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _logRequest
_TEXT	SEGMENT
_clientname$ = -72					; size = 64
_productName$ = -4					; size = 4
_logRequest PROC					; COMDAT
; _baseRequest$ = ecx

; 357  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH

; 358  : #ifndef NO_VERBOSE_LOG
; 359  : 	if (logverbose)

  00006	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _logverbose, 0
  0000d	53		 push	 ebx
  0000e	56		 push	 esi
  0000f	57		 push	 edi
  00010	8b f1		 mov	 esi, ecx
  00012	74 14		 je	 SHORT $LN5@logRequest

; 360  : 	{
; 361  : 		logger("<<< Incoming KMS request\n");

  00014	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6?$AA@
  00019	e8 00 00 00 00	 call	 _logger
  0001e	59		 pop	 ecx

; 362  : 		logRequestVerbose(baseRequest, &logger);

  0001f	8b ce		 mov	 ecx, esi
  00021	e8 00 00 00 00	 call	 _logRequestVerbose

; 363  : 		return;

  00026	eb 7f		 jmp	 SHORT $LN6@logRequest
$LN5@logRequest:

; 364  : 	}
; 365  : #endif // NO_VERBOSE_LOG
; 366  : 
; 367  : 	char *productName;
; 368  : 	char clientname[64];
; 369  : 
; 370  : 	int32_t index = getProductIndexFromAllLists(&baseRequest->ActID, &productName);

  00028	8d 55 fc	 lea	 edx, DWORD PTR _productName$[ebp]
  0002b	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  0002e	e8 00 00 00 00	 call	 _getProductIndexFromAllLists

; 371  : 	if (index < 0) index = getProductIndexFromAllLists(&baseRequest->KMSID, &productName);

  00033	85 c0		 test	 eax, eax
  00035	79 1e		 jns	 SHORT $LN8@logRequest
  00037	8d 4e 30	 lea	 ecx, DWORD PTR [esi+48]
  0003a	8d 55 fc	 lea	 edx, DWORD PTR _productName$[ebp]
  0003d	e8 00 00 00 00	 call	 _getProductIndexFromAllLists

; 372  : 	if (index < 0) index = getProductIndexFromAllLists(&baseRequest->AppID, &productName);

  00042	85 c0		 test	 eax, eax
  00044	79 0f		 jns	 SHORT $LN8@logRequest
  00046	8d 4e 10	 lea	 ecx, DWORD PTR [esi+16]
  00049	8d 55 fc	 lea	 edx, DWORD PTR _productName$[ebp]
  0004c	e8 00 00 00 00	 call	 _getProductIndexFromAllLists

; 373  : 
; 374  : 	if (index < 0 || !strcasecmp(productName, "Unknown"))

  00051	85 c0		 test	 eax, eax
  00053	78 15		 js	 SHORT $LN1@logRequest
$LN8@logRequest:
  00055	8b 7d fc	 mov	 edi, DWORD PTR _productName$[ebp]
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_07NBCGADJA@Unknown?$AA@
  0005d	57		 push	 edi
  0005e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___stricmp
  00064	59		 pop	 ecx
  00065	59		 pop	 ecx
  00066	85 c0		 test	 eax, eax
  00068	75 14		 jne	 SHORT $LN2@logRequest
$LN1@logRequest:

; 375  : 	{
; 376  : 		productName = (char*)alloca(GUID_STRING_LENGTH + 1);

  0006a	6a 28		 push	 40			; 00000028H
  0006c	58		 pop	 eax
  0006d	e8 00 00 00 00	 call	 __alloca_probe
  00072	8b fc		 mov	 edi, esp

; 377  : 		uuid2StringLE(&baseRequest->ActID, productName);

  00074	8d 4e 20	 lea	 ecx, DWORD PTR [esi+32]
  00077	8b d7		 mov	 edx, edi
  00079	e8 00 00 00 00	 call	 _uuid2StringLE
$LN2@logRequest:

; 378  : 	}
; 379  : 
; 380  : 	ucs2_to_utf8(baseRequest->WorkstationName, clientname, 64, 64);

  0007e	6a 40		 push	 64			; 00000040H
  00080	51		 push	 ecx
  00081	8d 4e 6c	 lea	 ecx, DWORD PTR [esi+108]
  00084	8d 55 b8	 lea	 edx, DWORD PTR _clientname$[ebp]
  00087	e8 00 00 00 00	 call	 _ucs2_to_utf8

; 381  : 	logger("KMS v%i.%i request from %s for %s\n", LE16(baseRequest->MajorVer), LE16(baseRequest->MinorVer), clientname, productName);

  0008c	57		 push	 edi
  0008d	8d 45 b8	 lea	 eax, DWORD PTR _clientname$[ebp]
  00090	50		 push	 eax
  00091	0f b7 06	 movzx	 eax, WORD PTR [esi]
  00094	50		 push	 eax
  00095	0f b7 46 02	 movzx	 eax, WORD PTR [esi+2]
  00099	50		 push	 eax
  0009a	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5?$CF@
  0009f	e8 00 00 00 00	 call	 _logger
  000a4	83 c4 1c	 add	 esp, 28			; 0000001cH
$LN6@logRequest:

; 382  : }

  000a7	8d 65 a8	 lea	 esp, DWORD PTR [ebp-88]
  000aa	5f		 pop	 edi
  000ab	5e		 pop	 esi
  000ac	5b		 pop	 ebx
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
_logRequest ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _getEpidFromString
_TEXT	SEGMENT
_getEpidFromString PROC					; COMDAT
; _Response$ = ecx
; _pid$ = edx

; 391  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 392  : 	size_t length = utf8_to_ucs2(Response->KmsPID, pid, PID_BUFFER_SIZE, PID_BUFFER_SIZE * 3);

  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00008	e8 00 00 00 00	 call	 _utf8_to_ucs2
  0000d	59		 pop	 ecx
  0000e	59		 pop	 ecx

; 393  : 	Response->PIDSize = LE32(((unsigned int)length + 1) << 1);

  0000f	8d 04 45 02 00
	00 00		 lea	 eax, DWORD PTR [eax*2+2]
  00016	89 46 04	 mov	 DWORD PTR [esi+4], eax
  00019	5e		 pop	 esi

; 394  : }

  0001a	c3		 ret	 0
_getEpidFromString ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _getEpid
_TEXT	SEGMENT
_baseResponse$1$ = -68					; size = 4
_szPid$1 = -64						; size = 64
_index$ = 8						; size = 4
_HwId$ = 12						; size = 4
_defaultEPid$ = 16					; size = 4
_getEpid PROC						; COMDAT
; _baseResponse$ = ecx
; _EpidSource$ = edx

; 401  : {

  00000	83 ec 44	 sub	 esp, 68			; 00000044H
  00003	53		 push	 ebx

; 402  : 	#if !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 403  : 	const char* pid;
; 404  : 	if (KmsResponseParameters[index].Epid == NULL)

  00004	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _KmsResponseParameters
  0000a	55		 push	 ebp
  0000b	56		 push	 esi
  0000c	89 4c 24 0c	 mov	 DWORD PTR _baseResponse$1$[esp+80], ecx
  00010	8b ea		 mov	 ebp, edx
  00012	8b 4c 24 54	 mov	 ecx, DWORD PTR _index$[esp+76]
  00016	57		 push	 edi
  00017	6b f9 0c	 imul	 edi, ecx, 12
  0001a	8b 14 1f	 mov	 edx, DWORD PTR [edi+ebx]
  0001d	85 d2		 test	 edx, edx
  0001f	75 46		 jne	 SHORT $LN5@getEpid

; 405  : 	{
; 406  : 		#ifndef NO_RANDOM_EPID
; 407  : 		if (RandomizationLevel == 2)

  00021	80 3d 00 00 00
	00 02		 cmp	 BYTE PTR _RandomizationLevel, 2
  00028	75 30		 jne	 SHORT $LN4@getEpid

; 408  : 		{
; 409  : 			char szPid[PID_BUFFER_SIZE];
; 410  : 			generateRandomPid(index, szPid, -1, Lcid ? Lcid : -1);

  0002a	66 a1 00 00 00
	00		 mov	 ax, WORD PTR _Lcid
  00030	83 ce ff	 or	 esi, -1
  00033	0f b7 d0	 movzx	 edx, ax
  00036	66 85 c0	 test	 ax, ax
  00039	0f 45 f2	 cmovne	 esi, edx
  0003c	8d 54 24 14	 lea	 edx, DWORD PTR _szPid$1[esp+84]
  00040	0f b7 c6	 movzx	 eax, si
  00043	50		 push	 eax
  00044	6a ff		 push	 -1
  00046	e8 00 00 00 00	 call	 _generateRandomPid
  0004b	59		 pop	 ecx
  0004c	59		 pop	 ecx

; 411  : 			pid = szPid;

  0004d	8d 54 24 14	 lea	 edx, DWORD PTR _szPid$1[esp+84]

; 412  : 
; 413  : 			#ifndef NO_LOG
; 414  : 			*EpidSource = "randomized on every request";

  00051	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], OFFSET ??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request?$AA@

; 415  : 			#endif // NO_LOG
; 416  : 		}
; 417  : 		else

  00058	eb 2e		 jmp	 SHORT $LN2@getEpid
$LN4@getEpid:

; 418  : 		#endif // NO_RANDOM_EPID
; 419  : 		{
; 420  : 			pid = defaultEPid;

  0005a	8b 54 24 60	 mov	 edx, DWORD PTR _defaultEPid$[esp+80]

; 421  : 			#ifndef NO_LOG
; 422  : 			*EpidSource = "vlmcsd default";

  0005e	c7 45 00 00 00
	00 00		 mov	 DWORD PTR [ebp], OFFSET ??_C@_0P@CACDFLGA@vlmcsd?5default?$AA@

; 423  : 			#endif // NO_LOG
; 424  : 		}
; 425  : 	}
; 426  : 	else

  00065	eb 21		 jmp	 SHORT $LN2@getEpid
$LN5@getEpid:

; 427  : 	{
; 428  : 		pid = KmsResponseParameters[index].Epid;
; 429  : 
; 430  : 		if (HwId && KmsResponseParameters[index].HwId != NULL)

  00067	8b 74 24 5c	 mov	 esi, DWORD PTR _HwId$[esp+80]
  0006b	85 f6		 test	 esi, esi
  0006d	74 12		 je	 SHORT $LN1@getEpid
  0006f	8b 4c 1f 04	 mov	 ecx, DWORD PTR [edi+ebx+4]
  00073	85 c9		 test	 ecx, ecx
  00075	74 0a		 je	 SHORT $LN1@getEpid

; 431  : 			memcpy(HwId, KmsResponseParameters[index].HwId, sizeof(((RESPONSE_V6 *)0)->HwId));

  00077	8b 01		 mov	 eax, DWORD PTR [ecx]
  00079	89 06		 mov	 DWORD PTR [esi], eax
  0007b	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0007e	89 46 04	 mov	 DWORD PTR [esi+4], eax
$LN1@getEpid:

; 432  : 
; 433  : 		#ifndef NO_LOG
; 434  : 		*EpidSource = KmsResponseParameters[index].EpidSource;

  00081	8b 44 1f 08	 mov	 eax, DWORD PTR [edi+ebx+8]
  00085	89 45 00	 mov	 DWORD PTR [ebp], eax
$LN2@getEpid:

; 435  : 		#endif // NO_LOG
; 436  : 	}
; 437  : 
; 438  : 	getEpidFromString(baseResponse, pid);

  00088	8b 74 24 10	 mov	 esi, DWORD PTR _baseResponse$1$[esp+84]
  0008c	51		 push	 ecx
  0008d	51		 push	 ecx
  0008e	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  00091	e8 00 00 00 00	 call	 _utf8_to_ucs2
  00096	59		 pop	 ecx
  00097	59		 pop	 ecx
  00098	5f		 pop	 edi
  00099	8d 04 45 02 00
	00 00		 lea	 eax, DWORD PTR [eax*2+2]
  000a0	89 46 04	 mov	 DWORD PTR [esi+4], eax
  000a3	5e		 pop	 esi
  000a4	5d		 pop	 ebp
  000a5	5b		 pop	 ebx

; 439  : 
; 440  : 	#else // defined(NO_RANDOM_EPID) && defined(NO_CL_PIDS) && !defined(NO_INI_FILE)
; 441  : 
; 442  : 	getEpidFromString(baseResponse, defaultEPid);
; 443  : 
; 444  : #	ifndef NO_LOG
; 445  : 	*EpidSource = "vlmcsd default";
; 446  : #	endif // NO_LOG
; 447  : 
; 448  : 	#endif // defined(NO_RANDOM_EPID) && defined(NO_CL_PIDS) && !defined(NO_INI_FILE)
; 449  : }

  000a6	83 c4 44	 add	 esp, 68			; 00000044H
  000a9	c3		 ret	 0
_getEpid ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _logResponse
_TEXT	SEGMENT
_utf8pid$ = -196					; size = 192
_EpidSource$ = 8					; size = 4
_logResponse PROC					; COMDAT
; _baseResponse$ = ecx
; _hwId$ = edx

; 486  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b f1		 mov	 esi, ecx
  0000d	8b fa		 mov	 edi, edx

; 487  : 	char utf8pid[PID_BUFFER_SIZE * 3];
; 488  : 	ucs2_to_utf8(baseResponse->KmsPID, utf8pid, PID_BUFFER_SIZE, PID_BUFFER_SIZE * 3);

  0000f	68 c0 00 00 00	 push	 192			; 000000c0H
  00014	51		 push	 ecx
  00015	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR _utf8pid$[ebp]
  0001b	8d 4e 08	 lea	 ecx, DWORD PTR [esi+8]
  0001e	e8 00 00 00 00	 call	 _ucs2_to_utf8

; 489  : 
; 490  : #ifndef NO_VERBOSE_LOG
; 491  : 	if (!logverbose)

  00023	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _logverbose, 0
  0002a	59		 pop	 ecx
  0002b	59		 pop	 ecx
  0002c	75 19		 jne	 SHORT $LN2@logRespons

; 492  : 	{
; 493  : #endif // NO_VERBOSE_LOG
; 494  : 		logger("Sending ePID (%s): %s\n", EpidSource, utf8pid);

  0002e	8d 85 3c ff ff
	ff		 lea	 eax, DWORD PTR _utf8pid$[ebp]
  00034	50		 push	 eax
  00035	ff 75 08	 push	 DWORD PTR _EpidSource$[ebp]
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6?$AA@
  0003d	e8 00 00 00 00	 call	 _logger
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 495  : #ifndef NO_VERBOSE_LOG
; 496  : 	}
; 497  : 	else

  00045	eb 1e		 jmp	 SHORT $LN1@logRespons
$LN2@logRespons:

; 498  : 	{
; 499  : 		logger(">>> Sending response, ePID source = %s\n", EpidSource);

  00047	ff 75 08	 push	 DWORD PTR _EpidSource$[ebp]
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sourc@
  0004f	e8 00 00 00 00	 call	 _logger
  00054	59		 pop	 ecx

; 500  : 		logResponseVerbose(utf8pid, hwId, baseResponse, &logger);

  00055	56		 push	 esi
  00056	8b d7		 mov	 edx, edi
  00058	8d 8d 3c ff ff
	ff		 lea	 ecx, DWORD PTR _utf8pid$[ebp]
  0005e	e8 00 00 00 00	 call	 _logResponseVerbose
  00063	59		 pop	 ecx
  00064	59		 pop	 ecx
$LN1@logRespons:

; 501  : 	}
; 502  : #endif // NO_VERBOSE_LOG
; 503  : 
; 504  : }

  00065	5f		 pop	 edi
  00066	5e		 pop	 esi
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
_logResponse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _CreateResponseBaseCallback@16
_TEXT	SEGMENT
_appIndex$1$ = -212					; size = 4
tv322 = -212						; size = 4
tv306 = -212						; size = 4
tv565 = -208						; size = 8
_ePidIndex$1$ = -208					; size = 4
_requestTime$1$ = -208					; size = 4
_EpidSource$ = -208					; size = 4
tv440 = -200						; size = 4
_ePid$ = -196						; size = 4
_utf8pid$1 = -192					; size = 192
_baseRequest$ = 8					; size = 4
_baseResponse$ = 12					; size = 4
_hwId$ = 16						; size = 4
_ipstr_unused$ = 20					; size = 4
_CreateResponseBaseCallback@16 PROC			; COMDAT

; 518  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  0000c	53		 push	 ebx
  0000d	56		 push	 esi
  0000e	57		 push	 edi

; 519  : 	const char* EpidSource;
; 520  : #ifndef NO_LOG
; 521  : 	logRequest(baseRequest);

  0000f	8b 7d 08	 mov	 edi, DWORD PTR _baseRequest$[ebp]
  00012	8b cf		 mov	 ecx, edi
  00014	e8 00 00 00 00	 call	 _logRequest

; 522  : #ifdef _PEDANTIC
; 523  : 	CheckRequest(baseRequest);
; 524  : #endif // _PEDANTIC
; 525  : #endif // NO_LOG
; 526  : 
; 527  : 	char* ePid;
; 528  : 	DWORD minClients = LE32(baseRequest->N_Policy);

  00019	8b 47 50	 mov	 eax, DWORD PTR [edi+80]

; 529  : 	DWORD required_clients = minClients < 1 ? 1 : minClients << 1;

  0001c	33 c9		 xor	 ecx, ecx

; 530  : 
; 531  : 	int32_t index = getProductIndex(&baseRequest->KMSID, KmsData->KmsItemList, KmsData->KmsItemCount, NULL, &ePid);

  0001e	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _KmsData
  00024	41		 inc	 ecx
  00025	3b c1		 cmp	 eax, ecx
  00027	8d 1c 00	 lea	 ebx, DWORD PTR [eax+eax]
  0002a	8b 56 20	 mov	 edx, DWORD PTR [esi+32]
  0002d	8d 44 24 1c	 lea	 eax, DWORD PTR _ePid$[esp+224]
  00031	50		 push	 eax
  00032	6a 00		 push	 0
  00034	ff 76 10	 push	 DWORD PTR [esi+16]
  00037	0f 42 d9	 cmovb	 ebx, ecx
  0003a	8d 4f 30	 lea	 ecx, DWORD PTR [edi+48]
  0003d	e8 00 00 00 00	 call	 _getProductIndex
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
  00045	8b f8		 mov	 edi, eax

; 532  : 
; 533  : #	ifndef NO_STRICT_MODES
; 534  : 
; 535  : 	if (required_clients > 2000)

  00047	81 fb d0 07 00
	00		 cmp	 ebx, 2000		; 000007d0H
  0004d	76 15		 jbe	 SHORT $LN23@CreateResp

; 536  : 	{
; 537  : #		ifndef NO_LOG
; 538  : 		logger("Rejecting request with more than 1000 minimum clients (0x8007000D)\n");

  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5than@
  00054	e8 00 00 00 00	 call	 _logger
  00059	59		 pop	 ecx

; 539  : #		endif
; 540  : 
; 541  : 		return 0x8007000D;

  0005a	b8 0d 00 07 80	 mov	 eax, -2147024883	; 8007000dH
  0005f	e9 80 03 00 00	 jmp	 $LN24@CreateResp
$LN23@CreateResp:

; 542  : 	}
; 543  : 
; 544  : 	if (CheckClientTime)

  00064	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _CheckClientTime, 0
  0006b	74 6a		 je	 SHORT $LN21@CreateResp

; 545  : 	{
; 546  : 		time_t requestTime = (time_t)fileTimeToUnixTime(&baseRequest->ClientTime);

  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _baseRequest$[ebp]
  00070	6a 00		 push	 0
  00072	68 80 96 98 00	 push	 10000000		; 00989680H
  00077	ff 71 58	 push	 DWORD PTR [ecx+88]
  0007a	ff 71 54	 push	 DWORD PTR [ecx+84]
  0007d	e8 00 00 00 00	 call	 __aulldiv
  00082	2d 00 91 10 b6	 sub	 eax, -1240428288	; b6109100H
  00087	8b f2		 mov	 esi, edx

; 547  : 
; 548  : 		if (llabs(requestTime - time(NULL)) > 60 * 60 * 4)

  00089	6a 00		 push	 0
  0008b	89 44 24 14	 mov	 DWORD PTR _requestTime$1$[esp+228], eax
  0008f	83 de 02	 sbb	 esi, 2
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___time64
  00098	59		 pop	 ecx
  00099	8b 4c 24 10	 mov	 ecx, DWORD PTR _requestTime$1$[esp+224]
  0009d	2b c8		 sub	 ecx, eax
  0009f	1b f2		 sbb	 esi, edx
  000a1	8b c6		 mov	 eax, esi
  000a3	99		 cdq
  000a4	33 c2		 xor	 eax, edx
  000a6	33 ca		 xor	 ecx, edx
  000a8	2b ca		 sub	 ecx, edx
  000aa	1b c2		 sbb	 eax, edx
  000ac	89 44 24 14	 mov	 DWORD PTR tv565[esp+228], eax
  000b0	78 1f		 js	 SHORT $LN61@CreateResp
  000b2	7f 08		 jg	 SHORT $LN50@CreateResp
  000b4	81 f9 40 38 00
	00		 cmp	 ecx, 14400		; 00003840H
  000ba	76 15		 jbe	 SHORT $LN61@CreateResp
$LN50@CreateResp:

; 549  : 		{
; 550  : #			ifndef NO_LOG
; 551  : 			logger("Client time differs more than 4 hours from system time (0xC004F06C)\n");

  000bc	68 00 00 00 00	 push	 OFFSET ??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54?5@
  000c1	e8 00 00 00 00	 call	 _logger
  000c6	59		 pop	 ecx

; 552  : #			endif // !NO_LOG
; 553  : 
; 554  : 			return 0xC004F06C;

  000c7	b8 6c f0 04 c0	 mov	 eax, -1073418132	; c004f06cH
  000cc	e9 13 03 00 00	 jmp	 $LN24@CreateResp
$LN61@CreateResp:
  000d1	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _KmsData
$LN21@CreateResp:

; 555  : 		}
; 556  : 	}
; 557  : 
; 558  : 	if (WhitelistingLevel & 2)

  000d7	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _WhitelistingLevel
  000dd	f6 c2 02	 test	 dl, 2
  000e0	74 2f		 je	 SHORT $LN19@CreateResp

; 559  : 	{
; 560  : 		if (index >= 0 && (KmsData->KmsItemList[index].IsPreview || KmsData->KmsItemList[index].IsRetail))

  000e2	85 ff		 test	 edi, edi
  000e4	78 2b		 js	 SHORT $LN19@CreateResp
  000e6	8b 4e 20	 mov	 ecx, DWORD PTR [esi+32]
  000e9	8b c7		 mov	 eax, edi
  000eb	c1 e0 05	 shl	 eax, 5
  000ee	80 7c 01 1d 00	 cmp	 BYTE PTR [ecx+eax+29], 0
  000f3	75 07		 jne	 SHORT $LN18@CreateResp
  000f5	80 7c 01 1c 00	 cmp	 BYTE PTR [ecx+eax+28], 0
  000fa	74 15		 je	 SHORT $LN19@CreateResp
$LN18@CreateResp:

; 561  : 		{
; 562  : #			ifndef NO_LOG
; 563  : 			logger("Refusing retail or beta product (0xC004F042)\n");

  000fc	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product?5@
$LN68@CreateResp:
  00101	e8 00 00 00 00	 call	 _logger
  00106	59		 pop	 ecx

; 564  : #			endif // !NO_LOG
; 565  : 
; 566  : 			return 0xC004F042;

  00107	b8 42 f0 04 c0	 mov	 eax, -1073418174	; c004f042H
  0010c	e9 d3 02 00 00	 jmp	 $LN24@CreateResp
$LN19@CreateResp:

; 567  : 		}
; 568  : 	}
; 569  : 
; 570  : 	if ((WhitelistingLevel & 1) && index < 0)

  00111	83 e2 01	 and	 edx, 1
  00114	74 0b		 je	 SHORT $LN17@CreateResp
  00116	85 ff		 test	 edi, edi
  00118	79 12		 jns	 SHORT $LN26@CreateResp

; 571  : 	{
; 572  : #		ifndef NO_LOG
; 573  : 		logger("Refusing unknown product (0xC004F042)\n");

  0011a	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC004@

; 574  : #		endif // !NO_LOG
; 575  : 
; 576  : 		return 0xC004F042;

  0011f	eb e0		 jmp	 SHORT $LN68@CreateResp
$LN17@CreateResp:

; 577  : 	}
; 578  : 
; 579  : #	ifndef NO_CLIENT_LIST
; 580  : 	int32_t appIndex = index < 0 ? 0 : KmsData->KmsItemList[index].AppIndex;

  00121	85 ff		 test	 edi, edi
  00123	79 07		 jns	 SHORT $LN26@CreateResp
  00125	83 64 24 0c 00	 and	 DWORD PTR _appIndex$1$[esp+224], 0
  0012a	eb 11		 jmp	 SHORT $LN27@CreateResp
$LN26@CreateResp:
  0012c	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0012f	8b cf		 mov	 ecx, edi
  00131	c1 e1 05	 shl	 ecx, 5
  00134	0f b6 44 08 18	 movzx	 eax, BYTE PTR [eax+ecx+24]
  00139	89 44 24 0c	 mov	 DWORD PTR _appIndex$1$[esp+224], eax
$LN27@CreateResp:

; 581  : #	endif // NO_CLIENT_LIST
; 582  : 
; 583  : #	endif // !NO_STRICT_MODES
; 584  : 
; 585  : 	int32_t ePidIndex = index < 0 ? 0 : KmsData->KmsItemList[index].EPidIndex;

  0013d	85 ff		 test	 edi, edi
  0013f	79 07		 jns	 SHORT $LN28@CreateResp
  00141	83 64 24 10 00	 and	 DWORD PTR _ePidIndex$1$[esp+224], 0
  00146	eb 11		 jmp	 SHORT $LN29@CreateResp
$LN28@CreateResp:
  00148	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  0014b	8b cf		 mov	 ecx, edi
  0014d	c1 e1 05	 shl	 ecx, 5
  00150	0f b6 44 08 1e	 movzx	 eax, BYTE PTR [eax+ecx+30]
  00155	89 44 24 10	 mov	 DWORD PTR _ePidIndex$1$[esp+224], eax
$LN29@CreateResp:

; 586  : 
; 587  : #	if !defined(NO_STRICT_MODES)
; 588  : 
; 589  : 	if ((WhitelistingLevel & 1) && index >= 0 && !IsEqualGUID(&KmsData->AppItemList[KmsData->KmsItemList[index].AppIndex].Guid, &baseRequest->AppID))

  00159	85 d2		 test	 edx, edx
  0015b	74 35		 je	 SHORT $LN64@CreateResp
  0015d	85 ff		 test	 edi, edi
  0015f	78 31		 js	 SHORT $LN64@CreateResp
  00161	8b 46 20	 mov	 eax, DWORD PTR [esi+32]
  00164	c1 e7 05	 shl	 edi, 5
  00167	0f b6 54 38 18	 movzx	 edx, BYTE PTR [eax+edi+24]
  0016c	8b 7d 08	 mov	 edi, DWORD PTR _baseRequest$[ebp]
  0016f	c1 e2 05	 shl	 edx, 5
  00172	03 56 18	 add	 edx, DWORD PTR [esi+24]
  00175	33 c9		 xor	 ecx, ecx
$LL51@CreateResp:
  00177	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]
  0017a	3b 44 8f 10	 cmp	 eax, DWORD PTR [edi+ecx*4+16]
  0017e	75 08		 jne	 SHORT $LN52@CreateResp
  00180	41		 inc	 ecx
  00181	83 f9 04	 cmp	 ecx, 4
  00184	75 f1		 jne	 SHORT $LL51@CreateResp
  00186	eb 0d		 jmp	 SHORT $LN16@CreateResp
$LN52@CreateResp:

; 590  : 	{
; 591  : #		ifndef NO_LOG
; 592  : 		logger("Refusing product with incorrect Application ID (0xC004F042)\n");

  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect?5@

; 593  : #		endif // NO_LOG
; 594  : 		return 0xC004F042;

  0018d	e9 6f ff ff ff	 jmp	 $LN68@CreateResp
$LN64@CreateResp:
  00192	8b 7d 08	 mov	 edi, DWORD PTR _baseRequest$[ebp]
$LN16@CreateResp:

; 595  : 	}
; 596  : 
; 597  : #	ifndef NO_CLIENT_LIST
; 598  : 	if (MaintainClients)

  00195	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _MaintainClients, 0
  0019c	0f 84 7f 01 00
	00		 je	 $LN15@CreateResp

; 599  : 	{
; 600  : 		lock_client_lists();

  001a2	ff 35 00 00 00
	00		 push	 DWORD PTR _mutex
  001a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__EnterCriticalSection@4

; 601  : 
; 602  : 		int_fast16_t i;
; 603  : 		int_fast8_t isKnownClient = FALSE;
; 604  : 
; 605  : 		if (required_clients > (DWORD)ClientLists[appIndex].MaxCount) ClientLists[appIndex].MaxCount = required_clients;

  001ae	69 44 24 0c fc
	29 00 00	 imul	 eax, DWORD PTR _appIndex$1$[esp+224], 10748
  001b6	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _ClientLists
  001bc	03 d0		 add	 edx, eax
  001be	89 44 24 18	 mov	 DWORD PTR tv440[esp+224], eax
  001c2	3b 9a f4 29 00
	00		 cmp	 ebx, DWORD PTR [edx+10740]
  001c8	76 06		 jbe	 SHORT $LN14@CreateResp
  001ca	89 9a f4 29 00
	00		 mov	 DWORD PTR [edx+10740], ebx
$LN14@CreateResp:

; 606  : 
; 607  : 		for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  001d0	8b 9a f4 29 00
	00		 mov	 ebx, DWORD PTR [edx+10740]
  001d6	33 f6		 xor	 esi, esi
  001d8	85 db		 test	 ebx, ebx
  001da	7e 2d		 jle	 SHORT $LN58@CreateResp
  001dc	8b c2		 mov	 eax, edx
  001de	89 54 24 0c	 mov	 DWORD PTR tv306[esp+224], edx
$LL13@CreateResp:

; 608  : 		{
; 609  : 			if (IsEqualGUID(&ClientLists[appIndex].Guid[i], &baseRequest->CMID))

  001e2	33 c9		 xor	 ecx, ecx
$LL53@CreateResp:
  001e4	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  001e7	3b 44 8f 40	 cmp	 eax, DWORD PTR [edi+ecx*4+64]
  001eb	75 0c		 jne	 SHORT $LN54@CreateResp
  001ed	41		 inc	 ecx
  001ee	83 f9 04	 cmp	 ecx, 4
  001f1	74 71		 je	 SHORT $LN57@CreateResp
  001f3	8b 44 24 0c	 mov	 eax, DWORD PTR tv306[esp+224]
  001f7	eb eb		 jmp	 SHORT $LL53@CreateResp
$LN54@CreateResp:

; 606  : 
; 607  : 		for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  001f9	8b 44 24 0c	 mov	 eax, DWORD PTR tv306[esp+224]
  001fd	46		 inc	 esi
  001fe	83 c0 10	 add	 eax, 16			; 00000010H
  00201	89 44 24 0c	 mov	 DWORD PTR tv306[esp+224], eax
  00205	3b f3		 cmp	 esi, ebx
  00207	7c d9		 jl	 SHORT $LL13@CreateResp
$LN58@CreateResp:

; 621  : 		{
; 622  : 			for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  00209	33 c9		 xor	 ecx, ecx
  0020b	85 db		 test	 ebx, ebx
  0020d	8b 5d 0c	 mov	 ebx, DWORD PTR _baseResponse$[ebp]
  00210	7e 71		 jle	 SHORT $LN66@CreateResp
  00212	89 54 24 0c	 mov	 DWORD PTR tv322[esp+224], edx
$LL7@CreateResp:

; 623  : 			{
; 624  : 				if (IsEqualGUID(ZeroGuid, &ClientLists[appIndex].Guid[i]))

  00216	33 f6		 xor	 esi, esi
$LN67@CreateResp:
  00218	8b 7c 24 0c	 mov	 edi, DWORD PTR tv322[esp+224]
  0021c	b8 00 00 00 00	 mov	 eax, OFFSET _ZeroGuid
  00221	8b 04 b0	 mov	 eax, DWORD PTR [eax+esi*4]
  00224	3b 04 b7	 cmp	 eax, DWORD PTR [edi+esi*4]
  00227	8b 7d 08	 mov	 edi, DWORD PTR _baseRequest$[ebp]
  0022a	75 49		 jne	 SHORT $LN56@CreateResp
  0022c	46		 inc	 esi
  0022d	83 fe 04	 cmp	 esi, 4
  00230	75 e6		 jne	 SHORT $LN67@CreateResp

; 625  : 				{
; 626  : 					if (ClientLists[appIndex].CurrentCount >= MAX_CLIENTS)

  00232	8b 82 f0 29 00
	00		 mov	 eax, DWORD PTR [edx+10736]
  00238	3d 9f 02 00 00	 cmp	 eax, 671		; 0000029fH
  0023d	0f 8c b4 00 00
	00		 jl	 $LN3@CreateResp

; 627  : 					{
; 628  : #						ifndef NO_LOG
; 629  : 						logger("Rejecting more than 671 clients (0xC004D104)\n");

  00243	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients?5@
  00248	e8 00 00 00 00	 call	 _logger
  0024d	59		 pop	 ecx

; 630  : #						endif // !NO_LOG
; 631  : 
; 632  : 						unlock_client_lists();

  0024e	ff 35 00 00 00
	00		 push	 DWORD PTR _mutex
  00254	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 633  : 						return 0xC004D104;

  0025a	b8 04 d1 04 c0	 mov	 eax, -1073426172	; c004d104H
  0025f	e9 80 01 00 00	 jmp	 $LN24@CreateResp
$LN57@CreateResp:

; 610  : 			{
; 611  : 				isKnownClient = TRUE;
; 612  : 				break;
; 613  : 			}
; 614  : 		}
; 615  : 
; 616  : 		if (isKnownClient)
; 617  : 		{
; 618  : 			baseResponse->Count = LE32(ClientLists[appIndex].CurrentCount);

  00264	8b 5d 0c	 mov	 ebx, DWORD PTR _baseResponse$[ebp]
  00267	8b 82 f0 29 00
	00		 mov	 eax, DWORD PTR [edx+10736]
  0026d	89 83 a0 00 00
	00		 mov	 DWORD PTR [ebx+160], eax

; 619  : 		}
; 620  : 		else

  00273	eb 70		 jmp	 SHORT $LN2@CreateResp
$LN56@CreateResp:

; 621  : 		{
; 622  : 			for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  00275	83 44 24 0c 10	 add	 DWORD PTR tv322[esp+224], 16 ; 00000010H
  0027a	41		 inc	 ecx
  0027b	3b 8a f4 29 00
	00		 cmp	 ecx, DWORD PTR [edx+10740]
  00281	7c 93		 jl	 SHORT $LL7@CreateResp
$LN66@CreateResp:
  00283	8b 44 24 18	 mov	 eax, DWORD PTR tv440[esp+224]
$LN60@CreateResp:

; 638  : 					break;
; 639  : 				}
; 640  : 			}
; 641  : 
; 642  : 			if (i >= ClientLists[appIndex].MaxCount)

  00287	3b 8a f4 29 00
	00		 cmp	 ecx, DWORD PTR [edx+10740]
  0028d	7c 53		 jl	 SHORT $LN62@CreateResp

; 643  : 			{
; 644  : 				memcpy(&ClientLists[appIndex].Guid[ClientLists[appIndex].CurrentPosition], &baseRequest->CMID, sizeof(GUID));

  0028f	8b ba f8 29 00
	00		 mov	 edi, DWORD PTR [edx+10744]
  00295	8b 75 08	 mov	 esi, DWORD PTR _baseRequest$[ebp]
  00298	c1 e7 04	 shl	 edi, 4
  0029b	03 f8		 add	 edi, eax

; 645  : 				ClientLists[appIndex].CurrentPosition = (ClientLists[appIndex].CurrentPosition + 1) % (ClientLists[appIndex].MaxCount > MAX_CLIENTS ? MAX_CLIENTS : ClientLists[appIndex].MaxCount);

  0029d	b8 9f 02 00 00	 mov	 eax, 671		; 0000029fH
  002a2	03 3d 00 00 00
	00		 add	 edi, DWORD PTR _ClientLists
  002a8	8d 76 40	 lea	 esi, DWORD PTR [esi+64]
  002ab	a5		 movsd
  002ac	a5		 movsd
  002ad	a5		 movsd
  002ae	a5		 movsd
  002af	8b 8a f4 29 00
	00		 mov	 ecx, DWORD PTR [edx+10740]
  002b5	3b c8		 cmp	 ecx, eax
  002b7	0f 4f c8	 cmovg	 ecx, eax
  002ba	8b 82 f8 29 00
	00		 mov	 eax, DWORD PTR [edx+10744]
  002c0	40		 inc	 eax
  002c1	99		 cdq
  002c2	f7 f9		 idiv	 ecx
  002c4	8b 44 24 18	 mov	 eax, DWORD PTR tv440[esp+224]
  002c8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _ClientLists
  002ce	89 94 08 f8 29
	00 00		 mov	 DWORD PTR [eax+ecx+10744], edx

; 646  : 				baseResponse->Count = LE32(ClientLists[appIndex].CurrentCount);

  002d5	8b 84 08 f0 29
	00 00		 mov	 eax, DWORD PTR [eax+ecx+10736]
  002dc	89 83 a0 00 00
	00		 mov	 DWORD PTR [ebx+160], eax
$LN62@CreateResp:
  002e2	8b 7d 08	 mov	 edi, DWORD PTR _baseRequest$[ebp]
$LN2@CreateResp:

; 647  : 			}
; 648  : 		}
; 649  : 
; 650  : 		unlock_client_lists();

  002e5	ff 35 00 00 00
	00		 push	 DWORD PTR _mutex
  002eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__LeaveCriticalSection@4

; 651  : 	}
; 652  : 	else

  002f1	8b 4c 24 10	 mov	 ecx, DWORD PTR _ePidIndex$1$[esp+224]
  002f5	eb 46		 jmp	 SHORT $LN1@CreateResp
$LN3@CreateResp:

; 634  : 					}
; 635  : 
; 636  : 					baseResponse->Count = LE32(++ClientLists[appIndex].CurrentCount);
; 637  : 					memcpy(&ClientLists[appIndex].Guid[i], &baseRequest->CMID, sizeof(GUID));

  002f7	8d 77 40	 lea	 esi, DWORD PTR [edi+64]
  002fa	40		 inc	 eax
  002fb	89 82 f0 29 00
	00		 mov	 DWORD PTR [edx+10736], eax
  00301	8b f9		 mov	 edi, ecx
  00303	c1 e7 04	 shl	 edi, 4
  00306	89 83 a0 00 00
	00		 mov	 DWORD PTR [ebx+160], eax
  0030c	8b 44 24 18	 mov	 eax, DWORD PTR tv440[esp+224]
  00310	03 f8		 add	 edi, eax
  00312	03 3d 00 00 00
	00		 add	 edi, DWORD PTR _ClientLists
  00318	a5		 movsd
  00319	a5		 movsd
  0031a	a5		 movsd
  0031b	a5		 movsd
  0031c	e9 66 ff ff ff	 jmp	 $LN60@CreateResp
$LN15@CreateResp:

; 653  : #	endif // !NO_CLIENT_LIST
; 654  : #	endif // !defined(NO_STRICT_MODES)
; 655  : 	{
; 656  : 		uint8_t minimum_answer_clients = (uint8_t)KmsData->CsvlkData[ePidIndex].MinActiveClients;

  00321	8b 4c 24 10	 mov	 ecx, DWORD PTR _ePidIndex$1$[esp+224]
  00325	6b c1 18	 imul	 eax, ecx, 24
  00328	8a 44 30 44	 mov	 al, BYTE PTR [eax+esi+68]

; 657  : 		baseResponse->Count = LE32(required_clients > minimum_answer_clients ? required_clients : minimum_answer_clients);

  0032c	0f b6 c0	 movzx	 eax, al
  0032f	3b d8		 cmp	 ebx, eax
  00331	0f 47 c3	 cmova	 eax, ebx
  00334	8b 5d 0c	 mov	 ebx, DWORD PTR _baseResponse$[ebp]
  00337	89 83 a0 00 00
	00		 mov	 DWORD PTR [ebx+160], eax
$LN1@CreateResp:

; 658  : 		//if (LE32(baseRequest->N_Policy) > LE32(baseResponse->Count)) baseResponse->Count = LE32(LE32(baseRequest->N_Policy) << 1);
; 659  : 	}
; 660  : 
; 661  : 	getEpid(baseResponse, &EpidSource, ePidIndex, hwId, ePid);

  0033d	ff 74 24 1c	 push	 DWORD PTR _ePid$[esp+224]
  00341	8d 54 24 14	 lea	 edx, DWORD PTR _EpidSource$[esp+228]
  00345	ff 75 10	 push	 DWORD PTR _hwId$[ebp]
  00348	51		 push	 ecx
  00349	8b cb		 mov	 ecx, ebx
  0034b	e8 00 00 00 00	 call	 _getEpid

; 662  : 
; 663  : 	baseResponse->Version = baseRequest->Version;

  00350	8b 07		 mov	 eax, DWORD PTR [edi]

; 664  : 
; 665  : 	memcpy(&baseResponse->CMID, &baseRequest->CMID, sizeof(GUID));

  00352	8d 77 40	 lea	 esi, DWORD PTR [edi+64]

; 666  : 	memcpy(&baseResponse->ClientTime, &baseRequest->ClientTime, sizeof(FILETIME));

  00355	8b 4d 08	 mov	 ecx, DWORD PTR _baseRequest$[ebp]
  00358	8d bb 88 00 00
	00		 lea	 edi, DWORD PTR [ebx+136]
  0035e	89 03		 mov	 DWORD PTR [ebx], eax

; 667  : 
; 668  : 	baseResponse->VLActivationInterval = LE32(VLActivationInterval);
; 669  : 	baseResponse->VLRenewalInterval = LE32(VLRenewalInterval);
; 670  : 
; 671  : #ifndef NO_LOG
; 672  : 	logResponse(baseResponse, hwId, EpidSource);

  00360	8d 54 24 2c	 lea	 edx, DWORD PTR _utf8pid$1[esp+236]
  00364	a5		 movsd
  00365	83 c4 0c	 add	 esp, 12			; 0000000cH
  00368	a5		 movsd
  00369	68 c0 00 00 00	 push	 192			; 000000c0H
  0036e	51		 push	 ecx
  0036f	a5		 movsd
  00370	a5		 movsd
  00371	8b 41 54	 mov	 eax, DWORD PTR [ecx+84]
  00374	89 83 98 00 00
	00		 mov	 DWORD PTR [ebx+152], eax
  0037a	8b 41 58	 mov	 eax, DWORD PTR [ecx+88]
  0037d	8d 4b 08	 lea	 ecx, DWORD PTR [ebx+8]
  00380	89 83 9c 00 00
	00		 mov	 DWORD PTR [ebx+156], eax
  00386	a1 00 00 00 00	 mov	 eax, DWORD PTR _VLActivationInterval
  0038b	89 83 a4 00 00
	00		 mov	 DWORD PTR [ebx+164], eax
  00391	a1 00 00 00 00	 mov	 eax, DWORD PTR _VLRenewalInterval
  00396	89 83 a8 00 00
	00		 mov	 DWORD PTR [ebx+168], eax
  0039c	e8 00 00 00 00	 call	 _ucs2_to_utf8
  003a1	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _logverbose, 0
  003a8	59		 pop	 ecx
  003a9	59		 pop	 ecx
  003aa	75 18		 jne	 SHORT $LN37@CreateResp
  003ac	8d 44 24 20	 lea	 eax, DWORD PTR _utf8pid$1[esp+224]
  003b0	50		 push	 eax
  003b1	ff 74 24 14	 push	 DWORD PTR _EpidSource$[esp+228]
  003b5	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6?$AA@
  003ba	e8 00 00 00 00	 call	 _logger
  003bf	83 c4 0c	 add	 esp, 12			; 0000000cH
  003c2	eb 1e		 jmp	 SHORT $LN36@CreateResp
$LN37@CreateResp:
  003c4	ff 74 24 10	 push	 DWORD PTR _EpidSource$[esp+224]
  003c8	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sourc@
  003cd	e8 00 00 00 00	 call	 _logger
  003d2	8b 55 10	 mov	 edx, DWORD PTR _hwId$[ebp]
  003d5	59		 pop	 ecx
  003d6	53		 push	 ebx
  003d7	8d 4c 24 28	 lea	 ecx, DWORD PTR _utf8pid$1[esp+232]
  003db	e8 00 00 00 00	 call	 _logResponseVerbose
  003e0	59		 pop	 ecx
  003e1	59		 pop	 ecx
$LN36@CreateResp:

; 673  : #endif // NO_LOG
; 674  : 
; 675  : 	return S_OK;

  003e2	33 c0		 xor	 eax, eax
$LN24@CreateResp:

; 676  : }

  003e4	5f		 pop	 edi
  003e5	5e		 pop	 esi
  003e6	5b		 pop	 ebx
  003e7	8b e5		 mov	 esp, ebp
  003e9	5d		 pop	 ebp
  003ea	c2 10 00	 ret	 16			; 00000010H
_CreateResponseBaseCallback@16 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _get16RandomBytes
_TEXT	SEGMENT
_get16RandomBytes PROC					; COMDAT
; _ptr$ = ecx

; 689  : {

  00000	53		 push	 ebx

; 690  : 	int i;
; 691  : 	for (i = 0; i < 4; i++)	((DWORD*)ptr)[i] = rand32();

  00001	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__rand
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b e9		 mov	 ebp, ecx
  0000c	33 ff		 xor	 edi, edi
$LL3@get16Rando:
  0000e	ff d3		 call	 ebx
  00010	8b f0		 mov	 esi, eax
  00012	c1 e6 0f	 shl	 esi, 15			; 0000000fH
  00015	ff d3		 call	 ebx
  00017	0b f0		 or	 esi, eax
  00019	c1 e6 02	 shl	 esi, 2
  0001c	ff d3		 call	 ebx
  0001e	83 e0 03	 and	 eax, 3
  00021	0b c6		 or	 eax, esi
  00023	89 44 bd 00	 mov	 DWORD PTR [ebp+edi*4], eax
  00027	47		 inc	 edi
  00028	83 ff 04	 cmp	 edi, 4
  0002b	7c e1		 jl	 SHORT $LL3@get16Rando

; 692  : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5d		 pop	 ebp
  00030	5b		 pop	 ebx
  00031	c3		 ret	 0
_get16RandomBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _CreateResponseV4
_TEXT	SEGMENT
_request_v4$ = 8					; size = 4
_responseBuffer$ = 12					; size = 4
_ipstr$ = 16						; size = 4
_CreateResponseV4 PROC					; COMDAT

; 698  : {

  00000	57		 push	 edi

; 699  : 	RESPONSE_V4* Response = (RESPONSE_V4*)responseBuffer;
; 700  : 
; 701  : 	HRESULT hResult;
; 702  : 	if (FAILED(hResult = CreateResponseBase(&request_v4->RequestBase, &Response->ResponseBase, NULL, ipstr))) return hResult;

  00001	ff 74 24 10	 push	 DWORD PTR _ipstr$[esp]
  00005	8b 7c 24 10	 mov	 edi, DWORD PTR _responseBuffer$[esp+4]
  00009	6a 00		 push	 0
  0000b	57		 push	 edi
  0000c	ff 74 24 14	 push	 DWORD PTR _request_v4$[esp+12]
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR _CreateResponseBase
  00016	85 c0		 test	 eax, eax
  00018	78 30		 js	 SHORT $LN2@CreateResp

; 703  : 
; 704  : 	DWORD pidSize = LE32(Response->ResponseBase.PIDSize);

  0001a	56		 push	 esi
  0001b	8b 77 04	 mov	 esi, DWORD PTR [edi+4]

; 705  : 	BYTE* postEpidPtr = responseBuffer + V4_PRE_EPID_SIZE + pidSize;
; 706  : 	memmove(postEpidPtr, &Response->ResponseBase.CMID, V4_POST_EPID_SIZE);

  0001e	8d 87 88 00 00
	00		 lea	 eax, DWORD PTR [edi+136]
  00024	6a 24		 push	 36			; 00000024H
  00026	50		 push	 eax
  00027	8d 47 08	 lea	 eax, DWORD PTR [edi+8]
  0002a	03 c6		 add	 eax, esi
  0002c	50		 push	 eax
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 707  : 
; 708  : 	size_t encryptSize = V4_PRE_EPID_SIZE + V4_POST_EPID_SIZE + pidSize;

  00033	83 c6 2c	 add	 esi, 44			; 0000002cH

; 709  : 	AesCmacV4(responseBuffer, encryptSize, responseBuffer + encryptSize);

  00036	8b cf		 mov	 ecx, edi
  00038	8b d6		 mov	 edx, esi
  0003a	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 _AesCmacV4
  00043	83 c4 10	 add	 esp, 16			; 00000010H

; 710  : 
; 711  : 	return encryptSize + sizeof(Response->MAC);

  00046	8d 46 10	 lea	 eax, DWORD PTR [esi+16]
  00049	5e		 pop	 esi
$LN2@CreateResp:
  0004a	5f		 pop	 edi

; 712  : }

  0004b	c3		 ret	 0
_CreateResponseV4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _CreateV6Hmac
_TEXT	SEGMENT
_hash$ = -40						; size = 32
_timeSlot$ = -8						; size = 8
_tolerance$dead$ = 8					; size = 1
_CreateV6Hmac PROC					; COMDAT
; _encrypt_start$ = ecx
; _encryptSize$ = edx

; 729  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	53		 push	 ebx
  00007	57		 push	 edi
  00008	8b fa		 mov	 edi, edx
  0000a	8b d9		 mov	 ebx, ecx

; 730  : 	BYTE hash[32];
; 731  : 	const uint8_t halfHashSize = sizeof(hash) >> 1;
; 732  : 	BYTE *responseEnd = encrypt_start + encryptSize;
; 733  : 
; 734  : 	// This is the time from the response
; 735  : 	FILETIME* ft = (FILETIME*)(responseEnd - V6_POST_EPID_SIZE + sizeof(((RESPONSE*)0)->CMID));
; 736  : 
; 737  : 	// Generate a time slot that changes every 4.11 hours.
; 738  : 	// Request and repsonse time must match +/- 1 slot.
; 739  : 	// When generating a response tolerance must be 0.
; 740  : 	// If verifying the hash, try tolerance -1, 0 and +1. One of them must match.
; 741  : 
; 742  : 	uint64_t timeSlot = LE64((GET_UA64LE(ft) / TIME_C1 * TIME_C2 + TIME_C3) + (tolerance * TIME_C1));

  0000c	6a 22		 push	 34			; 00000022H
  0000e	68 bd 89 68 81	 push	 -2123855427		; 816889bdH
  00013	ff 74 3b 98	 push	 DWORD PTR [ebx+edi-104]
  00017	ff 74 3b 94	 push	 DWORD PTR [ebx+edi-108]
  0001b	e8 00 00 00 00	 call	 __aulldiv
  00020	6a 20		 push	 32			; 00000020H
  00022	68 ed b5 ba 8c	 push	 -1933920787		; 8cbab5edH
  00027	52		 push	 edx
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 __allmul
  0002e	05 7a 47 28 c6	 add	 eax, -970438790		; c628477aH

; 743  : 
; 744  : 	// The time slot is hashed with SHA256 so it is not so obvious that it is time
; 745  : 	Sha256((BYTE*)&timeSlot, sizeof(timeSlot), hash);

  00033	8d 4d f8	 lea	 ecx, DWORD PTR _timeSlot$[ebp]
  00036	89 45 f8	 mov	 DWORD PTR _timeSlot$[ebp], eax
  00039	8d 45 d8	 lea	 eax, DWORD PTR _hash$[ebp]
  0003c	50		 push	 eax
  0003d	81 d2 5a cd 56
	31		 adc	 edx, 827772250		; 3156cd5aH
  00043	89 55 fc	 mov	 DWORD PTR _timeSlot$[ebp+4], edx
  00046	6a 08		 push	 8
  00048	5a		 pop	 edx
  00049	e8 00 00 00 00	 call	 _Sha256

; 746  : 
; 747  : 	// The last 16 bytes of the hashed time slot are the actual HMAC key
; 748  : 	if (!Sha256Hmac
; 749  : 	(
; 750  : 		hash + halfHashSize,									// Use last 16 bytes of SHA256 as HMAC key
; 751  : 		encrypt_start,											// hash only the encrypted part of the v6 response
; 752  : 		(DWORD)(encryptSize - sizeof(((RESPONSE_V6*)0)->HMAC)),	// encryptSize minus the HMAC itself
; 753  : 		hash													// use same buffer for resulting hash where the key came from
; 754  : 	))

  0004e	8d 45 d8	 lea	 eax, DWORD PTR _hash$[ebp]
  00051	8b d3		 mov	 edx, ebx
  00053	50		 push	 eax
  00054	8d 47 f0	 lea	 eax, DWORD PTR [edi-16]
  00057	50		 push	 eax
  00058	8d 4d e8	 lea	 ecx, DWORD PTR _hash$[ebp+16]
  0005b	e8 00 00 00 00	 call	 _Sha256Hmac
  00060	83 c4 0c	 add	 esp, 12			; 0000000cH
  00063	84 c0		 test	 al, al
  00065	74 10		 je	 SHORT $LN2@CreateV6Hm
$LN1@CreateV6Hm:

; 755  : 	{
; 756  : 		return FALSE;
; 757  : 	}
; 758  : 
; 759  : 	memcpy(responseEnd - sizeof(((RESPONSE_V6*)0)->HMAC), hash + halfHashSize, halfHashSize);

  00067	83 c7 f0	 add	 edi, -16		; fffffff0H

; 760  : 	return TRUE;

  0006a	b0 01		 mov	 al, 1
  0006c	56		 push	 esi
  0006d	03 fb		 add	 edi, ebx
  0006f	8d 75 e8	 lea	 esi, DWORD PTR _hash$[ebp+16]
  00072	a5		 movsd
  00073	a5		 movsd
  00074	a5		 movsd
  00075	a5		 movsd
  00076	5e		 pop	 esi
$LN2@CreateV6Hm:
  00077	5f		 pop	 edi
  00078	5b		 pop	 ebx

; 761  : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_CreateV6Hmac ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\kms.c
;	COMDAT _CreateResponseV6
_TEXT	SEGMENT
_v6$ = -204						; size = 1
_encryptSize$ = -200					; size = 4
_aesCtx$ = -196						; size = 196
_request_v6$ = 8					; size = 4
_responseBuffer$ = 12					; size = 4
_ipstr$ = 16						; size = 4
_CreateResponseV6 PROC					; COMDAT

; 768  : {

  00000	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00006	53		 push	 ebx

; 769  : 	// The response will be created in a fixed sized struct to
; 770  : 	// avoid unaligned access macros and packed structs on RISC systems
; 771  : 	// which largely increase code size.
; 772  : 	//
; 773  : 	// The fixed sized struct with 64 WCHARs for the ePID will be converted
; 774  : 	// to a variable sized struct later and requires unaligned access macros.
; 775  : 
; 776  : 	RESPONSE_V6* Response = (RESPONSE_V6*)responseBuffer;
; 777  : 	RESPONSE* baseResponse = &Response->ResponseBase;

  00007	8b 9c 24 d8 00
	00 00		 mov	 ebx, DWORD PTR _responseBuffer$[esp+204]

; 778  : 
; 779  : #ifdef _DEBUG
; 780  : 	// ReSharper disable once CppEntityNeverUsed
; 781  : 	RESPONSE_V6_DEBUG* xxx_unused = (RESPONSE_V6_DEBUG*)responseBuffer;
; 782  : #endif
; 783  : 
; 784  : 	static const BYTE DefaultHwid[8] = { HWID };
; 785  : 	int_fast8_t v6 = LE16(request_v6->MajorVer) > 5;
; 786  : 	AesCtx aesCtx;
; 787  : 
; 788  : 	AesInitKey(&aesCtx, v6 ? AesKeyV6 : AesKeyV5, v6, AES_KEY_BYTES);

  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET _AesKeyV5
  00013	55		 push	 ebp
  00014	8b ac 24 d8 00
	00 00		 mov	 ebp, DWORD PTR _request_v6$[esp+208]
  0001b	ba 00 00 00 00	 mov	 edx, OFFSET _AesKeyV6
  00020	56		 push	 esi
  00021	57		 push	 edi
  00022	6a 05		 push	 5
  00024	58		 pop	 eax
  00025	66 39 45 02	 cmp	 WORD PTR [ebp+2], ax
  00029	6a 10		 push	 16			; 00000010H
  0002b	0f 97 c0	 seta	 al
  0002e	84 c0		 test	 al, al
  00030	88 44 24 14	 mov	 BYTE PTR _v6$[esp+224], al
  00034	ff 74 24 14	 push	 DWORD PTR _v6$[esp+224]
  00038	0f 44 d1	 cmove	 edx, ecx
  0003b	8d 4c 24 20	 lea	 ecx, DWORD PTR _aesCtx$[esp+228]
  0003f	e8 00 00 00 00	 call	 _AesInitKey

; 789  : 	AesDecryptCbc(&aesCtx, NULL, request_v6->IV, V6_DECRYPT_SIZE);

  00044	83 c4 04	 add	 esp, 4
  00047	8d 75 04	 lea	 esi, DWORD PTR [ebp+4]
  0004a	8d 4c 24 1c	 lea	 ecx, DWORD PTR _aesCtx$[esp+224]
  0004e	56		 push	 esi
  0004f	e8 00 00 00 00	 call	 _AesDecryptCbc

; 790  : 
; 791  : 	// get random salt and SHA256 it
; 792  : 	get16RandomBytes(Response->RandomXoredIVs);

  00054	8d bb c0 00 00
	00		 lea	 edi, DWORD PTR [ebx+192]
  0005a	8b cf		 mov	 ecx, edi
  0005c	e8 00 00 00 00	 call	 _get16RandomBytes

; 793  : 	Sha256(Response->RandomXoredIVs, sizeof(Response->RandomXoredIVs), Response->Hash);

  00061	8d 83 d0 00 00
	00		 lea	 eax, DWORD PTR [ebx+208]
  00067	8b cf		 mov	 ecx, edi
  00069	50		 push	 eax
  0006a	6a 10		 push	 16			; 00000010H
  0006c	5a		 pop	 edx
  0006d	e8 00 00 00 00	 call	 _Sha256
  00072	83 c4 0c	 add	 esp, 12			; 0000000cH

; 794  : 
; 795  : 	if (v6) // V6 specific stuff

  00075	80 7c 24 10 00	 cmp	 BYTE PTR _v6$[esp+220], 0
  0007a	74 2f		 je	 SHORT $LN4@CreateResp

; 796  : 	{
; 797  : 		// In v6 a random IV is generated
; 798  : 		Response->Version = request_v6->Version;

  0007c	8b 45 00	 mov	 eax, DWORD PTR [ebp]

; 799  : 		get16RandomBytes(Response->IV);

  0007f	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00082	89 03		 mov	 DWORD PTR [ebx], eax
  00084	e8 00 00 00 00	 call	 _get16RandomBytes

; 800  : 
; 801  : 		// pre-fill with default HwId (not required for v5)
; 802  : 		memcpy(Response->HwId, DefaultHwid, sizeof(Response->HwId));

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?DefaultHwid@?1??CreateResponseV6@@9@9

; 803  : 
; 804  : 		// Just copy decrypted request IV (using Null IV) here. Note this is identical
; 805  : 		// to XORing non-decrypted request and reponse IVs
; 806  : 		memcpy(Response->XoredIVs, request_v6->IV, sizeof(Response->XoredIVs));

  0008e	8d bb f8 00 00
	00		 lea	 edi, DWORD PTR [ebx+248]
  00094	89 83 f0 00 00
	00		 mov	 DWORD PTR [ebx+240], eax
  0009a	a1 04 00 00 00	 mov	 eax, DWORD PTR ?DefaultHwid@?1??CreateResponseV6@@9@9+4
  0009f	a5		 movsd
  000a0	89 83 f4 00 00
	00		 mov	 DWORD PTR [ebx+244], eax
  000a6	a5		 movsd
  000a7	a5		 movsd
  000a8	a5		 movsd

; 807  : 	}
; 808  : 	else // V5 specific stuff

  000a9	eb 09		 jmp	 SHORT $LN3@CreateResp
$LN4@CreateResp:

; 809  : 	{
; 810  : 		// In v5 IVs of request and response must be identical (MS client checks this)
; 811  : 		// The following memcpy copies Version and IVs at once
; 812  : 		memcpy(Response, request_v6, V6_UNENCRYPTED_SIZE);

  000ab	6a 05		 push	 5
  000ad	59		 pop	 ecx
  000ae	8b f5		 mov	 esi, ebp
  000b0	8b fb		 mov	 edi, ebx
  000b2	f3 a5		 rep movsd
$LN3@CreateResp:

; 813  : 	}
; 814  : 
; 815  : 	// Xor Random bytes with decrypted request IV
; 816  : 	XorBlock(request_v6->IV, Response->RandomXoredIVs);

  000b4	8d 93 c0 00 00
	00		 lea	 edx, DWORD PTR [ebx+192]
  000ba	8d 4d 04	 lea	 ecx, DWORD PTR [ebp+4]
  000bd	e8 00 00 00 00	 call	 _XorBlock

; 817  : 
; 818  : 	// Get the base response
; 819  : 	HRESULT hResult;
; 820  : 	if (FAILED(hResult = CreateResponseBase(&request_v6->RequestBase, baseResponse, Response->HwId, ipstr))) return hResult;

  000c2	ff b4 24 e8 00
	00 00		 push	 DWORD PTR _ipstr$[esp+216]
  000c9	8d 83 f0 00 00
	00		 lea	 eax, DWORD PTR [ebx+240]
  000cf	50		 push	 eax
  000d0	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
  000d3	50		 push	 eax
  000d4	8d 45 14	 lea	 eax, DWORD PTR [ebp+20]
  000d7	50		 push	 eax
  000d8	ff 15 00 00 00
	00		 call	 DWORD PTR _CreateResponseBase
  000de	85 c0		 test	 eax, eax
  000e0	78 67		 js	 SHORT $LN5@CreateResp

; 821  : 
; 822  : 	// Convert the fixed sized struct into variable sized
; 823  : 	DWORD pidSize = LE32(baseResponse->PIDSize);
; 824  : 	BYTE* postEpidPtr = responseBuffer + V6_PRE_EPID_SIZE + pidSize;
; 825  : 	size_t post_epid_size = v6 ? V6_POST_EPID_SIZE : V5_POST_EPID_SIZE;

  000e2	80 7c 24 10 00	 cmp	 BYTE PTR _v6$[esp+220], 0
  000e7	8d 43 14	 lea	 eax, DWORD PTR [ebx+20]
  000ea	8b 78 04	 mov	 edi, DWORD PTR [eax+4]
  000ed	6a 54		 push	 84			; 00000054H
  000ef	5e		 pop	 esi
  000f0	6a 7c		 push	 124			; 0000007cH
  000f2	59		 pop	 ecx
  000f3	0f 45 f1	 cmovne	 esi, ecx

; 826  : 
; 827  : 	memmove(postEpidPtr, &baseResponse->CMID, post_epid_size);

  000f6	05 88 00 00 00	 add	 eax, 136		; 00000088H
  000fb	56		 push	 esi
  000fc	50		 push	 eax
  000fd	8d 43 1c	 lea	 eax, DWORD PTR [ebx+28]
  00100	03 c7		 add	 eax, edi
  00102	50		 push	 eax
  00103	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__memmove

; 828  : 
; 829  : 	// number of bytes to encrypt
; 830  : 	size_t encryptSize =
; 831  : 		V6_PRE_EPID_SIZE
; 832  : 		- sizeof(Response->Version)
; 833  : 		+ pidSize
; 834  : 		+ post_epid_size;

  00109	8d 57 18	 lea	 edx, DWORD PTR [edi+24]
  0010c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010f	03 d6		 add	 edx, esi

; 835  : 
; 836  : 	//AesDecryptBlock(&aesCtx, Response->IV);
; 837  : 	if (v6 && !CreateV6Hmac(Response->IV, encryptSize, 0)) return 0;

  00111	80 7c 24 10 00	 cmp	 BYTE PTR _v6$[esp+220], 0
  00116	89 54 24 14	 mov	 DWORD PTR _encryptSize$[esp+220], edx
  0011a	74 12		 je	 SHORT $LN1@CreateResp
  0011c	51		 push	 ecx
  0011d	8d 4b 04	 lea	 ecx, DWORD PTR [ebx+4]
  00120	e8 00 00 00 00	 call	 _CreateV6Hmac
  00125	59		 pop	 ecx
  00126	84 c0		 test	 al, al
  00128	75 04		 jne	 SHORT $LN1@CreateResp
  0012a	33 c0		 xor	 eax, eax
  0012c	eb 1b		 jmp	 SHORT $LN5@CreateResp
$LN1@CreateResp:

; 838  : 
; 839  : 	// Padding auto handled by encryption func
; 840  : 	AesEncryptCbc(&aesCtx, NULL, Response->IV, &encryptSize);

  0012e	8d 44 24 14	 lea	 eax, DWORD PTR _encryptSize$[esp+220]
  00132	50		 push	 eax
  00133	8d 43 04	 lea	 eax, DWORD PTR [ebx+4]
  00136	50		 push	 eax
  00137	8d 4c 24 20	 lea	 ecx, DWORD PTR _aesCtx$[esp+228]
  0013b	e8 00 00 00 00	 call	 _AesEncryptCbc

; 841  : 
; 842  : 	return encryptSize + sizeof(Response->Version);

  00140	8b 44 24 1c	 mov	 eax, DWORD PTR _encryptSize$[esp+228]
  00144	59		 pop	 ecx
  00145	59		 pop	 ecx
  00146	83 c0 04	 add	 eax, 4
$LN5@CreateResp:
  00149	5f		 pop	 edi
  0014a	5e		 pop	 esi
  0014b	5d		 pop	 ebp
  0014c	5b		 pop	 ebx

; 843  : }

  0014d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00153	c3		 ret	 0
_CreateResponseV6 ENDP
_TEXT	ENDS
END
