; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Dell\Desktop\vlmcsd\src\crypto_windows.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

EXTRN	__imp__CryptHashData@16:PROC
EXTRN	__imp__CryptDestroyHash@4:PROC
EXTRN	__imp__CryptDestroyKey@4:PROC
EXTRN	__imp__CryptCreateHash@20:PROC
EXTRN	__imp__CryptImportKey@24:PROC
EXTRN	__imp__CryptAcquireContextW@20:PROC
EXTRN	__imp__CryptGetHashParam@20:PROC
EXTRN	__imp__CryptSetHashParam@16:PROC
_hRsaAesProvider DD 01H DUP (?)
_BSS	ENDS
PUBLIC	_Sha256Hmac
PUBLIC	_Sha256
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto_windows.c
;	COMDAT _AcquireCryptContext
_TEXT	SEGMENT
_AcquireCryptContext PROC				; COMDAT

; 40   : 	if (!hRsaAesProvider)

  00000	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _hRsaAesProvider, 0
  00007	75 17		 jne	 SHORT $LN1@AcquireCry

; 41   : 	{
; 42   : 		return (int_fast8_t)CryptAcquireContextW
; 43   : 		(
; 44   : 			&hRsaAesProvider,		// Provider handle
; 45   : 			NULL,					// No key container name
; 46   : 			NULL,					// Default provider
; 47   : 			PROV_RSA_AES,			// Provides SHA and AES
; 48   : 			CRYPT_VERIFYCONTEXT		// We don't need access to persistent keys
; 49   : 		);

  00009	68 00 00 00 f0	 push	 -268435456		; f0000000H
  0000e	6a 18		 push	 24			; 00000018H
  00010	6a 00		 push	 0
  00012	6a 00		 push	 0
  00014	68 00 00 00 00	 push	 OFFSET _hRsaAesProvider
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptAcquireContextW@20

; 53   : }

  0001f	c3		 ret	 0
$LN1@AcquireCry:

; 50   : 	}
; 51   : 
; 52   : 	return TRUE;

  00020	b0 01		 mov	 al, 1

; 53   : }

  00022	c3		 ret	 0
_AcquireCryptContext ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto_windows.c
;	COMDAT _Sha256
_TEXT	SEGMENT
_HashSize$ = -8						; size = 4
_hHash$ = -4						; size = 4
_hash$ = 8						; size = 4
_Sha256	PROC						; COMDAT
; _data$ = ecx
; _DataSize$ = edx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	53		 push	 ebx
  00006	56		 push	 esi
  00007	57		 push	 edi

; 58   : 	HCRYPTHASH hHash = 0;

  00008	33 db		 xor	 ebx, ebx

; 59   : 	DWORD HashSize = 32;

  0000a	c7 45 f8 20 00
	00 00		 mov	 DWORD PTR _HashSize$[ebp], 32 ; 00000020H
  00011	8b f2		 mov	 esi, edx
  00013	89 5d fc	 mov	 DWORD PTR _hHash$[ebp], ebx
  00016	8b f9		 mov	 edi, ecx

; 60   : 
; 61   : 	int_fast8_t success =
; 62   : 		AcquireCryptContext() &&
; 63   : 
; 64   : 		CryptCreateHash
; 65   : 		(
; 66   : 			hRsaAesProvider,// Provider handle
; 67   : 			CALG_SHA_256,	// Algorithm
; 68   : 			NULLHANDLE,		// SHA256 requires no key
; 69   : 			NULLFLAGS,		// Use default flags
; 70   : 			&hHash			// Handle for hashing
; 71   : 		) &&
; 72   : 
; 73   : 		CryptHashData
; 74   : 		(
; 75   : 			hHash,			// Handle
; 76   : 			data,			// data to hash
; 77   : 			DataSize,		// size of data
; 78   : 			NULLFLAGS		// Use default flags
; 79   : 		) &&
; 80   : 
; 81   : 		CryptGetHashParam
; 82   : 		(
; 83   : 			hHash,			// Handle
; 84   : 			HP_HASHVAL,		// what you actually want to get (the resulting hash)
; 85   : 			hash,			// data to retrieve
; 86   : 			&HashSize,		// size of data
; 87   : 			NULLFLAGS		// currently reserved (as of this writing)
; 88   : 		);

  00018	e8 00 00 00 00	 call	 _AcquireCryptContext
  0001d	84 c0		 test	 al, al
  0001f	74 44		 je	 SHORT $LN4@Sha256
  00021	8d 45 fc	 lea	 eax, DWORD PTR _hHash$[ebp]
  00024	50		 push	 eax
  00025	53		 push	 ebx
  00026	53		 push	 ebx
  00027	68 0c 80 00 00	 push	 32780			; 0000800cH
  0002c	ff 35 00 00 00
	00		 push	 DWORD PTR _hRsaAesProvider
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptCreateHash@20
  00038	85 c0		 test	 eax, eax
  0003a	74 29		 je	 SHORT $LN4@Sha256
  0003c	53		 push	 ebx
  0003d	56		 push	 esi
  0003e	57		 push	 edi
  0003f	ff 75 fc	 push	 DWORD PTR _hHash$[ebp]
  00042	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptHashData@16
  00048	85 c0		 test	 eax, eax
  0004a	74 19		 je	 SHORT $LN4@Sha256
  0004c	53		 push	 ebx
  0004d	8d 45 f8	 lea	 eax, DWORD PTR _HashSize$[ebp]
  00050	50		 push	 eax
  00051	ff 75 08	 push	 DWORD PTR _hash$[ebp]
  00054	6a 02		 push	 2
  00056	ff 75 fc	 push	 DWORD PTR _hHash$[ebp]
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGetHashParam@20
  0005f	85 c0		 test	 eax, eax
  00061	74 02		 je	 SHORT $LN4@Sha256
  00063	b3 01		 mov	 bl, 1
$LN4@Sha256:

; 89   : 
; 90   : 	if (hHash) CryptDestroyHash(hHash);

  00065	83 7d fc 00	 cmp	 DWORD PTR _hHash$[ebp], 0
  00069	74 09		 je	 SHORT $LN1@Sha256
  0006b	ff 75 fc	 push	 DWORD PTR _hHash$[ebp]
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptDestroyHash@4
$LN1@Sha256:

; 91   : 
; 92   : 	return success;

  00074	5f		 pop	 edi
  00075	5e		 pop	 esi
  00076	8a c3		 mov	 al, bl
  00078	5b		 pop	 ebx

; 93   : }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_Sha256	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto_windows.c
;	COMDAT _Sha256Hmac
_TEXT	SEGMENT
_hHmacHash$ = -60					; size = 4
_hKey$ = -56						; size = 4
_dwHmacSize$ = -52					; size = 4
_HmacInfo$ = -48					; size = 20
_hmackeyblob$ = -28					; size = 28
_len$ = 8						; size = 4
_hmac$ = 12						; size = 4
_Sha256Hmac PROC					; COMDAT
; _key$ = ecx
; _data$ = edx

; 97   : {

  00000	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi

; 98   : #	ifndef USE_THREADS // In fork() mode thread-safety is not required
; 99   : 	static
; 100  : #	endif
; 101  : 	HMAC_KEYBLOB hmackeyblob = {
; 102  : 		// Type, Version, Algorithm
; 103  : 		{ PLAINTEXTKEYBLOB, CUR_BLOB_VERSION, 0, CALG_RC2 },
; 104  : 		// Key length
; 105  : 		16
; 106  : 	};

  00007	c7 44 24 30 08
	02 00 00	 mov	 DWORD PTR _hmackeyblob$[esp+76], 520 ; 00000208H
  0000f	8d 7c 24 3c	 lea	 edi, DWORD PTR _hmackeyblob$[esp+88]
  00013	c7 44 24 34 02
	66 00 00	 mov	 DWORD PTR _hmackeyblob$[esp+80], 26114 ; 00006602H
  0001b	33 c0		 xor	 eax, eax
  0001d	c7 44 24 38 10
	00 00 00	 mov	 DWORD PTR _hmackeyblob$[esp+84], 16 ; 00000010H

; 107  : 
; 108  : 	HCRYPTKEY hKey = NULLHANDLE;
; 109  : 	HCRYPTHASH hHmacHash = NULLHANDLE;
; 110  : 	HMAC_INFO HmacInfo = { 0 };
; 111  : 	DWORD dwHmacSize = 32;
; 112  : 
; 113  : 	HmacInfo.HashAlgid = CALG_SHA_256;
; 114  : 	memcpy(hmackeyblob.KeyData, key, sizeof(hmackeyblob.KeyData));

  00025	8b f1		 mov	 esi, ecx
  00027	ab		 stosd
  00028	33 db		 xor	 ebx, ebx
  0002a	8b ea		 mov	 ebp, edx
  0002c	89 5c 24 14	 mov	 DWORD PTR _hKey$[esp+76], ebx
  00030	89 5c 24 10	 mov	 DWORD PTR _hHmacHash$[esp+76], ebx
  00034	c7 44 24 18 20
	00 00 00	 mov	 DWORD PTR _dwHmacSize$[esp+76], 32 ; 00000020H
  0003c	ab		 stosd
  0003d	ab		 stosd
  0003e	ab		 stosd
  0003f	33 c0		 xor	 eax, eax
  00041	8d 7c 24 20	 lea	 edi, DWORD PTR _HmacInfo$[esp+80]
  00045	ab		 stosd
  00046	ab		 stosd
  00047	ab		 stosd
  00048	ab		 stosd
  00049	8d 7c 24 3c	 lea	 edi, DWORD PTR _hmackeyblob$[esp+88]
  0004d	c7 44 24 1c 0c
	80 00 00	 mov	 DWORD PTR _HmacInfo$[esp+76], 32780 ; 0000800cH
  00055	a5		 movsd
  00056	a5		 movsd
  00057	a5		 movsd
  00058	a5		 movsd

; 115  : 
; 116  : 	BOOL success =
; 117  : 		AcquireCryptContext() &&
; 118  : 
; 119  : 		CryptImportKey
; 120  : 		(
; 121  : 			hRsaAesProvider,        // provider handle
; 122  : 			(PBYTE)&hmackeyblob,    // the actual key MS blob format
; 123  : 			sizeof(HMAC_KEYBLOB),   // size of the entire blob
; 124  : 			NULLHANDLE,             // password/key for the key store (none required here)
; 125  : 			NULLFLAGS,              // default flags
; 126  : 			&hKey                   // key handle to retrieve (must be kept until you finish hashing)
; 127  : 		) &&
; 128  : 
; 129  : 		CryptCreateHash
; 130  : 		(
; 131  : 			hRsaAesProvider,        // provider handle
; 132  : 			CALG_HMAC,              // the actual key MS blob format
; 133  : 			hKey,                   // size of the entire blob
; 134  : 			NULLFLAGS,              // password/key for the key store (none required here)
; 135  : 			&hHmacHash              // default flags
; 136  : 		) &&                        // key handle to retrieve (must be kept until you finish hashing)
; 137  : 
; 138  : 		CryptSetHashParam
; 139  : 		(
; 140  : 			hHmacHash,              // hash handle
; 141  : 			HP_HMAC_INFO,           // parameter you want to set
; 142  : 			(PBYTE)&HmacInfo,       // the HMAC parameters (SHA256 with default ipad and opad)
; 143  : 			NULLFLAGS               // flags are reserved up to Windows 8.1
; 144  : 		) &&
; 145  : 
; 146  : 		CryptHashData
; 147  : 		(
; 148  : 			hHmacHash,              // hash handle
; 149  : 			data,                   // Pointer to data you want to hash
; 150  : 			len,                    // data length
; 151  : 			NULLFLAGS               // default flags
; 152  : 		) &&
; 153  : 
; 154  : 		CryptGetHashParam
; 155  : 		(
; 156  : 			hHmacHash,              // hash handle
; 157  : 			HP_HASHVAL,             // what you actually want to get (the resulting HMAC)
; 158  : 			hmac,                   // data to retrieve
; 159  : 			&dwHmacSize,            // size of data
; 160  : 			NULLFLAGS               // currently reserved (as of this writing)
; 161  : 		);

  00059	e8 00 00 00 00	 call	 _AcquireCryptContext
  0005e	84 c0		 test	 al, al
  00060	0f 84 82 00 00
	00		 je	 $LN5@Sha256Hmac
  00066	8d 44 24 14	 lea	 eax, DWORD PTR _hKey$[esp+76]
  0006a	50		 push	 eax
  0006b	53		 push	 ebx
  0006c	53		 push	 ebx
  0006d	6a 1c		 push	 28			; 0000001cH
  0006f	8d 44 24 40	 lea	 eax, DWORD PTR _hmackeyblob$[esp+92]
  00073	50		 push	 eax
  00074	ff 35 00 00 00
	00		 push	 DWORD PTR _hRsaAesProvider
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptImportKey@24
  00080	85 c0		 test	 eax, eax
  00082	74 64		 je	 SHORT $LN5@Sha256Hmac
  00084	8d 44 24 10	 lea	 eax, DWORD PTR _hHmacHash$[esp+76]
  00088	50		 push	 eax
  00089	53		 push	 ebx
  0008a	ff 74 24 1c	 push	 DWORD PTR _hKey$[esp+84]
  0008e	68 09 80 00 00	 push	 32777			; 00008009H
  00093	ff 35 00 00 00
	00		 push	 DWORD PTR _hRsaAesProvider
  00099	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptCreateHash@20
  0009f	85 c0		 test	 eax, eax
  000a1	74 45		 je	 SHORT $LN5@Sha256Hmac
  000a3	53		 push	 ebx
  000a4	8d 44 24 20	 lea	 eax, DWORD PTR _HmacInfo$[esp+80]
  000a8	50		 push	 eax
  000a9	6a 05		 push	 5
  000ab	ff 74 24 1c	 push	 DWORD PTR _hHmacHash$[esp+88]
  000af	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptSetHashParam@16
  000b5	85 c0		 test	 eax, eax
  000b7	74 2f		 je	 SHORT $LN5@Sha256Hmac
  000b9	53		 push	 ebx
  000ba	ff 74 24 54	 push	 DWORD PTR _len$[esp+76]
  000be	55		 push	 ebp
  000bf	ff 74 24 1c	 push	 DWORD PTR _hHmacHash$[esp+88]
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptHashData@16
  000c9	85 c0		 test	 eax, eax
  000cb	74 1b		 je	 SHORT $LN5@Sha256Hmac
  000cd	53		 push	 ebx
  000ce	8d 44 24 1c	 lea	 eax, DWORD PTR _dwHmacSize$[esp+80]
  000d2	50		 push	 eax
  000d3	ff 74 24 5c	 push	 DWORD PTR _hmac$[esp+80]
  000d7	6a 02		 push	 2
  000d9	ff 74 24 20	 push	 DWORD PTR _hHmacHash$[esp+92]
  000dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptGetHashParam@20
  000e3	85 c0		 test	 eax, eax
  000e5	74 01		 je	 SHORT $LN5@Sha256Hmac
  000e7	43		 inc	 ebx
$LN5@Sha256Hmac:

; 162  : 
; 163  : 	if (hKey) CryptDestroyKey(hKey);

  000e8	83 7c 24 14 00	 cmp	 DWORD PTR _hKey$[esp+76], 0
  000ed	74 0a		 je	 SHORT $LN2@Sha256Hmac
  000ef	ff 74 24 14	 push	 DWORD PTR _hKey$[esp+76]
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptDestroyKey@4
$LN2@Sha256Hmac:

; 164  : 	if (hHmacHash) CryptDestroyHash(hHmacHash);

  000f9	83 7c 24 10 00	 cmp	 DWORD PTR _hHmacHash$[esp+76], 0
  000fe	74 0a		 je	 SHORT $LN1@Sha256Hmac
  00100	ff 74 24 10	 push	 DWORD PTR _hHmacHash$[esp+76]
  00104	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CryptDestroyHash@4
$LN1@Sha256Hmac:

; 165  : 
; 166  : 	return (int_fast8_t)success;

  0010a	5f		 pop	 edi
  0010b	5e		 pop	 esi
  0010c	5d		 pop	 ebp
  0010d	8a c3		 mov	 al, bl
  0010f	5b		 pop	 ebx

; 167  : }

  00110	83 c4 3c	 add	 esp, 60			; 0000003cH
  00113	c3		 ret	 0
_Sha256Hmac ENDP
_TEXT	ENDS
END
