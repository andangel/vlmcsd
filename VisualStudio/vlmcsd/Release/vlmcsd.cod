; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Dell\Desktop\vlmcsd\src\vlmcsd.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0EN@OAFFBID@N?3B?3m?3t?3w?30?33?36?3H?3A?3R?3u?3G?3g?3L?3p?3@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_07LDLFNPGN@Windows?$AA@			; `string'
PUBLIC	??_C@_0L@NOKOPGDB@Office2010?$AA@		; `string'
PUBLIC	??_C@_0L@PFIDKFPC@Office2013?$AA@		; `string'
PUBLIC	??_C@_0L@IIPEFBLH@Office2016?$AA@		; `string'
PUBLIC	??_C@_0M@HIMAJJKJ@WinChinaGov?$AA@		; `string'
PUBLIC	??_C@_09BIFGJFAC@ExitLevel?$AA@			; `string'
PUBLIC	??_C@_03DCJLDMKG@VPN?$AA@			; `string'
PUBLIC	??_C@_07IIAKFIOC@KmsData?$AA@			; `string'
PUBLIC	??_C@_0BC@IJCDKLCC@WhiteListingLevel?$AA@	; `string'
PUBLIC	??_C@_0BA@PHKIMFI@CheckClientTime?$AA@		; `string'
PUBLIC	??_C@_0L@MPMBKNGK@StartEmpty?$AA@		; `string'
PUBLIC	??_C@_0BA@PFAJBMD@MaintainClients?$AA@		; `string'
PUBLIC	??_C@_0BD@BOJJAJAF@RandomizationLevel?$AA@	; `string'
PUBLIC	??_C@_04MGCBHGDH@LCID?$AA@			; `string'
PUBLIC	??_C@_04HOKNCALA@Port?$AA@			; `string'
PUBLIC	??_C@_06CBIOIDCI@Listen?$AA@			; `string'
PUBLIC	??_C@_0L@CJHAKJAH@MaxWorkers?$AA@		; `string'
PUBLIC	??_C@_0BC@JIAPHOFH@ConnectionTimeout?$AA@	; `string'
PUBLIC	??_C@_0BN@MMGPMACK@DisconnectClientsImmediately?$AA@ ; `string'
PUBLIC	??_C@_08LIILCCDA@UseNDR64?$AA@			; `string'
PUBLIC	??_C@_07HOBDIJEO@UseBTFN?$AA@			; `string'
PUBLIC	??_C@_07ECHLBDEG@PIDFile?$AA@			; `string'
PUBLIC	??_C@_0P@DLGBEDLC@LogDateAndTime?$AA@		; `string'
PUBLIC	??_C@_07EEDKEMBM@LogFile?$AA@			; `string'
PUBLIC	??_C@_0L@JCGDMJPB@LogVerbose?$AA@		; `string'
PUBLIC	??_C@_0BD@NEDPHNH@ActivationInterval?$AA@	; `string'
PUBLIC	??_C@_0BA@MJJIHAAL@RenewalInterval?$AA@		; `string'
PUBLIC	??_C@_0BI@DFILPCOB@PublicIPProtectionLevel?$AA@	; `string'
PUBLIC	??_C@_0IHN@EKOFFKCI@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5option@ ; `string'
PUBLIC	??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4?$AA@	; `string'
PUBLIC	??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5specif@ ; `string'
PUBLIC	??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5o@ ; `string'
PUBLIC	??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5?$CF@ ; `string'
PUBLIC	??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4?$AA@ ; `string'
PUBLIC	??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4?$AA@ ; `string'
PUBLIC	??_C@_0BB@MJCPHOFN@Unknown?5keyword?4?$AA@	; `string'
PUBLIC	??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Wind@ ; `string'
PUBLIC	??_C@_0N@BACOLJMI@command?5line?$AA@		; `string'
PUBLIC	??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6?$AA@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu?$AA@			; `string'
PUBLIC	??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5?8@ ; `string'
PUBLIC	??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6?$AA@ ; `string'
PUBLIC	??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semaph@ ; `string'
PUBLIC	??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_02MOLJINC@?3?3?$AA@			; `string'
PUBLIC	??_C@_07OHKHACFK@0?40?40?40?$AA@		; `string'
PUBLIC	??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5s@ ; `string'
PUBLIC	??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Wind@ ; `string'
PUBLIC	??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6?$AA@ ; `string'
PUBLIC	_IniFileErrorBuffer
PUBLIC	_tapArgument
EXTRN	__imp__CommandLineToArgvW@8:PROC
EXTRN	__imp__DeleteFileA@4:PROC
EXTRN	__imp__GetCurrentProcessId@0:PROC
EXTRN	__imp__WSAStartup@8:PROC
EXTRN	__imp__SetConsoleCtrlHandler@8:PROC
EXTRN	__imp__ferror:PROC
EXTRN	__imp__fgets:PROC
EXTRN	__imp__CreateSemaphoreA@16:PROC
EXTRN	__imp__WideCharToMultiByte@32:PROC
EXTRN	__imp__isspace:PROC
EXTRN	__imp__StartServiceCtrlDispatcherA@4:PROC
EXTRN	__imp__GetCommandLineW@0:PROC
	ALIGN	4

_IniFileErrorBuffer DD 01H DUP (?)
_fn_pid	DD	01H DUP (?)
_ServiceUser DD	01H DUP (?)
_maxsockets DB	01H DUP (?)
	ALIGN	4

_fn_ini	DD	01H DUP (?)
_installService DB 01H DUP (?)
	ALIGN	4

_tapArgument DD	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6?$AA@
CONST	SEGMENT
??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6?$AA@ DB 'vlmcsd'
	DB	' %s started successfully', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Wind@
CONST	SEGMENT
??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Wind@ DB 'Fatal: Coul'
	DB	'd not initialize Windows sockets (Error: %d).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5s@
CONST	SEGMENT
??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5s@ DB 'Fatal: Co'
	DB	'uld not listen on any socket.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHKHACFK@0?40?40?40?$AA@
CONST	SEGMENT
??_C@_07OHKHACFK@0?40?40?40?$AA@ DB '0.0.0.0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02MOLJINC@?3?3?$AA@
CONST	SEGMENT
??_C@_02MOLJINC@?3?3?$AA@ DB '::', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6?$AA@ DB 'War'
	DB	'ning: Can''t read %s: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semaph@
CONST	SEGMENT
??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semaph@ DB 'Warning: Co'
	DB	'uld not create semaphore: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6?$AA@
CONST	SEGMENT
??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6?$AA@ DB 'vlmcsd %s was '
	DB	'shutdown', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5?8@
CONST	SEGMENT
??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5?8@ DB 'Warning: '
	DB	'Cannot write pid file ''%s''. %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu?$AA@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu?$AA@ DB '%u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6?$AA@
CONST	SEGMENT
??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6?$AA@ DB 'vlmcsd %s %i-bit', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BACOLJMI@command?5line?$AA@
CONST	SEGMENT
??_C@_0N@BACOLJMI@command?5line?$AA@ DB 'command line', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Wind@
CONST	SEGMENT
??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Wind@ DB 'Warning: Co'
	DB	'uld not register Windows signal handler: Error %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6?$AA@ DB 'Read ini file %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6?$AA@ DB 'W'
	DB	'arning: %s line %u: "%s". %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4?$AA@
CONST	SEGMENT
??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4?$AA@ DB 'Cannot listen on '
	DB	'%s.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MJCPHOFN@Unknown?5keyword?4?$AA@
CONST	SEGMENT
??_C@_0BB@MJCPHOFN@Unknown?5keyword?4?$AA@ DB 'Unknown keyword.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4?$AA@
CONST	SEGMENT
??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4?$AA@ DB 'missing '
	DB	'argument after ''=''.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4?$AA@
CONST	SEGMENT
??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4?$AA@ DB '''='' re'
	DB	'quired after keyword.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5?$CF@
CONST	SEGMENT
??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5?$CF@ DB 'Must'
	DB	' be integer between %u and %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5o@
CONST	SEGMENT
??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5o@ DB 'Argument '
	DB	'must be true/on/yes/1 or false/off/no/0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5specif@
CONST	SEGMENT
??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5specif@ DB 'Fatal: No '
	DB	'valid time span specified in option -%c.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4?$AA@
CONST	SEGMENT
??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4?$AA@ DB 'Incorrect time span.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IHN@EKOFFKCI@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5option@
CONST	SEGMENT
??_C@_0IHN@EKOFFKCI@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5option@ DB 'v'
	DB	'lmcsd %s', 0aH, 0aH, 'Usage:', 0aH, '   %s [ options ]', 0aH, 0aH
	DB	'Where:', 0aH, '  -w <ePID>', 09H, 09H, 'always use <ePID> for'
	DB	' Windows', 0aH, '  -0 <ePID>', 09H, 09H, 'always use <ePID> f'
	DB	'or Office2010', 0aH, '  -3 <ePID>', 09H, 09H, 'always use <eP'
	DB	'ID> for Office2013', 0aH, '  -6 <ePID>', 09H, 09H, 'always us'
	DB	'e <ePID> for Office2016', 0aH, '  -G <ePID>', 09H, 09H, 'alwa'
	DB	'ys use <ePID> for Win China Gov', 0aH, '  -H <HwId>', 09H, 09H
	DB	'always use hardware Id <HwId>', 0aH, '  -r 0|1|2', 09H, 09H, 's'
	DB	'et ePID randomization level (default 1)', 0aH, '  -C <LCID>', 09H
	DB	09H, 'use fixed <LCID> in random ePIDs', 0aH, '  -o 0|1|2|3', 09H
	DB	09H, 'set protection level against clients with public IP addr'
	DB	'esses (default 0)', 0aH, '  -O <v>[=<a>][/<c>]', 09H, 'use VP'
	DB	'N adapter <v> with IPv4 address <a> and CIDR <c>', 0aH, '  -x'
	DB	' <level>', 09H, 09H, 'exit if warning <level> reached (defaul'
	DB	't 0)', 0aH, '  -L <address>[:<port>]', 09H, 'listen on IP add'
	DB	'ress <address> with optional <port>', 0aH, '  -P <port>', 09H
	DB	09H, 'set TCP port <port> for subsequent -L statements (defaul'
	DB	't 1688)', 0aH, '  -m <clients>', 09H, 09H, 'Handle max. <clie'
	DB	'nts> simultaneously (default no limit)', 0aH, '  -s', 09H, 09H
	DB	09H, 'install vlmcsd as an NT service. Ignores -e', 0aH, '  -S'
	DB	09H, 09H, 09H, 'remove vlmcsd service. Ignores all other optio'
	DB	'ns', 0aH, '  -U <username>', 09H, 09H, 'run NT service as <us'
	DB	'ername>. Must be used with -s', 0aH, '  -W <password>', 09H, 09H
	DB	'optional <password> for -U. Must be used with -s', 0aH, '  -e'
	DB	09H, 09H, 09H, 'log to stdout', 0aH, '  -D', 09H, 09H, 09H, 'd'
	DB	'oes nothing. Provided for compatibility with POSIX versions o'
	DB	'nly', 0aH, '  -K 0|1|2|3', 09H, 09H, 'set whitelisting level '
	DB	'for KMS IDs (default -K0)', 0aH, '  -c0, -c1', 09H, 09H, 'dis'
	DB	'able/enable client time checking (default -c0)', 0aH, '  -M0,'
	DB	' -M1', 09H, 09H, 'disable/enable maintaining clients (default'
	DB	' -M0)', 0aH, '  -E0, -E1', 09H, 09H, 'disable/enable start wi'
	DB	'th empty client list (default -E0, ignored if -M0)', 0aH, '  '
	DB	'-t <seconds>', 09H, 09H, 'disconnect clients after <seconds> '
	DB	'of inactivity (default 30)', 0aH, '  -d', 09H, 09H, 09H, 'dis'
	DB	'connect clients after each request', 0aH, '  -k', 09H, 09H, 09H
	DB	'don''t disconnect clients after each request (default)', 0aH, ' '
	DB	' -N0, -N1', 09H, 09H, 'disable/enable NDR64', 0aH, '  -B0, -B'
	DB	'1', 09H, 09H, 'disable/enable bind time feature negotiation', 0aH
	DB	'  -p <file>', 09H, 09H, 'write pid to <file>', 0aH, '  -i <fi'
	DB	'le>', 09H, 09H, 'use config file <file>', 0aH, '  -j <file>', 09H
	DB	09H, 'use KMS data file <file>', 0aH, '  -R <interval>', 09H, 09H
	DB	'renew activation every <interval> (default 1w)', 0aH, '  -A <'
	DB	'interval>', 09H, 09H, 'retry activation every <interval> (def'
	DB	'ault 2h)', 0aH, '  -l <file>', 09H, 09H, 'log to <file>', 0aH
	DB	'  -T0, -T1', 09H, 09H, 'disable/enable logging with time and '
	DB	'date (default -T1)', 0aH, '  -v', 09H, 09H, 09H, 'log verbose'
	DB	0aH, '  -q', 09H, 09H, 09H, 'don''t log verbose (default)', 0aH
	DB	'  -V', 09H, 09H, 09H, 'display version information and exit', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DFILPCOB@PublicIPProtectionLevel?$AA@
CONST	SEGMENT
??_C@_0BI@DFILPCOB@PublicIPProtectionLevel?$AA@ DB 'PublicIPProtectionLev'
	DB	'el', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MJJIHAAL@RenewalInterval?$AA@
CONST	SEGMENT
??_C@_0BA@MJJIHAAL@RenewalInterval?$AA@ DB 'RenewalInterval', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NEDPHNH@ActivationInterval?$AA@
CONST	SEGMENT
??_C@_0BD@NEDPHNH@ActivationInterval?$AA@ DB 'ActivationInterval', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JCGDMJPB@LogVerbose?$AA@
CONST	SEGMENT
??_C@_0L@JCGDMJPB@LogVerbose?$AA@ DB 'LogVerbose', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEDKEMBM@LogFile?$AA@
CONST	SEGMENT
??_C@_07EEDKEMBM@LogFile?$AA@ DB 'LogFile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DLGBEDLC@LogDateAndTime?$AA@
CONST	SEGMENT
??_C@_0P@DLGBEDLC@LogDateAndTime?$AA@ DB 'LogDateAndTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECHLBDEG@PIDFile?$AA@
CONST	SEGMENT
??_C@_07ECHLBDEG@PIDFile?$AA@ DB 'PIDFile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HOBDIJEO@UseBTFN?$AA@
CONST	SEGMENT
??_C@_07HOBDIJEO@UseBTFN?$AA@ DB 'UseBTFN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LIILCCDA@UseNDR64?$AA@
CONST	SEGMENT
??_C@_08LIILCCDA@UseNDR64?$AA@ DB 'UseNDR64', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MMGPMACK@DisconnectClientsImmediately?$AA@
CONST	SEGMENT
??_C@_0BN@MMGPMACK@DisconnectClientsImmediately?$AA@ DB 'DisconnectClient'
	DB	'sImmediately', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JIAPHOFH@ConnectionTimeout?$AA@
CONST	SEGMENT
??_C@_0BC@JIAPHOFH@ConnectionTimeout?$AA@ DB 'ConnectionTimeout', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CJHAKJAH@MaxWorkers?$AA@
CONST	SEGMENT
??_C@_0L@CJHAKJAH@MaxWorkers?$AA@ DB 'MaxWorkers', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CBIOIDCI@Listen?$AA@
CONST	SEGMENT
??_C@_06CBIOIDCI@Listen?$AA@ DB 'Listen', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOKNCALA@Port?$AA@
CONST	SEGMENT
??_C@_04HOKNCALA@Port?$AA@ DB 'Port', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MGCBHGDH@LCID?$AA@
CONST	SEGMENT
??_C@_04MGCBHGDH@LCID?$AA@ DB 'LCID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BOJJAJAF@RandomizationLevel?$AA@
CONST	SEGMENT
??_C@_0BD@BOJJAJAF@RandomizationLevel?$AA@ DB 'RandomizationLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PFAJBMD@MaintainClients?$AA@
CONST	SEGMENT
??_C@_0BA@PFAJBMD@MaintainClients?$AA@ DB 'MaintainClients', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPMBKNGK@StartEmpty?$AA@
CONST	SEGMENT
??_C@_0L@MPMBKNGK@StartEmpty?$AA@ DB 'StartEmpty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PHKIMFI@CheckClientTime?$AA@
CONST	SEGMENT
??_C@_0BA@PHKIMFI@CheckClientTime?$AA@ DB 'CheckClientTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IJCDKLCC@WhiteListingLevel?$AA@
CONST	SEGMENT
??_C@_0BC@IJCDKLCC@WhiteListingLevel?$AA@ DB 'WhiteListingLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IIAKFIOC@KmsData?$AA@
CONST	SEGMENT
??_C@_07IIAKFIOC@KmsData?$AA@ DB 'KmsData', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DCJLDMKG@VPN?$AA@
CONST	SEGMENT
??_C@_03DCJLDMKG@VPN?$AA@ DB 'VPN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BIFGJFAC@ExitLevel?$AA@
CONST	SEGMENT
??_C@_09BIFGJFAC@ExitLevel?$AA@ DB 'ExitLevel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HIMAJJKJ@WinChinaGov?$AA@
CONST	SEGMENT
??_C@_0M@HIMAJJKJ@WinChinaGov?$AA@ DB 'WinChinaGov', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IIPEFBLH@Office2016?$AA@
CONST	SEGMENT
??_C@_0L@IIPEFBLH@Office2016?$AA@ DB 'Office2016', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PFIDKFPC@Office2013?$AA@
CONST	SEGMENT
??_C@_0L@PFIDKFPC@Office2013?$AA@ DB 'Office2013', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NOKOPGDB@Office2010?$AA@
CONST	SEGMENT
??_C@_0L@NOKOPGDB@Office2010?$AA@ DB 'Office2010', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDLFNPGN@Windows?$AA@
CONST	SEGMENT
??_C@_07LDLFNPGN@Windows?$AA@ DB 'Windows', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@OAFFBID@N?3B?3m?3t?3w?30?33?36?3H?3A?3R?3u?3G?3g?3L?3p?3@
CONST	SEGMENT
??_C@_0EN@OAFFBID@N?3B?3m?3t?3w?30?33?36?3H?3A?3R?3u?3G?3g?3L?3p?3@ DB 'N'
	DB	':B:m:t:w:0:3:6:H:A:R:u:G:g:L:p:i:P:l:r:U:W:C:c:F:O:o:x:T:K:E:'
	DB	'M:j:SseDdVvqkZ', 00H			; `string'
_IniFileErrorMessage DD FLAT:??_C@_00CNPNBAHC@?$AA@
	ORG $+4
_IniFileParameterList DD FLAT:??_C@_07LDLFNPGN@Windows?$AA@
	DB	014H
	ORG $+3
	DD	FLAT:??_C@_0L@NOKOPGDB@Office2010?$AA@
	DB	015H
	ORG $+3
	DD	FLAT:??_C@_0L@PFIDKFPC@Office2013?$AA@
	DB	016H
	ORG $+3
	DD	FLAT:??_C@_0L@IIPEFBLH@Office2016?$AA@
	DB	017H
	ORG $+3
	DD	FLAT:??_C@_0M@HIMAJJKJ@WinChinaGov?$AA@
	DB	01fH
	ORG $+3
	DD	FLAT:??_C@_09BIFGJFAC@ExitLevel?$AA@
	DB	01eH
	ORG $+3
	DD	FLAT:??_C@_03DCJLDMKG@VPN?$AA@
	DB	01dH
	ORG $+3
	DD	FLAT:??_C@_07IIAKFIOC@KmsData?$AA@
	DB	01cH
	ORG $+3
	DD	FLAT:??_C@_0BC@IJCDKLCC@WhiteListingLevel?$AA@
	DB	018H
	ORG $+3
	DD	FLAT:??_C@_0BA@PHKIMFI@CheckClientTime?$AA@
	DB	019H
	ORG $+3
	DD	FLAT:??_C@_0L@MPMBKNGK@StartEmpty?$AA@
	DB	01bH
	ORG $+3
	DD	FLAT:??_C@_0BA@PFAJBMD@MaintainClients?$AA@
	DB	01aH
	ORG $+3
	DD	FLAT:??_C@_0BD@BOJJAJAF@RandomizationLevel?$AA@
	DB	01H
	ORG $+3
	DD	FLAT:??_C@_04MGCBHGDH@LCID?$AA@
	DB	02H
	ORG $+3
	DD	FLAT:??_C@_04HOKNCALA@Port?$AA@
	DB	0eH
	ORG $+3
	DD	FLAT:??_C@_06CBIOIDCI@Listen?$AA@
	DB	03H
	ORG $+3
	DD	FLAT:??_C@_0L@CJHAKJAH@MaxWorkers?$AA@
	DB	04H
	ORG $+3
	DD	FLAT:??_C@_0BC@JIAPHOFH@ConnectionTimeout?$AA@
	DB	05H
	ORG $+3
	DD	FLAT:??_C@_0BN@MMGPMACK@DisconnectClientsImmediately?$AA@
	DB	0bH
	ORG $+3
	DD	FLAT:??_C@_08LIILCCDA@UseNDR64?$AA@
	DB	0fH
	ORG $+3
	DD	FLAT:??_C@_07HOBDIJEO@UseBTFN?$AA@
	DB	010H
	ORG $+3
	DD	FLAT:??_C@_07ECHLBDEG@PIDFile?$AA@
	DB	06H
	ORG $+3
	DD	FLAT:??_C@_0P@DLGBEDLC@LogDateAndTime?$AA@
	DB	013H
	ORG $+3
	DD	FLAT:??_C@_07EEDKEMBM@LogFile?$AA@
	DB	07H
	ORG $+3
	DD	FLAT:??_C@_0L@JCGDMJPB@LogVerbose?$AA@
	DB	08H
	ORG $+3
	DD	FLAT:??_C@_0BD@NEDPHNH@ActivationInterval?$AA@
	DB	09H
	ORG $+3
	DD	FLAT:??_C@_0BA@MJJIHAAL@RenewalInterval?$AA@
	DB	0aH
	ORG $+3
	DD	FLAT:??_C@_0BI@DFILPCOB@PublicIPProtectionLevel?$AA@
	DB	012H
	ORG $+3
_ServicePassword DD FLAT:??_C@_00CNPNBAHC@?$AA@
_optstring DD	FLAT:??_C@_0EN@OAFFBID@N?3B?3m?3t?3w?30?33?36?3H?3A?3R?3u?3G?3g?3L?3p?3@
CONST	ENDS
PUBLIC	_WinStartUp@0
PUBLIC	_main
PUBLIC	_setupListeningSockets
PUBLIC	_newmain
PUBLIC	_cleanup
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _cleanup
_TEXT	SEGMENT
_cleanup PROC						; COMDAT

; 1474 : 	if (!InetdMode)

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  00007	75 44		 jne	 SHORT $LN3@cleanup

; 1475 : 	{
; 1476 : #		ifndef NO_CLIENT_LIST
; 1477 : 		if (MaintainClients) CleanUpClientLists();
; 1478 : #		endif // !NO_CLIENT_LIST
; 1479 : 
; 1480 : #		ifndef NO_PID_FILE
; 1481 : 		if (fn_pid) vlmcsd_unlink(fn_pid);

  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR _fn_pid
  0000e	85 c0		 test	 eax, eax
  00010	74 07		 je	 SHORT $LN1@cleanup
  00012	50		 push	 eax
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeleteFileA@4
$LN1@cleanup:

; 1482 : #		endif // NO_PID_FILE
; 1483 : 		closeAllListeningSockets();

  00019	56		 push	 esi
  0001a	33 f6		 xor	 esi, esi
  0001c	39 35 00 00 00
	00		 cmp	 DWORD PTR _numsockets, esi
  00022	7e 17		 jle	 SHORT $LN8@cleanup
$LL10@cleanup:
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR _SocketList
  00029	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00032	46		 inc	 esi
  00033	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _numsockets
  00039	7c e9		 jl	 SHORT $LL10@cleanup
$LN8@cleanup:

; 1484 : 
; 1485 : #		if !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !defined(_WIN32) && !__minix__
; 1486 : 		sem_unlink("/vlmcsd");
; 1487 : #		if !defined(USE_THREADS) && !defined(CYGWIN)
; 1488 : 		if (shmid >= 0)
; 1489 : 		{
; 1490 : 			if (MaxTaskSemaphore != (sem_t*)-1) shmdt(MaxTaskSemaphore);
; 1491 : 			shmctl(shmid, IPC_RMID, NULL);
; 1492 : 		}
; 1493 : #		endif // !defined(USE_THREADS) && !defined(CYGWIN)
; 1494 : #		endif // !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !defined(_WIN32) && !__minix__
; 1495 : 
; 1496 : #		ifndef NO_LOG
; 1497 : 		logger("vlmcsd %s was shutdown\n", Version);

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LEPLNMP@private?5build?$AA@
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6?$AA@
  00045	e8 00 00 00 00	 call	 _logger
  0004a	59		 pop	 ecx
  0004b	59		 pop	 ecx
  0004c	5e		 pop	 esi
$LN3@cleanup:

; 1498 : #		endif // NO_LOG
; 1499 : 	}
; 1500 : }

  0004d	c3		 ret	 0
_cleanup ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _newmain
_TEXT	SEGMENT
_wsadata$ = -400					; size = 400
_newmain PROC						; COMDAT

; 1700 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec 94 01 00
	00		 sub	 esp, 404		; 00000194H
  0000c	56		 push	 esi

; 1701 : #	if !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 1702 : 	KmsResponseParameters = (KmsResponseParam_t*)vlmcsd_malloc(sizeof(KmsResponseParam_t) * MIN_CSVLK);

  0000d	6a 3c		 push	 60			; 0000003cH
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00015	59		 pop	 ecx
  00016	85 c0		 test	 eax, eax
  00018	0f 84 86 01 00
	00		 je	 $LN28@newmain

; 1703 : 	memset(KmsResponseParameters, 0, sizeof(KmsResponseParam_t) * MIN_CSVLK);

  0001e	6a 3c		 push	 60			; 0000003cH
  00020	6a 00		 push	 0
  00022	50		 push	 eax
  00023	a3 00 00 00 00	 mov	 DWORD PTR _KmsResponseParameters, eax
  00028	e8 00 00 00 00	 call	 _memset
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1704 : #	endif // !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 1705 : 
; 1706 : 	// Initialize thread synchronization objects for Windows and Cygwin
; 1707 : #	ifdef USE_THREADS
; 1708 : 
; 1709 : #	ifndef NO_LOG
; 1710 : // Initialize the Critical Section for proper logging
; 1711 : #	if _WIN32 || __CYGWIN__
; 1712 : 	InitializeCriticalSection(&logmutex);

  00030	68 00 00 00 00	 push	 OFFSET _logmutex
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__InitializeCriticalSection@4

; 1713 : #	endif // _WIN32 || __CYGWIN__
; 1714 : #	endif // NO_LOG
; 1715 : 
; 1716 : #	endif // USE_THREADS
; 1717 : 
; 1718 : #	ifdef _WIN32
; 1719 : 
; 1720 : #	ifndef USE_MSRPC
; 1721 : 	WSADATA wsadata;
; 1722 : 	{
; 1723 : 		// Windows Sockets must be initialized
; 1724 : 		int error;
; 1725 : 		if ((error = WSAStartup(0x0202, &wsadata)))

  0003b	8d 44 24 08	 lea	 eax, DWORD PTR _wsadata$[esp+408]
  0003f	50		 push	 eax
  00040	68 02 02 00 00	 push	 514			; 00000202H
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAStartup@8
  0004b	8b f0		 mov	 esi, eax
  0004d	85 f6		 test	 esi, esi
  0004f	74 11		 je	 SHORT $LN14@newmain

; 1726 : 		{
; 1727 : 			printerrorf("Fatal: Could not initialize Windows sockets (Error: %d).\n", error);

  00051	56		 push	 esi
  00052	68 00 00 00 00	 push	 OFFSET ??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Wind@
  00057	e8 00 00 00 00	 call	 _printerrorf
  0005c	59		 pop	 ecx

; 1728 : 			return error;

  0005d	e9 3a 01 00 00	 jmp	 $LN27@newmain
$LN14@newmain:

; 1729 : 		}
; 1730 : 	}
; 1731 : #	endif // USE_MSRPC
; 1732 : 
; 1733 : 	// Windows can never daemonize
; 1734 : 	//nodaemon = 1;
; 1735 : 
; 1736 : #	else // __CYGWIN__
; 1737 : 
; 1738 : 	// Do not daemonize if we are a Windows service
; 1739 : #	ifdef _NTSERVICE 
; 1740 : 	if (IsNTService) nodaemon = 1;
; 1741 : #	endif
; 1742 : 
; 1743 : #	endif // _WIN32 / __CYGWIN__
; 1744 : 
; 1745 : 	parseGeneralArguments(); // Does not return if an error occurs

  00062	e8 00 00 00 00	 call	 _parseGeneralArguments

; 1746 : 
; 1747 : #	if !defined(_WIN32) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1748 : 
; 1749 : 	struct stat statbuf;
; 1750 : 	fstat(STDIN_FILENO, &statbuf);
; 1751 : 
; 1752 : 	if (S_ISSOCK(statbuf.st_mode))
; 1753 : 	{
; 1754 : 		InetdMode = 1;
; 1755 : #		ifndef NO_CLIENT_LIST
; 1756 : 		MaintainClients = FALSE;
; 1757 : #		endif // !NO_CLIENT_LIST
; 1758 : 		nodaemon = 1;
; 1759 : #		ifndef SIMPLE_SOCKETS
; 1760 : 		maxsockets = 0;
; 1761 : #		endif // !SIMPLE_SOCKETS
; 1762 : #		ifndef NO_LOG
; 1763 : 		logstdout = 0;
; 1764 : #		endif // !NO_LOG
; 1765 : 	}
; 1766 : 
; 1767 : #	endif // !defined(_WIN32) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1768 : 
; 1769 : #	ifndef NO_INI_FILE
; 1770 : 
; 1771 : 	if (fn_ini && !readIniFile(INI_FILE_PASS_1))

  00067	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _fn_ini, 0
  0006e	74 2e		 je	 SHORT $LN13@newmain
  00070	b1 01		 mov	 cl, 1
  00072	e8 00 00 00 00	 call	 _readIniFile
  00077	85 c0		 test	 eax, eax
  00079	75 23		 jne	 SHORT $LN13@newmain

; 1772 : 	{
; 1773 : #		ifdef INI_FILE
; 1774 : 		if (strcmp(fn_ini, INI_FILE))
; 1775 : #		endif // INI_FILE
; 1776 : 			printerrorf("Warning: Can't read %s: %s\n", fn_ini, strerror(errno));

  0007b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00081	ff 30		 push	 DWORD PTR [eax]
  00083	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  00089	59		 pop	 ecx
  0008a	50		 push	 eax
  0008b	ff 35 00 00 00
	00		 push	 DWORD PTR _fn_ini
  00091	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6?$AA@
  00096	e8 00 00 00 00	 call	 _printerrorf
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN13@newmain:

; 1777 : 	}
; 1778 : 
; 1779 : #	endif // NO_INI_FILE
; 1780 : 
; 1781 : 	loadKmsData();

  0009e	e8 00 00 00 00	 call	 _loadKmsData

; 1782 : 
; 1783 : #	ifndef NO_CLIENT_LIST
; 1784 : 	if (MaintainClients) InitializeClientLists();

  000a3	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _MaintainClients, 0
  000aa	74 05		 je	 SHORT $LN12@newmain
  000ac	e8 00 00 00 00	 call	 _InitializeClientLists
$LN12@newmain:

; 1785 : #	endif // !NO_CLIENT_LIST
; 1786 : 
; 1787 : #	if defined(USE_MSRPC) && !defined(NO_PRIVATE_IP_DETECT)
; 1788 : 	if (PublicIPProtectionLevel)
; 1789 : 	{
; 1790 : 		printerrorf("Warning: Public IP address protection using MS RPC is poor. See vlmcsd.8\n");
; 1791 : 	}
; 1792 : #	endif // defined(USE_MSRPC) && !defined(NO_PRIVATE_IP_DETECT)
; 1793 : 
; 1794 : #	if !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !__minix__ && !defined(USE_MSRPC)
; 1795 : 	allocateSemaphore();

  000b1	e8 00 00 00 00	 call	 _allocateSemaphore

; 1796 : #	endif // !defined(NO_LIMIT) && !defined(NO_SOCKETS) && __minix__
; 1797 : 
; 1798 : #	ifdef _NTSERVICE
; 1799 : 	if (installService)

  000b6	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _installService, 0
  000bd	74 0c		 je	 SHORT $LN11@newmain

; 1800 : 		return NtServiceInstallation(installService, ServiceUser, ServicePassword);

  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 _NtServiceInstallation
  000c5	59		 pop	 ecx
  000c6	e9 d4 00 00 00	 jmp	 $LN15@newmain
$LN11@newmain:

; 1801 : #	endif // _NTSERVICE
; 1802 : 
; 1803 : #	ifndef NO_TAP
; 1804 : 	if (tapArgument && !InetdMode) startTap(tapArgument);

  000cb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _tapArgument, 0
  000d2	74 0e		 je	 SHORT $LN10@newmain
  000d4	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  000db	75 1b		 jne	 SHORT $LN8@newmain
  000dd	e8 00 00 00 00	 call	 _startTap
$LN10@newmain:

; 1805 : #	endif // NO_TAP
; 1806 : 
; 1807 : #	if !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1808 : 	if (!InetdMode)

  000e2	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  000e9	75 0d		 jne	 SHORT $LN8@newmain

; 1809 : 	{
; 1810 : 		int error;
; 1811 : #		ifdef SIMPLE_SOCKETS
; 1812 : 		if ((error = listenOnAllAddresses())) return error;
; 1813 : #		else // !SIMPLE_SOCKETS
; 1814 : 		if ((error = setupListeningSockets())) return error;

  000eb	e8 00 00 00 00	 call	 _setupListeningSockets
  000f0	85 c0		 test	 eax, eax
  000f2	0f 85 a7 00 00
	00		 jne	 $LN15@newmain
$LN8@newmain:

; 1815 : #		endif // !SIMPLE_SOCKETS
; 1816 : 	}
; 1817 : #	endif // !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1818 : 
; 1819 : 	// After sockets have been set up, we may switch to a lower privileged user
; 1820 : #	if !defined(_WIN32) && !defined(NO_USER_SWITCH)
; 1821 : 
; 1822 : #	ifndef NO_SIGHUP
; 1823 : 	if (!IsRestarted)
; 1824 : 	{
; 1825 : #	endif // NO_SIGHUP
; 1826 : 		if (gid != INVALID_GID)
; 1827 : 		{
; 1828 : 			if (setgid(gid))
; 1829 : 			{
; 1830 : 				printerrorf("Fatal: %s for %s failed: %s\n", "setgid", gname, strerror(errno));
; 1831 : 				return errno;
; 1832 : 			}
; 1833 : 
; 1834 : 			if (setgroups(1, &gid))
; 1835 : 			{
; 1836 : 				printerrorf("Fatal: %s for %s failed: %s\n", "setgroups", gname, strerror(errno));
; 1837 : 				return errno;
; 1838 : 			}
; 1839 : 		}
; 1840 : 
; 1841 : 		if (uid != INVALID_UID && setuid(uid))
; 1842 : 		{
; 1843 : 			printerrorf("Fatal: %s for %s failed: %s\n", "setuid", uname, strerror(errno));
; 1844 : 			return errno;
; 1845 : 		}
; 1846 : #	ifndef NO_SIGHUP
; 1847 : 	}
; 1848 : #	endif // NO_SIGHUP
; 1849 : 
; 1850 : #	endif // !defined(_WIN32) && !defined(NO_USER_SWITCH)
; 1851 : 
; 1852 : 	randomNumberInit();

  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetTickCount@0
  000fe	50		 push	 eax
  000ff	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__srand

; 1853 : 
; 1854 : 	// Randomization Level 1 means generate ePIDs at startup and use them during
; 1855 : 	// the lifetime of the process. So we generate them now
; 1856 : #	ifndef NO_RANDOM_EPID
; 1857 : 	if (RandomizationLevel == 1) randomPidInit();

  00105	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR _RandomizationLevel, 1
  0010c	59		 pop	 ecx
  0010d	75 05		 jne	 SHORT $LN7@newmain
  0010f	e8 00 00 00 00	 call	 _randomPidInit
$LN7@newmain:

; 1858 : #	endif
; 1859 : 
; 1860 : #	if !defined(NO_SOCKETS)
; 1861 : #	ifdef _WIN32
; 1862 : 	if (!IsNTService)

  00114	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _IsNTService, 0
  0011b	75 24		 jne	 SHORT $LN23@newmain

; 1863 : 	{
; 1864 : #	endif // _WIN32
; 1865 : 		int error;
; 1866 : 		if ((error = daemonizeAndSetSignalAction())) return error;

  0011d	6a 01		 push	 1
  0011f	68 00 00 00 00	 push	 OFFSET _terminationHandler
  00124	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCtrlHandler@8
  0012a	85 c0		 test	 eax, eax
  0012c	75 13		 jne	 SHORT $LN23@newmain
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00134	50		 push	 eax
  00135	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Wind@
  0013a	e8 00 00 00 00	 call	 _logger
  0013f	59		 pop	 ecx
  00140	59		 pop	 ecx
$LN23@newmain:

; 1867 : #	ifdef _WIN32
; 1868 : 	}
; 1869 : #	endif // _WIN32
; 1870 : #	endif // !defined(NO_SOCKETS)
; 1871 : 
; 1872 : 	writePidFile();

  00141	e8 00 00 00 00	 call	 _writePidFile

; 1873 : 
; 1874 : #	if !defined(NO_LOG) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1875 : 	if (!InetdMode)

  00146	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  0014d	75 11		 jne	 SHORT $LN4@newmain

; 1876 : 		logger("vlmcsd %s started successfully\n", Version);

  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LEPLNMP@private?5build?$AA@
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6?$AA@
  00159	e8 00 00 00 00	 call	 _logger
  0015e	59		 pop	 ecx
  0015f	59		 pop	 ecx
$LN4@newmain:

; 1877 : #	endif // !defined(NO_LOG) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1878 : 
; 1879 : #	if defined(_NTSERVICE) && !defined(USE_MSRPC)
; 1880 : 	if (IsNTService) ReportServiceStatus(SERVICE_RUNNING, NO_ERROR, 200);

  00160	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _IsNTService, 0
  00167	74 10		 je	 SHORT $LN3@newmain
  00169	68 c8 00 00 00	 push	 200			; 000000c8H
  0016e	6a 04		 push	 4
  00170	33 d2		 xor	 edx, edx
  00172	59		 pop	 ecx
  00173	e8 00 00 00 00	 call	 _ReportServiceStatus
  00178	59		 pop	 ecx
$LN3@newmain:

; 1881 : #	endif // defined(_NTSERVICE) && !defined(USE_MSRPC)
; 1882 : 
; 1883 : 	int rc;
; 1884 : 	rc = runServer();

  00179	e8 00 00 00 00	 call	 _runServer

; 1885 : 
; 1886 : 	// Clean up things and exit
; 1887 : #	ifdef _NTSERVICE
; 1888 : 	if (!ServiceShutdown)

  0017e	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _ServiceShutdown, 0
  00185	8b f0		 mov	 esi, eax
  00187	75 07		 jne	 SHORT $LN2@newmain

; 1889 : #	endif
; 1890 : 		cleanup();

  00189	e8 00 00 00 00	 call	 _cleanup

; 1891 : #	ifdef _NTSERVICE
; 1892 : 	else

  0018e	eb 0d		 jmp	 SHORT $LN1@newmain
$LN2@newmain:

; 1893 : 		ReportServiceStatus(SERVICE_STOPPED, NO_ERROR, 0);

  00190	33 c9		 xor	 ecx, ecx
  00192	33 d2		 xor	 edx, edx
  00194	6a 00		 push	 0
  00196	41		 inc	 ecx
  00197	e8 00 00 00 00	 call	 _ReportServiceStatus
$LN27@newmain:
  0019c	59		 pop	 ecx
$LN1@newmain:

; 1894 : #	endif
; 1895 : 
; 1896 : 	return rc;

  0019d	8b c6		 mov	 eax, esi
$LN15@newmain:

; 1897 : }

  0019f	5e		 pop	 esi
  001a0	8b e5		 mov	 esp, ebp
  001a2	5d		 pop	 ebp
  001a3	c3		 ret	 0
$LN28@newmain:

; 1701 : #	if !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 1702 : 	KmsResponseParameters = (KmsResponseParam_t*)vlmcsd_malloc(sizeof(KmsResponseParam_t) * MIN_CSVLK);

  001a4	e8 00 00 00 00	 call	 _OutOfMemory
$LN30@newmain:
$LN26@newmain:
  001a9	cc		 int	 3
_newmain ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _usage
_TEXT	SEGMENT
_usage	PROC						; COMDAT

; 269  : 	printerrorf("vlmcsd %s\n"
; 270  : 		"\nUsage:\n"
; 271  : 		"   %s [ options ]\n\n"
; 272  : 		"Where:\n"
; 273  : #		ifndef NO_CL_PIDS
; 274  : 		"  -w <ePID>\t\talways use <ePID> for Windows\n"
; 275  : 		"  -0 <ePID>\t\talways use <ePID> for Office2010\n"
; 276  : 		"  -3 <ePID>\t\talways use <ePID> for Office2013\n"
; 277  : 		"  -6 <ePID>\t\talways use <ePID> for Office2016\n"
; 278  : 		"  -G <ePID>\t\talways use <ePID> for Win China Gov\n"
; 279  : 		"  -H <HwId>\t\talways use hardware Id <HwId>\n"
; 280  : #		endif // NO_CL_PIDS
; 281  : #		if !defined(_WIN32) && !defined(NO_USER_SWITCH)
; 282  : 		"  -u <user>\t\tset uid to <user>\n"
; 283  : 		"  -g <group>\t\tset gid to <group>\n"
; 284  : #		endif // !defined(_WIN32) && !defined(NO_USER_SWITCH)
; 285  : #		ifndef NO_RANDOM_EPID
; 286  : 		"  -r 0|1|2\t\tset ePID randomization level (default 1)\n"
; 287  : 		"  -C <LCID>\t\tuse fixed <LCID> in random ePIDs\n"
; 288  : #		endif // NO_RANDOM_EPID
; 289  : #		if !defined(NO_PRIVATE_IP_DETECT)
; 290  : #		if HAVE_GETIFADDR
; 291  : 		"  -o 0|1|2|3\t\tset protection level against clients with public IP addresses (default 0)\n"
; 292  : #		else // !HAVE_GETIFADDR
; 293  : #		ifndef USE_MSRPC
; 294  : 		"  -o 0|2\t\tset protection level against clients with public IP addresses (default 0)\n"
; 295  : #		else // USE_MSRPC
; 296  : 		"  -o 0|2\t\tset protection level against clients with public IP addresses (default 0). Limited use with MS RPC\n"
; 297  : #		endif // USE_MSRPC
; 298  : #		endif // !HAVE_GETIFADDR
; 299  : #		endif // !defined(NO_PRIVATE_IP_DETECT)
; 300  : #		ifndef NO_TAP
; 301  : 		"  -O <v>[=<a>][/<c>]\tuse VPN adapter <v> with IPv4 address <a> and CIDR <c>\n"
; 302  : #		endif
; 303  : #		ifndef NO_SOCKETS
; 304  : 		"  -x <level>\t\texit if warning <level> reached (default 0)\n"
; 305  : #		if !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 306  : 		"  -L <address>[:<port>]\tlisten on IP address <address> with optional <port>\n"
; 307  : 		"  -P <port>\t\tset TCP port <port> for subsequent -L statements (default 1688)\n"
; 308  : #		if HAVE_FREEBIND
; 309  : 		"  -F0, -F1\t\tdisable/enable binding to foreign IP addresses\n"
; 310  : #		endif // HAVE_FREEBIND
; 311  : #		else // defined(USE_MSRPC) || defined(SIMPLE_SOCKETS)
; 312  : 		"  -P <port>\t\tuse TCP port <port> (default 1688)\n"
; 313  : #		endif // defined(USE_MSRPC) || defined(SIMPLE_SOCKETS)
; 314  : #		if !defined(NO_LIMIT) && !__minix__
; 315  : 		"  -m <clients>\t\tHandle max. <clients> simultaneously (default no limit)\n"
; 316  : #		endif // !defined(NO_LIMIT) && !__minix__
; 317  : #		ifdef _NTSERVICE
; 318  : 		"  -s\t\t\tinstall vlmcsd as an NT service. Ignores -e"
; 319  : #		ifndef _WIN32
; 320  : 		", -f and -D"
; 321  : #		endif // _WIN32
; 322  : 		"\n"
; 323  : 		"  -S\t\t\tremove vlmcsd service. Ignores all other options\n"
; 324  : 		"  -U <username>\t\trun NT service as <username>. Must be used with -s\n"
; 325  : 		"  -W <password>\t\toptional <password> for -U. Must be used with -s\n"
; 326  : #		endif // _NTSERVICE
; 327  : #		ifndef NO_LOG
; 328  : 		"  -e\t\t\tlog to stdout\n"
; 329  : #		endif // NO_LOG
; 330  : #		ifndef _WIN32 //
; 331  : 		"  -D\t\t\trun in foreground\n"
; 332  : #		else // _WIN32
; 333  : 		"  -D\t\t\tdoes nothing. Provided for compatibility with POSIX versions only\n"
; 334  : #		endif // _WIN32
; 335  : #		endif // NO_SOCKETS
; 336  : #		ifndef NO_STRICT_MODES
; 337  : 		"  -K 0|1|2|3\t\tset whitelisting level for KMS IDs (default -K0)\n"
; 338  : 		"  -c0, -c1\t\tdisable/enable client time checking (default -c0)\n"
; 339  : #		ifndef NO_CLIENT_LIST
; 340  : 		"  -M0, -M1\t\tdisable/enable maintaining clients (default -M0)\n"
; 341  : 		"  -E0, -E1\t\tdisable/enable start with empty client list (default -E0, ignored if -M0)\n"
; 342  : #		endif // !NO_CLIENT_LIST
; 343  : #		endif // !NO_STRICT_MODES
; 344  : #		ifndef USE_MSRPC
; 345  : #		if !defined(NO_TIMEOUT) && !__minix__
; 346  : 		"  -t <seconds>\t\tdisconnect clients after <seconds> of inactivity (default 30)\n"
; 347  : #		endif // !defined(NO_TIMEOUT) && !__minix__
; 348  : 		"  -d\t\t\tdisconnect clients after each request\n"
; 349  : 		"  -k\t\t\tdon't disconnect clients after each request (default)\n"
; 350  : #		ifndef SIMPLE_RPC
; 351  : 		"  -N0, -N1\t\tdisable/enable NDR64\n"
; 352  : 		"  -B0, -B1\t\tdisable/enable bind time feature negotiation\n"
; 353  : #		endif // !SIMPLE_RPC
; 354  : #		endif // USE_MSRPC
; 355  : #		ifndef NO_PID_FILE
; 356  : 		"  -p <file>\t\twrite pid to <file>\n"
; 357  : #		endif // NO_PID_FILE
; 358  : #		ifndef NO_INI_FILE
; 359  : 		"  -i <file>\t\tuse config file <file>\n"
; 360  : #		endif // NO_INI_FILE
; 361  : #		ifndef NO_EXTERNAL_DATA
; 362  : 		"  -j <file>\t\tuse KMS data file <file>\n"
; 363  : #		endif // !NO_EXTERNAL_DATA
; 364  : #		ifndef NO_CUSTOM_INTERVALS
; 365  : 		"  -R <interval>\t\trenew activation every <interval> (default 1w)\n"
; 366  : 		"  -A <interval>\t\tretry activation every <interval> (default 2h)\n"
; 367  : #		endif // NO_CUSTOM_INTERVALS
; 368  : #		ifndef NO_LOG
; 369  : #		ifndef _WIN32
; 370  : 		"  -l syslog		log to syslog\n"
; 371  : #		endif // _WIN32
; 372  : 		"  -l <file>\t\tlog to <file>\n"
; 373  : 		"  -T0, -T1\t\tdisable/enable logging with time and date (default -T1)\n"
; 374  : #		ifndef NO_VERBOSE_LOG
; 375  : 		"  -v\t\t\tlog verbose\n"
; 376  : 		"  -q\t\t\tdon't log verbose (default)\n"
; 377  : #		endif // NO_VERBOSE_LOG
; 378  : #		endif // NO_LOG
; 379  : #		ifndef NO_VERSION_INFORMATION
; 380  : 		"  -V\t\t\tdisplay version information and exit\n"
; 381  : #		endif // NO_VERSION_INFORMATION
; 382  : 		,
; 383  : 		Version, global_argv[0]);

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _global_argv
  00005	ff 30		 push	 DWORD PTR [eax]
  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LEPLNMP@private?5build?$AA@
  0000c	68 00 00 00 00	 push	 OFFSET ??_C@_0IHN@EKOFFKCI@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5option@
  00011	e8 00 00 00 00	 call	 _printerrorf
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 384  : 
; 385  : 	exit(VLMCSD_EINVAL);

  00019	6a 57		 push	 87			; 00000057H
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN4@usage:
$LN3@usage:
  00021	cc		 int	 3
_usage	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _getTimeSpanFromIniFile
_TEXT	SEGMENT
_getTimeSpanFromIniFile PROC				; COMDAT
; _result$ = ecx
; _argument$ = edx

; 394  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 395  : 	DWORD val = timeSpanString2Minutes(argument);

  00003	8b ca		 mov	 ecx, edx
  00005	e8 00 00 00 00	 call	 _timeSpanString2Seconds
  0000a	6a 3c		 push	 60			; 0000003cH
  0000c	33 d2		 xor	 edx, edx
  0000e	59		 pop	 ecx
  0000f	f7 f1		 div	 ecx

; 396  : 	if (!val)

  00011	85 c0		 test	 eax, eax
  00013	75 0c		 jne	 SHORT $LN1@getTimeSpa

; 397  : 	{
; 398  : 		IniFileErrorMessage = "Incorrect time span.";

  00015	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _IniFileErrorMessage, OFFSET ??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4?$AA@

; 404  : }

  0001f	5e		 pop	 esi
  00020	c3		 ret	 0
$LN1@getTimeSpa:

; 399  : 		return FALSE;
; 400  : 	}
; 401  : 
; 402  : 	*result = val;

  00021	89 06		 mov	 DWORD PTR [esi], eax

; 403  : 	return TRUE;

  00023	33 c0		 xor	 eax, eax
  00025	40		 inc	 eax

; 404  : }

  00026	5e		 pop	 esi
  00027	c3		 ret	 0
_getTimeSpanFromIniFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _getTimeSpanFromCommandLine
_TEXT	SEGMENT
_getTimeSpanFromCommandLine PROC			; COMDAT
; _arg$dead$ = ecx
; _optchar$ = dl

; 410  : {

  00000	51		 push	 ecx
  00001	51		 push	 ecx

; 411  : 	DWORD val = timeSpanString2Minutes(arg);

  00002	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optarg
  00008	53		 push	 ebx
  00009	8a da		 mov	 bl, dl
  0000b	e8 00 00 00 00	 call	 _timeSpanString2Seconds
  00010	6a 3c		 push	 60			; 0000003cH
  00012	33 d2		 xor	 edx, edx
  00014	59		 pop	 ecx
  00015	f7 f1		 div	 ecx

; 412  : 
; 413  : 	if (!val)

  00017	85 c0		 test	 eax, eax
  00019	75 18		 jne	 SHORT $LN2@getTimeSpa

; 414  : 	{
; 415  : 		printerrorf("Fatal: No valid time span specified in option -%c.\n", optchar);

  0001b	0f be c3	 movsx	 eax, bl
  0001e	50		 push	 eax
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5specif@
  00024	e8 00 00 00 00	 call	 _printerrorf
  00029	59		 pop	 ecx
  0002a	59		 pop	 ecx

; 416  : 		exit(VLMCSD_EINVAL);

  0002b	6a 57		 push	 87			; 00000057H
  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN6@getTimeSpa:
$LN2@getTimeSpa:

; 417  : 	}
; 418  : 
; 419  : 	return val;
; 420  : }

  00033	5b		 pop	 ebx
  00034	59		 pop	 ecx
  00035	59		 pop	 ecx
  00036	c3		 ret	 0
$LN5@getTimeSpa:
_getTimeSpanFromCommandLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _ignoreIniFileParameter
_TEXT	SEGMENT
_ignoreIniFileParameter PROC				; COMDAT
; _iniFileParameterId$ = cl

; 428  : 	uint_fast8_t i;
; 429  : 
; 430  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  00000	32 d2		 xor	 dl, dl
$LL4@ignoreIniF:

; 431  : 	{
; 432  : 		if (IniFileParameterList[i].Id != iniFileParameterId) continue;

  00002	0f b6 c2	 movzx	 eax, dl
  00005	38 0c c5 04 00
	00 00		 cmp	 BYTE PTR _IniFileParameterList[eax*8+4], cl
  0000c	74 08		 je	 SHORT $LN1@ignoreIniF

; 428  : 	uint_fast8_t i;
; 429  : 
; 430  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  0000e	fe c2		 inc	 dl
  00010	80 fa 1c	 cmp	 dl, 28			; 0000001cH
  00013	72 ed		 jb	 SHORT $LL4@ignoreIniF

; 434  : 		break;
; 435  : 	}
; 436  : }

  00015	c3		 ret	 0
$LN1@ignoreIniF:

; 433  : 		IniFileParameterList[i].Id = 0;

  00016	0f b6 c2	 movzx	 eax, dl
  00019	c6 04 c5 04 00
	00 00 00	 mov	 BYTE PTR _IniFileParameterList[eax*8+4], 0

; 434  : 		break;
; 435  : 	}
; 436  : }

  00021	c3		 ret	 0
_ignoreIniFileParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _getIniFileArgumentBool
_TEXT	SEGMENT
_getIniFileArgumentBool PROC				; COMDAT
; _result$ = ecx
; _argument$ = edx

; 445  : 	IniFileErrorMessage = "Argument must be true/on/yes/1 or false/off/no/0";

  00000	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _IniFileErrorMessage, OFFSET ??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5o@

; 446  : 	return getArgumentBool(result, argument);

  0000a	e9 00 00 00 00	 jmp	 _getArgumentBool
_getIniFileArgumentBool ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _getIniFileArgumentInt
_TEXT	SEGMENT
_getIniFileArgumentInt PROC				; COMDAT
; _min$ = ecx
; _max$ = edx

; 452  : 	unsigned int tempResult;
; 453  : 
; 454  : 	if (!stringToInt(argument, min, max, &tempResult))
; 455  : 	{
; 456  : 		vlmcsd_snprintf(IniFileErrorBuffer, INIFILE_ERROR_BUFFERSIZE, "Must be integer between %u and %u", min, max);

  00000	52		 push	 edx
  00001	51		 push	 ecx
  00002	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5?$CF@
  00007	68 00 01 00 00	 push	 256			; 00000100H
  0000c	ff 35 00 00 00
	00		 push	 DWORD PTR _IniFileErrorBuffer
  00012	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf

; 457  : 		IniFileErrorMessage = IniFileErrorBuffer;

  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR _IniFileErrorBuffer
  0001d	83 c4 14	 add	 esp, 20			; 00000014H
  00020	a3 00 00 00 00	 mov	 DWORD PTR _IniFileErrorMessage, eax

; 458  : 		return FALSE;

  00025	33 c0		 xor	 eax, eax

; 459  : 	}
; 460  : 
; 461  : 	*result = tempResult;
; 462  : 	return TRUE;
; 463  : }

  00027	c3		 ret	 0
_getIniFileArgumentInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _isControlCharOrSlash
_TEXT	SEGMENT
_isControlCharOrSlash PROC				; COMDAT
; _c$ = cl

; 468  : 	if ((unsigned char)c < '!') return TRUE;

  00000	33 c0		 xor	 eax, eax
  00002	80 f9 21	 cmp	 cl, 33			; 00000021H
  00005	73 02		 jae	 SHORT $LN2@isControlC
  00007	40		 inc	 eax

; 470  : 	return FALSE;
; 471  : }

  00008	c3		 ret	 0
$LN2@isControlC:

; 469  : 	if (c == '/') return TRUE;

  00009	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  0000c	0f 94 c0	 sete	 al

; 470  : 	return FALSE;
; 471  : }

  0000f	c3		 ret	 0
_isControlCharOrSlash ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _iniFileLineNextWord
_TEXT	SEGMENT
_iniFileLineNextWord PROC				; COMDAT
; _s$ = ecx

; 475  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 476  : 	while (**s && isspace((int)**s)) (*s)++;

  00003	eb 13		 jmp	 SHORT $LN11@iniFileLin
$LL2@iniFileLin:
  00005	8b 06		 mov	 eax, DWORD PTR [esi]
  00007	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0000a	50		 push	 eax
  0000b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isspace
  00011	59		 pop	 ecx
  00012	85 c0		 test	 eax, eax
  00014	74 09		 je	 SHORT $LN9@iniFileLin
  00016	ff 06		 inc	 DWORD PTR [esi]
$LN11@iniFileLin:
  00018	8b 06		 mov	 eax, DWORD PTR [esi]
  0001a	80 38 00	 cmp	 BYTE PTR [eax], 0
  0001d	75 e6		 jne	 SHORT $LL2@iniFileLin
$LN9@iniFileLin:
  0001f	5e		 pop	 esi

; 477  : }

  00020	c3		 ret	 0
_iniFileLineNextWord ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _setHwIdFromIniFileLine
_TEXT	SEGMENT
_setHwIdFromIniFileLine PROC				; COMDAT
; _s$ = ecx
; _index$ = edx

; 481  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi
  00003	8b fa		 mov	 edi, edx
  00005	8b f1		 mov	 esi, ecx

; 482  : 	iniFileLineNextWord(s);

  00007	e8 00 00 00 00	 call	 _iniFileLineNextWord

; 483  : 
; 484  : 	if (**s == '/')

  0000c	8b 1e		 mov	 ebx, DWORD PTR [esi]
  0000e	80 3b 2f	 cmp	 BYTE PTR [ebx], 47	; 0000002fH
  00011	75 33		 jne	 SHORT $LN2@setHwIdFro

; 485  : 	{
; 486  : 		if (KmsResponseParameters[index].HwId) return TRUE;

  00013	a1 00 00 00 00	 mov	 eax, DWORD PTR _KmsResponseParameters
  00018	6b ff 0c	 imul	 edi, edi, 12
  0001b	83 7c 07 04 00	 cmp	 DWORD PTR [edi+eax+4], 0
  00020	75 24		 jne	 SHORT $LN2@setHwIdFro

; 487  : 
; 488  : 		BYTE* HwId = (BYTE*)vlmcsd_malloc(sizeof(((RESPONSE_V6 *)0)->HwId));

  00022	6a 08		 push	 8
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0002a	8b f0		 mov	 esi, eax
  0002c	59		 pop	 ecx
  0002d	85 f6		 test	 esi, esi
  0002f	74 1c		 je	 SHORT $LN10@setHwIdFro

; 489  : 		hex2bin(HwId, *s + 1, sizeof(((RESPONSE_V6 *)0)->HwId));

  00031	51		 push	 ecx
  00032	8d 53 01	 lea	 edx, DWORD PTR [ebx+1]
  00035	8b ce		 mov	 ecx, esi
  00037	e8 00 00 00 00	 call	 _hex2bin

; 490  : 		KmsResponseParameters[index].HwId = HwId;

  0003c	a1 00 00 00 00	 mov	 eax, DWORD PTR _KmsResponseParameters
  00041	59		 pop	 ecx
  00042	89 74 07 04	 mov	 DWORD PTR [edi+eax+4], esi
$LN2@setHwIdFro:

; 491  : 	}
; 492  : 
; 493  : 	return TRUE;

  00046	5f		 pop	 edi
  00047	33 c0		 xor	 eax, eax
  00049	5e		 pop	 esi
  0004a	40		 inc	 eax
  0004b	5b		 pop	 ebx

; 494  : }

  0004c	c3		 ret	 0
$LN10@setHwIdFro:

; 487  : 
; 488  : 		BYTE* HwId = (BYTE*)vlmcsd_malloc(sizeof(((RESPONSE_V6 *)0)->HwId));

  0004d	e8 00 00 00 00	 call	 _OutOfMemory
$LN12@setHwIdFro:
$LN9@setHwIdFro:
  00052	cc		 int	 3
_setHwIdFromIniFileLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _setEpidFromIniFileLine
_TEXT	SEGMENT
_savedPosition$1$ = -4					; size = 4
_setEpidFromIniFileLine PROC				; COMDAT
; _s$ = ecx
; _index$ = edx

; 498  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi
  00005	8b da		 mov	 ebx, edx
  00007	8b f1		 mov	 esi, ecx

; 499  : 	iniFileLineNextWord(s);

  00009	e8 00 00 00 00	 call	 _iniFileLineNextWord

; 500  : 	const char *savedPosition = *s;

  0000e	8b 16		 mov	 edx, DWORD PTR [esi]

; 501  : 	uint_fast16_t i;
; 502  : 
; 503  : 	for (i = 0; !isControlCharOrSlash(**s); i++)

  00010	33 ff		 xor	 edi, edi
  00012	89 54 24 10	 mov	 DWORD PTR _savedPosition$1$[esp+20], edx
$LL7@setEpidFro:
  00016	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00018	8a 01		 mov	 al, BYTE PTR [ecx]
  0001a	3c 21		 cmp	 al, 33			; 00000021H
  0001c	72 18		 jb	 SHORT $LN5@setEpidFro
  0001e	3c 2f		 cmp	 al, 47			; 0000002fH
  00020	74 14		 je	 SHORT $LN5@setEpidFro

; 504  : 	{
; 505  : 		if (utf8_to_ucs2_char((const unsigned char*)*s, (const unsigned char**)s) == (WCHAR)~0)

  00022	8b d6		 mov	 edx, esi
  00024	e8 00 00 00 00	 call	 _utf8_to_ucs2_char
  00029	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0002e	66 3b c1	 cmp	 ax, cx
  00031	74 58		 je	 SHORT $LN2@setEpidFro

; 501  : 	uint_fast16_t i;
; 502  : 
; 503  : 	for (i = 0; !isControlCharOrSlash(**s); i++)

  00033	47		 inc	 edi
  00034	eb e0		 jmp	 SHORT $LL7@setEpidFro
$LN5@setEpidFro:

; 506  : 		{
; 507  : 			return FALSE;
; 508  : 		}
; 509  : 	}
; 510  : 
; 511  : 	if (i < 1 || i >= PID_BUFFER_SIZE) return FALSE;

  00036	8d 47 ff	 lea	 eax, DWORD PTR [edi-1]
  00039	83 f8 3e	 cmp	 eax, 62			; 0000003eH
  0003c	77 4d		 ja	 SHORT $LN2@setEpidFro

; 512  : 	if (KmsResponseParameters[index].Epid) return TRUE;

  0003e	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR _KmsResponseParameters
  00044	6b db 0c	 imul	 ebx, ebx, 12
  00047	83 3c 2b 00	 cmp	 DWORD PTR [ebx+ebp], 0
  0004b	74 05		 je	 SHORT $LN1@setEpidFro
$LN25@setEpidFro:
  0004d	33 c0		 xor	 eax, eax
  0004f	40		 inc	 eax
  00050	eb 3b		 jmp	 SHORT $LN8@setEpidFro
$LN1@setEpidFro:

; 513  : 
; 514  : 	size_t size = *s - savedPosition + 1;

  00052	8b f1		 mov	 esi, ecx
  00054	2b 74 24 10	 sub	 esi, DWORD PTR _savedPosition$1$[esp+20]
  00058	46		 inc	 esi

; 515  : 
; 516  : 	char* epidbuffer = (char*)vlmcsd_malloc(size);

  00059	56		 push	 esi
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00060	8b f8		 mov	 edi, eax
  00062	59		 pop	 ecx
  00063	85 ff		 test	 edi, edi
  00065	74 2c		 je	 SHORT $LN26@setEpidFro

; 517  : 	memcpy(epidbuffer, savedPosition, size - 1);

  00067	8d 46 ff	 lea	 eax, DWORD PTR [esi-1]
  0006a	50		 push	 eax
  0006b	ff 74 24 14	 push	 DWORD PTR _savedPosition$1$[esp+24]
  0006f	57		 push	 edi
  00070	e8 00 00 00 00	 call	 _memcpy

; 518  : 	epidbuffer[size - 1] = 0;
; 519  : 
; 520  : 	KmsResponseParameters[index].Epid = epidbuffer;
; 521  : 
; 522  : #ifndef NO_LOG
; 523  : 	KmsResponseParameters[index].EpidSource = fn_ini;

  00075	a1 00 00 00 00	 mov	 eax, DWORD PTR _fn_ini
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	c6 44 37 ff 00	 mov	 BYTE PTR [edi+esi-1], 0
  00082	89 3c 2b	 mov	 DWORD PTR [ebx+ebp], edi
  00085	89 44 2b 08	 mov	 DWORD PTR [ebx+ebp+8], eax

; 524  : #endif //NO_LOG
; 525  : 
; 526  : 	return TRUE;

  00089	eb c2		 jmp	 SHORT $LN25@setEpidFro
$LN2@setEpidFro:

; 506  : 		{
; 507  : 			return FALSE;
; 508  : 		}
; 509  : 	}
; 510  : 
; 511  : 	if (i < 1 || i >= PID_BUFFER_SIZE) return FALSE;

  0008b	33 c0		 xor	 eax, eax
$LN8@setEpidFro:
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5d		 pop	 ebp
  00090	5b		 pop	 ebx

; 527  : }

  00091	59		 pop	 ecx
  00092	c3		 ret	 0
$LN26@setEpidFro:

; 515  : 
; 516  : 	char* epidbuffer = (char*)vlmcsd_malloc(size);

  00093	e8 00 00 00 00	 call	 _OutOfMemory
$LN28@setEpidFro:
$LN24@setEpidFro:
  00098	cc		 int	 3
_setEpidFromIniFileLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _setIniFileParameter
_TEXT	SEGMENT
_tempResult$1 = -4					; size = 4
_tempResult$2 = -4					; size = 4
_tempResult$3 = -4					; size = 4
_tempResult$4 = -4					; size = 4
_tempResult$5 = -4					; size = 4
_tempResult$6 = -4					; size = 4
_tempResult$7 = -4					; size = 4
_s$ = -4						; size = 4
_setIniFileParameter PROC				; COMDAT
; _id$ = cl
; _iniarg$ = edx

; 531  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx

; 532  : 	unsigned int result;
; 533  : 	BOOL success = TRUE;

  00005	33 db		 xor	 ebx, ebx

; 534  : 	const char *s = (const char*)iniarg;
; 535  : 
; 536  : 	switch (id)

  00007	0f b6 c1	 movzx	 eax, cl
  0000a	43		 inc	 ebx
  0000b	48		 dec	 eax
  0000c	56		 push	 esi
  0000d	8b f2		 mov	 esi, edx
  0000f	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
  00012	57		 push	 edi
  00013	83 f8 1e	 cmp	 eax, 30			; 0000001eH
  00016	0f 87 a2 02 00
	00		 ja	 $LN1@setIniFile
  0001c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN117@setIniFile[eax*4]
$LN33@setIniFile:

; 537  : 	{
; 538  : 	case INI_PARAM_WINDOWS:
; 539  : 		setEpidFromIniFileLine(&s, EPID_INDEX_WINDOWS);

  00023	33 d2		 xor	 edx, edx
  00025	8d 4d fc	 lea	 ecx, DWORD PTR _s$[ebp]
  00028	e8 00 00 00 00	 call	 _setEpidFromIniFileLine

; 540  : 		setHwIdFromIniFileLine(&s, EPID_INDEX_WINDOWS);

  0002d	33 d2		 xor	 edx, edx
$LN109@setIniFile:
  0002f	8d 4d fc	 lea	 ecx, DWORD PTR _s$[ebp]
  00032	e8 00 00 00 00	 call	 _setHwIdFromIniFileLine

; 541  : 		break;

  00037	e9 d2 00 00 00	 jmp	 $LN101@setIniFile
$LN32@setIniFile:

; 542  : 
; 543  : 	case INI_PARAM_OFFICE2010:
; 544  : 		setEpidFromIniFileLine(&s, EPID_INDEX_OFFICE2010);

  0003c	8b d3		 mov	 edx, ebx
  0003e	8d 4d fc	 lea	 ecx, DWORD PTR _s$[ebp]
  00041	e8 00 00 00 00	 call	 _setEpidFromIniFileLine

; 545  : 		setHwIdFromIniFileLine(&s, EPID_INDEX_OFFICE2010);

  00046	8b d3		 mov	 edx, ebx

; 546  : 		break;

  00048	eb e5		 jmp	 SHORT $LN109@setIniFile
$LN31@setIniFile:

; 547  : 
; 548  : 	case INI_PARAM_OFFICE2013:
; 549  : 		setEpidFromIniFileLine(&s, EPID_INDEX_OFFICE2013);

  0004a	6a 02		 push	 2
  0004c	5a		 pop	 edx
  0004d	8d 4d fc	 lea	 ecx, DWORD PTR _s$[ebp]
  00050	e8 00 00 00 00	 call	 _setEpidFromIniFileLine

; 550  : 		setHwIdFromIniFileLine(&s, EPID_INDEX_OFFICE2013);

  00055	6a 02		 push	 2
$LN111@setIniFile:
  00057	5a		 pop	 edx

; 551  : 		break;

  00058	eb d5		 jmp	 SHORT $LN109@setIniFile
$LN30@setIniFile:

; 552  : 
; 553  : 	case INI_PARAM_OFFICE2016:
; 554  : 		setEpidFromIniFileLine(&s, EPID_INDEX_OFFICE2016);

  0005a	6a 03		 push	 3
  0005c	5a		 pop	 edx
  0005d	8d 4d fc	 lea	 ecx, DWORD PTR _s$[ebp]
  00060	e8 00 00 00 00	 call	 _setEpidFromIniFileLine

; 555  : 		setHwIdFromIniFileLine(&s, EPID_INDEX_OFFICE2016);

  00065	6a 03		 push	 3

; 556  : 		break;

  00067	eb ee		 jmp	 SHORT $LN111@setIniFile
$LN29@setIniFile:

; 557  : 
; 558  : 	case INI_PARAM_WINCHINAGOV:
; 559  : 		setEpidFromIniFileLine(&s, EPID_INDEX_WINCHINAGOV);

  00069	6a 04		 push	 4
  0006b	5a		 pop	 edx
  0006c	8d 4d fc	 lea	 ecx, DWORD PTR _s$[ebp]
  0006f	e8 00 00 00 00	 call	 _setEpidFromIniFileLine

; 560  : 		setHwIdFromIniFileLine(&s, EPID_INDEX_WINCHINAGOV);

  00074	6a 04		 push	 4

; 561  : 		break;

  00076	eb df		 jmp	 SHORT $LN111@setIniFile
$LN28@setIniFile:

; 562  : 
; 563  : #	ifndef NO_TAP
; 564  : 
; 565  : 	case INI_PARAM_VPN:
; 566  : 		tapArgument = (char*)vlmcsd_strdup(iniarg);

  00078	56		 push	 esi
  00079	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  0007f	59		 pop	 ecx
  00080	85 c0		 test	 eax, eax
  00082	0f 84 3f 02 00
	00		 je	 $LN115@setIniFile
  00088	a3 00 00 00 00	 mov	 DWORD PTR _tapArgument, eax

; 567  : 		break;

  0008d	eb 7f		 jmp	 SHORT $LN101@setIniFile
$LN27@setIniFile:

; 568  : 
; 569  : #	endif // NO_TAP
; 570  : 
; 571  : #	if !defined(NO_USER_SWITCH) && !_WIN32
; 572  : 
; 573  : 	case INI_PARAM_GID:
; 574  : 	{
; 575  : 		struct group *g;
; 576  : 		IniFileErrorMessage = "Invalid group id or name";
; 577  : 		if (!(gname = vlmcsd_strdup(iniarg))) return FALSE;
; 578  : 
; 579  : 		if ((g = getgrnam(iniarg)))
; 580  : 			gid = g->gr_gid;
; 581  : 		else
; 582  : 			success = !GetNumericId(&gid, iniarg);
; 583  : 		break;
; 584  : 	}
; 585  : 
; 586  : 	case INI_PARAM_UID:
; 587  : 	{
; 588  : 		struct passwd *p;
; 589  : 		IniFileErrorMessage = "Invalid user id or name";
; 590  : 		if (!(uname = vlmcsd_strdup(iniarg))) return FALSE;
; 591  : 
; 592  : 		if ((p = getpwnam(iniarg)))
; 593  : 			uid = p->pw_uid;
; 594  : 		else
; 595  : 			success = !GetNumericId(&uid, iniarg);
; 596  : 		break;
; 597  : 	}
; 598  : 
; 599  : #	endif // !defined(NO_USER_SWITCH) && !defined(_WIN32)
; 600  : 
; 601  : #	ifndef NO_RANDOM_EPID
; 602  : 
; 603  : 	case INI_PARAM_LCID:
; 604  : 		success = getIniFileArgumentInt(&result, iniarg, 0, 32767);

  0008f	8d 45 fc	 lea	 eax, DWORD PTR _tempResult$7[ebp]
  00092	bf ff 7f 00 00	 mov	 edi, 32767		; 00007fffH
  00097	50		 push	 eax
  00098	57		 push	 edi
  00099	33 d2		 xor	 edx, edx
  0009b	8b ce		 mov	 ecx, esi
  0009d	e8 00 00 00 00	 call	 _stringToInt
  000a2	59		 pop	 ecx
  000a3	59		 pop	 ecx
  000a4	85 c0		 test	 eax, eax
  000a6	75 0b		 jne	 SHORT $LN42@setIniFile
  000a8	8b d7		 mov	 edx, edi
  000aa	33 c9		 xor	 ecx, ecx
  000ac	e8 00 00 00 00	 call	 _getIniFileArgumentInt
  000b1	8b d8		 mov	 ebx, eax
$LN42@setIniFile:
  000b3	8b 45 fc	 mov	 eax, DWORD PTR _tempResult$7[ebp]

; 605  : 		if (success) Lcid = (uint16_t)result;

  000b6	85 db		 test	 ebx, ebx
  000b8	74 54		 je	 SHORT $LN101@setIniFile
  000ba	66 a3 00 00 00
	00		 mov	 WORD PTR _Lcid, ax

; 606  : 		break;

  000c0	eb 4c		 jmp	 SHORT $LN101@setIniFile
$LN25@setIniFile:

; 607  : 
; 608  : 	case INI_PARAM_RANDOMIZATION_LEVEL:
; 609  : 		success = getIniFileArgumentInt(&result, iniarg, 0, 2);

  000c2	8d 45 fc	 lea	 eax, DWORD PTR _tempResult$6[ebp]
  000c5	33 d2		 xor	 edx, edx
  000c7	50		 push	 eax
  000c8	6a 02		 push	 2
  000ca	8b ce		 mov	 ecx, esi
  000cc	e8 00 00 00 00	 call	 _stringToInt
  000d1	59		 pop	 ecx
  000d2	59		 pop	 ecx
  000d3	85 c0		 test	 eax, eax
  000d5	75 0c		 jne	 SHORT $LN47@setIniFile
  000d7	6a 02		 push	 2
  000d9	5a		 pop	 edx
  000da	33 c9		 xor	 ecx, ecx
  000dc	e8 00 00 00 00	 call	 _getIniFileArgumentInt
  000e1	8b d8		 mov	 ebx, eax
$LN47@setIniFile:
  000e3	8b 45 fc	 mov	 eax, DWORD PTR _tempResult$6[ebp]

; 610  : 		if (success) RandomizationLevel = (int_fast8_t)result;

  000e6	85 db		 test	 ebx, ebx
  000e8	74 24		 je	 SHORT $LN101@setIniFile
  000ea	a2 00 00 00 00	 mov	 BYTE PTR _RandomizationLevel, al

; 611  : 		break;

  000ef	eb 1d		 jmp	 SHORT $LN101@setIniFile
$LN23@setIniFile:

; 612  : 
; 613  : #	endif // NO_RANDOM_EPID
; 614  : 
; 615  : #	if (defined(USE_MSRPC) || defined(SIMPLE_SOCKETS) || defined(HAVE_GETIFADDR)) && !defined(NO_SOCKETS)
; 616  : 
; 617  : 	case INI_PARAM_PORT:
; 618  : 		defaultport = vlmcsd_strdup(iniarg);

  000f1	56		 push	 esi
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  000f8	59		 pop	 ecx
  000f9	85 c0		 test	 eax, eax
  000fb	0f 84 c6 01 00
	00		 je	 $LN115@setIniFile
  00101	a3 00 00 00 00	 mov	 DWORD PTR _defaultport, eax

; 619  : 		break;

  00106	eb 06		 jmp	 SHORT $LN101@setIniFile
$LN22@setIniFile:

; 620  : 
; 621  : #	endif // (defined(USE_MSRPC) || defined(SIMPLE_SOCKETS) || defined(HAVE_GETIFADDR)) && !defined(NO_SOCKETS)
; 622  : 
; 623  : #	if !defined(NO_SOCKETS) && !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 624  : 
; 625  : 	case INI_PARAM_LISTEN:
; 626  : 		maxsockets++;

  00108	fe 05 00 00 00
	00		 inc	 BYTE PTR _maxsockets

; 745  : 
; 746  : #	endif // NO_SOCKETS
; 747  : 
; 748  : #	if HAVE_FREEBIND
; 749  : 
; 750  : 	case INI_PARAM_FREEBIND:
; 751  : 		success = getIniFileArgumentBool(&freebind, iniarg);
; 752  : 		break;
; 753  : 
; 754  : #	endif // HAVE_FREEBIND
; 755  : 
; 756  : #	if !defined(NO_PRIVATE_IP_DETECT)
; 757  : 
; 758  : 	case INI_PARAM_PUBLIC_IP_PROTECTION_LEVEL:
; 759  : 		success = getIniFileArgumentInt(&PublicIPProtectionLevel, iniarg, 0, 3);

$LN101@setIniFile:

; 627  : 		return TRUE;

  0010e	8b c3		 mov	 eax, ebx
  00110	e9 ab 01 00 00	 jmp	 $LN36@setIniFile
$LN21@setIniFile:

; 628  : 
; 629  : #	endif // !defined(NO_SOCKETS) && !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 630  : #	if !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !__minix__
; 631  : 
; 632  : 	case INI_PARAM_MAX_WORKERS:
; 633  : #		ifdef USE_MSRPC
; 634  : 		success = getIniFileArgumentInt(&MaxTasks, iniarg, 1, RPC_C_LISTEN_MAX_CALLS_DEFAULT);
; 635  : #		else // !USE_MSRPC
; 636  : 		success = getIniFileArgumentInt(&MaxTasks, iniarg, 1, SEM_VALUE_MAX);

  00115	8d 45 fc	 lea	 eax, DWORD PTR _tempResult$5[ebp]
  00118	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  0011d	50		 push	 eax
  0011e	57		 push	 edi
  0011f	8b d3		 mov	 edx, ebx
  00121	8b ce		 mov	 ecx, esi
  00123	e8 00 00 00 00	 call	 _stringToInt
  00128	59		 pop	 ecx
  00129	59		 pop	 ecx
  0012a	85 c0		 test	 eax, eax
  0012c	75 09		 jne	 SHORT $LN55@setIniFile
  0012e	8b d7		 mov	 edx, edi
  00130	8b cb		 mov	 ecx, ebx
  00132	e9 6e 01 00 00	 jmp	 $LN107@setIniFile
$LN55@setIniFile:
  00137	8b 45 fc	 mov	 eax, DWORD PTR _tempResult$5[ebp]
  0013a	a3 00 00 00 00	 mov	 DWORD PTR _MaxTasks, eax

; 637  : #		endif // !USE_MSRPC
; 638  : 		break;

  0013f	eb cd		 jmp	 SHORT $LN101@setIniFile
$LN20@setIniFile:

; 639  : 
; 640  : #	endif // !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !__minix__
; 641  : 
; 642  : #	ifndef NO_PID_FILE
; 643  : 
; 644  : 	case INI_PARAM_PID_FILE:
; 645  : 		fn_pid = vlmcsd_strdup(iniarg);

  00141	56		 push	 esi
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  00148	59		 pop	 ecx
  00149	85 c0		 test	 eax, eax
  0014b	0f 84 76 01 00
	00		 je	 $LN115@setIniFile
  00151	a3 00 00 00 00	 mov	 DWORD PTR _fn_pid, eax

; 646  : 		break;

  00156	eb b6		 jmp	 SHORT $LN101@setIniFile
$LN19@setIniFile:

; 647  : 
; 648  : #	endif // NO_PID_FILE
; 649  : 
; 650  : #	ifndef NO_EXTERNAL_DATA
; 651  : 
; 652  : 	case INI_PARAM_DATA_FILE:
; 653  : 		fn_data = vlmcsd_strdup(iniarg);

  00158	56		 push	 esi
  00159	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  0015f	59		 pop	 ecx
  00160	85 c0		 test	 eax, eax
  00162	0f 84 5f 01 00
	00		 je	 $LN115@setIniFile
  00168	a3 00 00 00 00	 mov	 DWORD PTR _fn_data, eax

; 654  : #		ifndef NO_INTERNAL_DATA
; 655  : 		ExplicitDataLoad = TRUE;

  0016d	88 1d 00 00 00
	00		 mov	 BYTE PTR _ExplicitDataLoad, bl

; 656  : #		endif // NO_INTERNAL_DATA
; 657  : 		break;

  00173	eb 99		 jmp	 SHORT $LN101@setIniFile
$LN18@setIniFile:

; 658  : 
; 659  : #	endif // NO_EXTERNAL_DATA
; 660  : 
; 661  : #	ifndef NO_STRICT_MODES
; 662  : 
; 663  : 	case INI_PARAM_WHITELISTING_LEVEL:
; 664  : 		success = getIniFileArgumentInt(&WhitelistingLevel, iniarg, 0, 3);

  00175	8d 45 fc	 lea	 eax, DWORD PTR _tempResult$4[ebp]
  00178	33 d2		 xor	 edx, edx
  0017a	50		 push	 eax
  0017b	6a 03		 push	 3
  0017d	8b ce		 mov	 ecx, esi
  0017f	e8 00 00 00 00	 call	 _stringToInt
  00184	59		 pop	 ecx
  00185	59		 pop	 ecx
  00186	85 c0		 test	 eax, eax
  00188	0f 84 12 01 00
	00		 je	 $LN108@setIniFile
  0018e	8b 45 fc	 mov	 eax, DWORD PTR _tempResult$4[ebp]
  00191	a3 00 00 00 00	 mov	 DWORD PTR _WhitelistingLevel, eax

; 665  : 		break;

  00196	e9 73 ff ff ff	 jmp	 $LN101@setIniFile
$LN17@setIniFile:

; 666  : 
; 667  : 	case INI_PARAM_CHECK_CLIENT_TIME:
; 668  : 		success = getIniFileArgumentBool(&CheckClientTime, iniarg);

  0019b	b9 00 00 00 00	 mov	 ecx, OFFSET _CheckClientTime
$LN114@setIniFile:
  001a0	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _IniFileErrorMessage, OFFSET ??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5o@
  001aa	e8 00 00 00 00	 call	 _getArgumentBool

; 669  : 		break;

  001af	e9 f6 00 00 00	 jmp	 $LN106@setIniFile
$LN16@setIniFile:

; 670  : 
; 671  : #	ifndef NO_CLIENT_LIST
; 672  : 	case INI_PARAM_MAINTAIN_CLIENTS:
; 673  : 		success = getIniFileArgumentBool(&MaintainClients, iniarg);

  001b4	b9 00 00 00 00	 mov	 ecx, OFFSET _MaintainClients

; 674  : 		break;

  001b9	eb e5		 jmp	 SHORT $LN114@setIniFile
$LN15@setIniFile:

; 675  : 
; 676  : 	case INI_PARAM_START_EMPTY:
; 677  : 		success = getIniFileArgumentBool(&StartEmpty, iniarg);

  001bb	b9 00 00 00 00	 mov	 ecx, OFFSET _StartEmpty

; 678  : 		break;

  001c0	eb de		 jmp	 SHORT $LN114@setIniFile
$LN14@setIniFile:

; 679  : 
; 680  : #	endif // NO_CLIENT_LIST
; 681  : #	endif // !NO_STRICT_MODES
; 682  : 
; 683  : 
; 684  : #	ifndef  NO_LOG
; 685  : 
; 686  : 	case INI_PARAM_LOG_FILE:
; 687  : 		fn_log = vlmcsd_strdup(iniarg);

  001c2	56		 push	 esi
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  001c9	59		 pop	 ecx
  001ca	85 c0		 test	 eax, eax
  001cc	0f 84 f5 00 00
	00		 je	 $LN115@setIniFile
  001d2	a3 00 00 00 00	 mov	 DWORD PTR _fn_log, eax

; 688  : 		break;

  001d7	e9 32 ff ff ff	 jmp	 $LN101@setIniFile
$LN13@setIniFile:

; 689  : 
; 690  : 	case INI_PARAM_LOG_DATE_AND_TIME:
; 691  : 		success = getIniFileArgumentBool(&LogDateAndTime, iniarg);

  001dc	b9 00 00 00 00	 mov	 ecx, OFFSET _LogDateAndTime

; 692  : 		break;

  001e1	eb bd		 jmp	 SHORT $LN114@setIniFile
$LN12@setIniFile:

; 693  : 
; 694  : #	ifndef NO_VERBOSE_LOG
; 695  : 	case INI_PARAM_LOG_VERBOSE:
; 696  : 		success = getIniFileArgumentBool(&logverbose, iniarg);

  001e3	b9 00 00 00 00	 mov	 ecx, OFFSET _logverbose

; 697  : 		break;

  001e8	eb b6		 jmp	 SHORT $LN114@setIniFile
$LN11@setIniFile:

; 698  : 
; 699  : #	endif // NO_VERBOSE_LOG
; 700  : #	endif // NO_LOG
; 701  : 
; 702  : #	ifndef NO_CUSTOM_INTERVALS
; 703  : 
; 704  : 	case INI_PARAM_ACTIVATION_INTERVAL:
; 705  : 		success = getTimeSpanFromIniFile(&VLActivationInterval, iniarg);

  001ea	b9 00 00 00 00	 mov	 ecx, OFFSET _VLActivationInterval
$LN113@setIniFile:
  001ef	e8 00 00 00 00	 call	 _getTimeSpanFromIniFile

; 706  : 		break;

  001f4	e9 b1 00 00 00	 jmp	 $LN106@setIniFile
$LN10@setIniFile:

; 707  : 
; 708  : 	case INI_PARAM_RENEWAL_INTERVAL:
; 709  : 		success = getTimeSpanFromIniFile(&VLRenewalInterval, iniarg);

  001f9	b9 00 00 00 00	 mov	 ecx, OFFSET _VLRenewalInterval

; 710  : 		break;

  001fe	eb ef		 jmp	 SHORT $LN113@setIniFile
$LN9@setIniFile:

; 711  : 
; 712  : #	endif // NO_CUSTOM_INTERVALS
; 713  : 
; 714  : #	ifndef USE_MSRPC
; 715  : 
; 716  : #	if !defined(NO_TIMEOUT) && !__minix__
; 717  : 
; 718  : 	case INI_PARAM_CONNECTION_TIMEOUT:
; 719  : 		success = getIniFileArgumentInt(&result, iniarg, 1, 600);

  00200	8d 45 fc	 lea	 eax, DWORD PTR _tempResult$3[ebp]
  00203	bf 58 02 00 00	 mov	 edi, 600		; 00000258H
  00208	50		 push	 eax
  00209	57		 push	 edi
  0020a	8b d3		 mov	 edx, ebx
  0020c	8b ce		 mov	 ecx, esi
  0020e	e8 00 00 00 00	 call	 _stringToInt
  00213	59		 pop	 ecx
  00214	59		 pop	 ecx
  00215	85 c0		 test	 eax, eax
  00217	75 0b		 jne	 SHORT $LN84@setIniFile
  00219	8b d7		 mov	 edx, edi
  0021b	8b cb		 mov	 ecx, ebx
  0021d	e8 00 00 00 00	 call	 _getIniFileArgumentInt
  00222	8b d8		 mov	 ebx, eax
$LN84@setIniFile:
  00224	8b 45 fc	 mov	 eax, DWORD PTR _tempResult$3[ebp]

; 720  : 		if (success) ServerTimeout = (DWORD)result;

  00227	85 db		 test	 ebx, ebx
  00229	0f 84 df fe ff
	ff		 je	 $LN101@setIniFile
  0022f	a3 00 00 00 00	 mov	 DWORD PTR _ServerTimeout, eax

; 721  : 		break;

  00234	e9 d5 fe ff ff	 jmp	 $LN101@setIniFile
$LN7@setIniFile:

; 722  : 
; 723  : #	endif // !defined(NO_TIMEOUT) && !__minix__
; 724  : 
; 725  : 	case INI_PARAM_DISCONNECT_IMMEDIATELY:
; 726  : 		success = getIniFileArgumentBool(&DisconnectImmediately, iniarg);

  00239	b9 00 00 00 00	 mov	 ecx, OFFSET _DisconnectImmediately

; 727  : 		break;

  0023e	e9 5d ff ff ff	 jmp	 $LN114@setIniFile
$LN6@setIniFile:

; 728  : 
; 729  : 	case INI_PARAM_RPC_NDR64:
; 730  : 		success = getIniFileArgumentBool(&UseServerRpcNDR64, iniarg);

  00243	b9 00 00 00 00	 mov	 ecx, OFFSET _UseServerRpcNDR64

; 731  : 		break;

  00248	e9 53 ff ff ff	 jmp	 $LN114@setIniFile
$LN5@setIniFile:

; 732  : 
; 733  : 	case INI_PARAM_RPC_BTFN:
; 734  : 		success = getIniFileArgumentBool(&UseServerRpcBTFN, iniarg);

  0024d	b9 00 00 00 00	 mov	 ecx, OFFSET _UseServerRpcBTFN

; 735  : 		break;

  00252	e9 49 ff ff ff	 jmp	 $LN114@setIniFile
$LN4@setIniFile:

; 736  : 
; 737  : #	endif // USE_MSRPC
; 738  : 
; 739  : #	ifndef NO_SOCKETS
; 740  : 
; 741  : 	case INI_PARAM_EXIT_LEVEL:
; 742  : 		success = getIniFileArgumentInt(&result, iniarg, 0, 1);

  00257	8d 45 fc	 lea	 eax, DWORD PTR _tempResult$2[ebp]
  0025a	33 d2		 xor	 edx, edx
  0025c	50		 push	 eax
  0025d	53		 push	 ebx
  0025e	8b ce		 mov	 ecx, esi
  00260	e8 00 00 00 00	 call	 _stringToInt
  00265	59		 pop	 ecx
  00266	59		 pop	 ecx
  00267	85 c0		 test	 eax, eax
  00269	75 0b		 jne	 SHORT $LN95@setIniFile
  0026b	8b d3		 mov	 edx, ebx
  0026d	33 c9		 xor	 ecx, ecx
  0026f	e8 00 00 00 00	 call	 _getIniFileArgumentInt
  00274	8b d8		 mov	 ebx, eax
$LN95@setIniFile:
  00276	8b 45 fc	 mov	 eax, DWORD PTR _tempResult$2[ebp]

; 743  : 		if (success) ExitLevel = (int_fast8_t)result;

  00279	85 db		 test	 ebx, ebx
  0027b	0f 84 8d fe ff
	ff		 je	 $LN101@setIniFile
  00281	a2 00 00 00 00	 mov	 BYTE PTR _ExitLevel, al

; 744  : 		break;

  00286	e9 83 fe ff ff	 jmp	 $LN101@setIniFile
$LN2@setIniFile:

; 745  : 
; 746  : #	endif // NO_SOCKETS
; 747  : 
; 748  : #	if HAVE_FREEBIND
; 749  : 
; 750  : 	case INI_PARAM_FREEBIND:
; 751  : 		success = getIniFileArgumentBool(&freebind, iniarg);
; 752  : 		break;
; 753  : 
; 754  : #	endif // HAVE_FREEBIND
; 755  : 
; 756  : #	if !defined(NO_PRIVATE_IP_DETECT)
; 757  : 
; 758  : 	case INI_PARAM_PUBLIC_IP_PROTECTION_LEVEL:
; 759  : 		success = getIniFileArgumentInt(&PublicIPProtectionLevel, iniarg, 0, 3);

  0028b	8d 45 fc	 lea	 eax, DWORD PTR _tempResult$1[ebp]
  0028e	33 d2		 xor	 edx, edx
  00290	50		 push	 eax
  00291	6a 03		 push	 3
  00293	8b ce		 mov	 ecx, esi
  00295	e8 00 00 00 00	 call	 _stringToInt
  0029a	59		 pop	 ecx
  0029b	59		 pop	 ecx
  0029c	85 c0		 test	 eax, eax
  0029e	75 11		 jne	 SHORT $LN100@setIniFile
$LN108@setIniFile:
  002a0	6a 03		 push	 3
  002a2	5a		 pop	 edx
  002a3	33 c9		 xor	 ecx, ecx
$LN107@setIniFile:
  002a5	e8 00 00 00 00	 call	 _getIniFileArgumentInt
$LN106@setIniFile:
  002aa	8b d8		 mov	 ebx, eax
  002ac	e9 5d fe ff ff	 jmp	 $LN101@setIniFile
$LN100@setIniFile:
  002b1	8b 45 fc	 mov	 eax, DWORD PTR _tempResult$1[ebp]
  002b4	a3 00 00 00 00	 mov	 DWORD PTR _PublicIPProtectionLevel, eax

; 775  : 	}
; 776  : 
; 777  : 	return success;

  002b9	e9 50 fe ff ff	 jmp	 $LN101@setIniFile
$LN1@setIniFile:

; 760  : 
; 761  : #		if !HAVE_GETIFADDR
; 762  : 		if (PublicIPProtectionLevel & 1)
; 763  : 		{
; 764  : 			IniFileErrorMessage = "Must be 0 or 2";
; 765  : 			success = FALSE;
; 766  : 		}
; 767  : #		endif // !HAVE_GETIFADDR
; 768  : 
; 769  : 		break;
; 770  : 
; 771  : #	endif // !defined(NO_PRIVATE_IP_DETECT)
; 772  : 
; 773  : 	default:
; 774  : 		return FALSE;

  002be	33 c0		 xor	 eax, eax
$LN36@setIniFile:

; 778  : }

  002c0	5f		 pop	 edi
  002c1	5e		 pop	 esi
  002c2	5b		 pop	 ebx
  002c3	8b e5		 mov	 esp, ebp
  002c5	5d		 pop	 ebp
  002c6	c3		 ret	 0
$LN115@setIniFile:

; 562  : 
; 563  : #	ifndef NO_TAP
; 564  : 
; 565  : 	case INI_PARAM_VPN:
; 566  : 		tapArgument = (char*)vlmcsd_strdup(iniarg);

  002c7	e8 00 00 00 00	 call	 _OutOfMemory
$LN118@setIniFile:
$LN105@setIniFile:
$LN117@setIniFile:

; 778  : }

  002cc	00 00 00 00	 DD	 $LN25@setIniFile
  002d0	00 00 00 00	 DD	 $LN27@setIniFile
  002d4	00 00 00 00	 DD	 $LN22@setIniFile
  002d8	00 00 00 00	 DD	 $LN21@setIniFile
  002dc	00 00 00 00	 DD	 $LN9@setIniFile
  002e0	00 00 00 00	 DD	 $LN20@setIniFile
  002e4	00 00 00 00	 DD	 $LN14@setIniFile
  002e8	00 00 00 00	 DD	 $LN12@setIniFile
  002ec	00 00 00 00	 DD	 $LN11@setIniFile
  002f0	00 00 00 00	 DD	 $LN10@setIniFile
  002f4	00 00 00 00	 DD	 $LN7@setIniFile
  002f8	00 00 00 00	 DD	 $LN1@setIniFile
  002fc	00 00 00 00	 DD	 $LN1@setIniFile
  00300	00 00 00 00	 DD	 $LN23@setIniFile
  00304	00 00 00 00	 DD	 $LN6@setIniFile
  00308	00 00 00 00	 DD	 $LN5@setIniFile
  0030c	00 00 00 00	 DD	 $LN1@setIniFile
  00310	00 00 00 00	 DD	 $LN2@setIniFile
  00314	00 00 00 00	 DD	 $LN13@setIniFile
  00318	00 00 00 00	 DD	 $LN33@setIniFile
  0031c	00 00 00 00	 DD	 $LN32@setIniFile
  00320	00 00 00 00	 DD	 $LN31@setIniFile
  00324	00 00 00 00	 DD	 $LN30@setIniFile
  00328	00 00 00 00	 DD	 $LN18@setIniFile
  0032c	00 00 00 00	 DD	 $LN17@setIniFile
  00330	00 00 00 00	 DD	 $LN16@setIniFile
  00334	00 00 00 00	 DD	 $LN15@setIniFile
  00338	00 00 00 00	 DD	 $LN19@setIniFile
  0033c	00 00 00 00	 DD	 $LN28@setIniFile
  00340	00 00 00 00	 DD	 $LN4@setIniFile
  00344	00 00 00 00	 DD	 $LN29@setIniFile
_setIniFileParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _getIniFileArgument
_TEXT	SEGMENT
_getIniFileArgument PROC				; COMDAT
; _s$ = ecx

; 782  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 783  : 	while (!isspace((int)**s) && **s != '=' && **s) (*s)++;

  00003	8b 06		 mov	 eax, DWORD PTR [esi]
  00005	eb 11		 jmp	 SHORT $LN13@getIniFile
$LL4@getIniFile:
  00007	8b 0e		 mov	 ecx, DWORD PTR [esi]
  00009	8a 01		 mov	 al, BYTE PTR [ecx]
  0000b	3c 3d		 cmp	 al, 61			; 0000003dH
  0000d	74 18		 je	 SHORT $LN11@getIniFile
  0000f	84 c0		 test	 al, al
  00011	74 14		 je	 SHORT $LN11@getIniFile
  00013	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00016	89 06		 mov	 DWORD PTR [esi], eax
$LN13@getIniFile:
  00018	0f be 00	 movsx	 eax, BYTE PTR [eax]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__isspace
  00022	59		 pop	 ecx
  00023	85 c0		 test	 eax, eax
  00025	74 e0		 je	 SHORT $LL4@getIniFile
$LN11@getIniFile:

; 784  : 	iniFileLineNextWord(s);

  00027	8b ce		 mov	 ecx, esi
  00029	e8 00 00 00 00	 call	 _iniFileLineNextWord

; 785  : 
; 786  : 	if (*((*s)++) != '=')

  0002e	8b 06		 mov	 eax, DWORD PTR [esi]
  00030	8a 08		 mov	 cl, BYTE PTR [eax]
  00032	40		 inc	 eax
  00033	89 06		 mov	 DWORD PTR [esi], eax
  00035	80 f9 3d	 cmp	 cl, 61			; 0000003dH
  00038	74 0e		 je	 SHORT $LN2@getIniFile

; 787  : 	{
; 788  : 		IniFileErrorMessage = "'=' required after keyword.";

  0003a	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _IniFileErrorMessage, OFFSET ??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4?$AA@
$LN14@getIniFile:

; 789  : 		return FALSE;

  00044	33 c0		 xor	 eax, eax
  00046	5e		 pop	 esi

; 801  : }

  00047	c3		 ret	 0
$LN2@getIniFile:

; 790  : 	}
; 791  : 
; 792  : 	iniFileLineNextWord(s);

  00048	8b ce		 mov	 ecx, esi
  0004a	e8 00 00 00 00	 call	 _iniFileLineNextWord

; 793  : 
; 794  : 	if (!**s)

  0004f	8b 06		 mov	 eax, DWORD PTR [esi]
  00051	80 38 00	 cmp	 BYTE PTR [eax], 0
  00054	75 0c		 jne	 SHORT $LN1@getIniFile

; 795  : 	{
; 796  : 		IniFileErrorMessage = "missing argument after '='.";

  00056	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _IniFileErrorMessage, OFFSET ??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4?$AA@

; 797  : 		return FALSE;

  00060	eb e2		 jmp	 SHORT $LN14@getIniFile
$LN1@getIniFile:

; 798  : 	}
; 799  : 
; 800  : 	return TRUE;

  00062	33 c0		 xor	 eax, eax
  00064	40		 inc	 eax
  00065	5e		 pop	 esi

; 801  : }

  00066	c3		 ret	 0
_getIniFileArgument ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _handleIniFileParameter
_TEXT	SEGMENT
_s$ = -4						; size = 4
_handleIniFileParameter PROC				; COMDAT
; _s$ = ecx

; 805  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	8b f1		 mov	 esi, ecx

; 806  : 	uint_fast8_t i;
; 807  : 
; 808  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  00008	32 db		 xor	 bl, bl
  0000a	57		 push	 edi
  0000b	89 75 fc	 mov	 DWORD PTR _s$[ebp], esi
$LL6@handleIniF:

; 809  : 	{
; 810  : 		if (strncasecmp(IniFileParameterList[i].Name, s, strlen(IniFileParameterList[i].Name))) continue;

  0000e	0f b6 c3	 movzx	 eax, bl
  00011	8b 14 c5 00 00
	00 00		 mov	 edx, DWORD PTR _IniFileParameterList[eax*8]
  00018	8b ca		 mov	 ecx, edx
  0001a	8d 79 01	 lea	 edi, DWORD PTR [ecx+1]
$LL13@handleIniF:
  0001d	8a 01		 mov	 al, BYTE PTR [ecx]
  0001f	41		 inc	 ecx
  00020	84 c0		 test	 al, al
  00022	75 f9		 jne	 SHORT $LL13@handleIniF
  00024	2b cf		 sub	 ecx, edi
  00026	51		 push	 ecx
  00027	56		 push	 esi
  00028	52		 push	 edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strnicmp
  0002f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00032	85 c0		 test	 eax, eax
  00034	74 13		 je	 SHORT $LN3@handleIniF

; 806  : 	uint_fast8_t i;
; 807  : 
; 808  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  00036	fe c3		 inc	 bl
  00038	80 fb 1c	 cmp	 bl, 28			; 0000001cH
  0003b	72 d1		 jb	 SHORT $LL6@handleIniF

; 816  : 	}
; 817  : 
; 818  : 	IniFileErrorMessage = "Unknown keyword.";

  0003d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _IniFileErrorMessage, OFFSET ??_C@_0BB@MJCPHOFN@Unknown?5keyword?4?$AA@

; 819  : 	return FALSE;

  00047	eb 1e		 jmp	 SHORT $LN14@handleIniF
$LN3@handleIniF:

; 811  : 		if (!IniFileParameterList[i].Id) return TRUE;

  00049	0f b6 f3	 movzx	 esi, bl
  0004c	80 3c f5 04 00
	00 00 00	 cmp	 BYTE PTR _IniFileParameterList[esi*8+4], 0
  00054	75 05		 jne	 SHORT $LN2@handleIniF
  00056	33 c0		 xor	 eax, eax
  00058	40		 inc	 eax
  00059	eb 1f		 jmp	 SHORT $LN7@handleIniF
$LN2@handleIniF:

; 812  : 
; 813  : 		if (!getIniFileArgument(&s)) return FALSE;

  0005b	8d 4d fc	 lea	 ecx, DWORD PTR _s$[ebp]
  0005e	e8 00 00 00 00	 call	 _getIniFileArgument
  00063	85 c0		 test	 eax, eax
  00065	75 04		 jne	 SHORT $LN1@handleIniF
$LN14@handleIniF:
  00067	33 c0		 xor	 eax, eax
  00069	eb 0f		 jmp	 SHORT $LN7@handleIniF
$LN1@handleIniF:

; 814  : 
; 815  : 		return setIniFileParameter(IniFileParameterList[i].Id, s);

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0006e	8a 0c f5 04 00
	00 00		 mov	 cl, BYTE PTR _IniFileParameterList[esi*8+4]
  00075	e8 00 00 00 00	 call	 _setIniFileParameter
$LN7@handleIniF:

; 820  : }

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c3		 ret	 0
_handleIniFileParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _setupListeningSocketsFromIniFile
_TEXT	SEGMENT
_s$ = -4						; size = 4
_setupListeningSocketsFromIniFile PROC			; COMDAT
; _s$ = ecx

; 825  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 826  : 	if (!maxsockets) return TRUE;

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _maxsockets, 0
  0000b	89 4d fc	 mov	 DWORD PTR _s$[ebp], ecx
  0000e	75 05		 jne	 SHORT $LN3@setupListe
$LN6@setupListe:
  00010	33 c0		 xor	 eax, eax
  00012	40		 inc	 eax
  00013	eb 4f		 jmp	 SHORT $LN4@setupListe
$LN3@setupListe:

; 827  : 	if (strncasecmp("Listen", s, 6)) return TRUE;

  00015	6a 06		 push	 6
  00017	51		 push	 ecx
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_06CBIOIDCI@Listen?$AA@
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strnicmp
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH
  00026	85 c0		 test	 eax, eax
  00028	75 e6		 jne	 SHORT $LN6@setupListe

; 828  : 	if (!getIniFileArgument(&s)) return TRUE;

  0002a	8d 4d fc	 lea	 ecx, DWORD PTR _s$[ebp]
  0002d	e8 00 00 00 00	 call	 _getIniFileArgument
  00032	85 c0		 test	 eax, eax
  00034	74 da		 je	 SHORT $LN6@setupListe

; 829  : 
; 830  : 	vlmcsd_snprintf(IniFileErrorBuffer, INIFILE_ERROR_BUFFERSIZE, "Cannot listen on %s.", s);

  00036	ff 75 fc	 push	 DWORD PTR _s$[ebp]
  00039	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4?$AA@
  0003e	68 00 01 00 00	 push	 256			; 00000100H
  00043	ff 35 00 00 00
	00		 push	 DWORD PTR _IniFileErrorBuffer
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf

; 831  : 	IniFileErrorMessage = IniFileErrorBuffer;

  0004f	a1 00 00 00 00	 mov	 eax, DWORD PTR _IniFileErrorBuffer
  00054	83 c4 10	 add	 esp, 16			; 00000010H

; 832  : 	return addListeningSocket(s);

  00057	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0005a	a3 00 00 00 00	 mov	 DWORD PTR _IniFileErrorMessage, eax
  0005f	e8 00 00 00 00	 call	 _addListeningSocket
$LN4@setupListe:

; 833  : }

  00064	8b e5		 mov	 esp, ebp
  00066	5d		 pop	 ebp
  00067	c3		 ret	 0
_setupListeningSocketsFromIniFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _readIniFile
_TEXT	SEGMENT
_lineNumber$1$ = -272					; size = 4
_s$ = -268						; size = 4
_line$ = -260						; size = 256
_readIniFile PROC					; COMDAT
; _pass$ = cl

; 838  : {

  00000	81 ec 14 01 00
	00		 sub	 esp, 276		; 00000114H
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi

; 839  : 	char  line[256];
; 840  : 	const char *s;
; 841  : 	unsigned int lineNumber;
; 842  : 	uint_fast8_t lineParseError;
; 843  : 
; 844  : 	FILE *restrict f;
; 845  : 	BOOL result = TRUE;
; 846  : 
; 847  : 	IniFileErrorBuffer = (char*)vlmcsd_malloc(INIFILE_ERROR_BUFFERSIZE);

  0000a	bd 00 01 00 00	 mov	 ebp, 256		; 00000100H
  0000f	33 f6		 xor	 esi, esi
  00011	55		 push	 ebp
  00012	8a d9		 mov	 bl, cl
  00014	46		 inc	 esi
  00015	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0001b	59		 pop	 ecx
  0001c	85 c0		 test	 eax, eax
  0001e	0f 84 3e 01 00
	00		 je	 $LN30@readIniFil

; 848  : 
; 849  : 	if (!((f = fopen(fn_ini, "r")))) return FALSE;

  00024	68 00 00 00 00	 push	 OFFSET ??_C@_01KDCPPGHE@r?$AA@
  00029	ff 35 00 00 00
	00		 push	 DWORD PTR _fn_ini
  0002f	a3 00 00 00 00	 mov	 DWORD PTR _IniFileErrorBuffer, eax
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0003a	8b f8		 mov	 edi, eax
  0003c	59		 pop	 ecx
  0003d	59		 pop	 ecx
  0003e	85 ff		 test	 edi, edi
  00040	75 07		 jne	 SHORT $LN15@readIniFil
$LN6@readIniFil:
  00042	33 c0		 xor	 eax, eax
  00044	e9 0e 01 00 00	 jmp	 $LN16@readIniFil
$LN15@readIniFil:

; 850  : 
; 851  : 	for (lineNumber = 1; (s = fgets(line, sizeof(line), f)); lineNumber++)

  00049	57		 push	 edi
  0004a	8d 44 24 24	 lea	 eax, DWORD PTR _line$[esp+296]
  0004e	89 74 24 18	 mov	 DWORD PTR _lineNumber$1$[esp+296], esi
  00052	55		 push	 ebp
  00053	50		 push	 eax
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgets
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005d	89 44 24 18	 mov	 DWORD PTR _s$[esp+292], eax
  00061	85 c0		 test	 eax, eax
  00063	0f 84 9b 00 00
	00		 je	 $LN27@readIniFil
  00069	8d 6c 24 20	 lea	 ebp, DWORD PTR _line$[esp+292]
$LL14@readIniFil:

; 852  : 	{
; 853  : 		line[strlen(line) - 1] = 0;

  0006d	8d 4c 24 20	 lea	 ecx, DWORD PTR _line$[esp+292]
  00071	8d 51 01	 lea	 edx, DWORD PTR [ecx+1]
$LL28@readIniFil:
  00074	8a 01		 mov	 al, BYTE PTR [ecx]
  00076	41		 inc	 ecx
  00077	84 c0		 test	 al, al
  00079	75 f9		 jne	 SHORT $LL28@readIniFil
  0007b	2b ca		 sub	 ecx, edx
  0007d	88 44 29 ff	 mov	 BYTE PTR [ecx+ebp-1], al

; 854  : 
; 855  : 		iniFileLineNextWord(&s);

  00081	8d 4c 24 18	 lea	 ecx, DWORD PTR _s$[esp+292]
  00085	e8 00 00 00 00	 call	 _iniFileLineNextWord

; 856  : 		if (*s == ';' || *s == '#' || !*s) continue;

  0008a	8b 4c 24 18	 mov	 ecx, DWORD PTR _s$[esp+292]
  0008e	8a 01		 mov	 al, BYTE PTR [ecx]
  00090	3c 3b		 cmp	 al, 59			; 0000003bH
  00092	74 4c		 je	 SHORT $LN13@readIniFil
  00094	3c 23		 cmp	 al, 35			; 00000023H
  00096	74 48		 je	 SHORT $LN13@readIniFil
  00098	84 c0		 test	 al, al
  0009a	74 44		 je	 SHORT $LN13@readIniFil

; 857  : 
; 858  : #		ifndef NO_SOCKETS
; 859  : 		if (pass == INI_FILE_PASS_1)

  0009c	80 fb 01	 cmp	 bl, 1
  0009f	75 0b		 jne	 SHORT $LN9@readIniFil

; 860  : #		endif // NO_SOCKETS
; 861  : 		{
; 862  : 			if (handleIniFileParameter(s)) continue;

  000a1	e8 00 00 00 00	 call	 _handleIniFileParameter
  000a6	85 c0		 test	 eax, eax
  000a8	75 36		 jne	 SHORT $LN13@readIniFil

; 863  : 
; 864  : 			lineParseError = TRUE;/*!checkGuidInIniFileLine(&s, &appIndex) ||

  000aa	eb 12		 jmp	 SHORT $LN26@readIniFil
$LN9@readIniFil:

; 865  : 					!setEpidFromIniFileLine(&s, appIndex) ||
; 866  : 					!setHwIdFromIniFileLine(&s, appIndex);*/
; 867  : 		}
; 868  : #		if !defined(NO_SOCKETS) && !defined(SIMPLE_SOCKETS) && !defined(USE_MSRPC)
; 869  : 		else if (pass == INI_FILE_PASS_2)

  000ac	80 fb 02	 cmp	 bl, 2
  000af	75 91		 jne	 SHORT $LN6@readIniFil

; 870  : 		{
; 871  : 			lineParseError = !setupListeningSocketsFromIniFile(s);

  000b1	e8 00 00 00 00	 call	 _setupListeningSocketsFromIniFile
  000b6	f7 d8		 neg	 eax
  000b8	1a c0		 sbb	 al, al
  000ba	fe c0		 inc	 al

; 872  : 		}
; 873  : 		else
; 874  : 		{
; 875  : 			return FALSE;
; 876  : 		}
; 877  : #		endif // !defined(NO_SOCKETS) &&  && !defined(SIMPLE_SOCKETS) && !defined(USE_MSRPC)
; 878  : 
; 879  : 		if (lineParseError)

  000bc	74 22		 je	 SHORT $LN13@readIniFil
$LN26@readIniFil:

; 880  : 		{
; 881  : 			printerrorf("Warning: %s line %u: \"%s\". %s\n", fn_ini, lineNumber, line, IniFileErrorMessage);

  000be	ff 35 00 00 00
	00		 push	 DWORD PTR _IniFileErrorMessage
  000c4	8d 44 24 24	 lea	 eax, DWORD PTR _line$[esp+296]
  000c8	50		 push	 eax
  000c9	ff 74 24 1c	 push	 DWORD PTR _lineNumber$1$[esp+300]
  000cd	ff 35 00 00 00
	00		 push	 DWORD PTR _fn_ini
  000d3	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6?$AA@
  000d8	e8 00 00 00 00	 call	 _printerrorf
  000dd	83 c4 14	 add	 esp, 20			; 00000014H
$LN13@readIniFil:

; 850  : 
; 851  : 	for (lineNumber = 1; (s = fgets(line, sizeof(line), f)); lineNumber++)

  000e0	ff 44 24 14	 inc	 DWORD PTR _lineNumber$1$[esp+292]
  000e4	8d 44 24 20	 lea	 eax, DWORD PTR _line$[esp+292]
  000e8	57		 push	 edi
  000e9	68 00 01 00 00	 push	 256			; 00000100H
  000ee	50		 push	 eax
  000ef	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fgets
  000f5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f8	89 44 24 18	 mov	 DWORD PTR _s$[esp+292], eax
  000fc	85 c0		 test	 eax, eax
  000fe	0f 85 69 ff ff
	ff		 jne	 $LL14@readIniFil
$LN27@readIniFil:

; 882  : 			continue;
; 883  : 		}
; 884  : 	}
; 885  : 
; 886  : 	if (ferror(f)) result = FALSE;

  00104	57		 push	 edi
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ferror
  0010b	59		 pop	 ecx

; 887  : 
; 888  : 	free(IniFileErrorBuffer);

  0010c	ff 35 00 00 00
	00		 push	 DWORD PTR _IniFileErrorBuffer
  00112	33 c9		 xor	 ecx, ecx
  00114	85 c0		 test	 eax, eax
  00116	0f 45 f1	 cmovne	 esi, ecx
  00119	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0011f	59		 pop	 ecx

; 889  : 	fclose(f);

  00120	57		 push	 edi
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00127	59		 pop	 ecx

; 890  : 
; 891  : #	if !defined(NO_SOCKETS) && !defined(NO_LOG)
; 892  : 
; 893  : 	if (pass == INI_FILE_PASS_1 && !InetdMode && result)

  00128	80 fb 01	 cmp	 bl, 1
  0012b	75 28		 jne	 SHORT $LN1@readIniFil
  0012d	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  00134	75 1f		 jne	 SHORT $LN1@readIniFil
  00136	85 f6		 test	 esi, esi
  00138	74 1b		 je	 SHORT $LN1@readIniFil

; 894  : 	{
; 895  : #		ifdef _NTSERVICE
; 896  : 		if (!installService)

  0013a	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _installService, 0
  00141	75 12		 jne	 SHORT $LN1@readIniFil

; 897  : #		endif // _NTSERVICE
; 898  : 			logger("Read ini file %s\n", fn_ini);

  00143	ff 35 00 00 00
	00		 push	 DWORD PTR _fn_ini
  00149	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6?$AA@
  0014e	e8 00 00 00 00	 call	 _logger
  00153	59		 pop	 ecx
  00154	59		 pop	 ecx
$LN1@readIniFil:

; 899  : 	}
; 900  : 
; 901  : #	endif // !defined(NO_SOCKETS) && !defined(NO_LOG)
; 902  : 
; 903  : 	return result;

  00155	8b c6		 mov	 eax, esi
$LN16@readIniFil:

; 904  : }

  00157	5f		 pop	 edi
  00158	5e		 pop	 esi
  00159	5d		 pop	 ebp
  0015a	5b		 pop	 ebx
  0015b	81 c4 14 01 00
	00		 add	 esp, 276		; 00000114H
  00161	c3		 ret	 0
$LN30@readIniFil:

; 839  : 	char  line[256];
; 840  : 	const char *s;
; 841  : 	unsigned int lineNumber;
; 842  : 	uint_fast8_t lineParseError;
; 843  : 
; 844  : 	FILE *restrict f;
; 845  : 	BOOL result = TRUE;
; 846  : 
; 847  : 	IniFileErrorBuffer = (char*)vlmcsd_malloc(INIFILE_ERROR_BUFFERSIZE);

  00162	e8 00 00 00 00	 call	 _OutOfMemory
$LN32@readIniFil:
$LN29@readIniFil:
  00167	cc		 int	 3
_readIniFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _terminationHandler
_TEXT	SEGMENT
_fdwCtrlType$ = 8					; size = 4
_terminationHandler PROC				; COMDAT

; 1025 : 	// What a lame substitute for Unix signal handling
; 1026 : 	switch (fdwCtrlType)

  00000	8b 44 24 04	 mov	 eax, DWORD PTR _fdwCtrlType$[esp-4]
  00004	83 f8 02	 cmp	 eax, 2
  00007	76 0b		 jbe	 SHORT $LN2@terminatio
  00009	83 c0 fb	 add	 eax, -5			; fffffffbH
  0000c	83 f8 01	 cmp	 eax, 1
  0000f	76 03		 jbe	 SHORT $LN2@terminatio

; 1035 : 	default:
; 1036 : 		return FALSE;

  00011	33 c0		 xor	 eax, eax

; 1037 : 	}
; 1038 : }

  00013	c3		 ret	 0
$LN2@terminatio:

; 1027 : 	{
; 1028 : 	case CTRL_C_EVENT:
; 1029 : 	case CTRL_CLOSE_EVENT:
; 1030 : 	case CTRL_BREAK_EVENT:
; 1031 : 	case CTRL_LOGOFF_EVENT:
; 1032 : 	case CTRL_SHUTDOWN_EVENT:
; 1033 : 		cleanup();
; 1034 : 		exit(0);

  00014	e8 00 00 00 00	 call	 _cleanup
  00019	6a 00		 push	 0
  0001b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN9@terminatio:
$LN8@terminatio:
  00021	cc		 int	 3
_terminationHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _daemonizeAndSetSignalAction
_TEXT	SEGMENT
_daemonizeAndSetSignalAction PROC			; COMDAT

; 1043 : 	if (!SetConsoleCtrlHandler((PHANDLER_ROUTINE)terminationHandler, TRUE))

  00000	6a 01		 push	 1
  00002	68 00 00 00 00	 push	 OFFSET _terminationHandler
  00007	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetConsoleCtrlHandler@8
  0000d	85 c0		 test	 eax, eax
  0000f	75 13		 jne	 SHORT $LN1@daemonizeA

; 1044 : 	{
; 1045 : #ifndef NO_LOG
; 1046 : 		DWORD rc = GetLastError();

  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0

; 1047 : 		logger("Warning: Could not register Windows signal handler: Error %u\n", rc);

  00017	50		 push	 eax
  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Wind@
  0001d	e8 00 00 00 00	 call	 _logger
  00022	59		 pop	 ecx
  00023	59		 pop	 ecx
$LN1@daemonizeA:

; 1048 : #endif // NO_LOG
; 1049 : 	}
; 1050 : 
; 1051 : 	return ERROR_SUCCESS;

  00024	33 c0		 xor	 eax, eax

; 1052 : }

  00026	c3		 ret	 0
_daemonizeAndSetSignalAction ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _getCommandLineArg
_TEXT	SEGMENT
_getCommandLineArg PROC					; COMDAT
; _arg$dead$ = ecx

; 1061 : {

  00000	51		 push	 ecx

; 1062 : #	if !__CYGWIN__ || defined(USE_THREADS) || defined(NO_SOCKETS)
; 1063 : 	return arg;

  00001	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg

; 1064 : #	else
; 1065 : 	if (!IsNTService) return arg;
; 1066 : 
; 1067 : 	return vlmcsd_strdup(arg);
; 1068 : #	endif
; 1069 : }

  00006	59		 pop	 ecx
  00007	c3		 ret	 0
_getCommandLineArg ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _parseGeneralArguments
_TEXT	SEGMENT
_parseGeneralArguments PROC				; COMDAT

; 1073 : static void parseGeneralArguments() {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1074 : 	int o;
; 1075 : 
; 1076 : #ifndef NO_CL_PIDS
; 1077 : 	BYTE* HwId;
; 1078 : #endif // NO_CL_PIDS
; 1079 : 
; 1080 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  00005	33 ff		 xor	 edi, edi
  00007	51		 push	 ecx
  00008	89 3d 00 00 00
	00		 mov	 DWORD PTR _opterr, edi
  0000e	e8 00 00 00 00	 call	 _getopt
  00013	8b d8		 mov	 ebx, eax
  00015	59		 pop	 ecx
  00016	85 db		 test	 ebx, ebx
  00018	0f 8e 9e 04 00
	00		 jle	 $LN55@parseGener
  0001e	bd 00 00 00 00	 mov	 ebp, OFFSET ??_C@_0N@BACOLJMI@command?5line?$AA@
$LL56@parseGener:
  00023	83 fb 55	 cmp	 ebx, 85			; 00000055H
  00026	0f 8f 42 02 00
	00		 jg	 $LN59@parseGener
  0002c	0f 84 2d 02 00
	00		 je	 $LN31@parseGener
  00032	83 fb 48	 cmp	 ebx, 72			; 00000048H
  00035	0f 8f 41 01 00
	00		 jg	 $LN60@parseGener
  0003b	0f 84 ff 00 00
	00		 je	 $LN46@parseGener
  00041	83 fb 42	 cmp	 ebx, 66			; 00000042H
  00044	0f 8f 8e 00 00
	00		 jg	 $LN61@parseGener
  0004a	74 6d		 je	 SHORT $LN8@parseGener
  0004c	83 fb 30	 cmp	 ebx, 48			; 00000030H
  0004f	74 52		 je	 SHORT $LN50@parseGener
  00051	83 fb 33	 cmp	 ebx, 51			; 00000033H
  00054	74 37		 je	 SHORT $LN49@parseGener
  00056	83 fb 36	 cmp	 ebx, 54			; 00000036H
  00059	74 1c		 je	 SHORT $LN48@parseGener
  0005b	83 fb 41	 cmp	 ebx, 65			; 00000041H
  0005e	0f 85 86 04 00
	00		 jne	 $LN113@parseGener

; 1379 : 
; 1380 : 	case 'A':
; 1381 : 		VLActivationInterval = getTimeSpanFromCommandLine(optarg, (char)o);

  00064	8a d3		 mov	 dl, bl
  00066	e8 00 00 00 00	 call	 _getTimeSpanFromCommandLine
  0006b	a3 00 00 00 00	 mov	 DWORD PTR _VLActivationInterval, eax

; 1382 : 		ignoreIniFileParameter(INI_PARAM_ACTIVATION_INTERVAL);

  00070	b1 09		 mov	 cl, 9

; 1383 : 		break;

  00072	e9 2f 04 00 00	 jmp	 $LN111@parseGener
$LN48@parseGener:

; 1120 : 
; 1121 : 	case '6':
; 1122 : 		KmsResponseParameters[EPID_INDEX_OFFICE2016].Epid = getCommandLineArg(optarg);

  00077	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KmsResponseParameters
  0007d	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg
  00082	89 41 24	 mov	 DWORD PTR [ecx+36], eax

; 1123 : #		ifndef NO_LOG
; 1124 : 		KmsResponseParameters[EPID_INDEX_OFFICE2016].EpidSource = "command line";

  00085	89 69 2c	 mov	 DWORD PTR [ecx+44], ebp

; 1125 : #		endif // NO_LOG
; 1126 : 		break;

  00088	e9 1e 04 00 00	 jmp	 $LN53@parseGener
$LN49@parseGener:

; 1113 : 
; 1114 : 	case '3':
; 1115 : 		KmsResponseParameters[EPID_INDEX_OFFICE2013].Epid = getCommandLineArg(optarg);

  0008d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KmsResponseParameters
  00093	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg
  00098	89 41 18	 mov	 DWORD PTR [ecx+24], eax

; 1116 : #		ifndef NO_LOG
; 1117 : 		KmsResponseParameters[EPID_INDEX_OFFICE2013].EpidSource = "command line";

  0009b	89 69 20	 mov	 DWORD PTR [ecx+32], ebp

; 1118 : #		endif // NO_LOG
; 1119 : 		break;

  0009e	e9 08 04 00 00	 jmp	 $LN53@parseGener
$LN50@parseGener:

; 1106 : 
; 1107 : 	case '0':
; 1108 : 		KmsResponseParameters[EPID_INDEX_OFFICE2010].Epid = getCommandLineArg(optarg);

  000a3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KmsResponseParameters
  000a9	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg
  000ae	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 1109 : #		ifndef NO_LOG
; 1110 : 		KmsResponseParameters[EPID_INDEX_OFFICE2010].EpidSource = "command line";

  000b1	89 69 14	 mov	 DWORD PTR [ecx+20], ebp

; 1111 : #		endif // NO_LOG
; 1112 : 		break;

  000b4	e9 f2 03 00 00	 jmp	 $LN53@parseGener
$LN8@parseGener:

; 1398 : 
; 1399 : 	case 'B':
; 1400 : 		if (!getArgumentBool(&UseServerRpcBTFN, optarg)) usage();

  000b9	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optarg
  000bf	b9 00 00 00 00	 mov	 ecx, OFFSET _UseServerRpcBTFN
  000c4	e8 00 00 00 00	 call	 _getArgumentBool
  000c9	85 c0		 test	 eax, eax
  000cb	0f 84 19 04 00
	00		 je	 $LN113@parseGener

; 1401 : 		ignoreIniFileParameter(INI_PARAM_RPC_BTFN);

  000d1	b1 10		 mov	 cl, 16			; 00000010H

; 1402 : 		break;

  000d3	e9 ce 03 00 00	 jmp	 $LN111@parseGener
$LN61@parseGener:

; 1074 : 	int o;
; 1075 : 
; 1076 : #ifndef NO_CL_PIDS
; 1077 : 	BYTE* HwId;
; 1078 : #endif // NO_CL_PIDS
; 1079 : 
; 1080 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  000d8	83 eb 43	 sub	 ebx, 67			; 00000043H
  000db	74 47		 je	 SHORT $LN14@parseGener
  000dd	4b		 dec	 ebx
  000de	0f 84 c7 03 00
	00		 je	 $LN53@parseGener
  000e4	4b		 dec	 ebx
  000e5	74 1e		 je	 SHORT $LN21@parseGener
  000e7	4b		 dec	 ebx
  000e8	4b		 dec	 ebx
  000e9	0f 85 fb 03 00
	00		 jne	 $LN113@parseGener

; 1127 : 
; 1128 : 	case 'G':
; 1129 : 		KmsResponseParameters[EPID_INDEX_WINCHINAGOV].Epid = getCommandLineArg(optarg);

  000ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KmsResponseParameters
  000f5	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg
  000fa	89 41 30	 mov	 DWORD PTR [ecx+48], eax

; 1130 : #		ifndef NO_LOG
; 1131 : 		KmsResponseParameters[EPID_INDEX_WINCHINAGOV].EpidSource = "command line";

  000fd	89 69 38	 mov	 DWORD PTR [ecx+56], ebp

; 1132 : #		endif // NO_LOG
; 1133 : 		break;

  00100	e9 a6 03 00 00	 jmp	 $LN53@parseGener
$LN21@parseGener:

; 1291 : 
; 1292 : #	ifndef NO_CLIENT_LIST
; 1293 : 	case 'E':
; 1294 : 		if (!getArgumentBool(&StartEmpty, optarg)) usage();

  00105	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optarg
  0010b	b9 00 00 00 00	 mov	 ecx, OFFSET _StartEmpty
  00110	e8 00 00 00 00	 call	 _getArgumentBool
  00115	85 c0		 test	 eax, eax
  00117	0f 84 cd 03 00
	00		 je	 $LN113@parseGener

; 1295 : 		ignoreIniFileParameter(INI_PARAM_START_EMPTY);

  0011d	b1 1b		 mov	 cl, 27			; 0000001bH

; 1296 : 		break;

  0011f	e9 82 03 00 00	 jmp	 $LN111@parseGener
$LN14@parseGener:

; 1329 : 		break;
; 1330 : 
; 1331 : 	case 'C':
; 1332 : 		Lcid = (uint16_t)getOptionArgumentInt((char)o, 0, 32767);

  00124	68 ff 7f 00 00	 push	 32767			; 00007fffH
  00129	33 d2		 xor	 edx, edx
  0012b	b1 43		 mov	 cl, 67			; 00000043H
  0012d	e8 00 00 00 00	 call	 _getOptionArgumentInt
  00132	59		 pop	 ecx
  00133	66 a3 00 00 00
	00		 mov	 WORD PTR _Lcid, ax

; 1333 : 
; 1334 : 		ignoreIniFileParameter(INI_PARAM_LCID);

  00139	b1 02		 mov	 cl, 2

; 1335 : 
; 1336 : #		ifdef _PEDANTIC
; 1337 : 		if (!IsValidLcid(Lcid))
; 1338 : 		{
; 1339 : 			printerrorf("Warning: %s is not a valid LCID.\n", optarg);
; 1340 : 		}
; 1341 : #		endif // _PEDANTIC
; 1342 : 
; 1343 : 		break;

  0013b	e9 66 03 00 00	 jmp	 $LN111@parseGener
$LN46@parseGener:

; 1134 : 
; 1135 : 	case 'H':
; 1136 : 		HwId = (BYTE*)vlmcsd_malloc(sizeof(((RESPONSE_V6 *)0)->HwId));

  00140	6a 08		 push	 8
  00142	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00148	8b f0		 mov	 esi, eax
  0014a	59		 pop	 ecx
  0014b	85 f6		 test	 esi, esi
  0014d	0f 84 9c 03 00
	00		 je	 $LN98@parseGener

; 1137 : 		hex2bin(HwId, optarg, sizeof(((RESPONSE_V6 *)0)->HwId));

  00153	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optarg
  00159	51		 push	 ecx
  0015a	8b ce		 mov	 ecx, esi
  0015c	e8 00 00 00 00	 call	 _hex2bin
  00161	59		 pop	 ecx

; 1138 : 
; 1139 : 		KmsResponseParameters[EPID_INDEX_WINDOWS].HwId =
; 1140 : 			KmsResponseParameters[EPID_INDEX_OFFICE2010].HwId =
; 1141 : 			KmsResponseParameters[EPID_INDEX_OFFICE2013].HwId =
; 1142 : 			KmsResponseParameters[EPID_INDEX_WINCHINAGOV].HwId =
; 1143 : 			KmsResponseParameters[EPID_INDEX_OFFICE2016].HwId = HwId;

  00162	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KmsResponseParameters
  00168	89 71 28	 mov	 DWORD PTR [ecx+40], esi
  0016b	89 71 34	 mov	 DWORD PTR [ecx+52], esi
  0016e	89 71 1c	 mov	 DWORD PTR [ecx+28], esi
  00171	89 71 10	 mov	 DWORD PTR [ecx+16], esi
  00174	89 71 04	 mov	 DWORD PTR [ecx+4], esi

; 1144 : 		break;

  00177	e9 2f 03 00 00	 jmp	 $LN53@parseGener
$LN60@parseGener:

; 1074 : 	int o;
; 1075 : 
; 1076 : #ifndef NO_CL_PIDS
; 1077 : 	BYTE* HwId;
; 1078 : #endif // NO_CL_PIDS
; 1079 : 
; 1080 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  0017c	8d 43 b5	 lea	 eax, DWORD PTR [ebx-75]
  0017f	83 f8 09	 cmp	 eax, 9
  00182	0f 87 62 03 00
	00		 ja	 $LN113@parseGener
  00188	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN114@parseGener[eax*4]
$LN52@parseGener:

; 1081 : 	{
; 1082 : #	if !defined(NO_SOCKETS) && !defined(NO_SIGHUP) && !defined(_WIN32)
; 1083 : 	case 'Z':
; 1084 : 		IsRestarted = TRUE;
; 1085 : 		nodaemon = TRUE;
; 1086 : 		break;
; 1087 : #	endif // !defined(NO_SOCKETS) && !defined(NO_SIGHUP) && !defined(_WIN32)
; 1088 : 
; 1089 : #	ifndef NO_TAP
; 1090 : 
; 1091 : 	case 'O':
; 1092 : 		ignoreIniFileParameter(INI_PARAM_VPN);

  0018f	b1 1d		 mov	 cl, 29			; 0000001dH
  00191	e8 00 00 00 00	 call	 _ignoreIniFileParameter

; 1093 : 		tapArgument = getCommandLineArg(optarg);

  00196	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg
  0019b	a3 00 00 00 00	 mov	 DWORD PTR _tapArgument, eax

; 1094 : 		break;

  001a0	e9 06 03 00 00	 jmp	 $LN53@parseGener
$LN43@parseGener:

; 1166 : 
; 1167 : 	case 'P':
; 1168 : 		ignoreIniFileParameter(INI_PARAM_PORT);

  001a5	b1 0e		 mov	 cl, 14			; 0000000eH
  001a7	e8 00 00 00 00	 call	 _ignoreIniFileParameter
$LN112@parseGener:

; 1169 : #		if !defined(SIMPLE_SOCKETS) && !defined(USE_MSRPC)
; 1170 : 		ignoreIniFileParameter(INI_PARAM_LISTEN);

  001ac	b1 03		 mov	 cl, 3

; 1171 : #		else
; 1172 : 		defaultport = optarg;
; 1173 : #		endif // !SIMPLE_SOCKETS
; 1174 : 		break;

  001ae	e9 f3 02 00 00	 jmp	 $LN111@parseGener
$LN37@parseGener:

; 1209 : #	endif
; 1210 : 
; 1211 : #	ifndef NO_LOG
; 1212 : 
; 1213 : 	case 'T':
; 1214 : 		if (!getArgumentBool(&LogDateAndTime, optarg)) usage();

  001b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optarg
  001b9	b9 00 00 00 00	 mov	 ecx, OFFSET _LogDateAndTime
  001be	e8 00 00 00 00	 call	 _getArgumentBool
  001c3	85 c0		 test	 eax, eax
  001c5	0f 84 1f 03 00
	00		 je	 $LN113@parseGener

; 1215 : 		ignoreIniFileParameter(INI_PARAM_LOG_DATE_AND_TIME);

  001cb	b1 13		 mov	 cl, 19			; 00000013H

; 1216 : 		break;

  001cd	e9 d4 02 00 00	 jmp	 $LN111@parseGener
$LN32@parseGener:

; 1243 : #	endif // !defined(NO_PRIVATE_IP_DETECT)
; 1244 : 
; 1245 : #	ifndef NO_SOCKETS
; 1246 : #	if !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 1247 : 	case 'L':
; 1248 : 		maxsockets++;

  001d2	fe 05 00 00 00
	00		 inc	 BYTE PTR _maxsockets

; 1249 : 		ignoreIniFileParameter(INI_PARAM_LISTEN);
; 1250 : 		break;

  001d8	eb d2		 jmp	 SHORT $LN112@parseGener
$LN26@parseGener:

; 1274 : 
; 1275 : 	case 'S':
; 1276 : 		if (!IsNTService) installService = 2; // Remove

  001da	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _IsNTService, 0
  001e1	0f 85 c4 02 00
	00		 jne	 $LN53@parseGener
  001e7	c6 05 00 00 00
	00 02		 mov	 BYTE PTR _installService, 2

; 1277 : 		break;

  001ee	e9 b8 02 00 00	 jmp	 $LN53@parseGener
$LN24@parseGener:

; 1278 : #	endif // _NTSERVICE
; 1279 : 
; 1280 : #	ifndef NO_STRICT_MODES
; 1281 : 
; 1282 : 	case 'K':
; 1283 : 		WhitelistingLevel = (int_fast8_t)getOptionArgumentInt((char)o, 0, 3);

  001f3	6a 03		 push	 3
  001f5	33 d2		 xor	 edx, edx
  001f7	8a cb		 mov	 cl, bl
  001f9	e8 00 00 00 00	 call	 _getOptionArgumentInt
  001fe	59		 pop	 ecx
  001ff	0f be c0	 movsx	 eax, al

; 1284 : 		ignoreIniFileParameter(INI_PARAM_WHITELISTING_LEVEL);

  00202	b1 18		 mov	 cl, 24			; 00000018H
  00204	a3 00 00 00 00	 mov	 DWORD PTR _WhitelistingLevel, eax

; 1285 : 		break;

  00209	e9 98 02 00 00	 jmp	 $LN111@parseGener
$LN19@parseGener:

; 1297 : 
; 1298 : 	case 'M':
; 1299 : 		if (!getArgumentBool(&MaintainClients, optarg)) usage();

  0020e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optarg
  00214	b9 00 00 00 00	 mov	 ecx, OFFSET _MaintainClients
  00219	e8 00 00 00 00	 call	 _getArgumentBool
  0021e	85 c0		 test	 eax, eax
  00220	0f 84 c4 02 00
	00		 je	 $LN113@parseGener

; 1300 : 		ignoreIniFileParameter(INI_PARAM_MAINTAIN_CLIENTS);

  00226	b1 1a		 mov	 cl, 26			; 0000001aH

; 1301 : 		break;

  00228	e9 79 02 00 00	 jmp	 $LN111@parseGener
$LN13@parseGener:

; 1344 : #	endif // NO_RANDOM_PID
; 1345 : 
; 1346 : #	if !defined(NO_USER_SWITCH) && !defined(_WIN32)
; 1347 : 	case 'g':
; 1348 : 		gname = optarg;
; 1349 : 		ignoreIniFileParameter(INI_PARAM_GID);
; 1350 : #		ifndef NO_SIGHUP
; 1351 : 		if (!IsRestarted)
; 1352 : #		endif // NO_SIGHUP
; 1353 : 			if (GetGid())
; 1354 : 			{
; 1355 : 				printerrorf("Fatal: %s for %s failed: %s\n", "setgid", gname, strerror(errno));
; 1356 : 				exit(errno);
; 1357 : 			}
; 1358 : 		break;
; 1359 : 
; 1360 : 	case 'u':
; 1361 : 		uname = optarg;
; 1362 : 		ignoreIniFileParameter(INI_PARAM_UID);
; 1363 : #		ifndef NO_SIGHUP
; 1364 : 		if (!IsRestarted)
; 1365 : #		endif // NO_SIGHUP
; 1366 : 			if (GetUid())
; 1367 : 			{
; 1368 : 				printerrorf("Fatal: %s for %s failed: %s\n", "setuid", uname, strerror(errno));
; 1369 : 				exit(errno);
; 1370 : 			}
; 1371 : 		break;
; 1372 : #	endif // NO_USER_SWITCH && !_WIN32
; 1373 : 
; 1374 : #	ifndef NO_CUSTOM_INTERVALS
; 1375 : 	case 'R':
; 1376 : 		VLRenewalInterval = getTimeSpanFromCommandLine(optarg, (char)o);

  0022d	8a d3		 mov	 dl, bl
  0022f	e8 00 00 00 00	 call	 _getTimeSpanFromCommandLine
  00234	a3 00 00 00 00	 mov	 DWORD PTR _VLRenewalInterval, eax

; 1377 : 		ignoreIniFileParameter(INI_PARAM_RENEWAL_INTERVAL);

  00239	b1 0a		 mov	 cl, 10			; 0000000aH

; 1378 : 		break;

  0023b	e9 66 02 00 00	 jmp	 $LN111@parseGener
$LN10@parseGener:

; 1392 : 
; 1393 : #	ifndef SIMPLE_RPC
; 1394 : 	case 'N':
; 1395 : 		if (!getArgumentBool(&UseServerRpcNDR64, optarg)) usage();

  00240	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optarg
  00246	b9 00 00 00 00	 mov	 ecx, OFFSET _UseServerRpcNDR64
  0024b	e8 00 00 00 00	 call	 _getArgumentBool
  00250	85 c0		 test	 eax, eax
  00252	0f 84 92 02 00
	00		 je	 $LN113@parseGener

; 1396 : 		ignoreIniFileParameter(INI_PARAM_RPC_NDR64);

  00258	b1 0f		 mov	 cl, 15			; 0000000fH

; 1397 : 		break;

  0025a	e9 47 02 00 00	 jmp	 $LN111@parseGener
$LN31@parseGener:

; 1251 : #	if HAVE_FREEBIND
; 1252 : 	case 'F':
; 1253 : 		if (!getArgumentBool(&freebind, optarg)) usage();
; 1254 : 		ignoreIniFileParameter(INI_PARAM_FREEBIND);
; 1255 : 		break;
; 1256 : #	endif // HAVE_FREEBIND
; 1257 : #	endif // !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 1258 : 
; 1259 : #	ifdef _NTSERVICE
; 1260 : 	case 'U':
; 1261 : 		ServiceUser = optarg;

  0025f	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg
  00264	a3 00 00 00 00	 mov	 DWORD PTR _ServiceUser, eax

; 1262 : 		break;

  00269	e9 3d 02 00 00	 jmp	 $LN53@parseGener
$LN59@parseGener:

; 1074 : 	int o;
; 1075 : 
; 1076 : #ifndef NO_CL_PIDS
; 1077 : 	BYTE* HwId;
; 1078 : #endif // NO_CL_PIDS
; 1079 : 
; 1080 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  0026e	83 fb 6d	 cmp	 ebx, 109		; 0000006dH
  00271	0f 8f 6d 01 00
	00		 jg	 $LN62@parseGener
  00277	0f 84 4b 01 00
	00		 je	 $LN42@parseGener
  0027d	83 fb 65	 cmp	 ebx, 101		; 00000065H
  00280	0f 8f d0 00 00
	00		 jg	 $LN63@parseGener
  00286	0f 84 be 00 00
	00		 je	 $LN16@parseGener
  0028c	8b c3		 mov	 eax, ebx
  0028e	83 e8 56	 sub	 eax, 86			; 00000056H
  00291	74 4e		 je	 SHORT $LN6@parseGener
  00293	48		 dec	 eax
  00294	74 3c		 je	 SHORT $LN30@parseGener
  00296	83 e8 0c	 sub	 eax, 12			; 0000000cH
  00299	74 18		 je	 SHORT $LN23@parseGener
  0029b	48		 dec	 eax
  0029c	0f 85 48 02 00
	00		 jne	 $LN113@parseGener
$LN11@parseGener:

; 1384 : #	endif // NO_CUSTOM_INTERVALS
; 1385 : 
; 1386 : #	ifndef USE_MSRPC
; 1387 : 	case 'd':
; 1388 : 	case 'k':
; 1389 : 		DisconnectImmediately = o == 'd';

  002a2	83 fb 64	 cmp	 ebx, 100		; 00000064H

; 1390 : 		ignoreIniFileParameter(INI_PARAM_DISCONNECT_IMMEDIATELY);

  002a5	b1 0b		 mov	 cl, 11			; 0000000bH
  002a7	0f 94 05 00 00
	00 00		 sete	 BYTE PTR _DisconnectImmediately

; 1391 : 		break;

  002ae	e9 f3 01 00 00	 jmp	 $LN111@parseGener
$LN23@parseGener:

; 1286 : 
; 1287 : 	case 'c':
; 1288 : 		if (!getArgumentBool(&CheckClientTime, optarg)) usage();

  002b3	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optarg
  002b9	b9 00 00 00 00	 mov	 ecx, OFFSET _CheckClientTime
  002be	e8 00 00 00 00	 call	 _getArgumentBool
  002c3	85 c0		 test	 eax, eax
  002c5	0f 84 1f 02 00
	00		 je	 $LN113@parseGener

; 1289 : 		ignoreIniFileParameter(INI_PARAM_CHECK_CLIENT_TIME);

  002cb	b1 19		 mov	 cl, 25			; 00000019H

; 1290 : 		break;

  002cd	e9 d4 01 00 00	 jmp	 $LN111@parseGener
$LN30@parseGener:

; 1263 : 
; 1264 : 	case 'W':
; 1265 : 		ServicePassword = optarg;

  002d2	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg
  002d7	a3 00 00 00 00	 mov	 DWORD PTR _ServicePassword, eax

; 1266 : 		break;

  002dc	e9 ca 01 00 00	 jmp	 $LN53@parseGener
$LN6@parseGener:

; 1403 : #	endif // !SIMPLE_RPC
; 1404 : #	endif // !USE_MSRPC
; 1405 : 
; 1406 : #	ifndef NO_VERSION_INFORMATION
; 1407 : 	case 'V':
; 1408 : #		ifdef _NTSERVICE
; 1409 : 		if (IsNTService) break;

  002e1	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _IsNTService, 0
  002e8	0f 85 bd 01 00
	00		 jne	 $LN53@parseGener

; 1410 : #		endif
; 1411 : #		if defined(__s390__) && !defined(__zarch__) && !defined(__s390x__)
; 1412 : 		printf("vlmcsd %s %i-bit\n", Version, sizeof(void*) == 4 ? 31 : (int)sizeof(void*) << 3);
; 1413 : #		else
; 1414 : 		printf("vlmcsd %s %i-bit\n", Version, (int)sizeof(void*) << 3);

  002ee	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__printf
  002f4	6a 20		 push	 32			; 00000020H
  002f6	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LEPLNMP@private?5build?$AA@
  002fb	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6?$AA@
  00300	ff d6		 call	 esi
  00302	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1415 : #		endif // defined(__s390__) && !defined(__zarch__) && !defined(__s390x__)
; 1416 : 		printPlatform();

  00305	68 b5 9e 00 00	 push	 40629			; 00009eb5H
  0030a	57		 push	 edi
  0030b	6a 12		 push	 18			; 00000012H
  0030d	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FAKKKCEM@Compiler?3?5VC?$CL?$CL?5?$CF02i?4?$CF02i?5build?5?$CF@
  00312	ff d6		 call	 esi
  00314	68 00 00 00 00	 push	 OFFSET ??_C@_0O@KEGGAHLA@little?9endian?$AA@
  00319	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KAHIDINA@?5Intel?5x86?5Windows32?$AA@
  0031e	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@MBJNOFCM@Intended?5platform?3?$CFs?5?$CFs?6?$AA@
  00323	ff d6		 call	 esi
  00325	83 c4 1c	 add	 esp, 28			; 0000001cH

; 1417 : 		printCommonFlags();

  00328	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NGPJLHEC@?5_CRYPTO_WINDOWS?$AA@
  0032d	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NGBEHLG@Common?5flags?3?$CFs?6?$AA@
  00332	ff d6		 call	 esi

; 1418 : 		printServerFlags();

  00334	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@DNHMBJJK@?5NO_SIGHUP?5THREADS?$DN1?5SUPPORT_WIN@
  00339	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@OGOEBGIP@vlmcsd?5flags?3?$CFs?6?$AA@
  0033e	ff d6		 call	 esi
  00340	83 c4 10	 add	 esp, 16			; 00000010H

; 1419 : 		exit(0);

  00343	57		 push	 edi
  00344	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN116@parseGener:
$LN16@parseGener:

; 1302 : 
; 1303 : #	endif // !NO_CLIENT_LIST
; 1304 : #	endif // !NO_STRICT_MODES
; 1305 : 
; 1306 : 	case 'D':
; 1307 : #		ifndef _WIN32
; 1308 : 		nodaemon = 1;
; 1309 : #		else // _WIN32
; 1310 : #		ifdef _PEDANTIC
; 1311 : 		printerrorf("Warning: Option -D has no effect in the Windows version of vlmcsd.\n");
; 1312 : #		endif // _PEDANTIC
; 1313 : #		endif // _WIN32
; 1314 : 		break;
; 1315 : 
; 1316 : #	ifndef NO_LOG
; 1317 : 
; 1318 : 	case 'e':
; 1319 : 		logstdout = 1;

  0034a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _logstdout, 1

; 1320 : 		break;

  00351	e9 55 01 00 00	 jmp	 $LN53@parseGener
$LN63@parseGener:

; 1074 : 	int o;
; 1075 : 
; 1076 : #ifndef NO_CL_PIDS
; 1077 : 	BYTE* HwId;
; 1078 : #endif // NO_CL_PIDS
; 1079 : 
; 1080 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  00356	8b c3		 mov	 eax, ebx
  00358	83 e8 69	 sub	 eax, 105		; 00000069H
  0035b	74 3f		 je	 SHORT $LN39@parseGener
  0035d	48		 dec	 eax
  0035e	74 1f		 je	 SHORT $LN45@parseGener
  00360	48		 dec	 eax
  00361	0f 84 3b ff ff
	ff		 je	 $LN11@parseGener
  00367	48		 dec	 eax
  00368	0f 85 7c 01 00
	00		 jne	 $LN113@parseGener

; 1217 : 
; 1218 : 	case 'l':
; 1219 : 		fn_log = getCommandLineArg(optarg);

  0036e	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg

; 1220 : 		ignoreIniFileParameter(INI_PARAM_LOG_FILE);

  00373	b1 07		 mov	 cl, 7
  00375	a3 00 00 00 00	 mov	 DWORD PTR _fn_log, eax

; 1221 : 		break;

  0037a	e9 27 01 00 00	 jmp	 $LN111@parseGener
$LN45@parseGener:

; 1145 : 
; 1146 : #	endif // NO_CL_PIDS
; 1147 : 
; 1148 : #	ifndef NO_EXTERNAL_DATA
; 1149 : 
; 1150 : 	case 'j':
; 1151 : 		ignoreIniFileParameter(INI_PARAM_DATA_FILE);

  0037f	b1 1c		 mov	 cl, 28			; 0000001cH
  00381	e8 00 00 00 00	 call	 _ignoreIniFileParameter

; 1152 : 		fn_data = getCommandLineArg(optarg);

  00386	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg
  0038b	a3 00 00 00 00	 mov	 DWORD PTR _fn_data, eax

; 1153 : #		ifndef NO_INTERNAL_DATA
; 1154 : 		ExplicitDataLoad = TRUE;

  00390	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _ExplicitDataLoad, 1

; 1155 : #		endif // NO_INTERNAL_DATA
; 1156 : 		break;

  00397	e9 0f 01 00 00	 jmp	 $LN53@parseGener
$LN39@parseGener:

; 1202 : #	endif
; 1203 : 
; 1204 : #	ifndef NO_INI_FILE
; 1205 : 	case 'i':
; 1206 : 		fn_ini = getCommandLineArg(optarg);

  0039c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optarg
  003a2	89 0d 00 00 00
	00		 mov	 DWORD PTR _fn_ini, ecx

; 1207 : 		if (!strcmp(fn_ini, "-")) fn_ini = NULL;

  003a8	80 39 2d	 cmp	 BYTE PTR [ecx], 45	; 0000002dH
  003ab	0f 85 fa 00 00
	00		 jne	 $LN53@parseGener
  003b1	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  003b5	84 c0		 test	 al, al
  003b7	0f 85 ee 00 00
	00		 jne	 $LN53@parseGener
  003bd	89 3d 00 00 00
	00		 mov	 DWORD PTR _fn_ini, edi

; 1208 : 		break;

  003c3	e9 e3 00 00 00	 jmp	 $LN53@parseGener
$LN42@parseGener:

; 1175 : 
; 1176 : #	if !defined(NO_LIMIT) && !__minix__
; 1177 : 
; 1178 : 	case 'm':
; 1179 : #		ifdef USE_MSRPC
; 1180 : 		MaxTasks = getOptionArgumentInt(o, 1, RPC_C_LISTEN_MAX_CALLS_DEFAULT);
; 1181 : #		else // !USE_MSRPC
; 1182 : 		MaxTasks = getOptionArgumentInt((char)o, 1, SEM_VALUE_MAX);

  003c8	33 d2		 xor	 edx, edx
  003ca	b1 6d		 mov	 cl, 109			; 0000006dH
  003cc	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  003d1	42		 inc	 edx
  003d2	e8 00 00 00 00	 call	 _getOptionArgumentInt
  003d7	59		 pop	 ecx
  003d8	a3 00 00 00 00	 mov	 DWORD PTR _MaxTasks, eax

; 1183 : #		endif // !USE_MSRPC
; 1184 : 		ignoreIniFileParameter(INI_PARAM_MAX_WORKERS);

  003dd	b1 04		 mov	 cl, 4

; 1185 : 		break;

  003df	e9 c2 00 00 00	 jmp	 $LN111@parseGener
$LN62@parseGener:

; 1074 : 	int o;
; 1075 : 
; 1076 : #ifndef NO_CL_PIDS
; 1077 : 	BYTE* HwId;
; 1078 : #endif // NO_CL_PIDS
; 1079 : 
; 1080 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  003e4	8d 43 91	 lea	 eax, DWORD PTR [ebx-111]
  003e7	83 f8 09	 cmp	 eax, 9
  003ea	0f 87 fa 00 00
	00		 ja	 $LN113@parseGener
  003f0	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN115@parseGener[eax*4]
$LN51@parseGener:

; 1095 : 
; 1096 : #	endif // NO_TAP
; 1097 : 
; 1098 : #	ifndef NO_CL_PIDS
; 1099 : 
; 1100 : 	case 'w':
; 1101 : 		KmsResponseParameters[EPID_INDEX_WINDOWS].Epid = getCommandLineArg(optarg);

  003f7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _KmsResponseParameters
  003fd	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg
  00402	89 01		 mov	 DWORD PTR [ecx], eax

; 1102 : #		ifndef NO_LOG
; 1103 : 		KmsResponseParameters[EPID_INDEX_WINDOWS].EpidSource = "command line";

  00404	89 69 08	 mov	 DWORD PTR [ecx+8], ebp

; 1104 : #		endif // NO_LOG
; 1105 : 		break;

  00407	e9 9f 00 00 00	 jmp	 $LN53@parseGener
$LN44@parseGener:

; 1157 : 
; 1158 : #	endif // NO_EXTERNAL_DATA
; 1159 : 
; 1160 : #	ifndef NO_SOCKETS
; 1161 : 
; 1162 : 	case 'x':
; 1163 : 		ignoreIniFileParameter(INI_PARAM_EXIT_LEVEL);

  0040c	b1 1e		 mov	 cl, 30			; 0000001eH
  0040e	e8 00 00 00 00	 call	 _ignoreIniFileParameter

; 1164 : 		ExitLevel = (int_fast8_t)getOptionArgumentInt((char)o, 0, 1);

  00413	6a 01		 push	 1
  00415	33 d2		 xor	 edx, edx
  00417	8a cb		 mov	 cl, bl
  00419	e8 00 00 00 00	 call	 _getOptionArgumentInt
  0041e	59		 pop	 ecx
  0041f	a2 00 00 00 00	 mov	 BYTE PTR _ExitLevel, al

; 1165 : 		break;

  00424	e9 82 00 00 00	 jmp	 $LN53@parseGener
$LN41@parseGener:

; 1186 : 
; 1187 : #		endif // !defined(NO_LIMIT) && !__minix__
; 1188 : #		endif // NO_SOCKETS
; 1189 : 
; 1190 : #	if !defined(NO_TIMEOUT) && !__minix__ && !defined(USE_MSRPC)
; 1191 : 	case 't':
; 1192 : 		ServerTimeout = getOptionArgumentInt((char)o, 1, 600);

  00429	33 d2		 xor	 edx, edx
  0042b	8a cb		 mov	 cl, bl
  0042d	68 58 02 00 00	 push	 600			; 00000258H
  00432	42		 inc	 edx
  00433	e8 00 00 00 00	 call	 _getOptionArgumentInt
  00438	59		 pop	 ecx
  00439	a3 00 00 00 00	 mov	 DWORD PTR _ServerTimeout, eax

; 1193 : 		ignoreIniFileParameter(INI_PARAM_CONNECTION_TIMEOUT);

  0043e	b1 05		 mov	 cl, 5

; 1194 : 		break;

  00440	eb 64		 jmp	 SHORT $LN111@parseGener
$LN40@parseGener:

; 1195 : #	endif // !defined(NO_TIMEOUT) && !__minix__ && !defined(USE_MSRPC)
; 1196 : 
; 1197 : #	ifndef NO_PID_FILE
; 1198 : 	case 'p':
; 1199 : 		fn_pid = getCommandLineArg(optarg);

  00442	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg

; 1200 : 		ignoreIniFileParameter(INI_PARAM_PID_FILE);

  00447	b1 06		 mov	 cl, 6
  00449	a3 00 00 00 00	 mov	 DWORD PTR _fn_pid, eax

; 1201 : 		break;

  0044e	eb 56		 jmp	 SHORT $LN111@parseGener
$LN34@parseGener:

; 1222 : 
; 1223 : #	ifndef NO_VERBOSE_LOG
; 1224 : 	case 'v':
; 1225 : 	case 'q':
; 1226 : 		logverbose = o == 'v';

  00450	83 fb 76	 cmp	 ebx, 118		; 00000076H

; 1227 : 		ignoreIniFileParameter(INI_PARAM_LOG_VERBOSE);

  00453	b1 08		 mov	 cl, 8
  00455	0f 94 05 00 00
	00 00		 sete	 BYTE PTR _logverbose

; 1228 : 		break;

  0045c	eb 48		 jmp	 SHORT $LN111@parseGener
$LN33@parseGener:

; 1229 : 
; 1230 : #	endif // NO_VERBOSE_LOG
; 1231 : #	endif // NO_LOG
; 1232 : 
; 1233 : #	if !defined(NO_PRIVATE_IP_DETECT)
; 1234 : 	case 'o':
; 1235 : 		ignoreIniFileParameter(INI_PARAM_PUBLIC_IP_PROTECTION_LEVEL);

  0045e	b1 12		 mov	 cl, 18			; 00000012H
  00460	e8 00 00 00 00	 call	 _ignoreIniFileParameter

; 1236 : 		PublicIPProtectionLevel = getOptionArgumentInt((char)o, 0, 3);

  00465	6a 03		 push	 3
  00467	33 d2		 xor	 edx, edx
  00469	8a cb		 mov	 cl, bl
  0046b	e8 00 00 00 00	 call	 _getOptionArgumentInt
  00470	59		 pop	 ecx
  00471	a3 00 00 00 00	 mov	 DWORD PTR _PublicIPProtectionLevel, eax

; 1237 : 
; 1238 : #		if !HAVE_GETIFADDR
; 1239 : 		if (PublicIPProtectionLevel & 1) usage();
; 1240 : #		endif // !HAVE_GETIFADDR
; 1241 : 
; 1242 : 		break;

  00476	eb 33		 jmp	 SHORT $LN53@parseGener
$LN29@parseGener:

; 1267 : 
; 1268 : 	case 's':
; 1269 : #		ifndef USE_MSRPC
; 1270 : 		if (InetdMode) usage();

  00478	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  0047f	75 69		 jne	 SHORT $LN113@parseGener

; 1271 : #		endif // USE_MSRPC
; 1272 : 		if (!IsNTService) installService = 1; // Install

  00481	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _IsNTService, 0
  00488	75 21		 jne	 SHORT $LN53@parseGener
  0048a	c6 05 00 00 00
	00 01		 mov	 BYTE PTR _installService, 1

; 1273 : 		break;

  00491	eb 18		 jmp	 SHORT $LN53@parseGener
$LN15@parseGener:

; 1321 : 
; 1322 : #	endif // NO_LOG
; 1323 : #	endif // NO_SOCKETS
; 1324 : 
; 1325 : #	ifndef NO_RANDOM_EPID
; 1326 : 	case 'r':
; 1327 : 		RandomizationLevel = (int_fast8_t)getOptionArgumentInt((char)o, 0, 2);

  00493	6a 02		 push	 2
  00495	33 d2		 xor	 edx, edx
  00497	8a cb		 mov	 cl, bl
  00499	e8 00 00 00 00	 call	 _getOptionArgumentInt
  0049e	59		 pop	 ecx
  0049f	a2 00 00 00 00	 mov	 BYTE PTR _RandomizationLevel, al

; 1328 : 		ignoreIniFileParameter(INI_PARAM_RANDOMIZATION_LEVEL);

  004a4	b1 01		 mov	 cl, 1
$LN111@parseGener:
  004a6	e8 00 00 00 00	 call	 _ignoreIniFileParameter
$LN53@parseGener:

; 1074 : 	int o;
; 1075 : 
; 1076 : #ifndef NO_CL_PIDS
; 1077 : 	BYTE* HwId;
; 1078 : #endif // NO_CL_PIDS
; 1079 : 
; 1080 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  004ab	51		 push	 ecx
  004ac	e8 00 00 00 00	 call	 _getopt
  004b1	8b d8		 mov	 ebx, eax
  004b3	59		 pop	 ecx
  004b4	85 db		 test	 ebx, ebx
  004b6	0f 8f 67 fb ff
	ff		 jg	 $LL56@parseGener
$LN55@parseGener:

; 1420 : #	endif // NO_VERSION_INFORMATION
; 1421 : 
; 1422 : 	default:
; 1423 : 		usage();
; 1424 : 	}
; 1425 : 
; 1426 : 	// Do not allow non-option arguments
; 1427 : 	if (optind != global_argc)

  004bc	a1 00 00 00 00	 mov	 eax, DWORD PTR _optind
  004c1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _global_argc
  004c7	75 21		 jne	 SHORT $LN113@parseGener

; 1428 : 		usage();
; 1429 : 
; 1430 : #	ifdef _NTSERVICE
; 1431 : 	// -U and -W must be used with -s
; 1432 : 	if ((ServiceUser || *ServicePassword) && installService != 1) usage();

  004c9	39 3d 00 00 00
	00		 cmp	 DWORD PTR _ServiceUser, edi
  004cf	75 0a		 jne	 SHORT $LN1@parseGener
  004d1	a1 00 00 00 00	 mov	 eax, DWORD PTR _ServicePassword
  004d6	80 38 00	 cmp	 BYTE PTR [eax], 0
  004d9	74 09		 je	 SHORT $LN2@parseGener
$LN1@parseGener:
  004db	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR _installService, 1
  004e2	75 06		 jne	 SHORT $LN113@parseGener
$LN2@parseGener:

; 1433 : #	endif // _NTSERVICE
; 1434 : }

  004e4	5f		 pop	 edi
  004e5	5e		 pop	 esi
  004e6	5d		 pop	 ebp
  004e7	5b		 pop	 ebx
  004e8	59		 pop	 ecx
  004e9	c3		 ret	 0
$LN113@parseGener:

; 1398 : 
; 1399 : 	case 'B':
; 1400 : 		if (!getArgumentBool(&UseServerRpcBTFN, optarg)) usage();

  004ea	e8 00 00 00 00	 call	 _usage
$LN117@parseGener:
$LN98@parseGener:

; 1134 : 
; 1135 : 	case 'H':
; 1136 : 		HwId = (BYTE*)vlmcsd_malloc(sizeof(((RESPONSE_V6 *)0)->HwId));

  004ef	e8 00 00 00 00	 call	 _OutOfMemory
$LN118@parseGener:
$LN110@parseGener:
$LN114@parseGener:

; 1433 : #	endif // _NTSERVICE
; 1434 : }

  004f4	00 00 00 00	 DD	 $LN24@parseGener
  004f8	00 00 00 00	 DD	 $LN32@parseGener
  004fc	00 00 00 00	 DD	 $LN19@parseGener
  00500	00 00 00 00	 DD	 $LN10@parseGener
  00504	00 00 00 00	 DD	 $LN52@parseGener
  00508	00 00 00 00	 DD	 $LN43@parseGener
  0050c	00 00 00 00	 DD	 $LN113@parseGener
  00510	00 00 00 00	 DD	 $LN13@parseGener
  00514	00 00 00 00	 DD	 $LN26@parseGener
  00518	00 00 00 00	 DD	 $LN37@parseGener
$LN115@parseGener:
  0051c	00 00 00 00	 DD	 $LN33@parseGener
  00520	00 00 00 00	 DD	 $LN40@parseGener
  00524	00 00 00 00	 DD	 $LN34@parseGener
  00528	00 00 00 00	 DD	 $LN15@parseGener
  0052c	00 00 00 00	 DD	 $LN29@parseGener
  00530	00 00 00 00	 DD	 $LN41@parseGener
  00534	00 00 00 00	 DD	 $LN113@parseGener
  00538	00 00 00 00	 DD	 $LN34@parseGener
  0053c	00 00 00 00	 DD	 $LN51@parseGener
  00540	00 00 00 00	 DD	 $LN44@parseGener
_parseGeneralArguments ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _writePidFile
_TEXT	SEGMENT
_writePidFile PROC					; COMDAT

; 1440 : #	ifndef NO_SIGHUP
; 1441 : 	if (IsRestarted) return;
; 1442 : #	endif // NO_SIGHUP
; 1443 : 
; 1444 : 	if (fn_pid && !InetdMode)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _fn_pid
  00005	85 c0		 test	 eax, eax
  00007	74 5d		 je	 SHORT $LN1@writePidFi
  00009	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  00010	75 54		 jne	 SHORT $LN1@writePidFi

; 1445 : 	{
; 1446 : 		FILE *file = fopen(fn_pid, "w");

  00012	56		 push	 esi
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_01NOFIACDB@w?$AA@
  00018	50		 push	 eax
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0001f	8b f0		 mov	 esi, eax
  00021	59		 pop	 ecx
  00022	59		 pop	 ecx

; 1447 : 
; 1448 : 		if (file)

  00023	85 f6		 test	 esi, esi
  00025	74 1c		 je	 SHORT $LN2@writePidFi

; 1449 : 		{
; 1450 : #			if _MSC_VER
; 1451 : 			fprintf(file, "%u", (unsigned int)GetCurrentProcessId());

  00027	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCurrentProcessId@0
  0002d	50		 push	 eax
  0002e	68 00 00 00 00	 push	 OFFSET ??_C@_02GMHACPFF@?$CFu?$AA@
  00033	56		 push	 esi
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf

; 1452 : #			else
; 1453 : 			fprintf(file, "%u", (unsigned int)getpid());
; 1454 : #			endif
; 1455 : 			fclose(file);

  0003a	56		 push	 esi
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose

; 1456 : 		}
; 1457 : 
; 1458 : #		ifndef NO_LOG
; 1459 : 		else

  00041	eb 1f		 jmp	 SHORT $LN7@writePidFi
$LN2@writePidFi:

; 1460 : 		{
; 1461 : 			logger("Warning: Cannot write pid file '%s'. %s.\n", fn_pid, strerror(errno));

  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00049	ff 30		 push	 DWORD PTR [eax]
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  00051	50		 push	 eax
  00052	ff 35 00 00 00
	00		 push	 DWORD PTR _fn_pid
  00058	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5?8@
  0005d	e8 00 00 00 00	 call	 _logger
$LN7@writePidFi:
  00062	83 c4 10	 add	 esp, 16			; 00000010H
  00065	5e		 pop	 esi
$LN1@writePidFi:

; 1462 : 		}
; 1463 : #		endif // NO_LOG
; 1464 : 	}
; 1465 : }

  00066	c3		 ret	 0
_writePidFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _allocateSemaphore
_TEXT	SEGMENT
_allocateSemaphore PROC					; COMDAT

; 1526 : #	ifdef USE_THREADS
; 1527 : #	define sharemode 0
; 1528 : #	else
; 1529 : #	define sharemode 1
; 1530 : #	endif
; 1531 : 
; 1532 : #	ifndef _WIN32
; 1533 : 	sem_unlink("/vlmcsd");
; 1534 : #	endif
; 1535 : 
; 1536 : 	if (MaxTasks < SEM_VALUE_MAX && !InetdMode)

  00000	a1 00 00 00 00	 mov	 eax, DWORD PTR _MaxTasks
  00005	56		 push	 esi
  00006	be ff ff ff 7f	 mov	 esi, 2147483647		; 7fffffffH
  0000b	3b c6		 cmp	 eax, esi
  0000d	73 3e		 jae	 SHORT $LN1@allocateSe
  0000f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  00016	75 35		 jne	 SHORT $LN1@allocateSe

; 1537 : 	{
; 1538 : #		ifndef _WIN32
; 1539 : 
; 1540 : #		if !defined(USE_THREADS) && !defined(CYGWIN)
; 1541 : 
; 1542 : 		if ((MaxTaskSemaphore = sem_open("/vlmcsd", O_CREAT /*| O_EXCL*/, 0700, MaxTasks)) == SEM_FAILED) // fails on many systems
; 1543 : 		{
; 1544 : 			// We didn't get a named Semaphore (/dev/shm on Linux) so let's try our own shared page
; 1545 : 
; 1546 : 			if (
; 1547 : 				(shmid = shmget(IPC_PRIVATE, sizeof(sem_t), IPC_CREAT | 0600)) < 0 ||
; 1548 : 				(MaxTaskSemaphore = (sem_t*)shmat(shmid, NULL, 0)) == (sem_t*)-1 ||
; 1549 : 				sem_init(MaxTaskSemaphore, 1, MaxTasks) < 0
; 1550 : 				)
; 1551 : 			{
; 1552 : 				int errno_save = errno;
; 1553 : 				if (MaxTaskSemaphore != (sem_t*)-1) shmdt(MaxTaskSemaphore);
; 1554 : 				if (shmid >= 0) shmctl(shmid, IPC_RMID, NULL);
; 1555 : 				printerrorf("Warning: Could not create semaphore: %s\n", vlmcsd_strerror(errno_save));
; 1556 : 				MaxTasks = SEM_VALUE_MAX;
; 1557 : 			}
; 1558 : 		}
; 1559 : 
; 1560 : #		else // THREADS or CYGWIN
; 1561 : 
; 1562 : 		MaxTaskSemaphore = (sem_t*)vlmcsd_malloc(sizeof(sem_t));
; 1563 : 
; 1564 : 		if (sem_init(MaxTaskSemaphore, sharemode, MaxTasks) < 0) // sem_init is not implemented on Darwin (returns ENOSYS)
; 1565 : 		{
; 1566 : 			free(MaxTaskSemaphore);
; 1567 : 
; 1568 : 			if ((MaxTaskSemaphore = sem_open("/vlmcsd", O_CREAT /*| O_EXCL*/, 0700, MaxTasks)) == SEM_FAILED)
; 1569 : 			{
; 1570 : 				printerrorf("Warning: Could not create semaphore: %s\n", vlmcsd_strerror(errno));
; 1571 : 				MaxTasks = SEM_VALUE_MAX;
; 1572 : 			}
; 1573 : 		}
; 1574 : 
; 1575 : #		endif // THREADS or CYGWIN
; 1576 : 
; 1577 : #		else // _WIN32
; 1578 : 
; 1579 : 		if (!((MaxTaskSemaphore = CreateSemaphoreA(NULL, MaxTasks, MaxTasks, NULL))))

  00018	6a 00		 push	 0
  0001a	50		 push	 eax
  0001b	50		 push	 eax
  0001c	6a 00		 push	 0
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateSemaphoreA@16
  00024	a3 00 00 00 00	 mov	 DWORD PTR _MaxTaskSemaphore, eax
  00029	85 c0		 test	 eax, eax
  0002b	75 20		 jne	 SHORT $LN1@allocateSe

; 1580 : 		{
; 1581 : 			printerrorf("Warning: Could not create semaphore: %s\n", vlmcsd_strerror(GetLastError()));

  0002d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00033	8b c8		 mov	 ecx, eax
  00035	e8 00 00 00 00	 call	 _win_strerror
  0003a	50		 push	 eax
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semaph@
  00040	e8 00 00 00 00	 call	 _printerrorf
  00045	59		 pop	 ecx
  00046	59		 pop	 ecx

; 1582 : 			MaxTasks = SEM_VALUE_MAX;

  00047	89 35 00 00 00
	00		 mov	 DWORD PTR _MaxTasks, esi
$LN1@allocateSe:
  0004d	5e		 pop	 esi

; 1583 : 		}
; 1584 : 
; 1585 : #		endif // _WIN32
; 1586 : 	}
; 1587 : }

  0004e	c3		 ret	 0
_allocateSemaphore ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _setupListeningSockets
_TEXT	SEGMENT
_haveIPv6Stack$1$ = -10					; size = 1
_haveIPv4Stack$1$ = -9					; size = 1
_numPrivateIPs$ = -8					; size = 4
_privateIPList$ = -4					; size = 4
_setupListeningSockets PROC				; COMDAT

; 1593 : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 1594 : 	int o;
; 1595 : #	if HAVE_GETIFADDR
; 1596 : 	char** privateIPList = NULL;
; 1597 : 	int numPrivateIPs = 0;
; 1598 : 	if (PublicIPProtectionLevel & 1) getPrivateIPAddresses(&numPrivateIPs, &privateIPList);

  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PublicIPProtectionLevel
  00009	53		 push	 ebx
  0000a	55		 push	 ebp
  0000b	33 ed		 xor	 ebp, ebp
  0000d	89 6c 24 10	 mov	 DWORD PTR _privateIPList$[esp+20], ebp
  00011	8b c5		 mov	 eax, ebp
  00013	89 44 24 0c	 mov	 DWORD PTR _numPrivateIPs$[esp+20], eax
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	f6 c1 01	 test	 cl, 1
  0001c	74 17		 je	 SHORT $LN18@setupListe
  0001e	8d 54 24 18	 lea	 edx, DWORD PTR _privateIPList$[esp+28]
  00022	8d 4c 24 14	 lea	 ecx, DWORD PTR _numPrivateIPs$[esp+28]
  00026	e8 00 00 00 00	 call	 _getPrivateIPAddresses
  0002b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _PublicIPProtectionLevel
  00031	8b 44 24 14	 mov	 eax, DWORD PTR _numPrivateIPs$[esp+28]
$LN18@setupListe:

; 1599 : 	uint_fast8_t allocsockets = (uint_fast8_t)(maxsockets ? (maxsockets + numPrivateIPs) : ((PublicIPProtectionLevel & 1) ? numPrivateIPs : 2));

  00035	8a 1d 00 00 00
	00		 mov	 bl, BYTE PTR _maxsockets
  0003b	f6 c1 01	 test	 cl, 1
  0003e	6a 02		 push	 2
  00040	59		 pop	 ecx
  00041	8d 14 18	 lea	 edx, DWORD PTR [eax+ebx]
  00044	0f b6 c0	 movzx	 eax, al
  00047	0f 45 c8	 cmovne	 ecx, eax
  0004a	0f b6 c2	 movzx	 eax, dl
  0004d	0f b6 c9	 movzx	 ecx, cl
  00050	84 db		 test	 bl, bl
  00052	0f 45 c8	 cmovne	 ecx, eax

; 1600 : #	else // !HAVE_GETIFADDR
; 1601 : 	uint_fast8_t allocsockets = maxsockets ? maxsockets : 2;
; 1602 : #	endif // !HAVE_GETIFADDR
; 1603 : 
; 1604 : 	SocketList = (SOCKET*)vlmcsd_malloc((size_t)allocsockets * sizeof(SOCKET));

  00055	0f b6 c1	 movzx	 eax, cl
  00058	c1 e0 02	 shl	 eax, 2
  0005b	50		 push	 eax
  0005c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00062	59		 pop	 ecx
  00063	85 c0		 test	 eax, eax
  00065	0f 84 53 01 00
	00		 je	 $LN44@setupListe

; 1605 : 
; 1606 : 	int_fast8_t haveIPv4Stack = checkProtocolStack(AF_INET);

  0006b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__socket@12
  00071	55		 push	 ebp
  00072	6a 01		 push	 1
  00074	6a 02		 push	 2
  00076	a3 00 00 00 00	 mov	 DWORD PTR _SocketList, eax
  0007b	ff d3		 call	 ebx
  0007d	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__closesocket@4
  00083	8b f0		 mov	 esi, eax
  00085	56		 push	 esi
  00086	ff d7		 call	 edi

; 1607 : 	int_fast8_t haveIPv6Stack = checkProtocolStack(AF_INET6);

  00088	55		 push	 ebp
  00089	6a 01		 push	 1
  0008b	83 fe ff	 cmp	 esi, -1
  0008e	6a 17		 push	 23			; 00000017H
  00090	0f 95 44 24 1f	 setne	 BYTE PTR _haveIPv4Stack$1$[esp+40]
  00095	ff d3		 call	 ebx
  00097	8b f0		 mov	 esi, eax
  00099	56		 push	 esi
  0009a	ff d7		 call	 edi
  0009c	83 fe ff	 cmp	 esi, -1

; 1608 : 
; 1609 : 	// Reset getopt since we've alread used it
; 1610 : 	optReset();

  0009f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _optind, 1

; 1611 : 
; 1612 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  000a9	89 2d 00 00 00
	00		 mov	 DWORD PTR _opterr, ebp
  000af	0f 95 c3	 setne	 bl
  000b2	88 5c 24 12	 mov	 BYTE PTR _haveIPv6Stack$1$[esp+28], bl
  000b6	eb 21		 jmp	 SHORT $LN14@setupListe
$LL17@setupListe:
  000b8	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  000bb	74 11		 je	 SHORT $LN12@setupListe
  000bd	83 f8 50	 cmp	 eax, 80			; 00000050H
  000c0	75 17		 jne	 SHORT $LN14@setupListe

; 1613 : 	{
; 1614 : 	case 'P':
; 1615 : 		defaultport = optarg;

  000c2	a1 00 00 00 00	 mov	 eax, DWORD PTR _optarg
  000c7	a3 00 00 00 00	 mov	 DWORD PTR _defaultport, eax

; 1616 : 		break;

  000cc	eb 0b		 jmp	 SHORT $LN14@setupListe
$LN12@setupListe:

; 1617 : 
; 1618 : 	case 'L':
; 1619 : 		addListeningSocket(optarg);

  000ce	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optarg
  000d4	e8 00 00 00 00	 call	 _addListeningSocket
$LN14@setupListe:

; 1611 : 
; 1612 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  000d9	51		 push	 ecx
  000da	e8 00 00 00 00	 call	 _getopt
  000df	59		 pop	 ecx
  000e0	85 c0		 test	 eax, eax
  000e2	7f d4		 jg	 SHORT $LL17@setupListe

; 1620 : 		break;
; 1621 : 
; 1622 : 	default:
; 1623 : 		break;
; 1624 : 	}
; 1625 : 
; 1626 : 
; 1627 : #	ifndef NO_INI_FILE
; 1628 : 	if (maxsockets && !numsockets)

  000e4	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _maxsockets, 0
  000eb	74 3e		 je	 SHORT $LN38@setupListe
  000ed	39 2d 00 00 00
	00		 cmp	 DWORD PTR _numsockets, ebp
  000f3	75 36		 jne	 SHORT $LN38@setupListe

; 1629 : 	{
; 1630 : 		if (fn_ini && !readIniFile(INI_FILE_PASS_2))

  000f5	39 2d 00 00 00
	00		 cmp	 DWORD PTR _fn_ini, ebp
  000fb	74 2e		 je	 SHORT $LN38@setupListe
  000fd	b1 02		 mov	 cl, 2
  000ff	e8 00 00 00 00	 call	 _readIniFile
  00104	85 c0		 test	 eax, eax
  00106	75 23		 jne	 SHORT $LN38@setupListe

; 1631 : 		{
; 1632 : #			ifdef INI_FILE
; 1633 : 			if (strcmp(fn_ini, INI_FILE))
; 1634 : #			endif // INI_FILE
; 1635 : 				printerrorf("Warning: Can't read %s: %s\n", fn_ini, strerror(errno));

  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  0010e	ff 30		 push	 DWORD PTR [eax]
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  00116	59		 pop	 ecx
  00117	50		 push	 eax
  00118	ff 35 00 00 00
	00		 push	 DWORD PTR _fn_ini
  0011e	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6?$AA@
  00123	e8 00 00 00 00	 call	 _printerrorf
  00128	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN38@setupListe:

; 1636 : 		}
; 1637 : 	}
; 1638 : #	endif
; 1639 : 
; 1640 : #	if HAVE_GETIFADDR
; 1641 : 	if (PublicIPProtectionLevel & 1)

  0012b	a1 00 00 00 00	 mov	 eax, DWORD PTR _PublicIPProtectionLevel
  00130	a8 01		 test	 al, 1
  00132	74 32		 je	 SHORT $LN8@setupListe

; 1642 : 	{
; 1643 : 		int i;
; 1644 : 		for (i = 0; i < numPrivateIPs; i++)

  00134	8b 74 24 14	 mov	 esi, DWORD PTR _numPrivateIPs$[esp+28]
  00138	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__free
  0013e	8b 7c 24 18	 mov	 edi, DWORD PTR _privateIPList$[esp+28]
  00142	85 f6		 test	 esi, esi
  00144	7e 13		 jle	 SHORT $LN5@setupListe
$LL7@setupListe:

; 1645 : 		{
; 1646 : 			addListeningSocket(privateIPList[i]);

  00146	8b 0c af	 mov	 ecx, DWORD PTR [edi+ebp*4]
  00149	e8 00 00 00 00	 call	 _addListeningSocket

; 1647 : 			free(privateIPList[i]);

  0014e	ff 34 af	 push	 DWORD PTR [edi+ebp*4]
  00151	ff d3		 call	 ebx
  00153	45		 inc	 ebp
  00154	59		 pop	 ecx
  00155	3b ee		 cmp	 ebp, esi
  00157	7c ed		 jl	 SHORT $LL7@setupListe
$LN5@setupListe:

; 1648 : 		}
; 1649 : 
; 1650 : 		free(privateIPList);

  00159	57		 push	 edi
  0015a	ff d3		 call	 ebx
  0015c	a1 00 00 00 00	 mov	 eax, DWORD PTR _PublicIPProtectionLevel
  00161	8a 5c 24 16	 mov	 bl, BYTE PTR _haveIPv6Stack$1$[esp+32]
  00165	59		 pop	 ecx
$LN8@setupListe:

; 1651 : 	}
; 1652 : #	endif // HAVE_GETIFADDR
; 1653 : 
; 1654 : 	// if -L hasn't been specified on the command line, use default sockets (all IP addresses)
; 1655 : 	// maxsocket results from first pass parsing the arguments
; 1656 : 	if (!maxsockets)

  00166	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _maxsockets, 0
  0016d	75 2c		 jne	 SHORT $LN2@setupListe

; 1657 : 	{
; 1658 : #		if HAVE_GETIFADDR
; 1659 : 		if (!(PublicIPProtectionLevel & 1) && haveIPv6Stack) addListeningSocket("::");

  0016f	a8 01		 test	 al, 1
  00171	75 28		 jne	 SHORT $LN2@setupListe
  00173	84 db		 test	 bl, bl
  00175	74 0f		 je	 SHORT $LN3@setupListe
  00177	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_02MOLJINC@?3?3?$AA@
  0017c	e8 00 00 00 00	 call	 _addListeningSocket
  00181	a1 00 00 00 00	 mov	 eax, DWORD PTR _PublicIPProtectionLevel
$LN3@setupListe:

; 1660 : 		if (!(PublicIPProtectionLevel & 1) && haveIPv4Stack) addListeningSocket("0.0.0.0");

  00186	a8 01		 test	 al, 1
  00188	75 11		 jne	 SHORT $LN2@setupListe
  0018a	80 7c 24 13 00	 cmp	 BYTE PTR _haveIPv4Stack$1$[esp+28], 0
  0018f	74 0a		 je	 SHORT $LN2@setupListe
  00191	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_07OHKHACFK@0?40?40?40?$AA@
  00196	e8 00 00 00 00	 call	 _addListeningSocket
$LN2@setupListe:

; 1661 : #		else // !HAVE_GETIFADDR
; 1662 : 		if (haveIPv6Stack) addListeningSocket("::");
; 1663 : 		if (haveIPv4Stack) addListeningSocket("0.0.0.0");
; 1664 : #		endif // !HAVE_GETIFADDR
; 1665 : 	}
; 1666 : 
; 1667 : 	if (!numsockets)

  0019b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numsockets, 0
  001a2	75 10		 jne	 SHORT $LN1@setupListe

; 1668 : 	{
; 1669 : 		printerrorf("Fatal: Could not listen on any socket.\n");

  001a4	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5s@
  001a9	e8 00 00 00 00	 call	 _printerrorf

; 1670 : 		return(!0);

  001ae	33 c0		 xor	 eax, eax
  001b0	59		 pop	 ecx
  001b1	40		 inc	 eax
  001b2	eb 02		 jmp	 SHORT $LN19@setupListe
$LN1@setupListe:

; 1671 : 	}
; 1672 : 
; 1673 : 	return 0;

  001b4	33 c0		 xor	 eax, eax
$LN19@setupListe:

; 1674 : }

  001b6	5f		 pop	 edi
  001b7	5e		 pop	 esi
  001b8	5d		 pop	 ebp
  001b9	5b		 pop	 ebx
  001ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  001bd	c3		 ret	 0
$LN44@setupListe:

; 1600 : #	else // !HAVE_GETIFADDR
; 1601 : 	uint_fast8_t allocsockets = maxsockets ? maxsockets : 2;
; 1602 : #	endif // !HAVE_GETIFADDR
; 1603 : 
; 1604 : 	SocketList = (SOCKET*)vlmcsd_malloc((size_t)allocsockets * sizeof(SOCKET));

  001be	e8 00 00 00 00	 call	 _OutOfMemory
$LN46@setupListe:
$LN41@setupListe:
  001c3	cc		 int	 3
_setupListeningSockets ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _main
_TEXT	SEGMENT
_main	PROC						; COMDAT

; 1680 : 	global_argc = argc;
; 1681 : 	global_argv = argv;
; 1682 : 
; 1683 : #	ifdef _NTSERVICE
; 1684 : 	DWORD lasterror = ERROR_SUCCESS;
; 1685 : 
; 1686 : 	if (!StartServiceCtrlDispatcher(NTServiceDispatchTable) && (lasterror = GetLastError()) == ERROR_FAILED_SERVICE_CONTROLLER_CONNECT)

  00000	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00006	3d 27 04 00 00	 cmp	 eax, 1063		; 00000427H
  0000b	75 0c		 jne	 SHORT $LN4@main

; 1687 : 	{
; 1688 : 		IsNTService = FALSE;

  0000d	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _IsNTService, 0

; 1689 : 		return newmain();

  00014	e9 00 00 00 00	 jmp	 _newmain
$LN4@main:

; 1690 : 	}
; 1691 : 
; 1692 : 	return lasterror;
; 1693 : #	else // !_NTSERVICE
; 1694 : 	return newmain();
; 1695 : #	endif // !_NTSERVICE
; 1696 : }

  00019	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT _WinStartUp@0
_TEXT	SEGMENT
_i$1$ = -8						; size = 4
_argc$ = -4						; size = 4
_WinStartUp@0 PROC					; COMDAT

; 1902 : {

  00000	51		 push	 ecx
  00001	51		 push	 ecx
  00002	53		 push	 ebx
  00003	56		 push	 esi
  00004	57		 push	 edi

; 1903 : 	WCHAR **szArgList;
; 1904 : 	int argc;
; 1905 : 	szArgList = CommandLineToArgvW(GetCommandLineW(), &argc);

  00005	8d 44 24 10	 lea	 eax, DWORD PTR _argc$[esp+20]
  00009	50		 push	 eax
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCommandLineW@0
  00010	50		 push	 eax
  00011	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CommandLineToArgvW@8

; 1906 : 
; 1907 : 	int i;
; 1908 : 	char **argv = (char**)vlmcsd_malloc(sizeof(char*)*argc);

  00017	8b 74 24 10	 mov	 esi, DWORD PTR _argc$[esp+20]
  0001b	8b f8		 mov	 edi, eax
  0001d	8b ce		 mov	 ecx, esi
  0001f	c1 e1 02	 shl	 ecx, 2
  00022	51		 push	 ecx
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00029	8b d8		 mov	 ebx, eax
  0002b	59		 pop	 ecx
  0002c	85 db		 test	 ebx, ebx
  0002e	75 05		 jne	 SHORT $LN6@WinStartUp
  00030	e8 00 00 00 00	 call	 _OutOfMemory
$LN23@WinStartUp:
$LN6@WinStartUp:

; 1909 : 
; 1910 : 	for (i = 0; i < argc; i++)

  00035	83 64 24 0c 00	 and	 DWORD PTR _i$1$[esp+20], 0
  0003a	55		 push	 ebp
  0003b	85 f6		 test	 esi, esi
  0003d	7e 5a		 jle	 SHORT $LN1@WinStartUp
  0003f	8b eb		 mov	 ebp, ebx
  00041	2b ef		 sub	 ebp, edi
$LL3@WinStartUp:

; 1911 : 	{
; 1912 : 		int size = WideCharToMultiByte(CP_UTF8, 0, szArgList[i], -1, argv[i], 0, NULL, NULL);

  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	ff 34 2f	 push	 DWORD PTR [edi+ebp]
  0004c	6a ff		 push	 -1
  0004e	ff 37		 push	 DWORD PTR [edi]
  00050	6a 00		 push	 0
  00052	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  0005d	8b f0		 mov	 esi, eax

; 1913 : 		argv[i] = (char*)vlmcsd_malloc(size);

  0005f	56		 push	 esi
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00066	59		 pop	 ecx
  00067	85 c0		 test	 eax, eax
  00069	74 70		 je	 SHORT $LN17@WinStartUp

; 1914 : 		WideCharToMultiByte(CP_UTF8, 0, szArgList[i], -1, argv[i], size, NULL, NULL);

  0006b	6a 00		 push	 0
  0006d	6a 00		 push	 0
  0006f	56		 push	 esi
  00070	50		 push	 eax
  00071	6a ff		 push	 -1
  00073	89 04 2f	 mov	 DWORD PTR [edi+ebp], eax
  00076	ff 37		 push	 DWORD PTR [edi]
  00078	6a 00		 push	 0
  0007a	68 e9 fd 00 00	 push	 65001			; 0000fde9H
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WideCharToMultiByte@32
  00085	8b 44 24 10	 mov	 eax, DWORD PTR _i$1$[esp+24]
  00089	83 c7 04	 add	 edi, 4
  0008c	8b 74 24 14	 mov	 esi, DWORD PTR _argc$[esp+24]
  00090	40		 inc	 eax
  00091	89 44 24 10	 mov	 DWORD PTR _i$1$[esp+24], eax
  00095	3b c6		 cmp	 eax, esi
  00097	7c aa		 jl	 SHORT $LL3@WinStartUp
$LN1@WinStartUp:

; 1915 : 	}
; 1916 : 
; 1917 : 	exit(server_main(argc, argv));

  00099	89 35 00 00 00
	00		 mov	 DWORD PTR _global_argc, esi
  0009f	33 f6		 xor	 esi, esi
  000a1	68 00 00 00 00	 push	 OFFSET _NTServiceDispatchTable
  000a6	89 1d 00 00 00
	00		 mov	 DWORD PTR _global_argv, ebx
  000ac	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__StartServiceCtrlDispatcherA@4
  000b2	85 c0		 test	 eax, eax
  000b4	75 1e		 jne	 SHORT $LN13@WinStartUp
  000b6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  000bc	8b f0		 mov	 esi, eax
  000be	81 fe 27 04 00
	00		 cmp	 esi, 1063		; 00000427H
  000c4	75 0e		 jne	 SHORT $LN13@WinStartUp
  000c6	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _IsNTService, 0
  000cd	e8 00 00 00 00	 call	 _newmain
  000d2	8b f0		 mov	 esi, eax
$LN13@WinStartUp:
  000d4	56		 push	 esi
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN24@WinStartUp:
$LN17@WinStartUp:

; 1913 : 		argv[i] = (char*)vlmcsd_malloc(size);

  000db	e8 00 00 00 00	 call	 _OutOfMemory
$LN25@WinStartUp:
$LN22@WinStartUp:
  000e0	cc		 int	 3
_WinStartUp@0 ENDP
_TEXT	ENDS
END
