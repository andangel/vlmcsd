; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Dell\Desktop\vlmcsd\src\wingetopt.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_optind
PUBLIC	_opterr
PUBLIC	??_C@_02BAABKJLB@?9?9?$AA@			; `string'
COMM	_optarg:DWORD
COMM	_optopt:DWORD
_DATA	ENDS
;	COMDAT ??_C@_02BAABKJLB@?9?9?$AA@
CONST	SEGMENT
??_C@_02BAABKJLB@?9?9?$AA@ DB '--', 00H			; `string'
_optind	DD	01H
_opterr	DD	01H
?sp@?1??getopt@@9@9 DD 01H				; `getopt'::`2'::sp
PUBLIC	_getopt
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\wingetopt.c
;	COMDAT _getopt
_TEXT	SEGMENT
_opts$dead$ = 8						; size = 4
_getopt	PROC						; COMDAT
; _argc$dead$ = ecx
; _argv$dead$ = edx

; 33   : {

  00000	51		 push	 ecx

; 34   : 	static int sp = 1;
; 35   : 	register int c;
; 36   : 	register char *cp;
; 37   : 
; 38   : 	if (sp == 1)

  00001	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?sp@?1??getopt@@9@9
  00007	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
  0000d	53		 push	 ebx
  0000e	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _global_argc
  00014	55		 push	 ebp
  00015	33 ed		 xor	 ebp, ebp
  00017	56		 push	 esi
  00018	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR _global_argv
  0001e	45		 inc	 ebp
  0001f	57		 push	 edi
  00020	3b d5		 cmp	 edx, ebp
  00022	75 34		 jne	 SHORT $LN11@getopt

; 39   : 		if (optind >= argc ||
; 40   : 			argv[optind][0] != '-' || argv[optind][1] == '\0')

  00024	3b cb		 cmp	 ecx, ebx
  00026	7d 28		 jge	 SHORT $LN13@getopt
  00028	8b 3c 8e	 mov	 edi, DWORD PTR [esi+ecx*4]
  0002b	80 3f 2d	 cmp	 BYTE PTR [edi], 45	; 0000002dH
  0002e	75 20		 jne	 SHORT $LN13@getopt
  00030	80 7f 01 00	 cmp	 BYTE PTR [edi+1], 0
  00034	74 1a		 je	 SHORT $LN13@getopt

; 42   : 		else if (strcmp(argv[optind], "--") == 0) {

  00036	80 3f 2d	 cmp	 BYTE PTR [edi], 45	; 0000002dH
  00039	75 1d		 jne	 SHORT $LN11@getopt
  0003b	80 7f 01 2d	 cmp	 BYTE PTR [edi+1], 45	; 0000002dH
  0003f	75 17		 jne	 SHORT $LN11@getopt
  00041	0f b6 47 02	 movzx	 eax, BYTE PTR [edi+2]
  00045	84 c0		 test	 al, al
  00047	75 0f		 jne	 SHORT $LN11@getopt

; 43   : 			optind++;

  00049	41		 inc	 ecx
  0004a	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx
$LN13@getopt:

; 41   : 			return(EOF);

  00050	83 c8 ff	 or	 eax, -1
  00053	e9 be 00 00 00	 jmp	 $LN16@getopt
$LN11@getopt:

; 44   : 			return(EOF);
; 45   : 		}
; 46   : 		optopt = c = argv[optind][sp];

  00058	8b 04 8e	 mov	 eax, DWORD PTR [esi+ecx*4]
  0005b	0f be 3c 10	 movsx	 edi, BYTE PTR [eax+edx]
  0005f	89 3d 00 00 00
	00		 mov	 DWORD PTR _optopt, edi

; 47   : 		if (c == ':' || (cp = strchr(opts, c)) == NULL) {

  00065	83 ff 3a	 cmp	 edi, 58			; 0000003aH
  00068	0f 84 88 00 00
	00		 je	 $LN9@getopt
  0006e	57		 push	 edi
  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_0EN@OAFFBID@N?3B?3m?3t?3w?30?33?36?3H?3A?3R?3u?3G?3g?3L?3p?3@
  00074	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strchr
  0007a	59		 pop	 ecx
  0007b	59		 pop	 ecx
  0007c	85 c0		 test	 eax, eax
  0007e	74 6a		 je	 SHORT $LN18@getopt

; 54   : 		}
; 55   : 		if (*++cp == ':') {

  00080	80 78 01 3a	 cmp	 BYTE PTR [eax+1], 58	; 0000003aH

; 56   : 			if (argv[optind][sp + 1] != '\0')

  00084	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _optind
  0008a	75 30		 jne	 SHORT $LN7@getopt
  0008c	a1 00 00 00 00	 mov	 eax, DWORD PTR ?sp@?1??getopt@@9@9
  00091	40		 inc	 eax
  00092	03 04 96	 add	 eax, DWORD PTR [esi+edx*4]

; 57   : 				optarg = (char*)&argv[optind++][sp + 1];

  00095	42		 inc	 edx
  00096	89 15 00 00 00
	00		 mov	 DWORD PTR _optind, edx
  0009c	80 38 00	 cmp	 BYTE PTR [eax], 0
  0009f	75 0e		 jne	 SHORT $LN19@getopt

; 58   : 			else if (++optind >= argc) {

  000a1	3b d3		 cmp	 edx, ebx
  000a3	7d 68		 jge	 SHORT $LN20@getopt

; 59   : 				//ERR(": option requires an argument -- ", (char)c);
; 60   : 				sp = 1;
; 61   : 				return('?');
; 62   : 			}
; 63   : 			else
; 64   : 				optarg = (char*)argv[optind++];

  000a5	8b 04 96	 mov	 eax, DWORD PTR [esi+edx*4]
  000a8	42		 inc	 edx
  000a9	89 15 00 00 00
	00		 mov	 DWORD PTR _optind, edx
$LN19@getopt:
  000af	a3 00 00 00 00	 mov	 DWORD PTR _optarg, eax

; 65   : 			sp = 1;

  000b4	89 2d 00 00 00
	00		 mov	 DWORD PTR ?sp@?1??getopt@@9@9, ebp

; 66   : 		}
; 67   : 		else {

  000ba	eb 2a		 jmp	 SHORT $LN2@getopt
$LN7@getopt:

; 68   : 			if (argv[optind][++sp] == '\0') {

  000bc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?sp@?1??getopt@@9@9
  000c2	8b 04 96	 mov	 eax, DWORD PTR [esi+edx*4]
  000c5	41		 inc	 ecx
  000c6	89 0d 00 00 00
	00		 mov	 DWORD PTR ?sp@?1??getopt@@9@9, ecx
  000cc	80 3c 01 00	 cmp	 BYTE PTR [ecx+eax], 0
  000d0	75 0d		 jne	 SHORT $LN1@getopt

; 69   : 				sp = 1;
; 70   : 				optind++;

  000d2	42		 inc	 edx
  000d3	89 2d 00 00 00
	00		 mov	 DWORD PTR ?sp@?1??getopt@@9@9, ebp
  000d9	89 15 00 00 00
	00		 mov	 DWORD PTR _optind, edx
$LN1@getopt:

; 71   : 			}
; 72   : 			optarg = NULL;

  000df	83 25 00 00 00
	00 00		 and	 DWORD PTR _optarg, 0
$LN2@getopt:

; 73   : 		}
; 74   : 		return(c);

  000e6	8b c7		 mov	 eax, edi
  000e8	eb 2c		 jmp	 SHORT $LN16@getopt
$LN18@getopt:
  000ea	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?sp@?1??getopt@@9@9
  000f0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _optind
$LN9@getopt:

; 48   : 			//ERR(": illegal option -- ", (char)c);
; 49   : 			if (argv[optind][++sp] == '\0') {

  000f6	8b 04 8e	 mov	 eax, DWORD PTR [esi+ecx*4]
  000f9	42		 inc	 edx
  000fa	89 15 00 00 00
	00		 mov	 DWORD PTR ?sp@?1??getopt@@9@9, edx
  00100	80 3c 02 00	 cmp	 BYTE PTR [edx+eax], 0
  00104	75 0d		 jne	 SHORT $LN8@getopt

; 50   : 				optind++;

  00106	41		 inc	 ecx
  00107	89 0d 00 00 00
	00		 mov	 DWORD PTR _optind, ecx
$LN20@getopt:

; 51   : 				sp = 1;

  0010d	89 2d 00 00 00
	00		 mov	 DWORD PTR ?sp@?1??getopt@@9@9, ebp
$LN8@getopt:

; 52   : 			}
; 53   : 			return('?');

  00113	6a 3f		 push	 63			; 0000003fH
  00115	58		 pop	 eax
$LN16@getopt:
  00116	5f		 pop	 edi
  00117	5e		 pop	 esi
  00118	5d		 pop	 ebp
  00119	5b		 pop	 ebx

; 75   : }

  0011a	59		 pop	 ecx
  0011b	c3		 ret	 0
_getopt	ENDP
_TEXT	ENDS
END
