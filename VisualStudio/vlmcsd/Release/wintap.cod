; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Dell\Desktop\vlmcsd\src\wintap.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@NDMDBMPG@10?410?410?49?$AA@		; `string'
PUBLIC	??_C@_02PJNFELNH@30?$AA@			; `string'
PUBLIC	??_C@_02CEIGAHOJ@1d?$AA@			; `string'
PUBLIC	??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5ad@ ; `string'
PUBLIC	??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5m@ ; `string'
PUBLIC	??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4?5@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0M@OCLPIPDG@ComponentId?$AA@		; `string'
PUBLIC	??_C@_07OCKMHPIG@tap0801?$AA@			; `string'
PUBLIC	??_C@_07FKBABIOD@tap0901?$AA@			; `string'
PUBLIC	??_C@_0O@LGAJAMKD@TEAMVIEWERVPN?$AA@		; `string'
PUBLIC	??_C@_0BB@BKNOGGLI@NetCfgInstanceId?$AA@	; `string'
PUBLIC	??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0M@CGLKMMLF@?2Connection?$AA@		; `string'
PUBLIC	??_C@_04FABLJDN@Name?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0M@KLEKCEEC@?2?2?4?2Global?2?$AA@		; `string'
PUBLIC	??_C@_04MFFLHGKN@?4tap?$AA@			; `string'
PUBLIC	??_C@_04PFKDJIIE@?4dgt?$AA@			; `string'
PUBLIC	??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapter@ ; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC?$AA@ ; `string'
PUBLIC	??_C@_0BE@BMEHODCL@?5available?5for?5use?6?$AA@	; `string'
PUBLIC	??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5?$CC@ ; `string'
PUBLIC	??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5threa@ ; `string'
PUBLIC	??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started?6@ ; `string'
PUBLIC	??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5ass@ ; `string'
PUBLIC	??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6?$AA@ ; `string'
EXTRN	__imp__RegCloseKey@4:PROC
EXTRN	__imp__inet_ntoa@4:PROC
EXTRN	__imp__inet_addr@4:PROC
EXTRN	__imp__DeviceIoControl@32:PROC
EXTRN	__imp__GetIpAddrTable@12:PROC
EXTRN	__imp__RegOpenKeyExA@20:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__RegEnumKeyExA@32:PROC
EXTRN	__imp__strtol:PROC
EXTRN	__imp__RegQueryValueExA@24:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__strncmp:PROC
EXTRN	__imp__CreateFileA@28:PROC
;	COMDAT ??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6?$AA@
CONST	SEGMENT
??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6?$AA@ DB 'IPv4 address'
	DB	' %s assigned', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5ass@
CONST	SEGMENT
??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5ass@ DB 'Warning'
	DB	': IPv4 address %s not assigned', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started?6@
CONST	SEGMENT
??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started?6@ DB '%'
	DB	's %u.%u.%u device "%s" started', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5threa@
CONST	SEGMENT
??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5threa@ DB 'Fatal: Una'
	DB	'ble to start VPN thread: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5?$CC@
CONST	SEGMENT
??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5?$CC@ DB 'Warning'
	DB	': VPN thread for device "%s" exiting: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6?$AA@ DB 'Fatal'
	DB	': VPN adapter error: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BMEHODCL@?5available?5for?5use?6?$AA@
CONST	SEGMENT
??_C@_0BE@BMEHODCL@?5available?5for?5use?6?$AA@ DB ' available for use', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC?$AA@ DB ' with name "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapter@
CONST	SEGMENT
??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapter@ DB 'Fatal: No c'
	DB	'ompatible VPN adapter', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFKDJIIE@?4dgt?$AA@
CONST	SEGMENT
??_C@_04PFKDJIIE@?4dgt?$AA@ DB '.dgt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MFFLHGKN@?4tap?$AA@
CONST	SEGMENT
??_C@_04MFFLHGKN@?4tap?$AA@ DB '.tap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KLEKCEEC@?2?2?4?2Global?2?$AA@
CONST	SEGMENT
??_C@_0M@KLEKCEEC@?2?2?4?2Global?2?$AA@ DB '\\.\Global\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FABLJDN@Name?$AA@
CONST	SEGMENT
??_C@_04FABLJDN@Name?$AA@ DB 'Name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CGLKMMLF@?2Connection?$AA@
CONST	SEGMENT
??_C@_0M@CGLKMMLF@?2Connection?$AA@ DB '\Connection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE10'
	DB	'318}\', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BKNOGGLI@NetCfgInstanceId?$AA@
CONST	SEGMENT
??_C@_0BB@BKNOGGLI@NetCfgInstanceId?$AA@ DB 'NetCfgInstanceId', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LGAJAMKD@TEAMVIEWERVPN?$AA@
CONST	SEGMENT
??_C@_0O@LGAJAMKD@TEAMVIEWERVPN?$AA@ DB 'TEAMVIEWERVPN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKBABIOD@tap0901?$AA@
CONST	SEGMENT
??_C@_07FKBABIOD@tap0901?$AA@ DB 'tap0901', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OCKMHPIG@tap0801?$AA@
CONST	SEGMENT
??_C@_07OCKMHPIG@tap0801?$AA@ DB 'tap0801', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OCLPIPDG@ComponentId?$AA@
CONST	SEGMENT
??_C@_0M@OCLPIPDG@ComponentId?$AA@ DB 'ComponentId', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE1031'
	DB	'8}', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6?$AA@ DB 'Registry rea'
	DB	'd error: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6?$AA@ DB 'between %s and %'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4?5@
CONST	SEGMENT
??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4?5@ DB 'Fatal: Fo'
	DB	'r this subnet the IPv4 address must be ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5m@
CONST	SEGMENT
??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5m@ DB 'Fata'
	DB	'l: /%s is not a valid CIDR mask between /8 and /30', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5ad@
CONST	SEGMENT
??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5ad@ DB 'Fatal'
	DB	': %s is not a valid IPv4 address', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02CEIGAHOJ@1d?$AA@
CONST	SEGMENT
??_C@_02CEIGAHOJ@1d?$AA@ DB '1d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PJNFELNH@30?$AA@
CONST	SEGMENT
??_C@_02PJNFELNH@30?$AA@ DB '30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDMDBMPG@10?410?410?49?$AA@
CONST	SEGMENT
??_C@_0L@NDMDBMPG@10?410?410?49?$AA@ DB '10.10.10.9', 00H ; `string'
_szIpAddress DD	FLAT:??_C@_0L@NDMDBMPG@10?410?410?49?$AA@
_szLeaseDuration DD FLAT:??_C@_02CEIGAHOJ@1d?$AA@
_szMask	DD	FLAT:??_C@_02PJNFELNH@30?$AA@
PUBLIC	_startTap
_Mask	DD	01H DUP (?)
_Mtu	DD	01H DUP (?)
_DhcpLeaseDuration DD 01H DUP (?)
_Broadcast DD	01H DUP (?)
_IpPacket DD	01H DUP (?)
_szTapName DD	01H DUP (?)
_ActiveTapName DD 01H DUP (?)
_Network DD	01H DUP (?)
_DriverVersion DB 010H DUP (?)
_TapHandle DD	01H DUP (?)
_DhcpServer DD	01H DUP (?)
_IpAddress DD	01H DUP (?)
_AdapterClass DD 01H DUP (?)
_Cidr	DB	01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\wintap.c
;	COMDAT _startTap
_TEXT	SEGMENT
_tapDhcpCfg$ = -32					; size = 16
_tapTunCfg$ = -16					; size = 12
_isCableConnected$ = -4					; size = 4
_startTap PROC						; COMDAT
; _argument$dead$ = ecx

; 306  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _tapArgument
  00009	83 ec 24	 sub	 esp, 36			; 00000024H

; 307  : 	if (!strcmp(argument, "-")) return;

  0000c	80 39 2d	 cmp	 BYTE PTR [ecx], 45	; 0000002dH
  0000f	56		 push	 esi
  00010	75 0c		 jne	 SHORT $LN18@startTap
  00012	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  00016	84 c0		 test	 al, al
  00018	0f 84 7f 01 00
	00		 je	 $LN1@startTap
$LN18@startTap:

; 308  : 	parseTapArgument(argument);

  0001e	e8 00 00 00 00	 call	 _parseTapArgument

; 309  : 
; 310  : 	TapHandle = OpenTapHandle();

  00023	e8 00 00 00 00	 call	 _OpenTapHandle

; 311  : 
; 312  : 	// Get MTU and driver version
; 313  : 	DevCtl(TAP_WIN_IOCTL_GET_MTU, &Mtu, sizeof(Mtu));

  00028	6a 04		 push	 4
  0002a	ba 00 00 00 00	 mov	 edx, OFFSET _Mtu
  0002f	a3 00 00 00 00	 mov	 DWORD PTR _TapHandle, eax
  00034	b9 0c 00 22 00	 mov	 ecx, 2228236		; 0022000cH
  00039	e8 00 00 00 00	 call	 _DevCtl
  0003e	59		 pop	 ecx

; 314  : 	DevCtl(TAP_WIN_IOCTL_GET_VERSION, &DriverVersion, sizeof(DriverVersion));

  0003f	6a 10		 push	 16			; 00000010H
  00041	ba 00 00 00 00	 mov	 edx, OFFSET _DriverVersion
  00046	b9 08 00 22 00	 mov	 ecx, 2228232		; 00220008H
  0004b	e8 00 00 00 00	 call	 _DevCtl

; 315  : 
; 316  : 	// Configure TUN mode
; 317  : 	TapConfigTun_t tapTunCfg;
; 318  : 	tapTunCfg.Address.s_addr = BE32(IpAddress);

  00050	a1 00 00 00 00	 mov	 eax, DWORD PTR _IpAddress

; 319  : 	tapTunCfg.Network.s_addr = BE32(Network);
; 320  : 	tapTunCfg.Mask.s_addr = BE32(Mask);
; 321  : 	DevCtl(TAP_WIN_IOCTL_CONFIG_TUN, &tapTunCfg, sizeof(tapTunCfg));

  00055	8d 55 f0	 lea	 edx, DWORD PTR _tapTunCfg$[ebp]
  00058	0f c8		 bswap	 eax
  0005a	89 45 f0	 mov	 DWORD PTR _tapTunCfg$[ebp], eax
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _Network
  00062	0f c8		 bswap	 eax
  00064	89 45 f4	 mov	 DWORD PTR _tapTunCfg$[ebp+4], eax
  00067	a1 00 00 00 00	 mov	 eax, DWORD PTR _Mask
  0006c	59		 pop	 ecx
  0006d	0f c8		 bswap	 eax
  0006f	6a 0c		 push	 12			; 0000000cH
  00071	b9 28 00 22 00	 mov	 ecx, 2228264		; 00220028H
  00076	89 45 f8	 mov	 DWORD PTR _tapTunCfg$[ebp+8], eax
  00079	e8 00 00 00 00	 call	 _DevCtl
  0007e	59		 pop	 ecx

; 322  : 
; 323  : 	// Setup the drivers internal DHCP server
; 324  : 	TapConfigDhcp_t tapDhcpCfg;
; 325  : 	tapDhcpCfg.Address.s_addr = BE32(IpAddress);

  0007f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _IpAddress

; 326  : 	tapDhcpCfg.Mask.s_addr = BE32(Mask);
; 327  : 	tapDhcpCfg.DhcpServer.s_addr = BE32(IpAddress + 1);
; 328  : 	tapDhcpCfg.LeaseDuration = DhcpLeaseDuration;
; 329  : 	DevCtl(TAP_WIN_IOCTL_CONFIG_DHCP_MASQ, &tapDhcpCfg, sizeof(tapDhcpCfg));

  00085	8d 55 e0	 lea	 edx, DWORD PTR _tapDhcpCfg$[ebp]
  00088	8b c1		 mov	 eax, ecx
  0008a	0f c8		 bswap	 eax
  0008c	89 45 e0	 mov	 DWORD PTR _tapDhcpCfg$[ebp], eax
  0008f	a1 00 00 00 00	 mov	 eax, DWORD PTR _Mask
  00094	0f c8		 bswap	 eax
  00096	89 45 e4	 mov	 DWORD PTR _tapDhcpCfg$[ebp+4], eax
  00099	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  0009c	0f c8		 bswap	 eax
  0009e	89 45 e8	 mov	 DWORD PTR _tapDhcpCfg$[ebp+8], eax
  000a1	b9 1c 00 22 00	 mov	 ecx, 2228252		; 0022001cH
  000a6	a1 00 00 00 00	 mov	 eax, DWORD PTR _DhcpLeaseDuration
  000ab	6a 10		 push	 16			; 00000010H
  000ad	89 45 ec	 mov	 DWORD PTR _tapDhcpCfg$[ebp+12], eax
  000b0	e8 00 00 00 00	 call	 _DevCtl
  000b5	59		 pop	 ecx

; 330  : 
; 331  : 	// Connect the virtual network cable
; 332  : 	BOOL isCableConnected = TRUE;
; 333  : 	DevCtl(TAP_WIN_IOCTL_SET_MEDIA_STATUS, &isCableConnected, sizeof(isCableConnected));

  000b6	6a 04		 push	 4
  000b8	8d 55 fc	 lea	 edx, DWORD PTR _isCableConnected$[ebp]
  000bb	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _isCableConnected$[ebp], 1
  000c2	b9 18 00 22 00	 mov	 ecx, 2228248		; 00220018H
  000c7	e8 00 00 00 00	 call	 _DevCtl
  000cc	59		 pop	 ecx

; 334  : 
; 335  : 	// Allocate buffer and start mirror thread
; 336  : 	IpPacket = (IpPacket_t*)vlmcsd_malloc(Mtu);

  000cd	ff 35 00 00 00
	00		 push	 DWORD PTR _Mtu
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000d9	59		 pop	 ecx
  000da	85 c0		 test	 eax, eax
  000dc	0f 84 c0 00 00
	00		 je	 $LN21@startTap

; 337  : 	HANDLE threadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)TapMirror, NULL, 0, NULL);

  000e2	33 f6		 xor	 esi, esi
  000e4	a3 00 00 00 00	 mov	 DWORD PTR _IpPacket, eax
  000e9	56		 push	 esi
  000ea	56		 push	 esi
  000eb	56		 push	 esi
  000ec	68 00 00 00 00	 push	 OFFSET _TapMirror@4
  000f1	56		 push	 esi
  000f2	56		 push	 esi
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24

; 338  : 
; 339  : 	if (!threadHandle)

  000f9	85 c0		 test	 eax, eax
  000fb	75 23		 jne	 SHORT $LN6@startTap

; 340  : 	{
; 341  : 		DWORD error = GetLastError();

  000fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00103	8b f0		 mov	 esi, eax

; 342  : 		printerrorf("Fatal: Unable to start VPN thread: %s\n", win_strerror(error));

  00105	8b ce		 mov	 ecx, esi
  00107	e8 00 00 00 00	 call	 _win_strerror
  0010c	50		 push	 eax
  0010d	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5threa@
  00112	e8 00 00 00 00	 call	 _printerrorf
  00117	59		 pop	 ecx
  00118	59		 pop	 ecx

; 343  : 		exit(error);

  00119	56		 push	 esi
  0011a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN23@startTap:
$LN6@startTap:

; 344  : 	}
; 345  : 
; 346  : 	CloseHandle(threadHandle);

  00120	50		 push	 eax
  00121	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 347  : 
; 348  : #	ifndef NO_LOG
; 349  : 	logger("%s %u.%u.%u device \"%s\" started\n", AdapterClass, DriverVersion.Major, DriverVersion.Minor, DriverVersion.Build, ActiveTapName);

  00127	ff 35 00 00 00
	00		 push	 DWORD PTR _ActiveTapName
  0012d	ff 35 08 00 00
	00		 push	 DWORD PTR _DriverVersion+8
  00133	ff 35 04 00 00
	00		 push	 DWORD PTR _DriverVersion+4
  00139	ff 35 00 00 00
	00		 push	 DWORD PTR _DriverVersion
  0013f	ff 35 00 00 00
	00		 push	 DWORD PTR _AdapterClass
  00145	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started?6@
  0014a	e8 00 00 00 00	 call	 _logger
  0014f	83 c4 18	 add	 esp, 24			; 00000018H

; 350  : #	endif // NO_LOG
; 351  : 
; 352  : 	DWORD i;
; 353  : 	BOOL isAssigned;
; 354  : 
; 355  : 	// Wait up to 4 seconds until the IP address is up and running
; 356  : 	// so vlmcsd can actually bind to and listen on it
; 357  : 	for (i = 0; !((isAssigned = isAddressAssigned())) && i < 20; i++) Sleep(200);

  00152	e8 00 00 00 00	 call	 _isAddressAssigned
  00157	85 c0		 test	 eax, eax
  00159	75 30		 jne	 SHORT $LN2@startTap
$LL5@startTap:
  0015b	83 fe 14	 cmp	 esi, 20			; 00000014H
  0015e	73 15		 jae	 SHORT $LN3@startTap
  00160	68 c8 00 00 00	 push	 200			; 000000c8H
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__Sleep@4
  0016b	46		 inc	 esi
  0016c	e8 00 00 00 00	 call	 _isAddressAssigned
  00171	85 c0		 test	 eax, eax
  00173	74 e6		 je	 SHORT $LL5@startTap
$LN3@startTap:

; 358  : 
; 359  : 	if (!isAssigned)

  00175	85 c0		 test	 eax, eax
  00177	75 12		 jne	 SHORT $LN2@startTap

; 360  : 	{
; 361  : 		printerrorf("Warning: IPv4 address %s not assigned\n", szIpAddress);

  00179	ff 35 00 00 00
	00		 push	 DWORD PTR _szIpAddress
  0017f	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5ass@
  00184	e8 00 00 00 00	 call	 _printerrorf

; 362  : 	}
; 363  : 	else

  00189	eb 10		 jmp	 SHORT $LN20@startTap
$LN2@startTap:

; 364  : 	{
; 365  : #		ifndef NO_LOG
; 366  : 		logger("IPv4 address %s assigned\n", szIpAddress);

  0018b	ff 35 00 00 00
	00		 push	 DWORD PTR _szIpAddress
  00191	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6?$AA@
  00196	e8 00 00 00 00	 call	 _logger
$LN20@startTap:
  0019b	59		 pop	 ecx
  0019c	59		 pop	 ecx
$LN1@startTap:

; 367  : #		endif // NO_LOG
; 368  : 	}
; 369  : }

  0019d	5e		 pop	 esi
  0019e	8b e5		 mov	 esp, ebp
  001a0	5d		 pop	 ebp
  001a1	c3		 ret	 0
$LN21@startTap:

; 334  : 
; 335  : 	// Allocate buffer and start mirror thread
; 336  : 	IpPacket = (IpPacket_t*)vlmcsd_malloc(Mtu);

  001a2	e8 00 00 00 00	 call	 _OutOfMemory
$LN24@startTap:
$LN19@startTap:
  001a7	cc		 int	 3
_startTap ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\wintap.c
;	COMDAT _isAddressAssigned
_TEXT	SEGMENT
_dwSize$ = -4						; size = 4
_isAddressAssigned PROC					; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	53		 push	 ebx
  00005	56		 push	 esi
  00006	57		 push	 edi

; 40   : 	PMIB_IPADDRTABLE pIPAddrTable;
; 41   : 	DWORD dwSize = 0;

  00007	33 ff		 xor	 edi, edi

; 42   : 	BOOL result = FALSE;
; 43   : 
; 44   : 	pIPAddrTable = (PMIB_IPADDRTABLE)vlmcsd_malloc(sizeof(MIB_IPADDRTABLE));

  00009	6a 1c		 push	 28			; 0000001cH
  0000b	89 7d fc	 mov	 DWORD PTR _dwSize$[ebp], edi
  0000e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00014	8b d8		 mov	 ebx, eax
  00016	59		 pop	 ecx
  00017	85 db		 test	 ebx, ebx
  00019	0f 84 81 00 00
	00		 je	 $LN25@isAddressA

; 45   : 	DWORD status = GetIpAddrTable(pIPAddrTable, &dwSize, 0);

  0001f	57		 push	 edi
  00020	8d 45 fc	 lea	 eax, DWORD PTR _dwSize$[ebp]
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetIpAddrTable@12

; 46   : 	free(pIPAddrTable);

  0002b	53		 push	 ebx
  0002c	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__free
  00032	8b f0		 mov	 esi, eax
  00034	ff d3		 call	 ebx
  00036	59		 pop	 ecx

; 47   : 
; 48   : 	if (status != ERROR_INSUFFICIENT_BUFFER) return FALSE;

  00037	83 fe 7a	 cmp	 esi, 122		; 0000007aH
  0003a	74 04		 je	 SHORT $LN6@isAddressA
  0003c	33 c0		 xor	 eax, eax
  0003e	eb 59		 jmp	 SHORT $LN7@isAddressA
$LN6@isAddressA:

; 49   : 	pIPAddrTable = (MIB_IPADDRTABLE *)vlmcsd_malloc(dwSize);

  00040	ff 75 fc	 push	 DWORD PTR _dwSize$[ebp]
  00043	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00049	8b f0		 mov	 esi, eax
  0004b	59		 pop	 ecx
  0004c	85 f6		 test	 esi, esi
  0004e	74 50		 je	 SHORT $LN25@isAddressA

; 50   : 
; 51   : 	if (GetIpAddrTable(pIPAddrTable, &dwSize, 0))

  00050	57		 push	 edi
  00051	8d 45 fc	 lea	 eax, DWORD PTR _dwSize$[ebp]
  00054	50		 push	 eax
  00055	56		 push	 esi
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetIpAddrTable@12
  0005c	85 c0		 test	 eax, eax
  0005e	74 07		 je	 SHORT $LN5@isAddressA

; 52   : 	{
; 53   : 		free(pIPAddrTable);

  00060	56		 push	 esi
  00061	ff d3		 call	 ebx

; 54   : 		return FALSE;

  00063	33 c0		 xor	 eax, eax
  00065	eb 31		 jmp	 SHORT $LN23@isAddressA
$LN5@isAddressA:

; 55   : 	}
; 56   : 
; 57   : 	PMIB_IPADDRROW row;
; 58   : 	for (row = pIPAddrTable->table; row < pIPAddrTable->table + pIPAddrTable->dwNumEntries; row++)

  00067	6b 06 18	 imul	 eax, DWORD PTR [esi], 24
  0006a	8d 56 04	 lea	 edx, DWORD PTR [esi+4]
  0006d	8d 4e 04	 lea	 ecx, DWORD PTR [esi+4]
  00070	03 d0		 add	 edx, eax
  00072	3b ca		 cmp	 ecx, edx
  00074	73 1d		 jae	 SHORT $LN21@isAddressA

; 59   : 	{
; 60   : 		if (
; 61   : 			row->dwAddr == BE32(IpAddress) &&
; 62   : 			!(row->wType & (MIB_IPADDR_DELETED | MIB_IPADDR_DISCONNECTED | MIB_IPADDR_TRANSIENT))
; 63   : 			)

  00076	a1 00 00 00 00	 mov	 eax, DWORD PTR _IpAddress
  0007b	0f c8		 bswap	 eax
$LL4@isAddressA:
  0007d	39 01		 cmp	 DWORD PTR [ecx], eax
  0007f	75 06		 jne	 SHORT $LN3@isAddressA
  00081	f6 41 16 c8	 test	 BYTE PTR [ecx+22], 200	; 000000c8H
  00085	74 09		 je	 SHORT $LN17@isAddressA
$LN3@isAddressA:

; 55   : 	}
; 56   : 
; 57   : 	PMIB_IPADDRROW row;
; 58   : 	for (row = pIPAddrTable->table; row < pIPAddrTable->table + pIPAddrTable->dwNumEntries; row++)

  00087	83 c1 18	 add	 ecx, 24			; 00000018H
  0008a	3b ca		 cmp	 ecx, edx
  0008c	72 ef		 jb	 SHORT $LL4@isAddressA
  0008e	eb 03		 jmp	 SHORT $LN21@isAddressA
$LN17@isAddressA:

; 64   : 		{
; 65   : 			result = TRUE;

  00090	33 ff		 xor	 edi, edi
  00092	47		 inc	 edi
$LN21@isAddressA:

; 66   : 			break;
; 67   : 		}
; 68   : 	}
; 69   : 
; 70   : 	free(pIPAddrTable);

  00093	56		 push	 esi
  00094	ff d3		 call	 ebx

; 71   : 	return result;

  00096	8b c7		 mov	 eax, edi
$LN23@isAddressA:

; 66   : 			break;
; 67   : 		}
; 68   : 	}
; 69   : 
; 70   : 	free(pIPAddrTable);

  00098	59		 pop	 ecx
$LN7@isAddressA:
  00099	5f		 pop	 edi
  0009a	5e		 pop	 esi
  0009b	5b		 pop	 ebx

; 72   : }

  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c3		 ret	 0
$LN25@isAddressA:

; 42   : 	BOOL result = FALSE;
; 43   : 
; 44   : 	pIPAddrTable = (PMIB_IPADDRTABLE)vlmcsd_malloc(sizeof(MIB_IPADDRTABLE));

  000a0	e8 00 00 00 00	 call	 _OutOfMemory
$LN27@isAddressA:
$LN22@isAddressA:
  000a5	cc		 int	 3
_isAddressAssigned ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\wintap.c
;	COMDAT _parseTapArgument
_TEXT	SEGMENT
_next$ = -4						; size = 4
_parseTapArgument PROC					; COMDAT
; _argument$ = ecx

; 76   : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx
  00002	55		 push	 ebp
  00003	56		 push	 esi

; 77   : 	char* equalsignPosition = strchr(argument, (int)'=');

  00004	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__strchr
  0000a	57		 push	 edi
  0000b	8b f9		 mov	 edi, ecx
  0000d	6a 3d		 push	 61			; 0000003dH
  0000f	57		 push	 edi
  00010	ff d6		 call	 esi

; 78   : 	char* slashPosition = strchr(argument, (int)'/');

  00012	6a 2f		 push	 47			; 0000002fH
  00014	57		 push	 edi
  00015	8b e8		 mov	 ebp, eax
  00017	ff d6		 call	 esi

; 79   : 	char* colonPosition = strchr(argument, (int)':');

  00019	6a 3a		 push	 58			; 0000003aH
  0001b	57		 push	 edi
  0001c	8b d8		 mov	 ebx, eax
  0001e	ff d6		 call	 esi
  00020	83 c4 18	 add	 esp, 24			; 00000018H

; 80   : 
; 81   : 	szTapName = argument;

  00023	89 3d 00 00 00
	00		 mov	 DWORD PTR _szTapName, edi
  00029	8b d0		 mov	 edx, eax

; 82   : 
; 83   : 	if (equalsignPosition)

  0002b	85 ed		 test	 ebp, ebp
  0002d	74 0f		 je	 SHORT $LN21@parseTapAr

; 84   : 	{
; 85   : 		*equalsignPosition = 0;
; 86   : 		szIpAddress = equalsignPosition + 1;

  0002f	8d 4d 01	 lea	 ecx, DWORD PTR [ebp+1]
  00032	c6 45 00 00	 mov	 BYTE PTR [ebp], 0
  00036	89 0d 00 00 00
	00		 mov	 DWORD PTR _szIpAddress, ecx
  0003c	eb 06		 jmp	 SHORT $LN11@parseTapAr
$LN21@parseTapAr:
  0003e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _szIpAddress
$LN11@parseTapAr:

; 87   : 	}
; 88   : 
; 89   : 	if (slashPosition)

  00044	85 db		 test	 ebx, ebx
  00046	74 0b		 je	 SHORT $LN10@parseTapAr

; 90   : 	{
; 91   : 		*slashPosition = 0;
; 92   : 		szMask = slashPosition + 1;

  00048	8d 43 01	 lea	 eax, DWORD PTR [ebx+1]
  0004b	c6 03 00	 mov	 BYTE PTR [ebx], 0
  0004e	a3 00 00 00 00	 mov	 DWORD PTR _szMask, eax
$LN10@parseTapAr:

; 93   : 	}
; 94   : 
; 95   : 	if (colonPosition)

  00053	85 d2		 test	 edx, edx
  00055	74 0b		 je	 SHORT $LN9@parseTapAr

; 96   : 	{
; 97   : 		*colonPosition = 0;
; 98   : 		szLeaseDuration = colonPosition + 1;

  00057	8d 42 01	 lea	 eax, DWORD PTR [edx+1]
  0005a	c6 02 00	 mov	 BYTE PTR [edx], 0
  0005d	a3 00 00 00 00	 mov	 DWORD PTR _szLeaseDuration, eax
$LN9@parseTapAr:

; 99   : 	}
; 100  : 
; 101  : 	IpAddress = BE32(inet_addr(szIpAddress));

  00062	51		 push	 ecx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__inet_addr@4
  00069	0f c8		 bswap	 eax

; 102  : 
; 103  : 	if (IpAddress == BE32(INADDR_NONE))

  0006b	83 ce ff	 or	 esi, -1
  0006e	a3 00 00 00 00	 mov	 DWORD PTR _IpAddress, eax
  00073	3b c6		 cmp	 eax, esi
  00075	75 1a		 jne	 SHORT $LN8@parseTapAr

; 104  : 	{
; 105  : 		printerrorf("Fatal: %s is not a valid IPv4 address\n", szIpAddress);

  00077	ff 35 00 00 00
	00		 push	 DWORD PTR _szIpAddress
  0007d	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5ad@
$LN23@parseTapAr:
  00082	e8 00 00 00 00	 call	 _printerrorf
  00087	59		 pop	 ecx
  00088	59		 pop	 ecx
$LN1@parseTapAr:

; 106  : 		exit(VLMCSD_EINVAL);

  00089	6a 57		 push	 87			; 00000057H
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN27@parseTapAr:
$LN8@parseTapAr:

; 107  : 	}
; 108  : 
; 109  : 	char* next;
; 110  : 	Cidr = (uint8_t)strtol(szMask, &next, 10);

  00091	6a 0a		 push	 10			; 0000000aH
  00093	8d 44 24 14	 lea	 eax, DWORD PTR _next$[esp+24]
  00097	50		 push	 eax
  00098	ff 35 00 00 00
	00		 push	 DWORD PTR _szMask
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol

; 111  : 
; 112  : 	if (*next || Cidr < 8 || Cidr > 30)

  000a4	8b 4c 24 1c	 mov	 ecx, DWORD PTR _next$[esp+32]
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	a2 00 00 00 00	 mov	 BYTE PTR _Cidr, al
  000b0	80 39 00	 cmp	 BYTE PTR [ecx], 0
  000b3	0f 85 c1 00 00
	00		 jne	 $LN6@parseTapAr
  000b9	2c 08		 sub	 al, 8
  000bb	3c 16		 cmp	 al, 22			; 00000016H
  000bd	0f 87 b7 00 00
	00		 ja	 $LN6@parseTapAr

; 116  : 	}
; 117  : 
; 118  : 	if (!((DhcpLeaseDuration = timeSpanString2Seconds(szLeaseDuration))))

  000c3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _szLeaseDuration
  000c9	e8 00 00 00 00	 call	 _timeSpanString2Seconds
  000ce	a3 00 00 00 00	 mov	 DWORD PTR _DhcpLeaseDuration, eax
  000d3	85 c0		 test	 eax, eax
  000d5	75 09		 jne	 SHORT $LN5@parseTapAr

; 119  : 	{
; 120  : 		printerrorf("Fatal: No valid time span specified in option -%c.\n", 'O');

  000d7	6a 4f		 push	 79			; 0000004fH
  000d9	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5specif@

; 121  : 		exit(VLMCSD_EINVAL);

  000de	eb a2		 jmp	 SHORT $LN23@parseTapAr
$LN5@parseTapAr:

; 122  : 	}
; 123  : 
; 124  : 	Mask = (uint32_t)~(0xffffffff >> Cidr);

  000e0	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR _Cidr

; 125  : 	Network = IpAddress & Mask;

  000e6	a1 00 00 00 00	 mov	 eax, DWORD PTR _IpAddress
  000eb	d3 ee		 shr	 esi, cl
  000ed	f7 d6		 not	 esi
  000ef	8b ce		 mov	 ecx, esi
  000f1	89 35 00 00 00
	00		 mov	 DWORD PTR _Mask, esi
  000f7	23 c8		 and	 ecx, eax

; 126  : 	Broadcast = IpAddress | ~Mask;
; 127  : 	DhcpServer = IpAddress + 1;

  000f9	8d 50 01	 lea	 edx, DWORD PTR [eax+1]
  000fc	f7 d6		 not	 esi
  000fe	89 0d 00 00 00
	00		 mov	 DWORD PTR _Network, ecx
  00104	0b f0		 or	 esi, eax
  00106	89 15 00 00 00
	00		 mov	 DWORD PTR _DhcpServer, edx
  0010c	89 35 00 00 00
	00		 mov	 DWORD PTR _Broadcast, esi

; 128  : 
; 129  : 	if (IpAddress <= Network || IpAddress + 1 >= Broadcast)

  00112	3b c1		 cmp	 eax, ecx
  00114	76 04		 jbe	 SHORT $LN3@parseTapAr
  00116	3b d6		 cmp	 edx, esi
  00118	72 70		 jb	 SHORT $LN4@parseTapAr
$LN3@parseTapAr:

; 130  : 	{
; 131  : 		uint32_t lowerIpBE = BE32(Network + 1);
; 132  : 		uint32_t upperIpBE = BE32(Broadcast - 2);
; 133  : 		const char* szLower = vlmcsd_strdup(inet_ntoa(*(struct in_addr*)&lowerIpBE));

  0011a	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__inet_ntoa@4
  00120	8d 69 01	 lea	 ebp, DWORD PTR [ecx+1]
  00123	0f cd		 bswap	 ebp
  00125	8d 7e fe	 lea	 edi, DWORD PTR [esi-2]
  00128	55		 push	 ebp
  00129	0f cf		 bswap	 edi
  0012b	ff d3		 call	 ebx
  0012d	50		 push	 eax
  0012e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  00134	8b f0		 mov	 esi, eax
  00136	59		 pop	 ecx
  00137	85 f6		 test	 esi, esi
  00139	74 55		 je	 SHORT $LN25@parseTapAr

; 134  : 		const char* szUpper = vlmcsd_strdup(inet_ntoa(*(struct in_addr*)&upperIpBE));

  0013b	57		 push	 edi
  0013c	ff d3		 call	 ebx
  0013e	50		 push	 eax
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  00145	8b d8		 mov	 ebx, eax
  00147	59		 pop	 ecx
  00148	85 db		 test	 ebx, ebx
  0014a	74 44		 je	 SHORT $LN25@parseTapAr

; 135  : 
; 136  : 		printerrorf("Fatal: For this subnet the IPv4 address must be ");

  0014c	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4?5@
  00151	e8 00 00 00 00	 call	 _printerrorf
  00156	59		 pop	 ecx

; 137  : 
; 138  : 		if (lowerIpBE == upperIpBE)

  00157	3b ef		 cmp	 ebp, edi
  00159	75 0b		 jne	 SHORT $LN2@parseTapAr

; 139  : 		{
; 140  : 			printerrorf("%s\n", szLower);

  0015b	56		 push	 esi
  0015c	68 00 00 00 00	 push	 OFFSET ??_C@_03OFAPEBGM@?$CFs?6?$AA@

; 141  : 		}
; 142  : 		else

  00161	e9 1c ff ff ff	 jmp	 $LN23@parseTapAr
$LN2@parseTapAr:

; 143  : 		{
; 144  : 			printerrorf("between %s and %s\n", szLower, szUpper);

  00166	53		 push	 ebx
  00167	56		 push	 esi
  00168	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6?$AA@
  0016d	e8 00 00 00 00	 call	 _printerrorf
  00172	83 c4 0c	 add	 esp, 12			; 0000000cH

; 145  : 		}
; 146  : 
; 147  : 		exit(VLMCSD_EINVAL);

  00175	e9 0f ff ff ff	 jmp	 $LN1@parseTapAr
$LN6@parseTapAr:

; 113  : 	{
; 114  : 		printerrorf("Fatal: /%s is not a valid CIDR mask between /8 and /30\n", szMask);

  0017a	ff 35 00 00 00
	00		 push	 DWORD PTR _szMask
  00180	68 00 00 00 00	 push	 OFFSET ??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5m@

; 115  : 		exit(VLMCSD_EINVAL);

  00185	e9 f8 fe ff ff	 jmp	 $LN23@parseTapAr
$LN4@parseTapAr:

; 148  : 	}
; 149  : }

  0018a	5f		 pop	 edi
  0018b	5e		 pop	 esi
  0018c	5d		 pop	 ebp
  0018d	5b		 pop	 ebx
  0018e	59		 pop	 ecx
  0018f	c3		 ret	 0
$LN25@parseTapAr:

; 130  : 	{
; 131  : 		uint32_t lowerIpBE = BE32(Network + 1);
; 132  : 		uint32_t upperIpBE = BE32(Broadcast - 2);
; 133  : 		const char* szLower = vlmcsd_strdup(inet_ntoa(*(struct in_addr*)&lowerIpBE));

  00190	e8 00 00 00 00	 call	 _OutOfMemory
$LN28@parseTapAr:
$LN22@parseTapAr:
  00195	cc		 int	 3
_parseTapArgument ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\wintap.c
;	COMDAT _WinErrorExit
_TEXT	SEGMENT
_WinErrorExit PROC					; COMDAT
; _error$ = ecx

; 153  : {

  00000	56		 push	 esi
  00001	8b f1		 mov	 esi, ecx

; 154  : 	printerrorf("Registry read error: %s\n", win_strerror((int)error));

  00003	e8 00 00 00 00	 call	 _win_strerror
  00008	50		 push	 eax
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6?$AA@
  0000e	e8 00 00 00 00	 call	 _printerrorf
  00013	59		 pop	 ecx
  00014	59		 pop	 ecx

; 155  : 	exit(error);

  00015	56		 push	 esi
  00016	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0001c	5e		 pop	 esi
$LN4@WinErrorEx:
$LN3@WinErrorEx:
_WinErrorExit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\wintap.c
;	COMDAT _OpenTapHandle
_TEXT	SEGMENT
_regDataSize$1 = -1052					; size = 4
_type$2 = -1048						; size = 4
_regAdapterKey$ = -1044					; size = 4
_regSubKey$3 = -1040					; size = 4
_subKeySize$ = -1036					; size = 4
_connectionKey$4 = -1032				; size = 4
_i$1$ = -1028						; size = 4
_regData$5 = -1024					; size = 256
_deviceName$6 = -768					; size = 256
_connectionKeyName$7 = -512				; size = 256
_subkeyName$ = -256					; size = 256
_OpenTapHandle PROC					; COMDAT

; 160  : {

  00000	81 ec 1c 04 00
	00		 sub	 esp, 1052		; 0000041cH

; 161  : 	HANDLE handle = INVALID_HANDLE_VALUE;
; 162  : 	HKEY regAdapterKey;
; 163  : 	DWORD regResult;
; 164  : 	if ((regResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ADAPTER_KEY, 0, KEY_READ | KEY_WOW64_64KEY, &regAdapterKey)) != ERROR_SUCCESS)

  00006	8d 44 24 08	 lea	 eax, DWORD PTR _regAdapterKey$[esp+1052]
  0000a	53		 push	 ebx
  0000b	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__RegOpenKeyExA@20
  00011	55		 push	 ebp
  00012	56		 push	 esi
  00013	50		 push	 eax
  00014	68 19 01 02 00	 push	 131353			; 00020119H
  00019	33 ed		 xor	 ebp, ebp
  0001b	83 ce ff	 or	 esi, -1
  0001e	55		 push	 ebp
  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Control@
  00024	68 02 00 00 80	 push	 -2147483646		; 80000002H
  00029	ff d3		 call	 ebx
  0002b	85 c0		 test	 eax, eax
  0002d	0f 85 83 03 00
	00		 jne	 $LN42@OpenTapHan

; 167  : 	}
; 168  : 
; 169  : 	char subkeyName[TAP_REGISTRY_DATA_SIZE];
; 170  : 	DWORD i, subKeySize = sizeof(subkeyName);
; 171  : 
; 172  : 	for (i = 0; (regResult = RegEnumKeyEx(regAdapterKey, i, subkeyName, &subKeySize, NULL, NULL, NULL, NULL)) != ERROR_NO_MORE_ITEMS; i++)

  00033	57		 push	 edi
  00034	55		 push	 ebp
  00035	55		 push	 ebp
  00036	55		 push	 ebp
  00037	55		 push	 ebp
  00038	8d 44 24 30	 lea	 eax, DWORD PTR _subKeySize$[esp+1084]
  0003c	c7 44 24 30 00
	01 00 00	 mov	 DWORD PTR _subKeySize$[esp+1084], 256 ; 00000100H
  00044	50		 push	 eax
  00045	8d 84 24 40 03
	00 00		 lea	 eax, DWORD PTR _subkeyName$[esp+1088]
  0004c	89 6c 24 3c	 mov	 DWORD PTR _i$1$[esp+1088], ebp
  00050	50		 push	 eax
  00051	55		 push	 ebp
  00052	ff 74 24 34	 push	 DWORD PTR _regAdapterKey$[esp+1096]
  00056	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegEnumKeyExA@32
  0005c	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__RegCloseKey@4
  00062	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  00067	0f 84 e3 02 00
	00		 je	 $LN33@OpenTapHan
  0006d	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__strncmp
$LL18@OpenTapHan:

; 173  : 	{
; 174  : 		HKEY regSubKey;
; 175  : 		DWORD type, regDataSize;
; 176  : 		char regData[TAP_REGISTRY_DATA_SIZE];
; 177  : 
; 178  : 		if (regResult) WinErrorExit(regResult);

  00073	85 c0		 test	 eax, eax
  00075	0f 85 47 03 00
	00		 jne	 $LN30@OpenTapHan

; 179  : 
; 180  : 		if ((regResult = RegOpenKeyEx(regAdapterKey, subkeyName, 0, KEY_READ | KEY_WOW64_64KEY, &regSubKey)) == ERROR_SUCCESS)

  0007b	8d 44 24 1c	 lea	 eax, DWORD PTR _regSubKey$3[esp+1068]
  0007f	50		 push	 eax
  00080	68 19 01 02 00	 push	 131353			; 00020119H
  00085	6a 00		 push	 0
  00087	8d 84 24 38 03
	00 00		 lea	 eax, DWORD PTR _subkeyName$[esp+1080]
  0008e	50		 push	 eax
  0008f	ff 74 24 28	 push	 DWORD PTR _regAdapterKey$[esp+1084]
  00093	ff d3		 call	 ebx
  00095	85 c0		 test	 eax, eax
  00097	0f 85 6e 02 00
	00		 jne	 $LN5@OpenTapHan

; 181  : 		{
; 182  : 			regDataSize = sizeof(regData);
; 183  : 
; 184  : 			if (RegQueryValueEx(regSubKey, "ComponentId", NULL, &type, (LPBYTE)regData, &regDataSize) == ERROR_SUCCESS)

  0009d	8d 44 24 10	 lea	 eax, DWORD PTR _regDataSize$1[esp+1068]
  000a1	c7 44 24 10 00
	01 00 00	 mov	 DWORD PTR _regDataSize$1[esp+1068], 256 ; 00000100H
  000a9	50		 push	 eax
  000aa	8d 44 24 30	 lea	 eax, DWORD PTR _regData$5[esp+1072]
  000ae	50		 push	 eax
  000af	8d 44 24 1c	 lea	 eax, DWORD PTR _type$2[esp+1076]
  000b3	50		 push	 eax
  000b4	6a 00		 push	 0
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0M@OCLPIPDG@ComponentId?$AA@
  000bb	ff 74 24 30	 push	 DWORD PTR _regSubKey$3[esp+1088]
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  000c5	85 c0		 test	 eax, eax
  000c7	0f 85 3e 02 00
	00		 jne	 $LN5@OpenTapHan

; 185  : 			{
; 186  : 				if (
; 187  : 					type == REG_SZ &&
; 188  : 					(
; 189  : 						!strncmp(regData, "tap0801", sizeof(regData)) ||
; 190  : 						!strncmp(regData, "tap0901", sizeof(regData)) ||
; 191  : 						!strncmp(regData, "TEAMVIEWERVPN", sizeof(regData))
; 192  : 						)
; 193  : 					)

  000cd	83 7c 24 14 01	 cmp	 DWORD PTR _type$2[esp+1068], 1
  000d2	0f 85 33 02 00
	00		 jne	 $LN5@OpenTapHan
  000d8	68 00 01 00 00	 push	 256			; 00000100H
  000dd	8d 44 24 30	 lea	 eax, DWORD PTR _regData$5[esp+1072]
  000e1	68 00 00 00 00	 push	 OFFSET ??_C@_07OCKMHPIG@tap0801?$AA@
  000e6	50		 push	 eax
  000e7	ff d5		 call	 ebp
  000e9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ec	85 c0		 test	 eax, eax
  000ee	74 34		 je	 SHORT $LN11@OpenTapHan
  000f0	68 00 01 00 00	 push	 256			; 00000100H
  000f5	8d 44 24 30	 lea	 eax, DWORD PTR _regData$5[esp+1072]
  000f9	68 00 00 00 00	 push	 OFFSET ??_C@_07FKBABIOD@tap0901?$AA@
  000fe	50		 push	 eax
  000ff	ff d5		 call	 ebp
  00101	83 c4 0c	 add	 esp, 12			; 0000000cH
  00104	85 c0		 test	 eax, eax
  00106	74 1c		 je	 SHORT $LN11@OpenTapHan
  00108	68 00 01 00 00	 push	 256			; 00000100H
  0010d	8d 44 24 30	 lea	 eax, DWORD PTR _regData$5[esp+1072]
  00111	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LGAJAMKD@TEAMVIEWERVPN?$AA@
  00116	50		 push	 eax
  00117	ff d5		 call	 ebp
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011c	85 c0		 test	 eax, eax
  0011e	0f 85 e7 01 00
	00		 jne	 $LN5@OpenTapHan
$LN11@OpenTapHan:

; 194  : 				{
; 195  : 					AdapterClass = vlmcsd_strdup(regData);

  00124	8d 44 24 2c	 lea	 eax, DWORD PTR _regData$5[esp+1068]
  00128	50		 push	 eax
  00129	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  0012f	59		 pop	 ecx
  00130	85 c0		 test	 eax, eax
  00132	0f 84 85 02 00
	00		 je	 $LN32@OpenTapHan
  00138	a3 00 00 00 00	 mov	 DWORD PTR _AdapterClass, eax

; 196  : 					regDataSize = sizeof(regData);
; 197  : 
; 198  : 					if (RegQueryValueEx(regSubKey, "NetCfgInstanceId", NULL, &type, (LPBYTE)regData, &regDataSize) == ERROR_SUCCESS && type == REG_SZ)

  0013d	8d 44 24 10	 lea	 eax, DWORD PTR _regDataSize$1[esp+1068]
  00141	50		 push	 eax
  00142	8d 44 24 30	 lea	 eax, DWORD PTR _regData$5[esp+1072]
  00146	c7 44 24 14 00
	01 00 00	 mov	 DWORD PTR _regDataSize$1[esp+1072], 256 ; 00000100H
  0014e	50		 push	 eax
  0014f	8d 44 24 1c	 lea	 eax, DWORD PTR _type$2[esp+1076]
  00153	50		 push	 eax
  00154	6a 00		 push	 0
  00156	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@BKNOGGLI@NetCfgInstanceId?$AA@
  0015b	ff 74 24 30	 push	 DWORD PTR _regSubKey$3[esp+1088]
  0015f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00165	85 c0		 test	 eax, eax
  00167	0f 85 8c 01 00
	00		 jne	 $LN10@OpenTapHan
  0016d	83 7c 24 14 01	 cmp	 DWORD PTR _type$2[esp+1068], 1
  00172	0f 85 81 01 00
	00		 jne	 $LN10@OpenTapHan

; 199  : 					{
; 200  : 						HKEY connectionKey;
; 201  : 						char connectionKeyName[TAP_REGISTRY_DATA_SIZE];
; 202  : 
; 203  : 						strncpy(connectionKeyName, NETWORK_CONNECTIONS_KEY "\\", sizeof(connectionKeyName));

  00178	68 00 01 00 00	 push	 256			; 00000100H
  0017d	8d 84 24 30 02
	00 00		 lea	 eax, DWORD PTR _connectionKeyName$7[esp+1072]
  00184	68 00 00 00 00	 push	 OFFSET ??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Control@
  00189	50		 push	 eax
  0018a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy

; 204  : 						strncat(connectionKeyName, regData, sizeof(connectionKeyName));

  00190	68 00 01 00 00	 push	 256			; 00000100H
  00195	8d 44 24 3c	 lea	 eax, DWORD PTR _regData$5[esp+1084]
  00199	50		 push	 eax
  0019a	8d 84 24 40 02
	00 00		 lea	 eax, DWORD PTR _connectionKeyName$7[esp+1088]
  001a1	50		 push	 eax
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncat

; 205  : 						strncat(connectionKeyName, "\\Connection", sizeof(connectionKeyName));

  001a8	68 00 01 00 00	 push	 256			; 00000100H
  001ad	8d 84 24 48 02
	00 00		 lea	 eax, DWORD PTR _connectionKeyName$7[esp+1096]
  001b4	68 00 00 00 00	 push	 OFFSET ??_C@_0M@CGLKMMLF@?2Connection?$AA@
  001b9	50		 push	 eax
  001ba	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncat
  001c0	83 c4 24	 add	 esp, 36			; 00000024H

; 206  : 
; 207  : 						if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, connectionKeyName, 0, KEY_READ | KEY_WOW64_64KEY, &connectionKey) == ERROR_SUCCESS)

  001c3	8d 44 24 24	 lea	 eax, DWORD PTR _connectionKey$4[esp+1068]
  001c7	50		 push	 eax
  001c8	68 19 01 02 00	 push	 131353			; 00020119H
  001cd	6a 00		 push	 0
  001cf	8d 84 24 38 02
	00 00		 lea	 eax, DWORD PTR _connectionKeyName$7[esp+1080]
  001d6	50		 push	 eax
  001d7	68 02 00 00 80	 push	 -2147483646		; 80000002H
  001dc	ff d3		 call	 ebx
  001de	85 c0		 test	 eax, eax
  001e0	0f 85 0d 01 00
	00		 jne	 $LN7@OpenTapHan

; 208  : 						{
; 209  : 							char deviceName[TAP_REGISTRY_DATA_SIZE];
; 210  : 							regDataSize = sizeof(deviceName);
; 211  : 
; 212  : 							if (RegQueryValueEx(connectionKey, "Name", NULL, &type, (LPBYTE)deviceName, &regDataSize) == ERROR_SUCCESS && type == REG_SZ)

  001e6	8d 44 24 10	 lea	 eax, DWORD PTR _regDataSize$1[esp+1068]
  001ea	c7 44 24 10 00
	01 00 00	 mov	 DWORD PTR _regDataSize$1[esp+1068], 256 ; 00000100H
  001f2	50		 push	 eax
  001f3	8d 84 24 30 01
	00 00		 lea	 eax, DWORD PTR _deviceName$6[esp+1072]
  001fa	50		 push	 eax
  001fb	8d 44 24 1c	 lea	 eax, DWORD PTR _type$2[esp+1076]
  001ff	50		 push	 eax
  00200	6a 00		 push	 0
  00202	68 00 00 00 00	 push	 OFFSET ??_C@_04FABLJDN@Name?$AA@
  00207	ff 74 24 38	 push	 DWORD PTR _connectionKey$4[esp+1088]
  0020b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegQueryValueExA@24
  00211	85 c0		 test	 eax, eax
  00213	0f 85 da 00 00
	00		 jne	 $LN7@OpenTapHan
  00219	83 7c 24 14 01	 cmp	 DWORD PTR _type$2[esp+1068], 1
  0021e	0f 85 cf 00 00
	00		 jne	 $LN7@OpenTapHan

; 213  : 							{
; 214  : 								if (!strcmp(szTapName, ".") || !strncasecmp(szTapName, deviceName, sizeof(deviceName)))

  00224	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _szTapName
  0022a	80 39 2e	 cmp	 BYTE PTR [ecx], 46	; 0000002eH
  0022d	75 08		 jne	 SHORT $LN38@OpenTapHan
  0022f	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  00233	84 c0		 test	 al, al
  00235	74 1f		 je	 SHORT $LN6@OpenTapHan
$LN38@OpenTapHan:
  00237	68 00 01 00 00	 push	 256			; 00000100H
  0023c	8d 84 24 30 01
	00 00		 lea	 eax, DWORD PTR _deviceName$6[esp+1072]
  00243	50		 push	 eax
  00244	51		 push	 ecx
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strnicmp
  0024b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0024e	85 c0		 test	 eax, eax
  00250	0f 85 9d 00 00
	00		 jne	 $LN7@OpenTapHan
$LN6@OpenTapHan:

; 215  : 								{
; 216  : 									ActiveTapName = vlmcsd_strdup(deviceName);

  00256	8d 84 24 2c 01
	00 00		 lea	 eax, DWORD PTR _deviceName$6[esp+1068]
  0025d	50		 push	 eax
  0025e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___strdup
  00264	59		 pop	 ecx
  00265	85 c0		 test	 eax, eax
  00267	0f 84 50 01 00
	00		 je	 $LN32@OpenTapHan

; 217  : 									strncpy(deviceName, USERMODEDEVICEDIR, sizeof(deviceName));

  0026d	be 00 01 00 00	 mov	 esi, 256		; 00000100H
  00272	a3 00 00 00 00	 mov	 DWORD PTR _ActiveTapName, eax
  00277	56		 push	 esi
  00278	8d 84 24 30 01
	00 00		 lea	 eax, DWORD PTR _deviceName$6[esp+1072]
  0027f	68 00 00 00 00	 push	 OFFSET ??_C@_0M@KLEKCEEC@?2?2?4?2Global?2?$AA@
  00284	50		 push	 eax
  00285	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strncpy

; 218  : 									strncat(deviceName, regData, sizeof(deviceName));

  0028b	56		 push	 esi
  0028c	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__strncat
  00292	8d 44 24 3c	 lea	 eax, DWORD PTR _regData$5[esp+1084]
  00296	50		 push	 eax
  00297	8d 84 24 40 01
	00 00		 lea	 eax, DWORD PTR _deviceName$6[esp+1088]
  0029e	50		 push	 eax
  0029f	ff d6		 call	 esi

; 219  : 									strncat(deviceName, strcmp(AdapterClass, "TEAMVIEWERVPN") ? TAP_WIN_SUFFIX : ".dgt", sizeof(deviceName));

  002a1	6a 0e		 push	 14			; 0000000eH
  002a3	68 00 00 00 00	 push	 OFFSET ??_C@_0O@LGAJAMKD@TEAMVIEWERVPN?$AA@
  002a8	ff 35 00 00 00
	00		 push	 DWORD PTR _AdapterClass
  002ae	e8 00 00 00 00	 call	 _memcmp
  002b3	85 c0		 test	 eax, eax
  002b5	ba 00 00 00 00	 mov	 edx, OFFSET ??_C@_04PFKDJIIE@?4dgt?$AA@
  002ba	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_04MFFLHGKN@?4tap?$AA@
  002bf	8d 84 24 50 01
	00 00		 lea	 eax, DWORD PTR _deviceName$6[esp+1104]
  002c6	68 00 01 00 00	 push	 256			; 00000100H
  002cb	0f 44 ca	 cmove	 ecx, edx
  002ce	51		 push	 ecx
  002cf	50		 push	 eax
  002d0	ff d6		 call	 esi
  002d2	83 c4 30	 add	 esp, 48			; 00000030H

; 220  : 									handle = CreateFile(deviceName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, NULL);

  002d5	33 c0		 xor	 eax, eax
  002d7	50		 push	 eax
  002d8	6a 04		 push	 4
  002da	6a 03		 push	 3
  002dc	50		 push	 eax
  002dd	50		 push	 eax
  002de	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  002e3	8d 84 24 44 01
	00 00		 lea	 eax, DWORD PTR _deviceName$6[esp+1092]
  002ea	50		 push	 eax
  002eb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  002f1	8b f0		 mov	 esi, eax
$LN7@OpenTapHan:

; 221  : 								}
; 222  : 							}
; 223  : 						}
; 224  : 
; 225  : 						RegCloseKey(connectionKey);

  002f3	ff 74 24 24	 push	 DWORD PTR _connectionKey$4[esp+1068]
  002f7	ff d7		 call	 edi
$LN10@OpenTapHan:

; 226  : 					}
; 227  : 
; 228  : 					if (handle == INVALID_HANDLE_VALUE) free(AdapterClass);

  002f9	83 fe ff	 cmp	 esi, -1
  002fc	75 0d		 jne	 SHORT $LN5@OpenTapHan
  002fe	ff 35 00 00 00
	00		 push	 DWORD PTR _AdapterClass
  00304	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0030a	59		 pop	 ecx
$LN5@OpenTapHan:

; 229  : 				}
; 230  : 			}
; 231  : 		}
; 232  : 
; 233  : 		RegCloseKey(regSubKey);

  0030b	ff 74 24 1c	 push	 DWORD PTR _regSubKey$3[esp+1068]
  0030f	ff d7		 call	 edi

; 234  : 		subKeySize = sizeof(subkeyName);

  00311	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR _subKeySize$[esp+1068], 256 ; 00000100H

; 235  : 		if (handle != INVALID_HANDLE_VALUE) break;

  00319	83 fe ff	 cmp	 esi, -1
  0031c	75 32		 jne	 SHORT $LN33@OpenTapHan

; 167  : 	}
; 168  : 
; 169  : 	char subkeyName[TAP_REGISTRY_DATA_SIZE];
; 170  : 	DWORD i, subKeySize = sizeof(subkeyName);
; 171  : 
; 172  : 	for (i = 0; (regResult = RegEnumKeyEx(regAdapterKey, i, subkeyName, &subKeySize, NULL, NULL, NULL, NULL)) != ERROR_NO_MORE_ITEMS; i++)

  0031e	8b 44 24 28	 mov	 eax, DWORD PTR _i$1$[esp+1068]
  00322	33 c9		 xor	 ecx, ecx
  00324	51		 push	 ecx
  00325	51		 push	 ecx
  00326	51		 push	 ecx
  00327	51		 push	 ecx
  00328	8d 4c 24 30	 lea	 ecx, DWORD PTR _subKeySize$[esp+1084]
  0032c	40		 inc	 eax
  0032d	51		 push	 ecx
  0032e	8d 8c 24 40 03
	00 00		 lea	 ecx, DWORD PTR _subkeyName$[esp+1088]
  00335	89 44 24 3c	 mov	 DWORD PTR _i$1$[esp+1088], eax
  00339	51		 push	 ecx
  0033a	50		 push	 eax
  0033b	ff 74 24 34	 push	 DWORD PTR _regAdapterKey$[esp+1096]
  0033f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RegEnumKeyExA@32
  00345	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  0034a	0f 85 23 fd ff
	ff		 jne	 $LL18@OpenTapHan
$LN33@OpenTapHan:

; 236  : 	}
; 237  : 
; 238  : 	RegCloseKey(regAdapterKey);

  00350	ff 74 24 18	 push	 DWORD PTR _regAdapterKey$[esp+1068]
  00354	ff d7		 call	 edi

; 239  : 
; 240  : 	if (handle == INVALID_HANDLE_VALUE)

  00356	83 fe ff	 cmp	 esi, -1
  00359	75 4e		 jne	 SHORT $LN3@OpenTapHan

; 241  : 	{
; 242  : 		printerrorf("Fatal: No compatible VPN adapter");

  0035b	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapter@
  00360	e8 00 00 00 00	 call	 _printerrorf
  00365	59		 pop	 ecx

; 243  : 
; 244  : 		if (!strcmp(szTapName, "."))

  00366	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR _szTapName
  0036c	80 39 2e	 cmp	 BYTE PTR [ecx], 46	; 0000002eH
  0036f	75 14		 jne	 SHORT $LN2@OpenTapHan
  00371	0f b6 41 01	 movzx	 eax, BYTE PTR [ecx+1]
  00375	84 c0		 test	 al, al
  00377	75 0c		 jne	 SHORT $LN2@OpenTapHan

; 245  : 		{
; 246  : 			printerrorf("s");

  00379	68 00 00 00 00	 push	 OFFSET ??_C@_01LKDEMHDF@s?$AA@
  0037e	e8 00 00 00 00	 call	 _printerrorf

; 247  : 		}
; 248  : 		else

  00383	eb 0c		 jmp	 SHORT $LN41@OpenTapHan
$LN2@OpenTapHan:

; 249  : 		{
; 250  : 			printerrorf(" with name \"%s\"", szTapName);

  00385	51		 push	 ecx
  00386	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC?$AA@
  0038b	e8 00 00 00 00	 call	 _printerrorf
  00390	59		 pop	 ecx
$LN41@OpenTapHan:
  00391	59		 pop	 ecx

; 251  : 		}
; 252  : 
; 253  : 		printerrorf(" available for use\n");

  00392	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@BMEHODCL@?5available?5for?5use?6?$AA@
  00397	e8 00 00 00 00	 call	 _printerrorf

; 254  : 		exit(ERROR_DEVICE_NOT_AVAILABLE);

  0039c	c7 04 24 df 10
	00 00		 mov	 DWORD PTR [esp], 4319	; 000010dfH
  003a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN44@OpenTapHan:
$LN3@OpenTapHan:
  003a9	5f		 pop	 edi

; 255  : 	}
; 256  : 
; 257  : 	return handle;

  003aa	8b c6		 mov	 eax, esi
  003ac	5e		 pop	 esi
  003ad	5d		 pop	 ebp
  003ae	5b		 pop	 ebx

; 258  : }

  003af	81 c4 1c 04 00
	00		 add	 esp, 1052		; 0000041cH
  003b5	c3		 ret	 0
$LN42@OpenTapHan:

; 165  : 	{
; 166  : 		WinErrorExit(regResult);

  003b6	8b c8		 mov	 ecx, eax
  003b8	e8 00 00 00 00	 call	 _WinErrorExit
$LN45@OpenTapHan:
$LN32@OpenTapHan:

; 215  : 								{
; 216  : 									ActiveTapName = vlmcsd_strdup(deviceName);

  003bd	e8 00 00 00 00	 call	 _OutOfMemory
$LN46@OpenTapHan:
$LN30@OpenTapHan:

; 173  : 	{
; 174  : 		HKEY regSubKey;
; 175  : 		DWORD type, regDataSize;
; 176  : 		char regData[TAP_REGISTRY_DATA_SIZE];
; 177  : 
; 178  : 		if (regResult) WinErrorExit(regResult);

  003c2	8b c8		 mov	 ecx, eax
  003c4	e8 00 00 00 00	 call	 _WinErrorExit
$LN47@OpenTapHan:
$LN40@OpenTapHan:
  003c9	cc		 int	 3
_OpenTapHandle ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\wintap.c
;	COMDAT _DevCtl
_TEXT	SEGMENT
_len$ = 8						; size = 4
_DevCtl	PROC						; COMDAT
; _code$ = ecx
; _data$ = edx

; 263  : 	if (!DeviceIoControl(TapHandle, code, data, len, data, len, &len, NULL))

  00000	6a 00		 push	 0
  00002	8d 44 24 08	 lea	 eax, DWORD PTR _len$[esp]
  00006	50		 push	 eax
  00007	ff 74 24 0c	 push	 DWORD PTR _len$[esp+4]
  0000b	52		 push	 edx
  0000c	ff 74 24 14	 push	 DWORD PTR _len$[esp+12]
  00010	52		 push	 edx
  00011	51		 push	 ecx
  00012	ff 35 00 00 00
	00		 push	 DWORD PTR _TapHandle
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__DeviceIoControl@32
  0001e	85 c0		 test	 eax, eax
  00020	75 25		 jne	 SHORT $LN1@DevCtl

; 264  : 	{
; 265  : 		DWORD error = GetLastError();

  00022	56		 push	 esi
  00023	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00029	8b f0		 mov	 esi, eax

; 266  : 		printerrorf("Fatal: VPN adapter error: %s\n", win_strerror(error));

  0002b	8b ce		 mov	 ecx, esi
  0002d	e8 00 00 00 00	 call	 _win_strerror
  00032	50		 push	 eax
  00033	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6?$AA@
  00038	e8 00 00 00 00	 call	 _printerrorf
  0003d	59		 pop	 ecx
  0003e	59		 pop	 ecx

; 267  : 		exit(error);

  0003f	56		 push	 esi
  00040	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00046	5e		 pop	 esi
$LN6@DevCtl:
$LN1@DevCtl:

; 268  : 	}
; 269  : 
; 270  : 	return len;

  00047	8b 44 24 04	 mov	 eax, DWORD PTR _len$[esp-4]

; 271  : }

  0004b	c3		 ret	 0
$LN5@DevCtl:
_DevCtl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\wintap.c
;	COMDAT _TapMirror@4
_TEXT	SEGMENT
_bytesWritten$1 = -8					; size = 4
_bytesRead$2 = -4					; size = 4
_data_unused$ = 8					; size = 4
_TapMirror@4 PROC					; COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	51		 push	 ecx
  00005	56		 push	 esi

; 276  : 	while (TRUE)
; 277  : 	{
; 278  : 		DWORD bytesRead, bytesWritten;
; 279  : 		if (!ReadFile(TapHandle, IpPacket, Mtu, &bytesRead, NULL)) break;

  00006	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__ReadFile@20
  0000c	eb 2c		 jmp	 SHORT $LN15@TapMirror
$LL4@TapMirror:

; 280  : 
; 281  : 		uint32_t temp = IpPacket->ip_src;

  0000e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _IpPacket

; 282  : 		IpPacket->ip_src = IpPacket->ip_dst;
; 283  : 		IpPacket->ip_dst = temp;
; 284  : 
; 285  : 		if (!WriteFile(TapHandle, IpPacket, bytesRead, &bytesWritten, NULL)) break;

  00014	6a 00		 push	 0
  00016	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00019	8b 4a 0c	 mov	 ecx, DWORD PTR [edx+12]
  0001c	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0001f	8d 45 f8	 lea	 eax, DWORD PTR _bytesWritten$1[ebp]
  00022	50		 push	 eax
  00023	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00026	ff 75 fc	 push	 DWORD PTR _bytesRead$2[ebp]
  00029	52		 push	 edx
  0002a	ff 35 00 00 00
	00		 push	 DWORD PTR _TapHandle
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20
  00036	85 c0		 test	 eax, eax
  00038	74 1e		 je	 SHORT $LN13@TapMirror
$LN15@TapMirror:

; 276  : 	while (TRUE)
; 277  : 	{
; 278  : 		DWORD bytesRead, bytesWritten;
; 279  : 		if (!ReadFile(TapHandle, IpPacket, Mtu, &bytesRead, NULL)) break;

  0003a	6a 00		 push	 0
  0003c	8d 45 fc	 lea	 eax, DWORD PTR _bytesRead$2[ebp]
  0003f	50		 push	 eax
  00040	ff 35 00 00 00
	00		 push	 DWORD PTR _Mtu
  00046	ff 35 00 00 00
	00		 push	 DWORD PTR _IpPacket
  0004c	ff 35 00 00 00
	00		 push	 DWORD PTR _TapHandle
  00052	ff d6		 call	 esi
  00054	85 c0		 test	 eax, eax
  00056	75 b6		 jne	 SHORT $LL4@TapMirror
$LN13@TapMirror:

; 286  : 
; 287  : #		if !defined(NO_LOG) && defined(_PEDANTIC)
; 288  : 		if (bytesRead != bytesWritten) logger("Warning: VPN device \"%s\": %u bytes could not be written\n", ActiveTapName, bytesRead - bytesWritten);
; 289  : #		endif // !defined(NO_LOG) && defined(_PEDANTIC)
; 290  : 	}
; 291  : 
; 292  : 	DWORD error = GetLastError();

  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  0005e	8b f0		 mov	 esi, eax

; 293  : 
; 294  : #	ifndef NO_LOG
; 295  : 	logger("Warning: VPN thread for device \"%s\" exiting: %s\n", ActiveTapName, win_strerror(error));

  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 _win_strerror
  00067	50		 push	 eax
  00068	ff 35 00 00 00
	00		 push	 DWORD PTR _ActiveTapName
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5?$CC@
  00073	e8 00 00 00 00	 call	 _logger

; 296  : #	endif // NO_LOG
; 297  : 
; 298  : 	free(ActiveTapName);

  00078	ff 35 00 00 00
	00		 push	 DWORD PTR _ActiveTapName
  0007e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00084	83 c4 10	 add	 esp, 16			; 00000010H

; 299  : 	CloseHandle(TapHandle);

  00087	ff 35 00 00 00
	00		 push	 DWORD PTR _TapHandle
  0008d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 300  : 	exitOnWarningLevel(1);

  00093	e8 00 00 00 00	 call	 _exitOnWarningLevel

; 301  : 	return error;

  00098	8b c6		 mov	 eax, esi
  0009a	5e		 pop	 esi

; 302  : }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c2 04 00	 ret	 4
_TapMirror@4 ENDP
_TEXT	ENDS
END
