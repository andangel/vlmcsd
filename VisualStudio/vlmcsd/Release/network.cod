; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Dell\Desktop\vlmcsd\src\network.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@		; `string'
PUBLIC	??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@MAEBPPDA@Connecting?5to?5?$CFs?5?$CI?$CFs?$CJ?5?4?4?4?5?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMGEJMIK@Connecting?5to?5?$CFs?5?4?4?4?5?$AA@ ; `string'
PUBLIC	??_C@_0M@DODJIFLM@successful?6?$AA@		; `string'
PUBLIC	??_C@_09OGKCMDDI@Timed?5out?$AA@		; `string'
PUBLIC	??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5add@ ; `string'
PUBLIC	??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addres@ ; `string'
PUBLIC	??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_08LMOPGBBD@accepted?$AA@			; `string'
PUBLIC	??_C@_06IKJOPBFO@closed?$AA@			; `string'
PUBLIC	??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5re@ ; `string'
PUBLIC	??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6?$AA@		; `string'
EXTRN	__imp__CreateThread@24:PROC
EXTRN	__imp__GetAdaptersAddresses@20:PROC
EXTRN	__imp__getpeername@12:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__ioctlsocket@12:PROC
EXTRN	__imp__connect@12:PROC
EXTRN	__imp__getaddrinfo@16:PROC
EXTRN	__imp__select@20:PROC
EXTRN	__imp__WSAGetLastError@0:PROC
EXTRN	__imp__GetLastError@0:PROC
EXTRN	__imp__ReleaseSemaphore@12:PROC
EXTRN	__imp__printf:PROC
EXTRN	__imp__setsockopt@20:PROC
EXTRN	__imp__recv@16:PROC
EXTRN	__imp__bind@12:PROC
EXTRN	__imp__socket@12:PROC
EXTRN	__imp__freeaddrinfo@4:PROC
EXTRN	__imp___snprintf:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp____WSAFDIsSet@8:PROC
EXTRN	__imp__closesocket@4:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__send@16:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__listen@8:PROC
EXTRN	__imp__getnameinfo@28:PROC
EXTRN	__imp__accept@12:PROC
;	COMDAT ??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6?$AA@ DB 'Fatal: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5re@
CONST	SEGMENT
??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5re@ DB 'Client with'
	DB	' public IP address rejected', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6?$AA@ DB '%s conn'
	DB	'ection %s: %s.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJOPBFO@closed?$AA@
CONST	SEGMENT
??_C@_06IKJOPBFO@closed?$AA@ DB 'closed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LMOPGBBD@accepted?$AA@
CONST	SEGMENT
??_C@_08LMOPGBBD@accepted?$AA@ DB 'accepted', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6?$AA@ DB 'Listening on %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6?$AA@ DB 'Warning: %'
	DB	's error. %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addres@
CONST	SEGMENT
??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addres@ DB 'WARNING: C'
	DB	'ould not get IP address from interface list: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5add@
CONST	SEGMENT
??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5add@ DB 'FATAL: Cou'
	DB	'ld not get network address list: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@ DB '%s: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OGKCMDDI@Timed?5out?$AA@
CONST	SEGMENT
??_C@_09OGKCMDDI@Timed?5out?$AA@ DB 'Timed out', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DODJIFLM@successful?6?$AA@
CONST	SEGMENT
??_C@_0M@DODJIFLM@successful?6?$AA@ DB 'successful', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMGEJMIK@Connecting?5to?5?$CFs?5?4?4?4?5?$AA@
CONST	SEGMENT
??_C@_0BG@GMGEJMIK@Connecting?5to?5?$CFs?5?4?4?4?5?$AA@ DB 'Connecting to'
	DB	' %s ... ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MAEBPPDA@Connecting?5to?5?$CFs?5?$CI?$CFs?$CJ?5?4?4?4?5?$AA@
CONST	SEGMENT
??_C@_0BL@MAEBPPDA@Connecting?5to?5?$CFs?5?$CI?$CFs?$CJ?5?4?4?4?5?$AA@ DB 'C'
	DB	'onnecting to %s (%s) ... ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6?$AA@ DB 'Warning: %s: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@
CONST	SEGMENT
??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@ DB '[%s]:%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@
CONST	SEGMENT
??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@ DB '%s:%s', 00H	; `string'
?fIP@?2??serveClient@@9@9 DD FLAT:??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6?$AA@ ; `serveClient'::`3'::fIP
?cClosed@?2??serveClient@@9@9 DD FLAT:??_C@_06IKJOPBFO@closed?$AA@ ; `serveClient'::`3'::cClosed
?cAccepted@?2??serveClient@@9@9 DD FLAT:??_C@_08LMOPGBBD@accepted?$AA@ ; `serveClient'::`3'::cAccepted
?fIPv6@?1??ip2str@@9@9 DD FLAT:??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@ ; `ip2str'::`2'::fIPv6
?fIPv4@?1??ip2str@@9@9 DD FLAT:??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@ ; `ip2str'::`2'::fIPv4
PUBLIC	_runServer
PUBLIC	_serveClientAsync
PUBLIC	_closeAllListeningSockets
PUBLIC	_checkProtocolStack
PUBLIC	_addListeningSocket
PUBLIC	_getPrivateIPAddresses
PUBLIC	_sendrecv
PUBLIC	_gai_strerrorA
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft sdks\windows\v7.1a\include\ws2tcpip.h
;	COMDAT _gai_strerrorA
_TEXT	SEGMENT
_gai_strerrorA PROC					; COMDAT
; _ecode$ = ecx

; 604  : {

  00000	56		 push	 esi

; 605  :     DWORD dwMsgLen;
; 606  :     static char buff[GAI_STRERROR_BUFFER_SIZE + 1];
; 607  : 
; 608  :     dwMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM
; 609  :                              |FORMAT_MESSAGE_IGNORE_INSERTS
; 610  :                              |FORMAT_MESSAGE_MAX_WIDTH_MASK,
; 611  :                               NULL,
; 612  :                               ecode,
; 613  :                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
; 614  :                               (LPSTR)buff,
; 615  :                               GAI_STRERROR_BUFFER_SIZE,
; 616  :                               NULL);

  00001	6a 00		 push	 0
  00003	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00008	be 00 00 00 00	 mov	 esi, OFFSET ?buff@?1??gai_strerrorA@@9@9 ; `gai_strerrorA'::`2'::buff
  0000d	52		 push	 edx
  0000e	56		 push	 esi
  0000f	52		 push	 edx
  00010	51		 push	 ecx
  00011	6a 00		 push	 0
  00013	68 ff 12 00 00	 push	 4863			; 000012ffH
  00018	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__FormatMessageA@28

; 617  : 
; 618  :     return buff;

  0001e	8b c6		 mov	 eax, esi
  00020	5e		 pop	 esi

; 619  : }

  00021	c3		 ret	 0
_gai_strerrorA ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _sendrecv
_TEXT	SEGMENT
_sock$1$ = -4						; size = 4
_len$ = 8						; size = 4
_do_send$ = 12						; size = 1
_sendrecv PROC						; COMDAT
; _sock$ = ecx
; _data$ = edx

; 57   : {

  00000	51		 push	 ecx

; 58   : 	int n;
; 59   : 	sendrecv_t  f = do_send
; 60   : 		? (sendrecv_t)send
; 61   : 		: (sendrecv_t)recv;

  00001	80 7c 24 0c 00	 cmp	 BYTE PTR _do_send$[esp], 0
  00006	8b c1		 mov	 eax, ecx
  00008	53		 push	 ebx
  00009	55		 push	 ebp
  0000a	8b 2d 00 00 00
	00		 mov	 ebp, DWORD PTR __imp__recv@16
  00010	8b da		 mov	 ebx, edx
  00012	0f 45 2d 00 00
	00 00		 cmovne	 ebp, DWORD PTR __imp__send@16
  00019	56		 push	 esi
  0001a	8b 74 24 14	 mov	 esi, DWORD PTR _len$[esp+12]
  0001e	57		 push	 edi
  0001f	89 44 24 10	 mov	 DWORD PTR _sock$1$[esp+20], eax
$LL5@sendrecv:

; 62   : 
; 63   : 	do
; 64   : 	{
; 65   : 		n = f(sock, data, len, 0);

  00023	6a 00		 push	 0
  00025	56		 push	 esi
  00026	53		 push	 ebx
  00027	50		 push	 eax
  00028	ff d5		 call	 ebp
  0002a	8b f8		 mov	 edi, eax

; 66   : 	} while (
; 67   : 		(n < 0 && socket_errno == SOCKET_EINTR) || (n > 0 && (data += n, (len -= n) > 0)));

  0002c	85 ff		 test	 edi, edi
  0002e	79 13		 jns	 SHORT $LN12@sendrecv
  00030	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00036	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  0003b	8b 44 24 10	 mov	 eax, DWORD PTR _sock$1$[esp+20]
  0003f	74 e2		 je	 SHORT $LL5@sendrecv
  00041	85 ff		 test	 edi, edi
$LN12@sendrecv:
  00043	7e 0c		 jle	 SHORT $LN1@sendrecv
  00045	8b 44 24 10	 mov	 eax, DWORD PTR _sock$1$[esp+20]
  00049	2b f7		 sub	 esi, edi
  0004b	03 df		 add	 ebx, edi
  0004d	85 f6		 test	 esi, esi
  0004f	7f d2		 jg	 SHORT $LL5@sendrecv
$LN1@sendrecv:
  00051	5f		 pop	 edi

; 68   : 
; 69   : 	return !len;

  00052	33 c0		 xor	 eax, eax
  00054	85 f6		 test	 esi, esi
  00056	5e		 pop	 esi
  00057	5d		 pop	 ebp
  00058	0f 94 c0	 sete	 al
  0005b	5b		 pop	 ebx

; 70   : }

  0005c	59		 pop	 ecx
  0005d	c3		 ret	 0
_sendrecv ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _ip2str
_TEXT	SEGMENT
_ipAddress$ = -72					; size = 64
_portNumber$ = -8					; size = 8
_socketAddress$ = 8					; size = 4
_socketLength$ = 12					; size = 4
_ip2str	PROC						; COMDAT
; _result$ = ecx
; _resultLength$dead$ = edx

; 74   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H

; 75   : 	static const char *const fIPv4 = "%s:%s";
; 76   : 	static const char *const fIPv6 = "[%s]:%s";
; 77   : 	char ipAddress[64], portNumber[8];
; 78   : 
; 79   : 	if (getnameinfo
; 80   : 	(
; 81   : 		socketAddress,
; 82   : 		socketLength,
; 83   : 		ipAddress,
; 84   : 		sizeof(ipAddress),
; 85   : 		portNumber,
; 86   : 		sizeof(portNumber),
; 87   : 		NI_NUMERICHOST | NI_NUMERICSERV
; 88   : 	))

  00006	8d 45 f8	 lea	 eax, DWORD PTR _portNumber$[ebp]
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	8b 75 08	 mov	 esi, DWORD PTR _socketAddress$[ebp]
  0000e	57		 push	 edi
  0000f	6a 0a		 push	 10			; 0000000aH
  00011	6a 08		 push	 8
  00013	50		 push	 eax
  00014	6a 40		 push	 64			; 00000040H
  00016	5b		 pop	 ebx
  00017	53		 push	 ebx
  00018	8d 45 b8	 lea	 eax, DWORD PTR _ipAddress$[ebp]
  0001b	8b f9		 mov	 edi, ecx
  0001d	50		 push	 eax
  0001e	ff 75 0c	 push	 DWORD PTR _socketLength$[ebp]
  00021	56		 push	 esi
  00022	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getnameinfo@28
  00028	85 c0		 test	 eax, eax
  0002a	74 04		 je	 SHORT $LN2@ip2str

; 89   : 	{
; 90   : 		return FALSE;

  0002c	32 c0		 xor	 al, al
  0002e	eb 2b		 jmp	 SHORT $LN1@ip2str
$LN2@ip2str:

; 91   : 	}
; 92   : 
; 93   : 	if ((unsigned int)vlmcsd_snprintf(result, resultLength, socketAddress->sa_family == AF_INET6 ? fIPv6 : fIPv4, ipAddress, portNumber) > resultLength) return FALSE;

  00030	66 83 3e 17	 cmp	 WORD PTR [esi], 23	; 00000017H
  00034	8d 45 f8	 lea	 eax, DWORD PTR _portNumber$[ebp]
  00037	50		 push	 eax
  00038	8d 45 b8	 lea	 eax, DWORD PTR _ipAddress$[ebp]
  0003b	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@
  00040	50		 push	 eax
  00041	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@
  00046	0f 45 c1	 cmovne	 eax, ecx
  00049	50		 push	 eax
  0004a	53		 push	 ebx
  0004b	57		 push	 edi
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___snprintf
  00052	83 c4 14	 add	 esp, 20			; 00000014H
  00055	3b d8		 cmp	 ebx, eax
  00057	1a c0		 sbb	 al, al
  00059	fe c0		 inc	 al
$LN1@ip2str:
  0005b	5f		 pop	 edi
  0005c	5e		 pop	 esi
  0005d	5b		 pop	 ebx

; 94   : 	return TRUE;
; 95   : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
_ip2str	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _getSocketList
_TEXT	SEGMENT
_hints$ = -44						; size = 32
_szHost$ = -12						; size = 4
_szPort$ = -8						; size = 4
_saList$1$ = -4						; size = 4
_flags$dead$ = 8					; size = 4
_AddressFamily$dead$ = 12				; size = 4
_getSocketList PROC					; COMDAT
; _saList$ = ecx
; _addr$ = edx

; 99   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	53		 push	 ebx
  00007	8b da		 mov	 ebx, edx
  00009	89 4d fc	 mov	 DWORD PTR _saList$1$[ebp], ecx
  0000c	56		 push	 esi

; 100  : 	int status;
; 101  : 	char *szHost, *szPort;
; 102  : 	size_t len = strlen(addr) + 1;

  0000d	8b f3		 mov	 esi, ebx
  0000f	57		 push	 edi
  00010	8d 56 01	 lea	 edx, DWORD PTR [esi+1]
$LL5@getSocketL:
  00013	8a 06		 mov	 al, BYTE PTR [esi]
  00015	46		 inc	 esi
  00016	84 c0		 test	 al, al
  00018	75 f9		 jne	 SHORT $LL5@getSocketL
  0001a	2b f2		 sub	 esi, edx
  0001c	8d 7e 01	 lea	 edi, DWORD PTR [esi+1]

; 103  : 
; 104  : 	// Don't alloca too much
; 105  : 	if (len > 264) return FALSE;

  0001f	81 ff 08 01 00
	00		 cmp	 edi, 264		; 00000108H
  00025	76 04		 jbe	 SHORT $LN2@getSocketL
$LN6@getSocketL:
  00027	32 c0		 xor	 al, al
  00029	eb 75		 jmp	 SHORT $LN3@getSocketL
$LN2@getSocketL:

; 106  : 
; 107  : 	char *addrcopy = (char*)alloca(len);

  0002b	8b c7		 mov	 eax, edi
  0002d	e8 00 00 00 00	 call	 __alloca_probe_16
  00032	8b f4		 mov	 esi, esp

; 108  : 	memcpy(addrcopy, addr, len);

  00034	57		 push	 edi
  00035	53		 push	 ebx
  00036	56		 push	 esi
  00037	e8 00 00 00 00	 call	 _memcpy

; 109  : 
; 110  : 	parseAddress(addrcopy, &szHost, &szPort);

  0003c	8d 45 f8	 lea	 eax, DWORD PTR _szPort$[ebp]
  0003f	8b ce		 mov	 ecx, esi
  00041	50		 push	 eax
  00042	8d 55 f4	 lea	 edx, DWORD PTR _szHost$[ebp]
  00045	e8 00 00 00 00	 call	 _parseAddress
  0004a	83 c4 10	 add	 esp, 16			; 00000010H

; 111  : 
; 112  : 	struct addrinfo hints;
; 113  : 
; 114  : 	memset(&hints, 0, sizeof(struct addrinfo));

  0004d	8d 7d d4	 lea	 edi, DWORD PTR _hints$[ebp]
  00050	33 c0		 xor	 eax, eax
  00052	6a 08		 push	 8
  00054	59		 pop	 ecx

; 115  : 
; 116  : 	hints.ai_family = AddressFamily;
; 117  : 	hints.ai_socktype = SOCK_STREAM;
; 118  : 	hints.ai_protocol = IPPROTO_TCP;
; 119  : 	hints.ai_flags = flags;
; 120  : 
; 121  : 	if ((status = getaddrinfo(szHost, szPort, &hints, saList)))

  00055	ff 75 fc	 push	 DWORD PTR _saList$1$[ebp]
  00058	f3 ab		 rep stosd
  0005a	21 45 d8	 and	 DWORD PTR _hints$[ebp+4], eax
  0005d	8d 45 d4	 lea	 eax, DWORD PTR _hints$[ebp]
  00060	50		 push	 eax
  00061	ff 75 f8	 push	 DWORD PTR _szPort$[ebp]
  00064	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _hints$[ebp+8], 1
  0006b	ff 75 f4	 push	 DWORD PTR _szHost$[ebp]
  0006e	c7 45 e0 06 00
	00 00		 mov	 DWORD PTR _hints$[ebp+12], 6
  00075	c7 45 d4 05 00
	00 00		 mov	 DWORD PTR _hints$[ebp], 5
  0007c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getaddrinfo@16
  00082	85 c0		 test	 eax, eax
  00084	74 18		 je	 SHORT $LN1@getSocketL

; 122  : 	{
; 123  : 		printerrorf("Warning: %s: %s\n", addr, gai_strerror(status));

  00086	8b c8		 mov	 ecx, eax
  00088	e8 00 00 00 00	 call	 _gai_strerrorA
  0008d	50		 push	 eax
  0008e	53		 push	 ebx
  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6?$AA@
  00094	e8 00 00 00 00	 call	 _printerrorf
  00099	83 c4 0c	 add	 esp, 12			; 0000000cH

; 124  : 		return FALSE;

  0009c	eb 89		 jmp	 SHORT $LN6@getSocketL
$LN1@getSocketL:

; 125  : 	}
; 126  : 
; 127  : 	return TRUE;

  0009e	b0 01		 mov	 al, 1
$LN3@getSocketL:

; 128  : }

  000a0	8d 65 c8	 lea	 esp, DWORD PTR [ebp-56]
  000a3	5f		 pop	 edi
  000a4	5e		 pop	 esi
  000a5	5b		 pop	 ebx
  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
_getSocketList ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _isPrivateIPAddress
_TEXT	SEGMENT
_isPrivateIPAddress PROC				; COMDAT
; _addr$ = ecx
; _length$ = edx

; 171  : {

  00000	56		 push	 esi

; 172  : 	union v6addr
; 173  : 	{
; 174  : 		uint8_t bytes[16];
; 175  : 		uint16_t words[8];
; 176  : 		uint32_t dwords[4];
; 177  : 		uint64_t qwords[2];
; 178  : 	};
; 179  : 
; 180  : 	if (addr == NULL) return FALSE;

  00001	85 c9		 test	 ecx, ecx
  00003	75 04		 jne	 SHORT $LN11@isPrivateI
$LN15@isPrivateI:
  00005	32 c0		 xor	 al, al

; 226  : }

  00007	5e		 pop	 esi
  00008	c3		 ret	 0
$LN11@isPrivateI:

; 181  : 
; 182  : 	switch (addr->sa_family)

  00009	0f b7 01	 movzx	 eax, WORD PTR [ecx]
  0000c	48		 dec	 eax
  0000d	48		 dec	 eax
  0000e	74 46		 je	 SHORT $LN4@isPrivateI
  00010	83 e8 15	 sub	 eax, 21			; 00000015H
  00013	75 f0		 jne	 SHORT $LN15@isPrivateI

; 183  : 	{
; 184  : 	case AF_INET6:
; 185  : 	{
; 186  : 		union v6addr* ipv6addr = (union v6addr*)&((struct sockaddr_in6*)addr)->sin6_addr;
; 187  : 
; 188  : 		if
; 189  : 			(
; 190  : 			(ipv6addr->qwords[0] != 0 || BE64(ipv6addr->qwords[1]) != 1) && // ::1 IPv6 localhost
; 191  : 				(BE16(ipv6addr->words[0]) & 0xe000) == 0x2000 // !2000::/3
; 192  : 				)

  00015	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00018	0b 41 0c	 or	 eax, DWORD PTR [ecx+12]
  0001b	75 13		 jne	 SHORT $LN14@isPrivateI
  0001d	8b 41 14	 mov	 eax, DWORD PTR [ecx+20]
  00020	8b 71 10	 mov	 esi, DWORD PTR [ecx+16]
  00023	0f c8		 bswap	 eax
  00025	0f ce		 bswap	 esi
  00027	83 f8 01	 cmp	 eax, 1
  0002a	75 04		 jne	 SHORT $LN14@isPrivateI
  0002c	85 f6		 test	 esi, esi
  0002e	74 1a		 je	 SHORT $LN7@isPrivateI
$LN14@isPrivateI:
  00030	66 8b 41 08	 mov	 ax, WORD PTR [ecx+8]
  00034	8a e8		 mov	 ch, al
  00036	8a cc		 mov	 cl, ah
  00038	b8 00 e0 00 00	 mov	 eax, 57344		; 0000e000H
  0003d	66 23 c8	 and	 cx, ax
  00040	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H
  00045	66 3b c8	 cmp	 cx, ax
  00048	74 bb		 je	 SHORT $LN15@isPrivateI
$LN7@isPrivateI:

; 193  : 		{
; 194  : 			return FALSE;
; 195  : 		}
; 196  : 
; 197  : 		if (length) *length = sizeof(struct sockaddr_in6);

  0004a	85 d2		 test	 edx, edx
  0004c	74 57		 je	 SHORT $LN2@isPrivateI
  0004e	c7 02 1c 00 00
	00		 mov	 DWORD PTR [edx], 28	; 0000001cH

; 198  : 		break;

  00054	eb 4f		 jmp	 SHORT $LN2@isPrivateI
$LN4@isPrivateI:

; 199  : 	}
; 200  : 
; 201  : 	case AF_INET:
; 202  : 	{
; 203  : 		uint32_t ipv4addr = BE32(((struct sockaddr_in*)addr)->sin_addr.s_addr);

  00056	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00059	0f c8		 bswap	 eax

; 204  : 
; 205  : 		if
; 206  : 			(
; 207  : 			(ipv4addr & 0xff000000) != 0x7f000000 && // 127.x.x.x localhost
; 208  : 				(ipv4addr & 0xffff0000) != 0xc0a80000 && // 192.168.x.x private routeable
; 209  : 				(ipv4addr & 0xffff0000) != 0xa9fe0000 && // 169.254.x.x link local
; 210  : 				(ipv4addr & 0xff000000) != 0x0a000000 && // 10.x.x.x private routeable
; 211  : 				(ipv4addr & 0xfff00000) != 0xac100000    // 172.16-31.x.x private routeable
; 212  : 				)

  0005b	8b f0		 mov	 esi, eax
  0005d	81 e6 00 00 00
	ff		 and	 esi, -16777216		; ff000000H
  00063	81 fe 00 00 00
	7f		 cmp	 esi, 2130706432		; 7f000000H
  00069	74 30		 je	 SHORT $LN3@isPrivateI
  0006b	8b c8		 mov	 ecx, eax
  0006d	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  00073	81 f9 00 00 a8
	c0		 cmp	 ecx, -1062731776	; c0a80000H
  00079	74 20		 je	 SHORT $LN3@isPrivateI
  0007b	81 f9 00 00 fe
	a9		 cmp	 ecx, -1442971648	; a9fe0000H
  00081	74 18		 je	 SHORT $LN3@isPrivateI
  00083	81 fe 00 00 00
	0a		 cmp	 esi, 167772160		; 0a000000H
  00089	74 10		 je	 SHORT $LN3@isPrivateI
  0008b	25 00 00 f0 ff	 and	 eax, -1048576		; fff00000H
  00090	3d 00 00 10 ac	 cmp	 eax, -1408237568	; ac100000H
  00095	0f 85 6a ff ff
	ff		 jne	 $LN15@isPrivateI
$LN3@isPrivateI:

; 213  : 		{
; 214  : 			return FALSE;
; 215  : 		}
; 216  : 
; 217  : 		if (length) *length = sizeof(struct sockaddr_in);

  0009b	85 d2		 test	 edx, edx
  0009d	74 06		 je	 SHORT $LN2@isPrivateI
  0009f	c7 02 10 00 00
	00		 mov	 DWORD PTR [edx], 16	; 00000010H
$LN2@isPrivateI:

; 218  : 		break;
; 219  : 	}
; 220  : 
; 221  : 	default:
; 222  : 		return FALSE;
; 223  : 	}
; 224  : 
; 225  : 	return TRUE;

  000a5	b0 01		 mov	 al, 1

; 226  : }

  000a7	5e		 pop	 esi
  000a8	c3		 ret	 0
_isPrivateIPAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _allowSocketReuse
_TEXT	SEGMENT
_socketOption$ = -4					; size = 4
_allowSocketReuse PROC					; COMDAT
; _s$ = ecx

; 299  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 300  : #	if !__CYGWIN__
; 301  : 
; 302  : 	BOOL socketOption = TRUE;
; 303  : 
; 304  : #	if !_WIN32
; 305  : #	define VLMCSD_SOCKET_OPTION SO_REUSEADDR
; 306  : #	else // _WIN32
; 307  : #	define VLMCSD_SOCKET_OPTION SO_EXCLUSIVEADDRUSE
; 308  : #	endif // _WIN32
; 309  : 
; 310  : 	if (setsockopt(s, SOL_SOCKET, VLMCSD_SOCKET_OPTION, (sockopt_t)&socketOption, sizeof(socketOption)))

  00004	6a 04		 push	 4
  00006	8d 45 fc	 lea	 eax, DWORD PTR _socketOption$[ebp]
  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _socketOption$[ebp], 1
  00010	50		 push	 eax
  00011	6a fb		 push	 -5			; fffffffbH
  00013	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00018	51		 push	 ecx
  00019	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setsockopt@20

; 311  : 	{
; 312  : #		ifdef _PEDANTIC
; 313  : 		printerrorf("Warning: Socket option SO_REUSEADDR unsupported: %s\n", vlmcsd_strerror(socket_errno));
; 314  : #		endif // _PEDANTIC
; 315  : 	}
; 316  : 
; 317  : #	undef VLMCSD_SOCKET_OPTION
; 318  : #	endif // !__CYGWIN__
; 319  : 
; 320  : 	return 0;

  0001f	32 c0		 xor	 al, al

; 321  : }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_allowSocketReuse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _getPrivateIPAddresses
_TEXT	SEGMENT
_outBufLen$ = -12					; size = 4
_buf$1$ = -8						; size = 4
_length$1 = -8						; size = 4
_length$2 = -8						; size = 4
_ipAddresses$1$ = -4					; size = 4
_getPrivateIPAddresses PROC				; COMDAT
; _numAddresses$ = ecx
; _ipAddresses$ = edx

; 390  : {

  00000	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi

; 391  : #	if _WIN32
; 392  : 
; 393  : 	PIP_ADAPTER_ADDRESSES firstAdapter, currentAdapter;
; 394  : 
; 395  : 	DWORD dwRetVal;
; 396  : 	ULONG outBufLen = 16384;

  00006	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  0000b	89 54 24 14	 mov	 DWORD PTR _ipAddresses$1$[esp+24], edx
  0000f	57		 push	 edi

; 397  : 	ULONG flags = GAA_FLAG_SKIP_MULTICAST | GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_DNS_SERVER | GAA_FLAG_SKIP_FRIENDLY_NAME;
; 398  : 
; 399  : 	firstAdapter = (PIP_ADAPTER_ADDRESSES)vlmcsd_malloc(outBufLen);

  00010	50		 push	 eax
  00011	8b e9		 mov	 ebp, ecx
  00013	89 44 24 14	 mov	 DWORD PTR _outBufLen$[esp+32], eax
  00017	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0001d	8b f0		 mov	 esi, eax
  0001f	59		 pop	 ecx
  00020	85 f6		 test	 esi, esi
  00022	0f 84 61 01 00
	00		 je	 $LN58@getPrivate

; 400  : 
; 401  : 	if ((dwRetVal = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, firstAdapter, &outBufLen)) == ERROR_BUFFER_OVERFLOW)

  00028	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR __imp__GetAdaptersAddresses@20
  0002e	8d 44 24 10	 lea	 eax, DWORD PTR _outBufLen$[esp+28]
  00032	50		 push	 eax
  00033	56		 push	 esi
  00034	6a 00		 push	 0
  00036	6a 2e		 push	 46			; 0000002eH
  00038	6a 00		 push	 0
  0003a	ff d3		 call	 ebx
  0003c	8b f8		 mov	 edi, eax
  0003e	83 ff 6f	 cmp	 edi, 111		; 0000006fH
  00041	75 2d		 jne	 SHORT $LN19@getPrivate

; 402  : 	{
; 403  : 		free(firstAdapter);

  00043	56		 push	 esi
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0004a	59		 pop	 ecx

; 404  : 		firstAdapter = (PIP_ADAPTER_ADDRESSES)vlmcsd_malloc(outBufLen);

  0004b	ff 74 24 10	 push	 DWORD PTR _outBufLen$[esp+28]
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00055	8b f0		 mov	 esi, eax
  00057	59		 pop	 ecx
  00058	85 f6		 test	 esi, esi
  0005a	0f 84 29 01 00
	00		 je	 $LN58@getPrivate

; 405  : 		dwRetVal = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, firstAdapter, &outBufLen);

  00060	8d 44 24 10	 lea	 eax, DWORD PTR _outBufLen$[esp+28]
  00064	50		 push	 eax
  00065	56		 push	 esi
  00066	6a 00		 push	 0
  00068	6a 2e		 push	 46			; 0000002eH
  0006a	6a 00		 push	 0
  0006c	ff d3		 call	 ebx
  0006e	8b f8		 mov	 edi, eax
$LN19@getPrivate:

; 406  : 	}
; 407  : 
; 408  : 	if (dwRetVal != NO_ERROR)

  00070	85 ff		 test	 edi, edi
  00072	74 1b		 je	 SHORT $LN18@getPrivate

; 409  : 	{
; 410  : 		printerrorf("FATAL: Could not get network address list: %s\n", vlmcsd_strerror(dwRetVal));

  00074	8b cf		 mov	 ecx, edi
  00076	e8 00 00 00 00	 call	 _win_strerror
  0007b	50		 push	 eax
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5add@
  00081	e8 00 00 00 00	 call	 _printerrorf
  00086	59		 pop	 ecx
  00087	59		 pop	 ecx

; 411  : 		exit(dwRetVal);

  00088	57		 push	 edi
  00089	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
$LN60@getPrivate:
$LN18@getPrivate:

; 412  : 	}
; 413  : 
; 414  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  0008f	83 65 00 00	 and	 DWORD PTR [ebp], 0
  00093	8b fe		 mov	 edi, esi
  00095	85 f6		 test	 esi, esi
  00097	74 2c		 je	 SHORT $LN15@getPrivate
$LL17@getPrivate:

; 415  : 	{
; 416  : 		PIP_ADAPTER_UNICAST_ADDRESS currentAddress;
; 417  : 		int length;
; 418  : 
; 419  : 		if (currentAdapter->OperStatus != IfOperStatusUp) continue;

  00099	83 7f 44 01	 cmp	 DWORD PTR [edi+68], 1
  0009d	75 1f		 jne	 SHORT $LN16@getPrivate

; 420  : 
; 421  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  0009f	8b 5f 10	 mov	 ebx, DWORD PTR [edi+16]
  000a2	eb 16		 jmp	 SHORT $LN55@getPrivate
$LL13@getPrivate:

; 422  : 		{
; 423  : 			if (isPrivateIPAddress(currentAddress->Address.lpSockaddr, &length)) (*numAddresses)++;

  000a4	8b 4b 0c	 mov	 ecx, DWORD PTR [ebx+12]
  000a7	8d 54 24 14	 lea	 edx, DWORD PTR _length$2[esp+28]
  000ab	e8 00 00 00 00	 call	 _isPrivateIPAddress
  000b0	84 c0		 test	 al, al
  000b2	74 03		 je	 SHORT $LN12@getPrivate
  000b4	ff 45 00	 inc	 DWORD PTR [ebp]
$LN12@getPrivate:

; 420  : 
; 421  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  000b7	8b 5b 08	 mov	 ebx, DWORD PTR [ebx+8]
$LN55@getPrivate:
  000ba	85 db		 test	 ebx, ebx
  000bc	75 e6		 jne	 SHORT $LL13@getPrivate
$LN16@getPrivate:

; 412  : 	}
; 413  : 
; 414  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  000be	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
  000c1	85 ff		 test	 edi, edi
  000c3	75 d4		 jne	 SHORT $LL17@getPrivate
$LN15@getPrivate:

; 424  : 		}
; 425  : 	}
; 426  : 
; 427  : 	*ipAddresses = (char**)vlmcsd_malloc(*numAddresses * sizeof(char*));

  000c5	8b 45 00	 mov	 eax, DWORD PTR [ebp]
  000c8	c1 e0 02	 shl	 eax, 2
  000cb	50		 push	 eax
  000cc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000d2	59		 pop	 ecx
  000d3	85 c0		 test	 eax, eax
  000d5	0f 84 ae 00 00
	00		 je	 $LN58@getPrivate
  000db	8b 4c 24 18	 mov	 ecx, DWORD PTR _ipAddresses$1$[esp+28]

; 428  : 
; 429  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  000df	8b de		 mov	 ebx, esi
  000e1	83 65 00 00	 and	 DWORD PTR [ebp], 0
  000e5	89 01		 mov	 DWORD PTR [ecx], eax
  000e7	85 f6		 test	 esi, esi
  000e9	0f 84 8a 00 00
	00		 je	 $LN52@getPrivate
$LL9@getPrivate:

; 430  : 	{
; 431  : 		PIP_ADAPTER_UNICAST_ADDRESS currentAddress;
; 432  : 		int length;
; 433  : 
; 434  : 		if (currentAdapter->OperStatus != IfOperStatusUp) continue;

  000ef	83 7b 44 01	 cmp	 DWORD PTR [ebx+68], 1
  000f3	75 79		 jne	 SHORT $LN8@getPrivate

; 435  : 
; 436  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  000f5	8b 7b 10	 mov	 edi, DWORD PTR [ebx+16]
  000f8	eb 70		 jmp	 SHORT $LN56@getPrivate
$LL5@getPrivate:

; 437  : 		{
; 438  : 			if (!isPrivateIPAddress(currentAddress->Address.lpSockaddr, &length)) continue;

  000fa	8b 4f 0c	 mov	 ecx, DWORD PTR [edi+12]
  000fd	8d 54 24 14	 lea	 edx, DWORD PTR _length$1[esp+28]
  00101	e8 00 00 00 00	 call	 _isPrivateIPAddress
  00106	84 c0		 test	 al, al
  00108	74 5d		 je	 SHORT $LN4@getPrivate

; 439  : 
; 440  : 			char *ipAddress = (char*)vlmcsd_malloc(64);

  0010a	6a 40		 push	 64			; 00000040H
  0010c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00112	89 44 24 18	 mov	 DWORD PTR _buf$1$[esp+32], eax
  00116	59		 pop	 ecx
  00117	85 c0		 test	 eax, eax
  00119	74 6e		 je	 SHORT $LN58@getPrivate

; 441  : 			int error = getnameinfo(currentAddress->Address.lpSockaddr, currentAddress->Address.iSockaddrLength, ipAddress, 64, NULL, 0, NI_NUMERICHOST);

  0011b	6a 02		 push	 2
  0011d	6a 00		 push	 0
  0011f	6a 00		 push	 0
  00121	6a 40		 push	 64			; 00000040H
  00123	50		 push	 eax
  00124	ff 77 10	 push	 DWORD PTR [edi+16]
  00127	ff 77 0c	 push	 DWORD PTR [edi+12]
  0012a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getnameinfo@28

; 442  : 
; 443  : 			if (error)

  00130	85 c0		 test	 eax, eax
  00132	74 1d		 je	 SHORT $LN53@getPrivate

; 444  : 			{
; 445  : 				printerrorf("WARNING: Could not get IP address from interface list: %s\n", gai_strerror(error));

  00134	8b c8		 mov	 ecx, eax
  00136	e8 00 00 00 00	 call	 _gai_strerrorA
  0013b	50		 push	 eax
  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addres@
  00141	e8 00 00 00 00	 call	 _printerrorf

; 446  : 				*ipAddress = 0;

  00146	8b 54 24 1c	 mov	 edx, DWORD PTR _buf$1$[esp+36]
  0014a	59		 pop	 ecx
  0014b	59		 pop	 ecx
  0014c	c6 02 00	 mov	 BYTE PTR [edx], 0
  0014f	eb 04		 jmp	 SHORT $LN1@getPrivate
$LN53@getPrivate:
  00151	8b 54 24 14	 mov	 edx, DWORD PTR _buf$1$[esp+28]
$LN1@getPrivate:

; 447  : 			}
; 448  : 
; 449  : 			(*ipAddresses)[(*numAddresses)++] = ipAddress;

  00155	8b 44 24 18	 mov	 eax, DWORD PTR _ipAddresses$1$[esp+28]
  00159	8b 4d 00	 mov	 ecx, DWORD PTR [ebp]
  0015c	8b 00		 mov	 eax, DWORD PTR [eax]
  0015e	89 14 88	 mov	 DWORD PTR [eax+ecx*4], edx
  00161	8d 41 01	 lea	 eax, DWORD PTR [ecx+1]
  00164	89 45 00	 mov	 DWORD PTR [ebp], eax
$LN4@getPrivate:

; 435  : 
; 436  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  00167	8b 7f 08	 mov	 edi, DWORD PTR [edi+8]
$LN56@getPrivate:
  0016a	85 ff		 test	 edi, edi
  0016c	75 8c		 jne	 SHORT $LL5@getPrivate
$LN8@getPrivate:

; 428  : 
; 429  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  0016e	8b 5b 08	 mov	 ebx, DWORD PTR [ebx+8]
  00171	85 db		 test	 ebx, ebx
  00173	0f 85 76 ff ff
	ff		 jne	 $LL9@getPrivate
$LN52@getPrivate:

; 450  : 		}
; 451  : 	}
; 452  : 
; 453  : 	free(firstAdapter);

  00179	56		 push	 esi
  0017a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00180	59		 pop	 ecx

; 454  : 
; 455  : #	else // !_WIN32
; 456  : 
; 457  : 	struct ifaddrs *addrs, *addr;
; 458  : 
; 459  : 	if (getifaddrs(&addrs))
; 460  : 	{
; 461  : 		printerrorf("FATAL: Could not get network address list: %s\n", vlmcsd_strerror(errno));
; 462  : 		exit(errno);
; 463  : 	}
; 464  : 
; 465  : 	socklen_t length;
; 466  : 
; 467  : 	for (addr = addrs, *numAddresses = 0; addr != NULL; addr = addr->ifa_next)
; 468  : 	{
; 469  : 		if (!isPrivateIPAddress(addr->ifa_addr, &length)) continue;
; 470  : 		(*numAddresses)++;
; 471  : 	}
; 472  : 
; 473  : 	*ipAddresses = (char**)vlmcsd_malloc(*numAddresses * sizeof(char*));
; 474  : 
; 475  : 	for (addr = addrs, *numAddresses = 0; addr != NULL; addr = addr->ifa_next)
; 476  : 	{
; 477  : 		if (!isPrivateIPAddress(addr->ifa_addr, &length)) continue;
; 478  : 
; 479  : 		char *ipAddress = (char*)vlmcsd_malloc(64);
; 480  : 		int error = getnameinfo(addr->ifa_addr, length, ipAddress, 64, NULL, 0, NI_NUMERICHOST);
; 481  : 
; 482  : 		if (error)
; 483  : 		{
; 484  : 			printerrorf("WARNING: Could not get IP address from interface list: %s\n", gai_strerror(error));
; 485  : 			*ipAddress = 0;
; 486  : 		}
; 487  : 
; 488  : #		if __UCLIBC__ || __gnu_hurd__
; 489  : 
; 490  : 		size_t adrlen = strlen(ipAddress);
; 491  : 
; 492  : 		if
; 493  : 			(
; 494  : 				addr->ifa_addr->sa_family == AF_INET6 &&
; 495  : 				adrlen > 5 &&
; 496  : 				!strchr(ipAddress, '%') &&
; 497  : 				(BE16(*(uint16_t*)&((struct sockaddr_in6*)addr->ifa_addr)->sin6_addr) & 0xffc0) == 0xfe80
; 498  : 				)
; 499  : 		{
; 500  : 			size_t ifnamelen = strlen(addr->ifa_name);
; 501  : 			char* workaroundIpAddress = (char*)vlmcsd_malloc(adrlen + ifnamelen + 2);
; 502  : 			strcpy(workaroundIpAddress, ipAddress);
; 503  : 			strcat(workaroundIpAddress, "%");
; 504  : 			strcat(workaroundIpAddress, addr->ifa_name);
; 505  : 			(*ipAddresses)[(*numAddresses)++] = workaroundIpAddress;
; 506  : 			free(ipAddress);
; 507  : 		}
; 508  : 		else
; 509  : 		{
; 510  : 			(*ipAddresses)[(*numAddresses)++] = ipAddress;
; 511  : 		}
; 512  : #		else // !(__UCLIBC__ || __gnu_hurd__)
; 513  : 
; 514  : 		(*ipAddresses)[(*numAddresses)++] = ipAddress;
; 515  : 
; 516  : #		endif // !(__UCLIBC__ || __gnu_hurd__)
; 517  : 	}
; 518  : 
; 519  : 	freeifaddrs(addrs);
; 520  : 
; 521  : #	endif // !_WIN32
; 522  : }

  00181	5f		 pop	 edi
  00182	5e		 pop	 esi
  00183	5d		 pop	 ebp
  00184	5b		 pop	 ebx
  00185	83 c4 0c	 add	 esp, 12			; 0000000cH
  00188	c3		 ret	 0
$LN58@getPrivate:

; 397  : 	ULONG flags = GAA_FLAG_SKIP_MULTICAST | GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_DNS_SERVER | GAA_FLAG_SKIP_FRIENDLY_NAME;
; 398  : 
; 399  : 	firstAdapter = (PIP_ADAPTER_ADDRESSES)vlmcsd_malloc(outBufLen);

  00189	e8 00 00 00 00	 call	 _OutOfMemory
$LN61@getPrivate:
$LN54@getPrivate:
  0018e	cc		 int	 3
_getPrivateIPAddresses ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _listenOnAddress
_TEXT	SEGMENT
_socketOption$ = -72					; size = 4
_socketOption$1 = -68					; size = 4
_ipstr$ = -64						; size = 64
_listenOnAddress PROC					; COMDAT
; _ai$ = ecx
; _s$ = edx

; 530  : {

  00000	83 ec 48	 sub	 esp, 72			; 00000048H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b f9		 mov	 edi, ecx
  00009	8b da		 mov	 ebx, edx

; 531  : 	int error;
; 532  : 	char ipstr[64];
; 533  : 
; 534  : 	ip2str(ipstr, sizeof(ipstr), ai->ai_addr, (socklen_t)ai->ai_addrlen);

  0000b	8d 4c 24 18	 lea	 ecx, DWORD PTR _ipstr$[esp+88]
  0000f	ff 77 10	 push	 DWORD PTR [edi+16]
  00012	ff 77 18	 push	 DWORD PTR [edi+24]
  00015	e8 00 00 00 00	 call	 _ip2str
  0001a	59		 pop	 ecx
  0001b	59		 pop	 ecx

; 535  : 
; 536  : 	//*s = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
; 537  : 	*s = socket(ai->ai_family, SOCK_STREAM, IPPROTO_TCP);

  0001c	6a 06		 push	 6
  0001e	33 ed		 xor	 ebp, ebp
  00020	45		 inc	 ebp
  00021	55		 push	 ebp
  00022	ff 77 04	 push	 DWORD PTR [edi+4]
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__socket@12
  0002b	89 03		 mov	 DWORD PTR [ebx], eax

; 538  : 
; 539  : 	if (*s == INVALID_SOCKET)

  0002d	83 f8 ff	 cmp	 eax, -1
  00030	75 34		 jne	 SHORT $LN4@listenOnAd

; 540  : 	{
; 541  : 		error = socket_errno;

  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00038	8b f0		 mov	 esi, eax

; 542  : 		printerrorf("Warning: %s error. %s\n", ai->ai_family == AF_INET6 ? cIPv6 : cIPv4, vlmcsd_strerror(error));

  0003a	8b ce		 mov	 ecx, esi
  0003c	e8 00 00 00 00	 call	 _win_strerror
  00041	83 7f 04 17	 cmp	 DWORD PTR [edi+4], 23	; 00000017H
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET ??_C@_04HOFDLIOP@IPv6?$AA@
  0004a	50		 push	 eax
  0004b	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04EMGFNKGN@IPv4?$AA@
  00050	0f 45 c8	 cmovne	 ecx, eax
  00053	51		 push	 ecx
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6?$AA@
  00059	e8 00 00 00 00	 call	 _printerrorf
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 543  : 		return error;

  00061	e9 96 00 00 00	 jmp	 $LN10@listenOnAd
$LN4@listenOnAd:

; 544  : 	}
; 545  : 
; 546  : #	if !defined(_WIN32) && !defined(NO_SIGHUP)
; 547  : 
; 548  : 	int flags = fcntl(*s, F_GETFD, 0);
; 549  : 
; 550  : 	if (flags != -1)
; 551  : 	{
; 552  : 		flags |= FD_CLOEXEC;
; 553  : 		fcntl(*s, F_SETFD, flags);
; 554  : 	}
; 555  : #	ifdef _PEDANTIC
; 556  : 	else
; 557  : 	{
; 558  : 		printerrorf("Warning: Could not set FD_CLOEXEC flag on %s: %s\n", ipstr, vlmcsd_strerror(errno));
; 559  : 	}
; 560  : #	endif // _PEDANTIC
; 561  : 
; 562  : #	endif // !defined(_WIN32) && !defined(NO_SIGHUP)
; 563  : 
; 564  : 	BOOL socketOption = TRUE;
; 565  : 
; 566  : #	ifdef IPV6_V6ONLY
; 567  : 	if (ai->ai_family == AF_INET6 && setsockopt(*s, IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_t)&socketOption, sizeof(socketOption)))

  00066	83 7f 04 17	 cmp	 DWORD PTR [edi+4], 23	; 00000017H
  0006a	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__setsockopt@20
  00070	89 6c 24 10	 mov	 DWORD PTR _socketOption$[esp+88], ebp
  00074	75 0e		 jne	 SHORT $LN3@listenOnAd
  00076	6a 04		 push	 4
  00078	8d 4c 24 14	 lea	 ecx, DWORD PTR _socketOption$[esp+92]
  0007c	51		 push	 ecx
  0007d	6a 1b		 push	 27			; 0000001bH
  0007f	6a 29		 push	 41			; 00000029H
  00081	50		 push	 eax
  00082	ff d6		 call	 esi
$LN3@listenOnAd:

; 568  : 	{
; 569  : #		ifdef _PEDANTIC
; 570  : #		if defined(_WIN32) || defined(__CYGWIN__)
; 571  : 		//		if (IsWindowsVistaOrGreater()) //Doesn't work with older version of MingW32-w64 toolchain
; 572  : 		if ((GetVersion() & 0xff) > 5)
; 573  : 		{
; 574  : #		endif // _WIN32
; 575  : 			printerrorf("Warning: %s does not support socket option IPV6_V6ONLY: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 576  : #		if defined(_WIN32) || defined(__CYGWIN__)
; 577  : 		}
; 578  : #		endif // _WIN32
; 579  : #		endif // _PEDANTIC
; 580  : 	}
; 581  : #	endif
; 582  : 
; 583  : 	allowSocketReuse(*s);

  00084	6a 04		 push	 4
  00086	8d 44 24 18	 lea	 eax, DWORD PTR _socketOption$1[esp+92]
  0008a	89 6c 24 18	 mov	 DWORD PTR _socketOption$1[esp+92], ebp
  0008e	50		 push	 eax
  0008f	6a fb		 push	 -5			; fffffffbH
  00091	68 ff ff 00 00	 push	 65535			; 0000ffffH
  00096	ff 33		 push	 DWORD PTR [ebx]
  00098	ff d6		 call	 esi

; 584  : 
; 585  : #	if HAVE_FREEBIND
; 586  : #	if (defined(IP_NONLOCALOK) || __FreeBSD_kernel__ || __FreeBSD__) && !defined(IPV6_BINDANY)
; 587  : #	define IPV6_BINDANY 64
; 588  : #	endif // (defined(IP_NONLOCALOK) || __FreeBSD_kernel__ || __FreeBSD__) && !defined(IPV6_BINDANY)
; 589  : 
; 590  : 	if (freebind)
; 591  : 	{
; 592  : #		if defined(IP_FREEBIND) // Linux
; 593  : 		if (setsockopt(*s, IPPROTO_IP, IP_FREEBIND, (sockopt_t)&socketOption, sizeof(socketOption)))
; 594  : 		{
; 595  : 			printerrorf("Warning: Cannot use FREEBIND on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 596  : 		}
; 597  : #		endif // defined(IP_FREEBIND)
; 598  : 
; 599  : #		if defined(IP_BINDANY) // FreeBSD IPv4
; 600  : 		if (ai->ai_family == AF_INET && setsockopt(*s, IPPROTO_IP, IP_BINDANY, (sockopt_t)&socketOption, sizeof(socketOption)))
; 601  : 		{
; 602  : 			printerrorf("Warning: Cannot use BINDANY on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 603  : 		}
; 604  : #		endif // defined(IP_BINDANY)
; 605  : 
; 606  : #		if defined(IPV6_BINDANY) // FreeBSD IPv6
; 607  : 		if (ai->ai_family == AF_INET6 && setsockopt(*s, IPPROTO_IP, IPV6_BINDANY, (sockopt_t)&socketOption, sizeof(socketOption)))
; 608  : 		{
; 609  : #			ifdef _PEDANTIC // FreeBSD defines the symbol but doesn't have BINDANY in IPv6 (Kame stack doesn't have it)
; 610  : 			printerrorf("Warning: Cannot use BINDANY on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 611  : #			endif
; 612  : 		}
; 613  : #		endif // defined(IPV6_BINDANY)
; 614  : 
; 615  : #		if defined(IP_NONLOCALOK) && !defined(IP_BINDANY) // FreeBSD with GNU userspace IPv4
; 616  : 		if (ai->ai_family == AF_INET && setsockopt(*s, IPPROTO_IP, IP_NONLOCALOK, (sockopt_t)&socketOption, sizeof(socketOption)))
; 617  : 		{
; 618  : 			printerrorf("Warning: Cannot use BINDANY on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 619  : 		}
; 620  : #		endif // defined(IP_NONLOCALOK) && !defined(IP_BINDANY)
; 621  : 	}
; 622  : 
; 623  : #	endif // HAVE_FREEBIND
; 624  : 
; 625  : 	if (bind(*s, ai->ai_addr, (int)ai->ai_addrlen) || listen(*s, SOMAXCONN))

  0009a	ff 77 10	 push	 DWORD PTR [edi+16]
  0009d	ff 77 18	 push	 DWORD PTR [edi+24]
  000a0	ff 33		 push	 DWORD PTR [ebx]
  000a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__bind@12
  000a8	85 c0		 test	 eax, eax
  000aa	75 26		 jne	 SHORT $LN1@listenOnAd
  000ac	68 ff ff ff 7f	 push	 2147483647		; 7fffffffH
  000b1	ff 33		 push	 DWORD PTR [ebx]
  000b3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__listen@8
  000b9	85 c0		 test	 eax, eax
  000bb	75 15		 jne	 SHORT $LN1@listenOnAd

; 631  : 	}
; 632  : 
; 633  : #	ifndef NO_LOG
; 634  : 	logger("Listening on %s\n", ipstr);

  000bd	8d 44 24 18	 lea	 eax, DWORD PTR _ipstr$[esp+88]
  000c1	50		 push	 eax
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6?$AA@
  000c7	e8 00 00 00 00	 call	 _logger
  000cc	59		 pop	 ecx
  000cd	59		 pop	 ecx

; 635  : #	endif
; 636  : 
; 637  : 	return 0;

  000ce	33 c0		 xor	 eax, eax
  000d0	eb 2c		 jmp	 SHORT $LN5@listenOnAd
$LN1@listenOnAd:

; 626  : 	{
; 627  : 		error = socket_errno;

  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  000d8	8b f0		 mov	 esi, eax

; 628  : 		printerrorf("Warning: %s: %s\n", ipstr, vlmcsd_strerror(error));

  000da	8b ce		 mov	 ecx, esi
  000dc	e8 00 00 00 00	 call	 _win_strerror
  000e1	50		 push	 eax
  000e2	8d 44 24 1c	 lea	 eax, DWORD PTR _ipstr$[esp+92]
  000e6	50		 push	 eax
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6?$AA@
  000ec	e8 00 00 00 00	 call	 _printerrorf
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 629  : 		socketclose(*s);

  000f4	ff 33		 push	 DWORD PTR [ebx]
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
$LN10@listenOnAd:

; 630  : 		return error;

  000fc	8b c6		 mov	 eax, esi
$LN5@listenOnAd:
  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5d		 pop	 ebp
  00101	5b		 pop	 ebx

; 638  : }

  00102	83 c4 48	 add	 esp, 72			; 00000048H
  00105	c3		 ret	 0
_listenOnAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _addListeningSocket
_TEXT	SEGMENT
_aiList$ = -4						; size = 4
_addListeningSocket PROC				; COMDAT
; _addr$ = ecx

; 643  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 644  : 	struct addrinfo *aiList, *ai;
; 645  : 	int result = FALSE;
; 646  : 	SOCKET *s = SocketList + numsockets;

  00004	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR _SocketList
  0000a	a1 00 00 00 00	 mov	 eax, DWORD PTR _numsockets
  0000f	53		 push	 ebx
  00010	56		 push	 esi
  00011	57		 push	 edi

; 647  : 
; 648  : 	if (getSocketList(&aiList, addr, AI_PASSIVE | AI_NUMERICHOST, AF_UNSPEC))

  00012	51		 push	 ecx
  00013	8d 1c 82	 lea	 ebx, DWORD PTR [edx+eax*4]
  00016	33 ff		 xor	 edi, edi
  00018	51		 push	 ecx
  00019	8b d1		 mov	 edx, ecx
  0001b	8d 4d fc	 lea	 ecx, DWORD PTR _aiList$[ebp]
  0001e	e8 00 00 00 00	 call	 _getSocketList
  00023	59		 pop	 ecx
  00024	59		 pop	 ecx
  00025	84 c0		 test	 al, al
  00027	74 3e		 je	 SHORT $LN7@addListeni

; 649  : 	{
; 650  : 		for (ai = aiList; ai; ai = ai->ai_next)

  00029	8b 75 fc	 mov	 esi, DWORD PTR _aiList$[ebp]
  0002c	85 f6		 test	 esi, esi
  0002e	74 30		 je	 SHORT $LN11@addListeni
$LL6@addListeni:

; 651  : 		{
; 652  : 			// struct sockaddr_in* addr4 = (struct sockaddr_in*)sa->ai_addr;
; 653  : 			// struct sockaddr_in6* addr6 = (struct sockaddr_in6*)sa->ai_addr;
; 654  : 
; 655  : 			if (numsockets >= FD_SETSIZE)

  00030	83 3d 00 00 00
	00 40		 cmp	 DWORD PTR _numsockets, 64 ; 00000040H
  00037	7d 24		 jge	 SHORT $LN15@addListeni

; 656  : 			{
; 657  : #ifdef _PEDANTIC // Do not report this error in normal builds to keep file size low
; 658  : 				printerrorf("Warning: Cannot listen on %s. Your OS only supports %u listening sockets in an FD_SET.\n", addr, FD_SETSIZE);
; 659  : #endif
; 660  : 				break;
; 661  : 			}
; 662  : 
; 663  : 			if (!listenOnAddress(ai, s))

  00039	8b d3		 mov	 edx, ebx
  0003b	8b ce		 mov	 ecx, esi
  0003d	e8 00 00 00 00	 call	 _listenOnAddress
  00042	85 c0		 test	 eax, eax
  00044	75 0b		 jne	 SHORT $LN2@addListeni

; 664  : 			{
; 665  : 				numsockets++;

  00046	ff 05 00 00 00
	00		 inc	 DWORD PTR _numsockets

; 666  : 				result = TRUE;

  0004c	33 ff		 xor	 edi, edi
  0004e	47		 inc	 edi

; 667  : 			}
; 668  : 			else

  0004f	eb 05		 jmp	 SHORT $LN5@addListeni
$LN2@addListeni:

; 669  : 			{
; 670  : 				exitOnWarningLevel(1);

  00051	e8 00 00 00 00	 call	 _exitOnWarningLevel
$LN5@addListeni:

; 649  : 	{
; 650  : 		for (ai = aiList; ai; ai = ai->ai_next)

  00056	8b 76 1c	 mov	 esi, DWORD PTR [esi+28]
  00059	85 f6		 test	 esi, esi
  0005b	75 d3		 jne	 SHORT $LL6@addListeni
$LN15@addListeni:
  0005d	8b 75 fc	 mov	 esi, DWORD PTR _aiList$[ebp]
$LN11@addListeni:

; 671  : 			}
; 672  : 		}
; 673  : 
; 674  : 		freeaddrinfo(aiList);

  00060	56		 push	 esi
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__freeaddrinfo@4
$LN7@addListeni:

; 675  : 	}
; 676  : 	return result;

  00067	8b c7		 mov	 eax, edi

; 677  : }

  00069	5f		 pop	 edi
  0006a	5e		 pop	 esi
  0006b	5b		 pop	 ebx
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
_addListeningSocket ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _checkProtocolStack
_TEXT	SEGMENT
_checkProtocolStack PROC				; COMDAT
; _addressfamily$ = ecx

; 682  : {

  00000	56		 push	 esi

; 683  : 	SOCKET s; // = INVALID_SOCKET;
; 684  : 
; 685  : 	s = socket(addressfamily, SOCK_STREAM, 0);

  00001	6a 00		 push	 0
  00003	6a 01		 push	 1
  00005	51		 push	 ecx
  00006	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__socket@12
  0000c	8b f0		 mov	 esi, eax

; 686  : 	int_fast8_t success = (s != INVALID_SOCKET);
; 687  : 
; 688  : 	socketclose(s);

  0000e	56		 push	 esi
  0000f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00015	83 fe ff	 cmp	 esi, -1
  00018	5e		 pop	 esi
  00019	0f 95 c0	 setne	 al

; 689  : 	return success;
; 690  : }

  0001c	c3		 ret	 0
_checkProtocolStack ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _network_accept_any
_TEXT	SEGMENT
_ListeningSocketsList$ = -260				; size = 260
_network_accept_any PROC				; COMDAT

; 695  : {

  00000	81 ec 04 01 00
	00		 sub	 esp, 260		; 00000104H
  00006	53		 push	 ebx

; 696  : 	fd_set ListeningSocketsList;
; 697  : 	SOCKET maxSocket, sock;
; 698  : 	int i;
; 699  : 	int status;
; 700  : 
; 701  : 	FD_ZERO(&ListeningSocketsList);
; 702  : 	maxSocket = 0;
; 703  : 
; 704  : 	for (i = 0; i < numsockets; i++)

  00007	8b 1d 00 00 00
	00		 mov	 ebx, DWORD PTR _numsockets
  0000d	55		 push	 ebp
  0000e	33 ed		 xor	 ebp, ebp
  00010	8b c5		 mov	 eax, ebp
  00012	8b d5		 mov	 edx, ebp
  00014	89 44 24 08	 mov	 DWORD PTR _ListeningSocketsList$[esp+268], eax
  00018	56		 push	 esi
  00019	8b f5		 mov	 esi, ebp
  0001b	85 db		 test	 ebx, ebx
  0001d	7e 43		 jle	 SHORT $LN18@network_ac
  0001f	57		 push	 edi
  00020	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR _SocketList
$LL20@network_ac:

; 705  : 	{
; 706  : 		FD_SET(SocketList[i], &ListeningSocketsList);

  00026	8b cd		 mov	 ecx, ebp
  00028	85 c0		 test	 eax, eax
  0002a	74 10		 je	 SHORT $LN26@network_ac
  0002c	8b 2c 97	 mov	 ebp, DWORD PTR [edi+edx*4]
$LL14@network_ac:
  0002f	39 6c 8c 14	 cmp	 DWORD PTR _ListeningSocketsList$[esp+ecx*4+280], ebp
  00033	74 05		 je	 SHORT $LN38@network_ac
  00035	41		 inc	 ecx
  00036	3b c8		 cmp	 ecx, eax
  00038	72 f5		 jb	 SHORT $LL14@network_ac
$LN38@network_ac:
  0003a	33 ed		 xor	 ebp, ebp
$LN26@network_ac:
  0003c	3b c8		 cmp	 ecx, eax
  0003e	75 15		 jne	 SHORT $LN16@network_ac
  00040	83 f8 40	 cmp	 eax, 64			; 00000040H
  00043	73 10		 jae	 SHORT $LN16@network_ac
  00045	8b 04 97	 mov	 eax, DWORD PTR [edi+edx*4]
  00048	89 44 8c 14	 mov	 DWORD PTR _ListeningSocketsList$[esp+ecx*4+280], eax
  0004c	8b 44 24 10	 mov	 eax, DWORD PTR _ListeningSocketsList$[esp+276]
  00050	40		 inc	 eax
  00051	89 44 24 10	 mov	 DWORD PTR _ListeningSocketsList$[esp+276], eax
$LN16@network_ac:

; 707  : 		if (SocketList[i] > maxSocket) maxSocket = SocketList[i];

  00055	39 34 97	 cmp	 DWORD PTR [edi+edx*4], esi
  00058	0f 47 34 97	 cmova	 esi, DWORD PTR [edi+edx*4]
  0005c	42		 inc	 edx
  0005d	3b d3		 cmp	 edx, ebx
  0005f	7c c5		 jl	 SHORT $LL20@network_ac
  00061	5f		 pop	 edi
$LN18@network_ac:

; 708  : 	}
; 709  : 
; 710  : 	status = select((int)maxSocket + 1, &ListeningSocketsList, NULL, NULL, NULL);

  00062	55		 push	 ebp
  00063	55		 push	 ebp
  00064	55		 push	 ebp
  00065	8d 44 24 18	 lea	 eax, DWORD PTR _ListeningSocketsList$[esp+284]
  00069	50		 push	 eax
  0006a	8d 46 01	 lea	 eax, DWORD PTR [esi+1]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__select@20

; 711  : 
; 712  : 	if (status < 0) return INVALID_SOCKET;

  00074	85 c0		 test	 eax, eax
  00076	78 2b		 js	 SHORT $LN37@network_ac

; 713  : 
; 714  : 	sock = INVALID_SOCKET;
; 715  : 
; 716  : 	for (i = 0; i < numsockets; i++)

  00078	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _numsockets, 0
  0007f	8b f5		 mov	 esi, ebp
  00081	7e 20		 jle	 SHORT $LN37@network_ac
$LL6@network_ac:

; 717  : 	{
; 718  : 		if (FD_ISSET(SocketList[i], &ListeningSocketsList))

  00083	8d 44 24 0c	 lea	 eax, DWORD PTR _ListeningSocketsList$[esp+272]
  00087	50		 push	 eax
  00088	a1 00 00 00 00	 mov	 eax, DWORD PTR _SocketList
  0008d	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____WSAFDIsSet@8
  00096	85 c0		 test	 eax, eax
  00098	75 16		 jne	 SHORT $LN27@network_ac

; 713  : 
; 714  : 	sock = INVALID_SOCKET;
; 715  : 
; 716  : 	for (i = 0; i < numsockets; i++)

  0009a	46		 inc	 esi
  0009b	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _numsockets
  000a1	7c e0		 jl	 SHORT $LL6@network_ac
$LN37@network_ac:

; 726  : 		return INVALID_SOCKET;

  000a3	83 c8 ff	 or	 eax, -1
$LN1@network_ac:
  000a6	5e		 pop	 esi
  000a7	5d		 pop	 ebp
  000a8	5b		 pop	 ebx

; 729  : }

  000a9	81 c4 04 01 00
	00		 add	 esp, 260		; 00000104H
  000af	c3		 ret	 0
$LN27@network_ac:

; 719  : 		{
; 720  : 			sock = SocketList[i];

  000b0	a1 00 00 00 00	 mov	 eax, DWORD PTR _SocketList

; 721  : 			break;
; 722  : 		}
; 723  : 	}
; 724  : 
; 725  : 	if (sock == INVALID_SOCKET)

  000b5	83 3c b0 ff	 cmp	 DWORD PTR [eax+esi*4], -1
  000b9	74 e8		 je	 SHORT $LN37@network_ac

; 727  : 	else
; 728  : 		return accept(sock, NULL, NULL);

  000bb	55		 push	 ebp
  000bc	55		 push	 ebp
  000bd	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__accept@12
  000c6	eb de		 jmp	 SHORT $LN1@network_ac
_network_accept_any ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _closeAllListeningSockets
_TEXT	SEGMENT
_closeAllListeningSockets PROC				; COMDAT

; 734  : {

  00000	56		 push	 esi

; 735  : #	ifdef SIMPLE_SOCKETS
; 736  : 
; 737  : 	socketclose(s_server);
; 738  : 
; 739  : #	else // !SIMPLE_SOCKETS
; 740  : 
; 741  : 	int i;
; 742  : 
; 743  : 	for (i = 0; i < numsockets; i++)

  00001	33 f6		 xor	 esi, esi
  00003	39 35 00 00 00
	00		 cmp	 DWORD PTR _numsockets, esi
  00009	7e 17		 jle	 SHORT $LN1@closeAllLi
$LL3@closeAllLi:

; 744  : 	{
; 745  : 		socketclose(SocketList[i]);

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR _SocketList
  00010	ff 34 b0	 push	 DWORD PTR [eax+esi*4]
  00013	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00019	46		 inc	 esi
  0001a	3b 35 00 00 00
	00		 cmp	 esi, DWORD PTR _numsockets
  00020	7c e9		 jl	 SHORT $LL3@closeAllLi
$LN1@closeAllLi:
  00022	5e		 pop	 esi

; 746  : 	}
; 747  : 
; 748  : #endif // !SIMPLE_SOCKETS
; 749  : }

  00023	c3		 ret	 0
_closeAllListeningSockets ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _serveClient
_TEXT	SEGMENT
_len$ = -200						; size = 4
_to$ = -196						; size = 4
_ipstr$ = -192						; size = 64
_addr$ = -128						; size = 128
_serveClient PROC					; COMDAT
; _s_client$ = ecx
; _RpcAssocGroup$ = edx

; 754  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 e4 f8	 and	 esp, -8			; fffffff8H
  00006	81 ec c8 00 00
	00		 sub	 esp, 200		; 000000c8H

; 755  : #	if !defined(NO_TIMEOUT) && !__minix__
; 756  : 
; 757  : #	ifndef _WIN32 // Standard Posix timeout structure
; 758  : 
; 759  : 	struct timeval to;
; 760  : 	to.tv_sec = ServerTimeout;
; 761  : 	to.tv_usec = 0;
; 762  : 
; 763  : #else // Windows requires a DWORD with milliseconds
; 764  : 
; 765  : 	DWORD to = ServerTimeout * 1000;

  0000c	69 05 00 00 00
	00 e8 03 00 00	 imul	 eax, DWORD PTR _ServerTimeout, 1000
  00016	53		 push	 ebx
  00017	55		 push	 ebp
  00018	56		 push	 esi

; 766  : 
; 767  : #	endif // _WIN32
; 768  : 
; 769  : #	if !defined(NO_LOG) && defined(_PEDANTIC)
; 770  : 
; 771  : 	int result =
; 772  : 		setsockopt(s_client, SOL_SOCKET, SO_RCVTIMEO, (sockopt_t)&to, sizeof(to)) ||
; 773  : 		setsockopt(s_client, SOL_SOCKET, SO_SNDTIMEO, (sockopt_t)&to, sizeof(to));
; 774  : 
; 775  : 	if (result) logger("Warning: Set timeout failed: %s\n", vlmcsd_strerror(socket_errno));
; 776  : 
; 777  : #	else // !(!defined(NO_LOG) && defined(_PEDANTIC))
; 778  : 
; 779  : 	setsockopt(s_client, SOL_SOCKET, SO_RCVTIMEO, (sockopt_t)&to, sizeof(to));

  00019	8b 35 00 00 00
	00		 mov	 esi, DWORD PTR __imp__setsockopt@20
  0001f	bd ff ff 00 00	 mov	 ebp, 65535		; 0000ffffH
  00024	57		 push	 edi
  00025	6a 04		 push	 4
  00027	89 44 24 18	 mov	 DWORD PTR _to$[esp+220], eax
  0002b	8b f9		 mov	 edi, ecx
  0002d	8d 44 24 18	 lea	 eax, DWORD PTR _to$[esp+220]
  00031	8b da		 mov	 ebx, edx
  00033	50		 push	 eax
  00034	68 06 10 00 00	 push	 4102			; 00001006H
  00039	55		 push	 ebp
  0003a	57		 push	 edi
  0003b	ff d6		 call	 esi

; 780  : 	setsockopt(s_client, SOL_SOCKET, SO_SNDTIMEO, (sockopt_t)&to, sizeof(to));

  0003d	6a 04		 push	 4
  0003f	8d 44 24 18	 lea	 eax, DWORD PTR _to$[esp+220]
  00043	50		 push	 eax
  00044	68 05 10 00 00	 push	 4101			; 00001005H
  00049	55		 push	 ebp
  0004a	57		 push	 edi
  0004b	ff d6		 call	 esi

; 781  : 
; 782  : #   endif // !(!defined(NO_LOG) && defined(_PEDANTIC))
; 783  : 
; 784  : #	endif // !defined(NO_TIMEOUT) && !__minix__
; 785  : 
; 786  : 	char ipstr[64];
; 787  : 	socklen_t len;
; 788  : 	struct sockaddr_storage addr;
; 789  : 
; 790  : 	len = sizeof(addr);
; 791  : 
; 792  : 	if (getpeername(s_client, (struct sockaddr*)&addr, &len) ||
; 793  : 		!ip2str(ipstr, sizeof(ipstr), (struct sockaddr*)&addr, len))

  0004d	8d 44 24 10	 lea	 eax, DWORD PTR _len$[esp+216]
  00051	c7 44 24 10 80
	00 00 00	 mov	 DWORD PTR _len$[esp+216], 128 ; 00000080H
  00059	50		 push	 eax
  0005a	8d 44 24 5c	 lea	 eax, DWORD PTR _addr$[esp+220]
  0005e	50		 push	 eax
  0005f	57		 push	 edi
  00060	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__getpeername@12
  00066	85 c0		 test	 eax, eax
  00068	0f 85 8b 00 00
	00		 jne	 $LN4@serveClien
  0006e	ff 74 24 10	 push	 DWORD PTR _len$[esp+216]
  00072	8d 44 24 5c	 lea	 eax, DWORD PTR _addr$[esp+220]
  00076	50		 push	 eax
  00077	8d 4c 24 20	 lea	 ecx, DWORD PTR _ipstr$[esp+224]
  0007b	e8 00 00 00 00	 call	 _ip2str
  00080	59		 pop	 ecx
  00081	59		 pop	 ecx
  00082	84 c0		 test	 al, al
  00084	74 73		 je	 SHORT $LN4@serveClien

; 799  : 		return;
; 800  : 	}
; 801  : 
; 802  : 
; 803  : #	ifndef NO_LOG
; 804  : 	const char *const connection_type = addr.ss_family == AF_INET6 ? cIPv6 : cIPv4;

  00086	66 83 7c 24 58
	17		 cmp	 WORD PTR _addr$[esp+216], 23 ; 00000017H
  0008c	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_04EMGFNKGN@IPv4?$AA@
  00091	be 00 00 00 00	 mov	 esi, OFFSET ??_C@_04HOFDLIOP@IPv6?$AA@

; 805  : 	static const char *const cAccepted = "accepted";
; 806  : 	static const char *const cClosed = "closed";
; 807  : 	static const char *const fIP = "%s connection %s: %s.\n";
; 808  : 
; 809  : 	logger(fIP, connection_type, cAccepted, ipstr);

  00096	bd 00 00 00 00	 mov	 ebp, OFFSET ??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6?$AA@
  0009b	0f 45 f0	 cmovne	 esi, eax
  0009e	8d 44 24 18	 lea	 eax, DWORD PTR _ipstr$[esp+216]
  000a2	50		 push	 eax
  000a3	68 00 00 00 00	 push	 OFFSET ??_C@_08LMOPGBBD@accepted?$AA@
  000a8	56		 push	 esi
  000a9	55		 push	 ebp
  000aa	e8 00 00 00 00	 call	 _logger
  000af	83 c4 10	 add	 esp, 16			; 00000010H

; 810  : #endif // NO_LOG
; 811  : 
; 812  : #	if !defined(NO_PRIVATE_IP_DETECT)
; 813  : 
; 814  : 	if (!(PublicIPProtectionLevel & 2) || isPrivateIPAddress((struct sockaddr*)&addr, NULL))

  000b2	f6 05 00 00 00
	00 02		 test	 BYTE PTR _PublicIPProtectionLevel, 2
  000b9	74 1b		 je	 SHORT $LN2@serveClien
  000bb	33 d2		 xor	 edx, edx
  000bd	8d 4c 24 58	 lea	 ecx, DWORD PTR _addr$[esp+216]
  000c1	e8 00 00 00 00	 call	 _isPrivateIPAddress
  000c6	84 c0		 test	 al, al
  000c8	75 0c		 jne	 SHORT $LN2@serveClien

; 817  : 	}
; 818  : #	ifndef NO_LOG
; 819  : 	else
; 820  : 	{
; 821  : 		logger("Client with public IP address rejected\n");

  000ca	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5re@
  000cf	e8 00 00 00 00	 call	 _logger
  000d4	eb 0e		 jmp	 SHORT $LN8@serveClien
$LN2@serveClien:

; 815  : 	{
; 816  : 		rpcServer(s_client, RpcAssocGroup, ipstr);

  000d6	8d 44 24 18	 lea	 eax, DWORD PTR _ipstr$[esp+216]
  000da	8b d3		 mov	 edx, ebx
  000dc	50		 push	 eax
  000dd	8b cf		 mov	 ecx, edi
  000df	e8 00 00 00 00	 call	 _rpcServer
$LN8@serveClien:
  000e4	59		 pop	 ecx

; 822  : 	}
; 823  : #	endif // NO_LOG
; 824  : 
; 825  : #   else // defined(NO_PRIVATE_IP_DETECT)
; 826  : 
; 827  : 	rpcServer(s_client, RpcAssocGroup, ipstr);
; 828  : 
; 829  : #	endif // defined(NO_PRIVATE_IP_DETECT)
; 830  : 
; 831  : #	ifndef NO_LOG
; 832  : 	logger(fIP, connection_type, cClosed, ipstr);

  000e5	8d 44 24 18	 lea	 eax, DWORD PTR _ipstr$[esp+216]
  000e9	50		 push	 eax
  000ea	68 00 00 00 00	 push	 OFFSET ??_C@_06IKJOPBFO@closed?$AA@
  000ef	56		 push	 esi
  000f0	55		 push	 ebp
  000f1	e8 00 00 00 00	 call	 _logger
  000f6	83 c4 10	 add	 esp, 16			; 00000010H
$LN4@serveClien:

; 794  : 	{
; 795  : #		if !defined(NO_LOG) && defined(_PEDANTIC)
; 796  : 		logger("Fatal: Cannot determine client's IP address: %s\n", vlmcsd_strerror(errno));
; 797  : #		endif // !defined(NO_LOG) && defined(_PEDANTIC)
; 798  : 		socketclose(s_client);

  000f9	57		 push	 edi
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 833  : #	endif // NO_LOG
; 834  : 
; 835  : 	socketclose(s_client);
; 836  : }

  00100	5f		 pop	 edi
  00101	5e		 pop	 esi
  00102	5d		 pop	 ebp
  00103	5b		 pop	 ebx
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
_serveClient ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _post_sem
_TEXT	SEGMENT
_post_sem PROC						; COMDAT

; 842  : #if !defined(NO_LIMIT) && !__minix__
; 843  : 	if (!InetdMode && MaxTasks != SEM_VALUE_MAX)

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  00007	75 1c		 jne	 SHORT $LN1@post_sem
  00009	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR _MaxTasks, 2147483647 ; 7fffffffH
  00013	74 10		 je	 SHORT $LN1@post_sem

; 844  : 	{
; 845  : 		semaphore_post(MaxTaskSemaphore);

  00015	6a 00		 push	 0
  00017	6a 01		 push	 1
  00019	ff 35 00 00 00
	00		 push	 DWORD PTR _MaxTaskSemaphore
  0001f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReleaseSemaphore@12
$LN1@post_sem:

; 846  : 	}
; 847  : #endif // !defined(NO_LIMIT) && !__minix__
; 848  : }

  00025	c3		 ret	 0
_post_sem ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _wait_sem
_TEXT	SEGMENT
_wait_sem PROC						; COMDAT

; 853  : #if !defined(NO_LIMIT) && !__minix__
; 854  : 	if (!InetdMode && MaxTasks != SEM_VALUE_MAX)

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  00007	75 1a		 jne	 SHORT $LN1@wait_sem
  00009	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR _MaxTasks, 2147483647 ; 7fffffffH
  00013	74 0e		 je	 SHORT $LN1@wait_sem

; 855  : 	{
; 856  : 		semaphore_wait(MaxTaskSemaphore);

  00015	6a ff		 push	 -1
  00017	ff 35 00 00 00
	00		 push	 DWORD PTR _MaxTaskSemaphore
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN1@wait_sem:

; 857  : 	}
; 858  : #endif // !defined(NO_LIMIT) && !__minix__
; 859  : }

  00023	c3		 ret	 0
_wait_sem ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _serveClientThreadProc@4
_TEXT	SEGMENT
_clData$ = 8						; size = 4
_serveClientThreadProc@4 PROC				; COMDAT

; 869  : {

  00000	56		 push	 esi

; 870  : 	serveClient(clData->socket, clData->RpcAssocGroup);

  00001	8b 74 24 08	 mov	 esi, DWORD PTR _clData$[esp]
  00005	8b 56 04	 mov	 edx, DWORD PTR [esi+4]
  00008	8b 0e		 mov	 ecx, DWORD PTR [esi]
  0000a	e8 00 00 00 00	 call	 _serveClient

; 871  : 	free(clData);

  0000f	56		 push	 esi
  00010	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00016	59		 pop	 ecx

; 872  : 	post_sem();

  00017	e8 00 00 00 00	 call	 _post_sem

; 873  : 
; 874  : 	return 0;

  0001c	33 c0		 xor	 eax, eax
  0001e	5e		 pop	 esi

; 875  : }

  0001f	c2 04 00	 ret	 4
_serveClientThreadProc@4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _serveClientAsyncWinThreads
_TEXT	SEGMENT
_serveClientAsyncWinThreads PROC			; COMDAT
; _thr_CLData$ = ecx

; 885  : 	wait_sem();

  00000	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  00007	56		 push	 esi
  00008	8b f1		 mov	 esi, ecx
  0000a	75 1a		 jne	 SHORT $LN5@serveClien
  0000c	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR _MaxTasks, 2147483647 ; 7fffffffH
  00016	74 0e		 je	 SHORT $LN5@serveClien
  00018	6a ff		 push	 -1
  0001a	ff 35 00 00 00
	00		 push	 DWORD PTR _MaxTaskSemaphore
  00020	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN5@serveClien:

; 886  : 
; 887  : 	HANDLE h = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)serveClientThreadProc, thr_CLData, 0, NULL);

  00026	33 c0		 xor	 eax, eax
  00028	50		 push	 eax
  00029	50		 push	 eax
  0002a	56		 push	 esi
  0002b	68 00 00 00 00	 push	 OFFSET _serveClientThreadProc@4
  00030	50		 push	 eax
  00031	50		 push	 eax
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24

; 888  : 
; 889  : 	if (h)

  00038	85 c0		 test	 eax, eax
  0003a	74 0b		 je	 SHORT $LN2@serveClien

; 890  : 	{
; 891  : 		CloseHandle(h);

  0003c	50		 push	 eax
  0003d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 892  : 		return NO_ERROR;

  00043	33 c0		 xor	 eax, eax
  00045	5e		 pop	 esi

; 900  : 	}
; 901  : }

  00046	c3		 ret	 0
$LN2@serveClien:

; 893  : 	}
; 894  : 	else
; 895  : 	{
; 896  : 		socketclose(thr_CLData->socket);

  00047	ff 36		 push	 DWORD PTR [esi]
  00049	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4

; 897  : 		free(thr_CLData);

  0004f	56		 push	 esi
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00056	59		 pop	 ecx

; 898  : 		post_sem();

  00057	e8 00 00 00 00	 call	 _post_sem
  0005c	5e		 pop	 esi

; 899  : 		return GetLastError();

  0005d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp__GetLastError@0
_serveClientAsyncWinThreads ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _serveClientAsync
_TEXT	SEGMENT
_serveClientAsync PROC					; COMDAT
; _s_client$ = ecx
; _RpcAssocGroup$ = edx

; 989  : {

  00000	53		 push	 ebx
  00001	56		 push	 esi
  00002	57		 push	 edi

; 990  : #ifndef USE_THREADS // fork() implementation
; 991  : 
; 992  : 	return ServeClientAsyncFork(s_client, RpcAssocGroup);
; 993  : 
; 994  : #else // threads implementation
; 995  : 
; 996  : 	PCLDATA thr_CLData = (PCLDATA)vlmcsd_malloc(sizeof(CLDATA));

  00003	6a 08		 push	 8
  00005	8b f2		 mov	 esi, edx
  00007	8b d9		 mov	 ebx, ecx
  00009	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0000f	8b f8		 mov	 edi, eax
  00011	59		 pop	 ecx
  00012	85 ff		 test	 edi, edi
  00014	74 6a		 je	 SHORT $LN15@serveClien

; 997  : 	thr_CLData->socket = s_client;
; 998  : 	thr_CLData->RpcAssocGroup = RpcAssocGroup;
; 999  : 
; 1000 : #if defined(_WIN32) || defined (__CYGWIN__) // Windows threads
; 1001 : 
; 1002 : 	return serveClientAsyncWinThreads(thr_CLData);

  00016	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  0001d	89 1f		 mov	 DWORD PTR [edi], ebx
  0001f	89 77 04	 mov	 DWORD PTR [edi+4], esi
  00022	75 1a		 jne	 SHORT $LN11@serveClien
  00024	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR _MaxTasks, 2147483647 ; 7fffffffH
  0002e	74 0e		 je	 SHORT $LN11@serveClien
  00030	6a ff		 push	 -1
  00032	ff 35 00 00 00
	00		 push	 DWORD PTR _MaxTaskSemaphore
  00038	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WaitForSingleObject@8
$LN11@serveClien:
  0003e	33 f6		 xor	 esi, esi
  00040	56		 push	 esi
  00041	56		 push	 esi
  00042	57		 push	 edi
  00043	68 00 00 00 00	 push	 OFFSET _serveClientThreadProc@4
  00048	56		 push	 esi
  00049	56		 push	 esi
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateThread@24
  00050	85 c0		 test	 eax, eax
  00052	74 09		 je	 SHORT $LN8@serveClien
  00054	50		 push	 eax
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4
  0005b	eb 1d		 jmp	 SHORT $LN7@serveClien
$LN8@serveClien:
  0005d	ff 37		 push	 DWORD PTR [edi]
  0005f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__closesocket@4
  00065	57		 push	 edi
  00066	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0006c	59		 pop	 ecx
  0006d	e8 00 00 00 00	 call	 _post_sem
  00072	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetLastError@0
  00078	8b f0		 mov	 esi, eax
$LN7@serveClien:
  0007a	5f		 pop	 edi
  0007b	8b c6		 mov	 eax, esi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx

; 1003 : 
; 1004 : #else // Posix Threads
; 1005 : 
; 1006 : 	return ServeClientAsyncPosixThreads(thr_CLData);
; 1007 : 
; 1008 : #endif // Posix Threads
; 1009 : 
; 1010 : #endif // USE_THREADS
; 1011 : }

  0007f	c3		 ret	 0
$LN15@serveClien:

; 990  : #ifndef USE_THREADS // fork() implementation
; 991  : 
; 992  : 	return ServeClientAsyncFork(s_client, RpcAssocGroup);
; 993  : 
; 994  : #else // threads implementation
; 995  : 
; 996  : 	PCLDATA thr_CLData = (PCLDATA)vlmcsd_malloc(sizeof(CLDATA));

  00080	e8 00 00 00 00	 call	 _OutOfMemory
$LN17@serveClien:
$LN14@serveClien:
  00085	cc		 int	 3
_serveClientAsync ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\network.c
;	COMDAT _runServer
_TEXT	SEGMENT
_runServer PROC						; COMDAT

; 1017 : {

  00000	56		 push	 esi
  00001	57		 push	 edi

; 1018 : 	DWORD RpcAssocGroup = rand32();

  00002	8b 3d 00 00 00
	00		 mov	 edi, DWORD PTR __imp__rand
  00008	ff d7		 call	 edi
  0000a	8b f0		 mov	 esi, eax
  0000c	c1 e6 0f	 shl	 esi, 15			; 0000000fH
  0000f	ff d7		 call	 edi
  00011	0b f0		 or	 esi, eax
  00013	c1 e6 02	 shl	 esi, 2
  00016	ff d7		 call	 edi
  00018	8b f8		 mov	 edi, eax
  0001a	83 e7 03	 and	 edi, 3
  0001d	0b fe		 or	 edi, esi

; 1019 : 
; 1020 : 	// If compiled for inetd-only mode just serve the stdin socket
; 1021 : #ifdef NO_SOCKETS
; 1022 : 	serveClient(STDIN_FILENO, RpcAssocGroup);
; 1023 : 	return 0;
; 1024 : #else
; 1025 : // In inetd mode just handle the stdin socket
; 1026 : 	if (InetdMode)

  0001f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _InetdMode, 0
  00026	74 0d		 je	 SHORT $LL6@runServer

; 1027 : 	{
; 1028 : 		serveClient(STDIN_FILENO, RpcAssocGroup);

  00028	8b d7		 mov	 edx, edi
  0002a	33 c9		 xor	 ecx, ecx
  0002c	e8 00 00 00 00	 call	 _serveClient
$LN20@runServer:

; 1029 : 		return 0;

  00031	33 c0		 xor	 eax, eax
  00033	eb 41		 jmp	 SHORT $LN5@runServer
$LL6@runServer:

; 1030 : 	}
; 1031 : 
; 1032 : 	for (;;)
; 1033 : 	{
; 1034 : 		int error;
; 1035 : 		SOCKET s_client;
; 1036 : 
; 1037 : #		ifdef SIMPLE_SOCKETS
; 1038 : 		if ((s_client = accept(s_server, NULL, NULL)) == INVALID_SOCKET)
; 1039 : #		else // Standalone mode fully featured sockets
; 1040 : 		if ((s_client = network_accept_any()) == INVALID_SOCKET)

  00035	e8 00 00 00 00	 call	 _network_accept_any
  0003a	83 f8 ff	 cmp	 eax, -1
  0003d	75 3a		 jne	 SHORT $LN4@runServer

; 1041 : #		endif // Standalone mode fully featured sockets
; 1042 : 		{
; 1043 : 			error = socket_errno;

  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WSAGetLastError@0
  00045	8b f0		 mov	 esi, eax

; 1044 : 			if (error == SOCKET_EINTR || error == SOCKET_ECONNABORTED) continue;

  00047	81 fe 14 27 00
	00		 cmp	 esi, 10004		; 00002714H
  0004d	74 e6		 je	 SHORT $LL6@runServer
  0004f	81 fe 45 27 00
	00		 cmp	 esi, 10053		; 00002745H
  00055	74 de		 je	 SHORT $LL6@runServer

; 1045 : 
; 1046 : #			ifdef _NTSERVICE
; 1047 : 			if (ServiceShutdown) return 0;

  00057	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR _ServiceShutdown, 0
  0005e	75 d1		 jne	 SHORT $LN20@runServer

; 1048 : #			endif
; 1049 : 
; 1050 : #			ifndef NO_LOG
; 1051 : 			logger("Fatal: %s\n", vlmcsd_strerror(error));

  00060	8b ce		 mov	 ecx, esi
  00062	e8 00 00 00 00	 call	 _win_strerror
  00067	50		 push	 eax
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6?$AA@
  0006d	e8 00 00 00 00	 call	 _logger
  00072	59		 pop	 ecx
  00073	59		 pop	 ecx

; 1052 : #			endif
; 1053 : 
; 1054 : 			return error;

  00074	8b c6		 mov	 eax, esi
$LN5@runServer:

; 1072 : #	endif // NO_SOCKETS
; 1073 : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	c3		 ret	 0
$LN4@runServer:

; 1055 : 		}
; 1056 : 
; 1057 : 		RpcAssocGroup++;
; 1058 : 
; 1059 : #		if !defined(NO_LOG) && defined(_PEDANTIC)
; 1060 : 		if ((error = serveClientAsync(s_client, RpcAssocGroup)))
; 1061 : 		{
; 1062 : #			ifdef USE_THREADS
; 1063 : 			logger("Warning: Could not create client thread: %s\n", vlmcsd_strerror(error));
; 1064 : #			else // !USE_THREADS
; 1065 : 			logger("Warning: Could not fork client: %s\n", vlmcsd_strerror(error));
; 1066 : #			endif // !USE_THREADS
; 1067 : 		}
; 1068 : #		else // NO_LOG || !_PEDANTIC
; 1069 : 		serveClientAsync(s_client, RpcAssocGroup);

  00079	47		 inc	 edi
  0007a	8b c8		 mov	 ecx, eax
  0007c	8b d7		 mov	 edx, edi
  0007e	e8 00 00 00 00	 call	 _serveClientAsync

; 1070 : #		endif // NO_LOG || !_PEDANTIC
; 1071 : 	}

  00083	eb b0		 jmp	 SHORT $LL6@runServer
_runServer ENDP
_TEXT	ENDS
END
