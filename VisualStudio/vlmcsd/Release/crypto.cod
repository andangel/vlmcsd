; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\Dell\Desktop\vlmcsd\src\crypto.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_AesKeyV4
PUBLIC	_AesKeyV6
PUBLIC	_AesKeyV5
_AesKeyV4 DB	05H
	DB	03dH
	DB	083H
	DB	07H
	DB	0f9H
	DB	0e5H
	DB	0f0H
	DB	088H
	DB	0ebH
	DB	05eH
	DB	0a6H
	DB	068H
	DB	06cH
	DB	0f0H
	DB	037H
	DB	0c7H
	DB	0e4H
	DB	0efH
	DB	0d2H
	DB	0d6H
_SBox	DB	063H
	DB	07cH
	DB	077H
	DB	07bH
	DB	0f2H
	DB	06bH
	DB	06fH
	DB	0c5H
	DB	030H
	DB	01H
	DB	067H
	DB	02bH
	DB	0feH
	DB	0d7H
	DB	0abH
	DB	076H
	DB	0caH
	DB	082H
	DB	0c9H
	DB	07dH
	DB	0faH
	DB	059H
	DB	047H
	DB	0f0H
	DB	0adH
	DB	0d4H
	DB	0a2H
	DB	0afH
	DB	09cH
	DB	0a4H
	DB	072H
	DB	0c0H
	DB	0b7H
	DB	0fdH
	DB	093H
	DB	026H
	DB	036H
	DB	03fH
	DB	0f7H
	DB	0ccH
	DB	034H
	DB	0a5H
	DB	0e5H
	DB	0f1H
	DB	071H
	DB	0d8H
	DB	031H
	DB	015H
	DB	04H
	DB	0c7H
	DB	023H
	DB	0c3H
	DB	018H
	DB	096H
	DB	05H
	DB	09aH
	DB	07H
	DB	012H
	DB	080H
	DB	0e2H
	DB	0ebH
	DB	027H
	DB	0b2H
	DB	075H
	DB	09H
	DB	083H
	DB	02cH
	DB	01aH
	DB	01bH
	DB	06eH
	DB	05aH
	DB	0a0H
	DB	052H
	DB	03bH
	DB	0d6H
	DB	0b3H
	DB	029H
	DB	0e3H
	DB	02fH
	DB	084H
	DB	053H
	DB	0d1H
	DB	00H
	DB	0edH
	DB	020H
	DB	0fcH
	DB	0b1H
	DB	05bH
	DB	06aH
	DB	0cbH
	DB	0beH
	DB	039H
	DB	04aH
	DB	04cH
	DB	058H
	DB	0cfH
	DB	0d0H
	DB	0efH
	DB	0aaH
	DB	0fbH
	DB	043H
	DB	04dH
	DB	033H
	DB	085H
	DB	045H
	DB	0f9H
	DB	02H
	DB	07fH
	DB	050H
	DB	03cH
	DB	09fH
	DB	0a8H
	DB	051H
	DB	0a3H
	DB	040H
	DB	08fH
	DB	092H
	DB	09dH
	DB	038H
	DB	0f5H
	DB	0bcH
	DB	0b6H
	DB	0daH
	DB	021H
	DB	010H
	DB	0ffH
	DB	0f3H
	DB	0d2H
	DB	0cdH
	DB	0cH
	DB	013H
	DB	0ecH
	DB	05fH
	DB	097H
	DB	044H
	DB	017H
	DB	0c4H
	DB	0a7H
	DB	07eH
	DB	03dH
	DB	064H
	DB	05dH
	DB	019H
	DB	073H
	DB	060H
	DB	081H
	DB	04fH
	DB	0dcH
	DB	022H
	DB	02aH
	DB	090H
	DB	088H
	DB	046H
	DB	0eeH
	DB	0b8H
	DB	014H
	DB	0deH
	DB	05eH
	DB	0bH
	DB	0dbH
	DB	0e0H
	DB	032H
	DB	03aH
	DB	0aH
	DB	049H
	DB	06H
	DB	024H
	DB	05cH
	DB	0c2H
	DB	0d3H
	DB	0acH
	DB	062H
	DB	091H
	DB	095H
	DB	0e4H
	DB	079H
	DB	0e7H
	DB	0c8H
	DB	037H
	DB	06dH
	DB	08dH
	DB	0d5H
	DB	04eH
	DB	0a9H
	DB	06cH
	DB	056H
	DB	0f4H
	DB	0eaH
	DB	065H
	DB	07aH
	DB	0aeH
	DB	08H
	DB	0baH
	DB	078H
	DB	025H
	DB	02eH
	DB	01cH
	DB	0a6H
	DB	0b4H
	DB	0c6H
	DB	0e8H
	DB	0ddH
	DB	074H
	DB	01fH
	DB	04bH
	DB	0bdH
	DB	08bH
	DB	08aH
	DB	070H
	DB	03eH
	DB	0b5H
	DB	066H
	DB	048H
	DB	03H
	DB	0f6H
	DB	0eH
	DB	061H
	DB	035H
	DB	057H
	DB	0b9H
	DB	086H
	DB	0c1H
	DB	01dH
	DB	09eH
	DB	0e1H
	DB	0f8H
	DB	098H
	DB	011H
	DB	069H
	DB	0d9H
	DB	08eH
	DB	094H
	DB	09bH
	DB	01eH
	DB	087H
	DB	0e9H
	DB	0ceH
	DB	055H
	DB	028H
	DB	0dfH
	DB	08cH
	DB	0a1H
	DB	089H
	DB	0dH
	DB	0bfH
	DB	0e6H
	DB	042H
	DB	068H
	DB	041H
	DB	099H
	DB	02dH
	DB	0fH
	DB	0b0H
	DB	054H
	DB	0bbH
	DB	016H
_AesKeyV6 DB	0a9H
	DB	04aH
	DB	041H
	DB	095H
	DB	0e2H
	DB	01H
	DB	043H
	DB	02dH
	DB	09bH
	DB	0cbH
	DB	046H
	DB	04H
	DB	05H
	DB	0d8H
	DB	04aH
	DB	021H
_AesKeyV5 DB	0cdH
	DB	07eH
	DB	079H
	DB	06fH
	DB	02aH
	DB	0b2H
	DB	05dH
	DB	0cbH
	DB	055H
	DB	0ffH
	DB	0c8H
	DB	0efH
	DB	083H
	DB	064H
	DB	0c4H
	DB	070H
?RCon@?1??AesInitKey@@9@9 DD 00H			; `AesInitKey'::`2'::RCon
	DD	01000000H
	DD	02000000H
	DD	04000000H
	DD	08000000H
	DD	010000000H
	DD	020000000H
	DD	040000000H
	DD	080000000H
	DD	01b000000H
	DD	036000000H
_SBoxR	DB	052H
	DB	09H
	DB	06aH
	DB	0d5H
	DB	030H
	DB	036H
	DB	0a5H
	DB	038H
	DB	0bfH
	DB	040H
	DB	0a3H
	DB	09eH
	DB	081H
	DB	0f3H
	DB	0d7H
	DB	0fbH
	DB	07cH
	DB	0e3H
	DB	039H
	DB	082H
	DB	09bH
	DB	02fH
	DB	0ffH
	DB	087H
	DB	034H
	DB	08eH
	DB	043H
	DB	044H
	DB	0c4H
	DB	0deH
	DB	0e9H
	DB	0cbH
	DB	054H
	DB	07bH
	DB	094H
	DB	032H
	DB	0a6H
	DB	0c2H
	DB	023H
	DB	03dH
	DB	0eeH
	DB	04cH
	DB	095H
	DB	0bH
	DB	042H
	DB	0faH
	DB	0c3H
	DB	04eH
	DB	08H
	DB	02eH
	DB	0a1H
	DB	066H
	DB	028H
	DB	0d9H
	DB	024H
	DB	0b2H
	DB	076H
	DB	05bH
	DB	0a2H
	DB	049H
	DB	06dH
	DB	08bH
	DB	0d1H
	DB	025H
	DB	072H
	DB	0f8H
	DB	0f6H
	DB	064H
	DB	086H
	DB	068H
	DB	098H
	DB	016H
	DB	0d4H
	DB	0a4H
	DB	05cH
	DB	0ccH
	DB	05dH
	DB	065H
	DB	0b6H
	DB	092H
	DB	06cH
	DB	070H
	DB	048H
	DB	050H
	DB	0fdH
	DB	0edH
	DB	0b9H
	DB	0daH
	DB	05eH
	DB	015H
	DB	046H
	DB	057H
	DB	0a7H
	DB	08dH
	DB	09dH
	DB	084H
	DB	090H
	DB	0d8H
	DB	0abH
	DB	00H
	DB	08cH
	DB	0bcH
	DB	0d3H
	DB	0aH
	DB	0f7H
	DB	0e4H
	DB	058H
	DB	05H
	DB	0b8H
	DB	0b3H
	DB	045H
	DB	06H
	DB	0d0H
	DB	02cH
	DB	01eH
	DB	08fH
	DB	0caH
	DB	03fH
	DB	0fH
	DB	02H
	DB	0c1H
	DB	0afH
	DB	0bdH
	DB	03H
	DB	01H
	DB	013H
	DB	08aH
	DB	06bH
	DB	03aH
	DB	091H
	DB	011H
	DB	041H
	DB	04fH
	DB	067H
	DB	0dcH
	DB	0eaH
	DB	097H
	DB	0f2H
	DB	0cfH
	DB	0ceH
	DB	0f0H
	DB	0b4H
	DB	0e6H
	DB	073H
	DB	096H
	DB	0acH
	DB	074H
	DB	022H
	DB	0e7H
	DB	0adH
	DB	035H
	DB	085H
	DB	0e2H
	DB	0f9H
	DB	037H
	DB	0e8H
	DB	01cH
	DB	075H
	DB	0dfH
	DB	06eH
	DB	047H
	DB	0f1H
	DB	01aH
	DB	071H
	DB	01dH
	DB	029H
	DB	0c5H
	DB	089H
	DB	06fH
	DB	0b7H
	DB	062H
	DB	0eH
	DB	0aaH
	DB	018H
	DB	0beH
	DB	01bH
	DB	0fcH
	DB	056H
	DB	03eH
	DB	04bH
	DB	0c6H
	DB	0d2H
	DB	079H
	DB	020H
	DB	09aH
	DB	0dbH
	DB	0c0H
	DB	0feH
	DB	078H
	DB	0cdH
	DB	05aH
	DB	0f4H
	DB	01fH
	DB	0ddH
	DB	0a8H
	DB	033H
	DB	088H
	DB	07H
	DB	0c7H
	DB	031H
	DB	0b1H
	DB	012H
	DB	010H
	DB	059H
	DB	027H
	DB	080H
	DB	0ecH
	DB	05fH
	DB	060H
	DB	051H
	DB	07fH
	DB	0a9H
	DB	019H
	DB	0b5H
	DB	04aH
	DB	0dH
	DB	02dH
	DB	0e5H
	DB	07aH
	DB	09fH
	DB	093H
	DB	0c9H
	DB	09cH
	DB	0efH
	DB	0a0H
	DB	0e0H
	DB	03bH
	DB	04dH
	DB	0aeH
	DB	02aH
	DB	0f5H
	DB	0b0H
	DB	0c8H
	DB	0ebH
	DB	0bbH
	DB	03cH
	DB	083H
	DB	053H
	DB	099H
	DB	061H
	DB	017H
	DB	02bH
	DB	04H
	DB	07eH
	DB	0baH
	DB	077H
	DB	0d6H
	DB	026H
	DB	0e1H
	DB	069H
	DB	014H
	DB	063H
	DB	055H
	DB	021H
	DB	0cH
	DB	07dH
PUBLIC	_AesDecryptCbc
PUBLIC	_AesDecryptBlock
PUBLIC	_AesEncryptCbc
PUBLIC	_AesCmacV4
PUBLIC	_AesEncryptBlock
PUBLIC	_AesInitKey
PUBLIC	_MixColumnsR
PUBLIC	_XorBlock
EXTRN	__allmul:PROC
EXTRN	__alloca_probe:PROC
EXTRN	__alloca_probe_16:PROC
EXTRN	__allrem:PROC
EXTRN	__aulldiv:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _XorBlock
_TEXT	SEGMENT
_XorBlock PROC						; COMDAT
; _in$ = ecx
; _out$ = edx

; 40   : {

  00000	56		 push	 esi

; 41   : 	/*UAA64( out, 0 ) ^= UAA64( in, 0 );
; 42   : 	UAA64( out, 1 ) ^= UAA64( in, 1 );*/
; 43   : 
; 44   : 	uint_fast8_t i;
; 45   : 
; 46   : 	for (i = 0; i < AES_BLOCK_WORDS; i++)

  00001	6a 04		 push	 4
  00003	2b ca		 sub	 ecx, edx
  00005	5e		 pop	 esi
$LL3@XorBlock:

; 47   : 	{
; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  00006	8b 04 11	 mov	 eax, DWORD PTR [ecx+edx]
  00009	31 02		 xor	 DWORD PTR [edx], eax
  0000b	8d 52 04	 lea	 edx, DWORD PTR [edx+4]
  0000e	4e		 dec	 esi
  0000f	75 f5		 jne	 SHORT $LL3@XorBlock
  00011	5e		 pop	 esi

; 49   : 	}
; 50   : }

  00012	c3		 ret	 0
_XorBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _MixColumnsR
_TEXT	SEGMENT
_state$1$ = -52						; size = 4
tv777 = -48						; size = 4
tv776 = -44						; size = 4
tv782 = -40						; size = 4
tv792 = -36						; size = 4
tv784 = -32						; size = 4
tv790 = -28						; size = 4
tv794 = -24						; size = 4
tv791 = -20						; size = 4
tv793 = -16						; size = 4
tv797 = -12						; size = 4
tv783 = -8						; size = 4
tv779 = -4						; size = 4
_MixColumnsR PROC					; COMDAT
; _state$ = ecx

; 80   : {

  00000	83 ec 34	 sub	 esp, 52			; 00000034H
  00003	53		 push	 ebx
  00004	55		 push	 ebp
  00005	56		 push	 esi
  00006	57		 push	 edi
  00007	8b c1		 mov	 eax, ecx
  00009	89 4c 24 10	 mov	 DWORD PTR _state$1$[esp+68], ecx

; 81   : 	uint_fast8_t i = 0;

  0000d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR tv792[esp+68], 4
  00015	bd 01 01 01 01	 mov	 ebp, 16843009		; 01010101H
$LL3@MixColumns:

; 82   : 	for (; i < AES_BLOCK_WORDS; i++)
; 83   : 	{
; 84   : 		#if defined(_CRYPTO_OPENSSL) && defined(_OPENSSL_SOFTWARE) && defined(_USE_AES_FROM_OPENSSL) //Always byte swap regardless of endianess
; 85   : 			DWORD word = BS32(((DWORD *) state)[i]);
; 86   : 			((DWORD *) state)[i] = BS32(MulE(word) ^ ROR32(MulB(word), 8) ^ ROR32(MulD(word), 16) ^ ROR32(Mul9(word), 24));
; 87   : 		#else
; 88   : 			DWORD word = LE32(((DWORD *) state)[i]);

  0001a	8b 18		 mov	 ebx, DWORD PTR [eax]

; 89   : 			((DWORD *) state)[i] = LE32(MulE(word) ^ ROR32(MulB(word), 8) ^ ROR32(MulD(word), 16) ^ ROR32(Mul9(word), 24));

  0001c	8b cb		 mov	 ecx, ebx
  0001e	c1 e9 07	 shr	 ecx, 7
  00021	8b c1		 mov	 eax, ecx
  00023	23 c5		 and	 eax, ebp
  00025	6b d0 1b	 imul	 edx, eax, 27
  00028	89 44 24 3c	 mov	 DWORD PTR tv783[esp+68], eax
  0002c	8b c2		 mov	 eax, edx
  0002e	89 54 24 14	 mov	 DWORD PTR tv777[esp+68], edx
  00032	d1 e8		 shr	 eax, 1
  00034	33 c3		 xor	 eax, ebx
  00036	c1 e8 06	 shr	 eax, 6
  00039	23 c5		 and	 eax, ebp
  0003b	89 44 24 40	 mov	 DWORD PTR tv779[esp+68], eax
  0003f	6b c0 1b	 imul	 eax, eax, 27
  00042	89 44 24 1c	 mov	 DWORD PTR tv782[esp+68], eax
  00046	d1 e8		 shr	 eax, 1
  00048	89 44 24 38	 mov	 DWORD PTR tv797[esp+68], eax
  0004c	33 c2		 xor	 eax, edx
  0004e	d1 e8		 shr	 eax, 1
  00050	8b d1		 mov	 edx, ecx
  00052	33 c3		 xor	 eax, ebx
  00054	81 e2 01 01 00
	00		 and	 edx, 257		; 00000101H
  0005a	c1 e8 05	 shr	 eax, 5
  0005d	23 c5		 and	 eax, ebp
  0005f	6b f2 1b	 imul	 esi, edx, 27
  00062	6b c0 1b	 imul	 eax, eax, 27
  00065	bd 01 01 01 00	 mov	 ebp, 65793		; 00010101H
  0006a	8b fe		 mov	 edi, esi
  0006c	89 44 24 24	 mov	 DWORD PTR tv784[esp+68], eax
  00070	8b c1		 mov	 eax, ecx
  00072	23 c5		 and	 eax, ebp
  00074	d1 ef		 shr	 edi, 1
  00076	89 44 24 2c	 mov	 DWORD PTR tv794[esp+68], eax
  0007a	83 e1 01	 and	 ecx, 1
  0007d	6b c0 1b	 imul	 eax, eax, 27
  00080	33 fb		 xor	 edi, ebx
  00082	89 4c 24 28	 mov	 DWORD PTR tv790[esp+68], ecx
  00086	c1 ef 06	 shr	 edi, 6
  00089	81 e7 01 01 00
	00		 and	 edi, 257		; 00000101H
  0008f	89 44 24 34	 mov	 DWORD PTR tv793[esp+68], eax
  00093	d1 e8		 shr	 eax, 1
  00095	33 c3		 xor	 eax, ebx
  00097	c1 e8 06	 shr	 eax, 6
  0009a	23 c5		 and	 eax, ebp
  0009c	6b e9 1b	 imul	 ebp, ecx, 27
  0009f	8b 4c 24 10	 mov	 ecx, DWORD PTR _state$1$[esp+68]
  000a3	89 44 24 30	 mov	 DWORD PTR tv791[esp+68], eax
  000a7	8b 01		 mov	 eax, DWORD PTR [ecx]
  000a9	8b dd		 mov	 ebx, ebp
  000ab	8b c8		 mov	 ecx, eax
  000ad	d1 eb		 shr	 ebx, 1
  000af	33 d8		 xor	 ebx, eax
  000b1	81 e1 1f ff ff
	ff		 and	 ecx, -225		; ffffff1fH
  000b7	03 c9		 add	 ecx, ecx
  000b9	c1 eb 06	 shr	 ebx, 6
  000bc	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  000c1	83 e3 01	 and	 ebx, 1
  000c4	33 c8		 xor	 ecx, eax
  000c6	8b 44 24 10	 mov	 eax, DWORD PTR _state$1$[esp+68]
  000ca	c1 e1 02	 shl	 ecx, 2
  000cd	33 08		 xor	 ecx, DWORD PTR [eax]
  000cf	c1 e1 10	 shl	 ecx, 16			; 00000010H
  000d2	89 4c 24 18	 mov	 DWORD PTR tv776[esp+68], ecx
  000d6	69 ca 00 00 6c
	00		 imul	 ecx, edx, 7077888
  000dc	69 c7 00 00 36
	00		 imul	 eax, edi, 3538944
  000e2	81 e1 ff ff fd
	fd		 and	 ecx, -33685505		; fdfdffffH
  000e8	33 c8		 xor	 ecx, eax
  000ea	69 c2 00 00 36
	00		 imul	 eax, edx, 3538944
  000f0	33 c8		 xor	 ecx, eax
  000f2	6b c7 1b	 imul	 eax, edi, 27
  000f5	81 e1 00 00 fe
	fe		 and	 ecx, -16908288		; fefe0000H
  000fb	31 4c 24 18	 xor	 DWORD PTR tv776[esp+68], ecx
  000ff	8b 4c 24 10	 mov	 ecx, DWORD PTR _state$1$[esp+68]
  00103	d1 e8		 shr	 eax, 1
  00105	33 c6		 xor	 eax, esi
  00107	8b 11		 mov	 edx, DWORD PTR [ecx]
  00109	d1 e8		 shr	 eax, 1
  0010b	33 c2		 xor	 eax, edx
  0010d	c1 e8 05	 shr	 eax, 5
  00110	25 01 01 00 00	 and	 eax, 257		; 00000101H
  00115	69 c0 00 00 1b
	00		 imul	 eax, eax, 1769472
  0011b	8b 74 24 18	 mov	 esi, DWORD PTR tv776[esp+68]
  0011f	33 f0		 xor	 esi, eax
  00121	69 c7 00 00 1b
	00		 imul	 eax, edi, 1769472
  00127	8b 7c 24 24	 mov	 edi, DWORD PTR tv784[esp+68]
  0012b	8b cf		 mov	 ecx, edi
  0012d	33 f0		 xor	 esi, eax
  0012f	8b 44 24 1c	 mov	 eax, DWORD PTR tv782[esp+68]
  00133	33 c8		 xor	 ecx, eax
  00135	33 44 24 14	 xor	 eax, DWORD PTR tv777[esp+68]
  00139	25 00 00 7f 7f	 and	 eax, 2139029504		; 7f7f0000H
  0013e	33 ca		 xor	 ecx, edx
  00140	d1 e9		 shr	 ecx, 1
  00142	33 c8		 xor	 ecx, eax
  00144	8b 44 24 14	 mov	 eax, DWORD PTR tv777[esp+68]
  00148	33 c2		 xor	 eax, edx
  0014a	d1 e9		 shr	 ecx, 1
  0014c	25 00 00 3f 3f	 and	 eax, 1061093376		; 3f3f0000H
  00151	33 c8		 xor	 ecx, eax
  00153	8b c2		 mov	 eax, edx
  00155	69 54 24 28 00
	00 00 6c	 imul	 edx, DWORD PTR tv790[esp+68], 1811939328
  0015d	25 00 00 1f 1f	 and	 eax, 522125312		; 1f1f0000H
  00162	d1 e9		 shr	 ecx, 1
  00164	33 c8		 xor	 ecx, eax
  00166	69 c3 00 00 00
	36		 imul	 eax, ebx, 905969664
  0016c	c1 e9 0d	 shr	 ecx, 13			; 0000000dH
  0016f	0b f1		 or	 esi, ecx
  00171	8b cf		 mov	 ecx, edi
  00173	81 e2 ff ff ff
	fd		 and	 edx, -33554433		; fdffffffH
  00179	33 4c 24 14	 xor	 ecx, DWORD PTR tv777[esp+68]
  0017d	33 d0		 xor	 edx, eax
  0017f	8b 44 24 10	 mov	 eax, DWORD PTR _state$1$[esp+68]
  00183	8b 00		 mov	 eax, DWORD PTR [eax]
  00185	c1 e0 19	 shl	 eax, 25			; 00000019H
  00188	33 d0		 xor	 edx, eax
  0018a	6b c3 1b	 imul	 eax, ebx, 27
  0018d	8b 5c 24 10	 mov	 ebx, DWORD PTR _state$1$[esp+68]
  00191	81 e2 00 00 00
	fe		 and	 edx, -33554432		; fe000000H
  00197	d1 e8		 shr	 eax, 1
  00199	33 c5		 xor	 eax, ebp
  0019b	8b 2b		 mov	 ebp, DWORD PTR [ebx]
  0019d	d1 e8		 shr	 eax, 1
  0019f	33 cd		 xor	 ecx, ebp
  001a1	33 c5		 xor	 eax, ebp
  001a3	d1 e9		 shr	 ecx, 1
  001a5	c1 e8 05	 shr	 eax, 5
  001a8	83 e0 01	 and	 eax, 1
  001ab	69 c0 00 00 00
	1b		 imul	 eax, eax, 452984832
  001b1	33 d0		 xor	 edx, eax
  001b3	8b c5		 mov	 eax, ebp
  001b5	c1 e0 03	 shl	 eax, 3
  001b8	33 c5		 xor	 eax, ebp
  001ba	c1 e0 18	 shl	 eax, 24			; 00000018H
  001bd	33 d0		 xor	 edx, eax
  001bf	69 44 24 28 00
	00 00 1b	 imul	 eax, DWORD PTR tv790[esp+68], 452984832
  001c7	33 d0		 xor	 edx, eax
  001c9	8b 44 24 1c	 mov	 eax, DWORD PTR tv782[esp+68]
  001cd	33 c5		 xor	 eax, ebp
  001cf	25 00 7f 7f 7f	 and	 eax, 2139062016		; 7f7f7f00H
  001d4	33 c8		 xor	 ecx, eax
  001d6	8b 44 24 14	 mov	 eax, DWORD PTR tv777[esp+68]
  001da	25 00 3f 3f 3f	 and	 eax, 1061109504		; 3f3f3f00H
  001df	d1 e9		 shr	 ecx, 1
  001e1	33 c8		 xor	 ecx, eax
  001e3	8b c5		 mov	 eax, ebp
  001e5	25 00 1f 1f 1f	 and	 eax, 522133248		; 1f1f1f00H
  001ea	d1 e9		 shr	 ecx, 1
  001ec	33 c8		 xor	 ecx, eax
  001ee	69 44 24 30 00
	36 00 00	 imul	 eax, DWORD PTR tv791[esp+68], 13824
  001f6	c1 e9 05	 shr	 ecx, 5
  001f9	0b d1		 or	 edx, ecx
  001fb	33 f2		 xor	 esi, edx
  001fd	69 54 24 2c 00
	6c 00 00	 imul	 edx, DWORD PTR tv794[esp+68], 27648
  00205	81 e2 ff fd fd
	fd		 and	 edx, -33686017		; fdfdfdffH
  0020b	33 d0		 xor	 edx, eax
  0020d	6b 44 24 30 1b	 imul	 eax, DWORD PTR tv791[esp+68], 27
  00212	81 e2 00 fe fe
	fe		 and	 edx, -16843264		; fefefe00H
  00218	d1 e8		 shr	 eax, 1
  0021a	33 44 24 34	 xor	 eax, DWORD PTR tv793[esp+68]
  0021e	d1 e8		 shr	 eax, 1
  00220	33 c5		 xor	 eax, ebp
  00222	c1 e8 05	 shr	 eax, 5
  00225	25 01 01 01 00	 and	 eax, 65793		; 00010101H
  0022a	8b 4c 24 14	 mov	 ecx, DWORD PTR tv777[esp+68]
  0022e	69 c0 00 1b 00
	00		 imul	 eax, eax, 6912
  00234	81 e1 ff ff 7f
	ff		 and	 ecx, -8388609		; ff7fffffH
  0023a	33 4c 24 38	 xor	 ecx, DWORD PTR tv797[esp+68]
  0023e	81 e1 00 00 80
	3f		 and	 ecx, 1065353216		; 3f800000H
  00244	33 d0		 xor	 edx, eax
  00246	8b c5		 mov	 eax, ebp
  00248	25 1f 1f ff ff	 and	 eax, -57569		; ffff1f1fH
  0024d	c1 e0 03	 shl	 eax, 3
  00250	33 c5		 xor	 eax, ebp
  00252	c1 e0 08	 shl	 eax, 8
  00255	33 d0		 xor	 edx, eax
  00257	8b c7		 mov	 eax, edi
  00259	33 c5		 xor	 eax, ebp
  0025b	c1 e8 02	 shr	 eax, 2
  0025e	33 c8		 xor	 ecx, eax
  00260	8b c5		 mov	 eax, ebp
  00262	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  00267	d1 e9		 shr	 ecx, 1
  00269	33 c8		 xor	 ecx, eax
  0026b	6b 44 24 40 36	 imul	 eax, DWORD PTR tv779[esp+68], 54
  00270	c1 e9 15	 shr	 ecx, 21			; 00000015H
  00273	0b d1		 or	 edx, ecx
  00275	6b 4c 24 3c 6c	 imul	 ecx, DWORD PTR tv783[esp+68], 108
  0027a	33 f2		 xor	 esi, edx
  0027c	81 e1 fd fd fd
	fd		 and	 ecx, -33686019		; fdfdfdfdH
  00282	33 c8		 xor	 ecx, eax
  00284	6b 44 24 3c 36	 imul	 eax, DWORD PTR tv783[esp+68], 54
  00289	33 c8		 xor	 ecx, eax
  0028b	8d 04 6d 00 00
	00 00		 lea	 eax, DWORD PTR [ebp*2]
  00292	33 c8		 xor	 ecx, eax
  00294	8b c5		 mov	 eax, ebp
  00296	25 1f 1f 1f ff	 and	 eax, -14737633		; ff1f1f1fH
  0029b	81 e5 3f 3f 3f
	ff		 and	 ebp, -12632257		; ff3f3f3fH
  002a1	03 c0		 add	 eax, eax
  002a3	81 e1 fe fe fe
	fe		 and	 ecx, -16843010		; fefefefeH
  002a9	33 c5		 xor	 eax, ebp
  002ab	33 f1		 xor	 esi, ecx
  002ad	c1 e0 02	 shl	 eax, 2
  002b0	bd 01 01 01 01	 mov	 ebp, 16843009		; 01010101H
  002b5	33 f0		 xor	 esi, eax
  002b7	8b c3		 mov	 eax, ebx
  002b9	33 f7		 xor	 esi, edi
  002bb	33 74 24 1c	 xor	 esi, DWORD PTR tv782[esp+68]
  002bf	33 74 24 14	 xor	 esi, DWORD PTR tv777[esp+68]
  002c3	89 30		 mov	 DWORD PTR [eax], esi
  002c5	83 c0 04	 add	 eax, 4
  002c8	ff 4c 24 20	 dec	 DWORD PTR tv792[esp+68]
  002cc	89 44 24 10	 mov	 DWORD PTR _state$1$[esp+68], eax
  002d0	0f 85 44 fd ff
	ff		 jne	 $LL3@MixColumns
  002d6	5f		 pop	 edi
  002d7	5e		 pop	 esi
  002d8	5d		 pop	 ebp
  002d9	5b		 pop	 ebx

; 90   : 		#endif
; 91   : 	}
; 92   : }

  002da	83 c4 34	 add	 esp, 52			; 00000034H
  002dd	c3		 ret	 0
_MixColumnsR ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _SubDword
_TEXT	SEGMENT
_v$ = -4						; size = 4
_SubDword PROC						; COMDAT
; _v$ = ecx

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 97   : 	BYTE *b = (BYTE *)&v;
; 98   : 	uint_fast8_t i = 0;

  00004	6a 04		 push	 4
  00006	89 4d fc	 mov	 DWORD PTR _v$[ebp], ecx
  00009	8d 4d fc	 lea	 ecx, DWORD PTR _v$[ebp]
  0000c	5a		 pop	 edx
$LL3@SubDword:

; 99   : 
; 100  : 	for (; i < sizeof(DWORD); i++) b[i] = SBox[b[i]];

  0000d	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00010	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _SBox[eax]
  00016	88 01		 mov	 BYTE PTR [ecx], al
  00018	41		 inc	 ecx
  00019	4a		 dec	 edx
  0001a	75 f1		 jne	 SHORT $LL3@SubDword

; 101  : 
; 102  : 	return v;

  0001c	8b 45 fc	 mov	 eax, DWORD PTR _v$[ebp]

; 103  : }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
_SubDword ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _AesInitKey
_TEXT	SEGMENT
_v$ = -8						; size = 4
tv359 = -4						; size = 4
_IsV6$ = 8						; size = 1
_i$1$ = 12						; size = 1
_RijndaelKeyBytes$ = 12					; size = 4
_AesInitKey PROC					; COMDAT
; _Ctx$ = ecx
; _Key$ = edx

; 107  : {

  00000	51		 push	 ecx
  00001	51		 push	 ecx
  00002	53		 push	 ebx

; 108  : 	int RijndaelKeyDwords = RijndaelKeyBytes / sizeof(DWORD);

  00003	8b 5c 24 14	 mov	 ebx, DWORD PTR _RijndaelKeyBytes$[esp+8]
  00007	56		 push	 esi
  00008	57		 push	 edi

; 109  : 	Ctx->rounds = (uint_fast8_t)(RijndaelKeyDwords + 6);
; 110  : 
; 111  : 	static const DWORD RCon[] = {
; 112  : 		0x00000000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,
; 113  : 		0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000 };
; 114  : 
; 115  : 	uint_fast8_t  i;
; 116  : 	DWORD  temp;
; 117  : 
; 118  : 	memcpy(Ctx->Key, Key, RijndaelKeyBytes);

  00009	ff 74 24 1c	 push	 DWORD PTR _RijndaelKeyBytes$[esp+16]
  0000d	8b f1		 mov	 esi, ecx
  0000f	c1 eb 02	 shr	 ebx, 2
  00012	52		 push	 edx
  00013	56		 push	 esi
  00014	8d 43 06	 lea	 eax, DWORD PTR [ebx+6]
  00017	88 86 c0 00 00
	00		 mov	 BYTE PTR [esi+192], al
  0001d	e8 00 00 00 00	 call	 _memcpy

; 119  : 
; 120  : 	for ( i = (uint_fast8_t)RijndaelKeyDwords; i < ( Ctx->rounds + 1 ) << 2; i++ )

  00022	0f b6 86 c0 00
	00 00		 movzx	 eax, BYTE PTR [esi+192]
  00029	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002c	0f b6 fb	 movzx	 edi, bl
  0002f	88 5c 24 1c	 mov	 BYTE PTR _i$1$[esp+16], bl
  00033	8d 04 85 04 00
	00 00		 lea	 eax, DWORD PTR [eax*4+4]
  0003a	3b f8		 cmp	 edi, eax
  0003c	7d 6e		 jge	 SHORT $LN3@AesInitKey
  0003e	55		 push	 ebp
$LL5@AesInitKey:

; 121  : 	{
; 122  : 		temp = Ctx->Key[ i - 1 ];
; 123  : 
; 124  : 		if ( ( i % RijndaelKeyDwords ) == 0 )

  0003f	8b c7		 mov	 eax, edi
  00041	8d 2c be	 lea	 ebp, DWORD PTR [esi+edi*4]
  00044	99		 cdq
  00045	f7 fb		 idiv	 ebx
  00047	8b 4d fc	 mov	 ecx, DWORD PTR [ebp-4]
  0004a	89 44 24 14	 mov	 DWORD PTR tv359[esp+24], eax
  0004e	85 d2		 test	 edx, edx
  00050	75 30		 jne	 SHORT $LN2@AesInitKey

; 125  : 			temp = BE32( SubDword( ROR32( BE32(temp), 24)  ) ^ RCon[ i / RijndaelKeyDwords ] );

  00052	0f c9		 bswap	 ecx
  00054	c1 c1 08	 rol	 ecx, 8
  00057	6a 04		 push	 4
  00059	89 4c 24 14	 mov	 DWORD PTR _v$[esp+28], ecx
  0005d	8d 4c 24 14	 lea	 ecx, DWORD PTR _v$[esp+28]
  00061	5a		 pop	 edx
$LL10@AesInitKey:
  00062	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00065	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _SBox[eax]
  0006b	88 01		 mov	 BYTE PTR [ecx], al
  0006d	41		 inc	 ecx
  0006e	4a		 dec	 edx
  0006f	75 f1		 jne	 SHORT $LL10@AesInitKey
  00071	8b 4c 24 14	 mov	 ecx, DWORD PTR tv359[esp+24]
  00075	8b 0c 8d 00 00
	00 00		 mov	 ecx, DWORD PTR ?RCon@?1??AesInitKey@@9@9[ecx*4]
  0007c	33 4c 24 10	 xor	 ecx, DWORD PTR _v$[esp+24]
  00080	0f c9		 bswap	 ecx
$LN2@AesInitKey:

; 126  : 
; 127  : 		Ctx->Key[ i ] = Ctx->Key[ i - RijndaelKeyDwords ] ^ temp;

  00082	2b fb		 sub	 edi, ebx
  00084	8b 04 be	 mov	 eax, DWORD PTR [esi+edi*4]
  00087	33 c1		 xor	 eax, ecx
  00089	89 45 00	 mov	 DWORD PTR [ebp], eax
  0008c	8a 44 24 20	 mov	 al, BYTE PTR _i$1$[esp+20]
  00090	fe c0		 inc	 al
  00092	0f b6 f8	 movzx	 edi, al
  00095	88 44 24 20	 mov	 BYTE PTR _i$1$[esp+20], al
  00099	0f b6 86 c0 00
	00 00		 movzx	 eax, BYTE PTR [esi+192]
  000a0	8d 04 85 04 00
	00 00		 lea	 eax, DWORD PTR [eax*4+4]
  000a7	3b f8		 cmp	 edi, eax
  000a9	7c 94		 jl	 SHORT $LL5@AesInitKey
  000ab	5d		 pop	 ebp
$LN3@AesInitKey:

; 128  : 	}
; 129  : 
; 130  : 	if ( IsV6 )

  000ac	80 7c 24 18 00	 cmp	 BYTE PTR _IsV6$[esp+16], 0
  000b1	74 0f		 je	 SHORT $LN1@AesInitKey

; 131  : 	{
; 132  : 		BYTE *_p = (BYTE *)Ctx->Key;
; 133  : 
; 134  : 		_p[ 4 * 16 ] ^= 0x73;

  000b3	80 76 40 73	 xor	 BYTE PTR [esi+64], 115	; 00000073H

; 135  : 		_p[ 6 * 16 ] ^= 0x09;

  000b7	80 76 60 09	 xor	 BYTE PTR [esi+96], 9

; 136  : 		_p[ 8 * 16 ] ^= 0xE4;

  000bb	80 b6 80 00 00
	00 e4		 xor	 BYTE PTR [esi+128], 228	; 000000e4H
$LN1@AesInitKey:
  000c2	5f		 pop	 edi
  000c3	5e		 pop	 esi
  000c4	5b		 pop	 ebx

; 137  : 	}
; 138  : }

  000c5	59		 pop	 ecx
  000c6	59		 pop	 ecx
  000c7	c3		 ret	 0
_AesInitKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _SubBytes
_TEXT	SEGMENT
_SubBytes PROC						; COMDAT
; _block$ = ecx

; 144  : 	uint_fast8_t i;
; 145  : 
; 146  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)

  00000	6a 10		 push	 16			; 00000010H
  00002	5a		 pop	 edx
$LL3@SubBytes:

; 147  : 		block[i] = SBox[ block[i] ];

  00003	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00006	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _SBox[eax]
  0000c	88 01		 mov	 BYTE PTR [ecx], al
  0000e	41		 inc	 ecx
  0000f	4a		 dec	 edx
  00010	75 f1		 jne	 SHORT $LL3@SubBytes

; 148  : }

  00012	c3		 ret	 0
_SubBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _ShiftRows
_TEXT	SEGMENT
_bIn$ = -16						; size = 16
_ShiftRows PROC						; COMDAT
; _state$ = ecx

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 153  : 	BYTE bIn[AES_BLOCK_BYTES];
; 154  : 	uint_fast8_t i;
; 155  : 
; 156  : 	memcpy(bIn, state, AES_BLOCK_BYTES);

  00006	33 d2		 xor	 edx, edx
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b f1		 mov	 esi, ecx
  0000c	8d 7d f0	 lea	 edi, DWORD PTR _bIn$[ebp]
  0000f	6a 10		 push	 16			; 00000010H
  00011	a5		 movsd
  00012	a5		 movsd
  00013	a5		 movsd
  00014	a5		 movsd
  00015	5e		 pop	 esi
$LL3@ShiftRows:

; 157  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)
; 158  : 	{
; 159  : 		state[i] = bIn[(i + ((i & 3) << 2)) & 0xf];

  00016	8b c2		 mov	 eax, edx
  00018	83 c2 05	 add	 edx, 5
  0001b	83 e0 0f	 and	 eax, 15			; 0000000fH
  0001e	8a 44 05 f0	 mov	 al, BYTE PTR _bIn$[ebp+eax]
  00022	88 01		 mov	 BYTE PTR [ecx], al
  00024	41		 inc	 ecx
  00025	4e		 dec	 esi
  00026	75 ee		 jne	 SHORT $LL3@ShiftRows
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi

; 160  : 	}
; 161  : };

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_ShiftRows ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _MixColumns
_TEXT	SEGMENT
_state$1$ = -8						; size = 4
tv214 = -4						; size = 4
_MixColumns PROC					; COMDAT
; _state$ = ecx

; 165  : {

  00000	51		 push	 ecx
  00001	51		 push	 ecx
  00002	53		 push	 ebx
  00003	55		 push	 ebp
  00004	56		 push	 esi
  00005	8b c1		 mov	 eax, ecx
  00007	89 4c 24 0c	 mov	 DWORD PTR _state$1$[esp+20], ecx

; 166  : 	uint_fast8_t i = 0;

  0000b	c7 44 24 10 04
	00 00 00	 mov	 DWORD PTR tv214[esp+20], 4
  00013	57		 push	 edi
$LL3@MixColumns:

; 167  : 	for (; i < AES_BLOCK_WORDS; i++)
; 168  : 	{
; 169  : 		DWORD word = LE32(((DWORD *) state)[i]);

  00014	8b 28		 mov	 ebp, DWORD PTR [eax]

; 170  : 		((DWORD *) state)[i] = LE32(Mul2(word) ^ ROR32(Mul3(word), 8) ^ ROR32(word, 16) ^ ROR32(word, 24));

  00016	8b f5		 mov	 esi, ebp
  00018	c1 ee 07	 shr	 esi, 7
  0001b	8b dd		 mov	 ebx, ebp
  0001d	8b c6		 mov	 eax, esi
  0001f	c1 c3 10	 rol	 ebx, 16			; 00000010H
  00022	25 01 01 01 01	 and	 eax, 16843009		; 01010101H
  00027	83 e6 01	 and	 esi, 1
  0002a	6b f8 1b	 imul	 edi, eax, 27
  0002d	8d 14 6d 00 00
	00 00		 lea	 edx, DWORD PTR [ebp*2]
  00034	8b c5		 mov	 eax, ebp
  00036	33 d5		 xor	 edx, ebp
  00038	c1 c0 08	 rol	 eax, 8
  0003b	33 d8		 xor	 ebx, eax
  0003d	c1 e2 18	 shl	 edx, 24			; 00000018H
  00040	69 c6 00 00 00
	1b		 imul	 eax, esi, 452984832
  00046	8b cf		 mov	 ecx, edi
  00048	33 cd		 xor	 ecx, ebp
  0004a	d1 e9		 shr	 ecx, 1
  0004c	33 d0		 xor	 edx, eax
  0004e	8b c5		 mov	 eax, ebp
  00050	25 00 7f 7f 7f	 and	 eax, 2139062016		; 7f7f7f00H
  00055	81 e5 7f 7f 7f
	ff		 and	 ebp, -8421505		; ff7f7f7fH
  0005b	33 c8		 xor	 ecx, eax
  0005d	03 ed		 add	 ebp, ebp
  0005f	8b 44 24 10	 mov	 eax, DWORD PTR _state$1$[esp+24]
  00063	c1 e9 07	 shr	 ecx, 7
  00066	0b d1		 or	 edx, ecx
  00068	33 da		 xor	 ebx, edx
  0006a	33 dd		 xor	 ebx, ebp
  0006c	33 df		 xor	 ebx, edi
  0006e	89 18		 mov	 DWORD PTR [eax], ebx
  00070	83 c0 04	 add	 eax, 4
  00073	ff 4c 24 14	 dec	 DWORD PTR tv214[esp+24]
  00077	89 44 24 10	 mov	 DWORD PTR _state$1$[esp+24], eax
  0007b	75 97		 jne	 SHORT $LL3@MixColumns
  0007d	5f		 pop	 edi
  0007e	5e		 pop	 esi
  0007f	5d		 pop	 ebp
  00080	5b		 pop	 ebx

; 171  : 	}
; 172  : }

  00081	59		 pop	 ecx
  00082	59		 pop	 ecx
  00083	c3		 ret	 0
_MixColumns ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _AesEncryptBlock
_TEXT	SEGMENT
_i$1$ = -21						; size = 1
tv295 = -20						; size = 4
_bIn$1 = -16						; size = 16
_AesEncryptBlock PROC					; COMDAT
; _Ctx$ = ecx
; _block$ = edx

; 176  : {

  00000	83 ec 18	 sub	 esp, 24			; 00000018H

; 177  : 	uint_fast8_t  i;
; 178  : 
; 179  : 	for ( i = 0 ;; i += 4 )

  00003	32 c0		 xor	 al, al
  00005	53		 push	 ebx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi
  00009	8b da		 mov	 ebx, edx
  0000b	8b e9		 mov	 ebp, ecx
$LN32@AesEncrypt:
  0000d	88 44 24 13	 mov	 BYTE PTR _i$1$[esp+40], al

; 180  : 	{
; 181  : 		AddRoundKey(block, &Ctx->Key[ i ]);

  00011	8b d3		 mov	 edx, ebx
  00013	0f b6 c0	 movzx	 eax, al
  00016	89 44 24 14	 mov	 DWORD PTR tv295[esp+40], eax
  0001a	8d 0c 85 00 00
	00 00		 lea	 ecx, DWORD PTR [eax*4]
  00021	03 cd		 add	 ecx, ebp
  00023	e8 00 00 00 00	 call	 _XorBlock
  00028	6a 10		 push	 16			; 00000010H
  0002a	8b cb		 mov	 ecx, ebx
  0002c	5a		 pop	 edx

; 182  : 		SubBytes(block);

$LL9@AesEncrypt:
  0002d	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00030	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _SBox[eax]
  00036	88 01		 mov	 BYTE PTR [ecx], al
  00038	41		 inc	 ecx
  00039	4a		 dec	 edx
  0003a	75 f1		 jne	 SHORT $LL9@AesEncrypt

; 183  : 		ShiftRows(block);

  0003c	8b f3		 mov	 esi, ebx
  0003e	8d 7c 24 18	 lea	 edi, DWORD PTR _bIn$1[esp+40]
  00042	6a 10		 push	 16			; 00000010H
  00044	8b cb		 mov	 ecx, ebx
  00046	a5		 movsd
  00047	a5		 movsd
  00048	a5		 movsd
  00049	a5		 movsd
  0004a	5e		 pop	 esi
$LL14@AesEncrypt:
  0004b	8b c2		 mov	 eax, edx
  0004d	83 c2 05	 add	 edx, 5
  00050	83 e0 0f	 and	 eax, 15			; 0000000fH
  00053	8a 44 04 18	 mov	 al, BYTE PTR _bIn$1[esp+eax+40]
  00057	88 01		 mov	 BYTE PTR [ecx], al
  00059	41		 inc	 ecx
  0005a	4e		 dec	 esi
  0005b	75 ee		 jne	 SHORT $LL14@AesEncrypt

; 184  : 
; 185  : 		if ( i >= ( Ctx->rounds - 1 ) << 2 ) break;

  0005d	0f b6 85 c0 00
	00 00		 movzx	 eax, BYTE PTR [ebp+192]
  00064	8d 04 85 fc ff
	ff ff		 lea	 eax, DWORD PTR [eax*4-4]
  0006b	39 44 24 14	 cmp	 DWORD PTR tv295[esp+40], eax
  0006f	7d 0f		 jge	 SHORT $LN21@AesEncrypt

; 186  : 
; 187  : 		MixColumns(block);

  00071	8b cb		 mov	 ecx, ebx
  00073	e8 00 00 00 00	 call	 _MixColumns
  00078	8a 44 24 13	 mov	 al, BYTE PTR _i$1$[esp+40]
  0007c	04 04		 add	 al, 4
  0007e	eb 8d		 jmp	 SHORT $LN32@AesEncrypt
$LN21@AesEncrypt:

; 188  : 	}
; 189  : 
; 190  : 	AddRoundKey(block, &Ctx->Key[ Ctx->rounds << 2 ]);

  00080	0f b6 8d c0 00
	00 00		 movzx	 ecx, BYTE PTR [ebp+192]
  00087	8b d3		 mov	 edx, ebx
  00089	5f		 pop	 edi
  0008a	c1 e1 04	 shl	 ecx, 4
  0008d	5e		 pop	 esi
  0008e	03 cd		 add	 ecx, ebp
  00090	5d		 pop	 ebp
  00091	5b		 pop	 ebx

; 191  : }

  00092	83 c4 18	 add	 esp, 24			; 00000018H

; 188  : 	}
; 189  : 
; 190  : 	AddRoundKey(block, &Ctx->Key[ Ctx->rounds << 2 ]);

  00095	e9 00 00 00 00	 jmp	 _XorBlock
_AesEncryptBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _AesCmacV4
_TEXT	SEGMENT
_mac$ = -212						; size = 16
_Ctx$ = -196						; size = 196
_MacOut$ = 8						; size = 4
_AesCmacV4 PROC						; COMDAT
; _Message$ = ecx
; _MessageSize$ = edx

; 195  : {

  00000	81 ec d4 00 00
	00		 sub	 esp, 212		; 000000d4H
  00006	53		 push	 ebx
  00007	55		 push	 ebp
  00008	56		 push	 esi
  00009	57		 push	 edi
  0000a	8b da		 mov	 ebx, edx
  0000c	8b e9		 mov	 ebp, ecx

; 196  :     size_t i;
; 197  :     BYTE mac[AES_BLOCK_BYTES];
; 198  :     AesCtx Ctx;
; 199  : 
; 200  :     AesInitKey(&Ctx, AesKeyV4, FALSE, V4_KEY_BYTES);

  0000e	6a 14		 push	 20			; 00000014H
  00010	33 f6		 xor	 esi, esi
  00012	8d 4c 24 24	 lea	 ecx, DWORD PTR _Ctx$[esp+232]
  00016	56		 push	 esi
  00017	ba 00 00 00 00	 mov	 edx, OFFSET _AesKeyV4
  0001c	e8 00 00 00 00	 call	 _AesInitKey

; 201  : 
; 202  :     memset(mac, 0, sizeof(mac));

  00021	33 c0		 xor	 eax, eax
  00023	8d 7c 24 18	 lea	 edi, DWORD PTR _mac$[esp+236]
  00027	ab		 stosd
  00028	59		 pop	 ecx
  00029	59		 pop	 ecx

; 203  :     memset(Message + MessageSize, 0, AES_BLOCK_BYTES);

  0002a	8d 0c 2b	 lea	 ecx, DWORD PTR [ebx+ebp]
  0002d	ab		 stosd
  0002e	ab		 stosd
  0002f	ab		 stosd
  00030	33 c0		 xor	 eax, eax
  00032	8b f9		 mov	 edi, ecx
  00034	ab		 stosd
  00035	ab		 stosd
  00036	ab		 stosd
  00037	ab		 stosd

; 204  :     Message[MessageSize] = 0x80;

  00038	c6 01 80	 mov	 BYTE PTR [ecx], 128	; 00000080H
$LL3@AesCmacV4:

; 205  : 
; 206  :     for (i = 0; i <= MessageSize; i += AES_BLOCK_BYTES)
; 207  :     {
; 208  :         XorBlock(Message + i, mac);

  0003b	8d 0c 2e	 lea	 ecx, DWORD PTR [esi+ebp]
  0003e	8d 54 24 10	 lea	 edx, DWORD PTR _mac$[esp+228]
  00042	e8 00 00 00 00	 call	 _XorBlock

; 209  :         AesEncryptBlock(&Ctx, mac);

  00047	8d 54 24 10	 lea	 edx, DWORD PTR _mac$[esp+228]
  0004b	8d 4c 24 20	 lea	 ecx, DWORD PTR _Ctx$[esp+228]
  0004f	e8 00 00 00 00	 call	 _AesEncryptBlock
  00054	83 c6 10	 add	 esi, 16			; 00000010H
  00057	3b f3		 cmp	 esi, ebx
  00059	76 e0		 jbe	 SHORT $LL3@AesCmacV4

; 210  :     }
; 211  : 
; 212  :     memcpy(MacOut, mac, AES_BLOCK_BYTES);

  0005b	8b bc 24 e8 00
	00 00		 mov	 edi, DWORD PTR _MacOut$[esp+224]
  00062	8d 74 24 10	 lea	 esi, DWORD PTR _mac$[esp+228]
  00066	a5		 movsd
  00067	a5		 movsd
  00068	a5		 movsd
  00069	a5		 movsd
  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5d		 pop	 ebp
  0006d	5b		 pop	 ebx

; 213  : }

  0006e	81 c4 d4 00 00
	00		 add	 esp, 212		; 000000d4H
  00074	c3		 ret	 0
_AesCmacV4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _ShiftRowsR
_TEXT	SEGMENT
_b$ = -16						; size = 16
_ShiftRowsR PROC					; COMDAT
; _state$ = ecx

; 259  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 260  : 	BYTE b[AES_BLOCK_BYTES];
; 261  : 	uint_fast8_t i;
; 262  : 
; 263  : 	memcpy(b, state, AES_BLOCK_BYTES);

  00006	33 d2		 xor	 edx, edx
  00008	53		 push	 ebx
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	8b d9		 mov	 ebx, ecx
  0000d	8d 7d f0	 lea	 edi, DWORD PTR _b$[ebp]
  00010	8b f3		 mov	 esi, ebx
  00012	6a 10		 push	 16			; 00000010H
  00014	a5		 movsd
  00015	a5		 movsd
  00016	a5		 movsd
  00017	a5		 movsd
  00018	5e		 pop	 esi
$LL3@ShiftRowsR:

; 264  : 
; 265  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)
; 266  : 		state[i] = b[(i - ((i & 0x3) << 2)) & 0xf];

  00019	8b ca		 mov	 ecx, edx
  0001b	8b c2		 mov	 eax, edx
  0001d	83 e1 03	 and	 ecx, 3
  00020	c1 e1 02	 shl	 ecx, 2
  00023	2b c1		 sub	 eax, ecx
  00025	83 e0 0f	 and	 eax, 15			; 0000000fH
  00028	8a 44 05 f0	 mov	 al, BYTE PTR _b$[ebp+eax]
  0002c	88 04 1a	 mov	 BYTE PTR [edx+ebx], al
  0002f	42		 inc	 edx
  00030	4e		 dec	 esi
  00031	75 e6		 jne	 SHORT $LL3@ShiftRowsR
  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx

; 267  : }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_ShiftRowsR ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _SubBytesR
_TEXT	SEGMENT
_SubBytesR PROC						; COMDAT
; _block$ = ecx

; 272  : 	uint_fast8_t i;
; 273  : 
; 274  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)

  00000	6a 10		 push	 16			; 00000010H
  00002	5a		 pop	 edx
$LL3@SubBytesR:

; 275  : 	{
; 276  : 		block[i] = GetSBoxR( block[i] );

  00003	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  00006	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _SBoxR[eax]
  0000c	88 01		 mov	 BYTE PTR [ecx], al
  0000e	41		 inc	 ecx
  0000f	4a		 dec	 edx
  00010	75 f1		 jne	 SHORT $LL3@SubBytesR

; 277  : 	}
; 278  : }

  00012	c3		 ret	 0
_SubBytesR ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _AesEncryptCbc
_TEXT	SEGMENT
_Ctx$1$ = -4						; size = 4
_data$ = 8						; size = 4
_len$ = 12						; size = 4
_AesEncryptCbc PROC					; COMDAT
; _Ctx$ = ecx
; _iv$dead$ = edx

; 282  : {

  00000	51		 push	 ecx
  00001	53		 push	 ebx

; 283  : 	// Pad up to blocksize inclusive
; 284  : 	size_t i;
; 285  : 	uint_fast8_t pad = (~*len & (AES_BLOCK_BYTES - 1)) + 1;

  00002	8b 5c 24 10	 mov	 ebx, DWORD PTR _len$[esp+4]
  00006	55		 push	 ebp

; 286  : 
; 287  : 	#if defined(__GNUC__) && (__GNUC__ == 4 && __GNUC_MINOR__ == 8) // gcc 4.8 memset bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56977
; 288  : 		for (i = 0; i < pad; i++) data[*len + i] = pad;
; 289  : 	#else
; 290  : 		memset(data + *len, pad, pad);

  00007	8b 6c 24 10	 mov	 ebp, DWORD PTR _data$[esp+8]
  0000b	56		 push	 esi
  0000c	8a 03		 mov	 al, BYTE PTR [ebx]
  0000e	8b 33		 mov	 esi, DWORD PTR [ebx]
  00010	f6 d0		 not	 al
  00012	24 0f		 and	 al, 15			; 0000000fH
  00014	89 4c 24 0c	 mov	 DWORD PTR _Ctx$1$[esp+16], ecx
  00018	57		 push	 edi
  00019	fe c0		 inc	 al
  0001b	0f b6 f8	 movzx	 edi, al
  0001e	8d 04 2e	 lea	 eax, DWORD PTR [esi+ebp]
  00021	57		 push	 edi
  00022	57		 push	 edi
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 _memset

; 291  : 	#endif
; 292  : 	*len += pad;
; 293  : 
; 294  : 	if ( iv ) XorBlock(iv, data);
; 295  : 	AesEncryptBlock(Ctx, data);

  00029	8b 4c 24 1c	 mov	 ecx, DWORD PTR _Ctx$1$[esp+32]
  0002d	8d 04 3e	 lea	 eax, DWORD PTR [esi+edi]
  00030	83 c4 0c	 add	 esp, 12			; 0000000cH
  00033	89 03		 mov	 DWORD PTR [ebx], eax
  00035	8b d5		 mov	 edx, ebp
  00037	e8 00 00 00 00	 call	 _AesEncryptBlock

; 296  : 
; 297  : 	for (i = *len - AES_BLOCK_BYTES; i; i -= AES_BLOCK_BYTES)

  0003c	8b 3b		 mov	 edi, DWORD PTR [ebx]
  0003e	eb 18		 jmp	 SHORT $LN11@AesEncrypt
$LL3@AesEncrypt:

; 298  : 	{
; 299  : 		XorBlock(data, data + AES_BLOCK_BYTES);

  00040	8d 55 10	 lea	 edx, DWORD PTR [ebp+16]
  00043	8b cd		 mov	 ecx, ebp
  00045	e8 00 00 00 00	 call	 _XorBlock

; 300  : 		data += AES_BLOCK_BYTES;
; 301  : 		AesEncryptBlock(Ctx, data);

  0004a	8b 4c 24 10	 mov	 ecx, DWORD PTR _Ctx$1$[esp+20]
  0004e	83 c5 10	 add	 ebp, 16			; 00000010H
  00051	8b d5		 mov	 edx, ebp
  00053	e8 00 00 00 00	 call	 _AesEncryptBlock
$LN11@AesEncrypt:

; 296  : 
; 297  : 	for (i = *len - AES_BLOCK_BYTES; i; i -= AES_BLOCK_BYTES)

  00058	83 ef 10	 sub	 edi, 16			; 00000010H
  0005b	75 e3		 jne	 SHORT $LL3@AesEncrypt
  0005d	5f		 pop	 edi
  0005e	5e		 pop	 esi
  0005f	5d		 pop	 ebp
  00060	5b		 pop	 ebx

; 302  : 	}
; 303  : }

  00061	59		 pop	 ecx
  00062	c3		 ret	 0
_AesEncryptCbc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _AesDecryptBlock
_TEXT	SEGMENT
_Ctx$1$ = -20						; size = 4
_b$1 = -16						; size = 16
_AesDecryptBlock PROC					; COMDAT
; _Ctx$ = ecx
; _block$ = edx

; 307  : {

  00000	83 ec 14	 sub	 esp, 20			; 00000014H
  00003	53		 push	 ebx
  00004	8b d9		 mov	 ebx, ecx
  00006	55		 push	 ebp
  00007	56		 push	 esi
  00008	57		 push	 edi

; 308  : 	uint_fast8_t  i;
; 309  : 
; 310  : 	AddRoundKey(block, &Ctx->Key[ Ctx->rounds << 2 ]);

  00009	0f b6 8b c0 00
	00 00		 movzx	 ecx, BYTE PTR [ebx+192]
  00010	8b ea		 mov	 ebp, edx
  00012	c1 e1 04	 shl	 ecx, 4
  00015	03 cb		 add	 ecx, ebx
  00017	89 5c 24 10	 mov	 DWORD PTR _Ctx$1$[esp+36], ebx
  0001b	e8 00 00 00 00	 call	 _XorBlock

; 311  : 
; 312  : 	for ( i = ( Ctx->rounds - 1 ) << 2 ;; i -= 4 )

  00020	8a 9b c0 00 00
	00		 mov	 bl, BYTE PTR [ebx+192]
  00026	fe cb		 dec	 bl
  00028	c0 e3 02	 shl	 bl, 2
$LL4@AesDecrypt:

; 313  : 	{
; 314  : 		ShiftRowsR(block);

  0002b	8b f5		 mov	 esi, ebp
  0002d	8d 7c 24 14	 lea	 edi, DWORD PTR _b$1[esp+36]
  00031	6a 10		 push	 16			; 00000010H
  00033	33 d2		 xor	 edx, edx
  00035	a5		 movsd
  00036	a5		 movsd
  00037	a5		 movsd
  00038	a5		 movsd
  00039	5e		 pop	 esi
$LL9@AesDecrypt:
  0003a	8b ca		 mov	 ecx, edx
  0003c	8b c2		 mov	 eax, edx
  0003e	83 e1 03	 and	 ecx, 3
  00041	c1 e1 02	 shl	 ecx, 2
  00044	2b c1		 sub	 eax, ecx
  00046	83 e0 0f	 and	 eax, 15			; 0000000fH
  00049	8a 44 04 14	 mov	 al, BYTE PTR _b$1[esp+eax+36]
  0004d	88 04 2a	 mov	 BYTE PTR [edx+ebp], al
  00050	42		 inc	 edx
  00051	4e		 dec	 esi
  00052	75 e6		 jne	 SHORT $LL9@AesDecrypt

; 315  : 		SubBytesR(block);

  00054	6a 10		 push	 16			; 00000010H
  00056	8b cd		 mov	 ecx, ebp
  00058	5a		 pop	 edx
$LL14@AesDecrypt:
  00059	0f b6 01	 movzx	 eax, BYTE PTR [ecx]
  0005c	8a 80 00 00 00
	00		 mov	 al, BYTE PTR _SBoxR[eax]
  00062	88 01		 mov	 BYTE PTR [ecx], al
  00064	41		 inc	 ecx
  00065	4a		 dec	 edx
  00066	75 f1		 jne	 SHORT $LL14@AesDecrypt

; 316  : 		AddRoundKey(block, &Ctx->Key[ i ]);

  00068	8b 4c 24 10	 mov	 ecx, DWORD PTR _Ctx$1$[esp+36]
  0006c	8b d5		 mov	 edx, ebp
  0006e	0f b6 c3	 movzx	 eax, bl
  00071	8d 0c 81	 lea	 ecx, DWORD PTR [ecx+eax*4]
  00074	e8 00 00 00 00	 call	 _XorBlock

; 317  : 
; 318  : 		if ( i == 0 ) break;

  00079	84 db		 test	 bl, bl
  0007b	74 0c		 je	 SHORT $LN21@AesDecrypt

; 319  : 
; 320  : 		MixColumnsR(block);

  0007d	8b cd		 mov	 ecx, ebp
  0007f	e8 00 00 00 00	 call	 _MixColumnsR
  00084	80 c3 fc	 add	 bl, 252			; 000000fcH
  00087	eb a2		 jmp	 SHORT $LL4@AesDecrypt
$LN21@AesDecrypt:
  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5d		 pop	 ebp
  0008c	5b		 pop	 ebx

; 321  : 	}
; 322  : }

  0008d	83 c4 14	 add	 esp, 20			; 00000014H
  00090	c3		 ret	 0
_AesDecryptBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\dell\desktop\vlmcsd\src\crypto.c
;	COMDAT _AesDecryptCbc
_TEXT	SEGMENT
_data$ = 8						; size = 4
_len$dead$ = 12						; size = 4
_AesDecryptCbc PROC					; COMDAT
; _Ctx$ = ecx
; _iv$dead$ = edx

; 326  : {

  00000	53		 push	 ebx

; 327  : 	BYTE  *cc;
; 328  : 
; 329  : 	for (cc = data + len - AES_BLOCK_BYTES; cc > data; cc -= AES_BLOCK_BYTES)

  00001	8b 5c 24 08	 mov	 ebx, DWORD PTR _data$[esp]
  00005	55		 push	 ebp
  00006	57		 push	 edi
  00007	8b e9		 mov	 ebp, ecx
  00009	8d bb f0 00 00
	00		 lea	 edi, DWORD PTR [ebx+240]
  0000f	3b fb		 cmp	 edi, ebx
  00011	76 1c		 jbe	 SHORT $LN2@AesDecrypt
  00013	56		 push	 esi
$LL4@AesDecrypt:

; 330  : 	{
; 331  : 		AesDecryptBlock(Ctx, cc);

  00014	8b d7		 mov	 edx, edi
  00016	8b cd		 mov	 ecx, ebp
  00018	e8 00 00 00 00	 call	 _AesDecryptBlock

; 332  : 		XorBlock(cc - AES_BLOCK_BYTES, cc);

  0001d	8b d7		 mov	 edx, edi
  0001f	8d 4f f0	 lea	 ecx, DWORD PTR [edi-16]
  00022	e8 00 00 00 00	 call	 _XorBlock
  00027	83 c7 f0	 add	 edi, -16		; fffffff0H
  0002a	3b fb		 cmp	 edi, ebx
  0002c	77 e6		 ja	 SHORT $LL4@AesDecrypt
  0002e	5e		 pop	 esi
$LN2@AesDecrypt:

; 333  : 	}
; 334  : 
; 335  : 	AesDecryptBlock(Ctx, cc);

  0002f	8b d7		 mov	 edx, edi
  00031	8b cd		 mov	 ecx, ebp
  00033	5f		 pop	 edi
  00034	5d		 pop	 ebp
  00035	5b		 pop	 ebx
  00036	e9 00 00 00 00	 jmp	 _AesDecryptBlock
_AesDecryptCbc ENDP
_TEXT	ENDS
END
