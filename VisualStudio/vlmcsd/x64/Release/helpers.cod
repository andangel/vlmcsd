; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5nume@ ; `string'
PUBLIC	??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@ ; `string'
PUBLIC	??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@	; `string'
PUBLIC	??_C@_04LOAJBDKD@true?$AA@			; `string'
PUBLIC	??_C@_02LIELOMNJ@on?$AA@			; `string'
PUBLIC	??_C@_03ICICOMAL@yes?$AA@			; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_05LAPONLG@false?$AA@			; `string'
PUBLIC	??_C@_03MCADLMAF@off?$AA@			; `string'
PUBLIC	??_C@_02KAJCLHKP@no?$AA@			; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@ ; `string'
PUBLIC	??_C@_0M@OPCADLF@?2vlmcsd?4kmd?$AA@		; `string'
PUBLIC	??_C@_01JOAMLHOP@?9?$AA@			; `string'
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	??_C@_0BH@GJJJGOK@Read?5KMS?5data?5file?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0DG@EIKFJMME@Warning?3?5Legacy?5database?3?5Some?5p@ ; `string'
PUBLIC	??_C@_03HOPJGLEN@KMD?$AA@			; `string'
PUBLIC	??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level?5@ ; `string'
EXTRN	__imp_exit:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fseek:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp_GetModuleHandleA:PROC
EXTRN	__imp_GetModuleFileNameA:PROC
EXTRN	__imp_ftell:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp_strrchr:PROC
EXTRN	__imp__strdup:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_PathRemoveFileSpecA:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_FormatMessageA:PROC
EXTRN	__imp_strchr:PROC
EXTRN	__imp_GetTickCount:PROC
EXTRN	__imp__strtoi64:PROC
EXTRN	__imp_strerror:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_strncat:PROC
COMM	?buff@?1??gai_strerrorW@@9@9:WORD:0401H							; `gai_strerrorW'::`2'::buff
COMM	?buff@?1??gai_strerrorA@@9@9:BYTE:0401H							; `gai_strerrorA'::`2'::buff
_DATA	ENDS
;	COMDAT ??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level?5@
CONST	SEGMENT
??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level?5@ DB 'Fatal: Exi'
	DB	'ting on warning level %i or greater', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03HOPJGLEN@KMD?$AA@
CONST	SEGMENT
??_C@_03HOPJGLEN@KMD?$AA@ DB 'KMD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@EIKFJMME@Warning?3?5Legacy?5database?3?5Some?5p@
CONST	SEGMENT
??_C@_0DG@EIKFJMME@Warning?3?5Legacy?5database?3?5Some?5p@ DB 'Warning: L'
	DB	'egacy database: Some products are missing.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GJJJGOK@Read?5KMS?5data?5file?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@GJJJGOK@Read?5KMS?5data?5file?5?$CFs?6?$AA@ DB 'Read KMS data f'
	DB	'ile %s', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02JDPG@rb?$AA@
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JOAMLHOP@?9?$AA@
CONST	SEGMENT
??_C@_01JOAMLHOP@?9?$AA@ DB '-', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OPCADLF@?2vlmcsd?4kmd?$AA@
CONST	SEGMENT
??_C@_0M@OPCADLF@?2vlmcsd?4kmd?$AA@ DB '\vlmcsd.kmd', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@
CONST	SEGMENT
??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@ DB 'Fatal'
	DB	': %s is not a KMS data file', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6?$AA@ DB 'F'
	DB	'atal: Could not read %s: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAJCLHKP@no?$AA@
CONST	SEGMENT
??_C@_02KAJCLHKP@no?$AA@ DB 'no', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCADLMAF@off?$AA@
CONST	SEGMENT
??_C@_03MCADLMAF@off?$AA@ DB 'off', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05LAPONLG@false?$AA@
CONST	SEGMENT
??_C@_05LAPONLG@false?$AA@ DB 'false', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ICICOMAL@yes?$AA@
CONST	SEGMENT
??_C@_03ICICOMAL@yes?$AA@ DB 'yes', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LIELOMNJ@on?$AA@
CONST	SEGMENT
??_C@_02LIELOMNJ@on?$AA@ DB 'on', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOAJBDKD@true?$AA@
CONST	SEGMENT
??_C@_04LOAJBDKD@true?$AA@ DB 'true', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@
CONST	SEGMENT
??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@ DB '0123456789ABCDEF', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@ DB 'Fatal: Out of memory'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5nume@
CONST	SEGMENT
??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5nume@ DB 'F'
	DB	'atal: Option "-%c" must be numeric between %u and %u.', 0aH, 00H ; `string'
?hexdigits@?1??hex2bin@@9@9 DQ FLAT:??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@ ; `hex2bin'::`2'::hexdigits
PUBLIC	exitOnWarningLevel
PUBLIC	loadKmsData
PUBLIC	getExeName
PUBLIC	getArgumentBool
PUBLIC	hex2bin
PUBLIC	vlmcsd_strdup
PUBLIC	vlmcsd_malloc
PUBLIC	OutOfMemory
PUBLIC	randomNumberInit
PUBLIC	parseAddress
PUBLIC	win_strerror
PUBLIC	optReset
PUBLIC	getOptionArgumentInt
PUBLIC	timeSpanString2Seconds
PUBLIC	stringToInt
PUBLIC	ucs2_to_utf8
PUBLIC	utf8_to_ucs2
PUBLIC	ucs2_to_utf8_char
PUBLIC	utf8_to_ucs2_char
?buffer@?1??win_strerror@@9@9 DB 0100H DUP (?)		; `win_strerror'::`2'::buffer
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$exitOnWarningLevel DD imagerel $LN6
	DD	imagerel $LN6+44
	DD	imagerel $unwind$exitOnWarningLevel
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$loadKmsData DD imagerel $LN72
	DD	imagerel $LN72+819
	DD	imagerel $unwind$loadKmsData
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getDefaultDataFile DD imagerel getDefaultDataFile
	DD	imagerel getDefaultDataFile+218
	DD	imagerel $unwind$getDefaultDataFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getExeName DD imagerel $LN13
	DD	imagerel $LN13+108
	DD	imagerel $unwind$getExeName
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dataFileFormatError DD imagerel dataFileFormatError
	DD	imagerel dataFileFormatError+35
	DD	imagerel $unwind$dataFileFormatError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$dataFileReadError DD imagerel dataFileReadError
	DD	imagerel dataFileReadError+53
	DD	imagerel $unwind$dataFileReadError
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getArgumentBool DD imagerel $LN10
	DD	imagerel $LN10+256
	DD	imagerel $unwind$getArgumentBool
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$hex2bin DD imagerel $LN29
	DD	imagerel $LN29+187
	DD	imagerel $unwind$hex2bin
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vlmcsd_strdup DD imagerel $LN13
	DD	imagerel $LN13+28
	DD	imagerel $unwind$vlmcsd_strdup
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vlmcsd_malloc DD imagerel $LN9
	DD	imagerel $LN9+44
	DD	imagerel $unwind$vlmcsd_malloc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OutOfMemory DD imagerel $LN4
	DD	imagerel $LN4+28
	DD	imagerel $unwind$OutOfMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$randomNumberInit DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$randomNumberInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$parseAddress DD imagerel $LN9
	DD	imagerel $LN9+167
	DD	imagerel $unwind$parseAddress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$win_strerror DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$win_strerror
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getOptionArgumentInt DD imagerel $LN10
	DD	imagerel $LN10+155
	DD	imagerel $unwind$getOptionArgumentInt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$timeSpanString2Seconds DD imagerel $LN15
	DD	imagerel $LN15+129
	DD	imagerel $unwind$timeSpanString2Seconds
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ucs2_to_utf8 DD imagerel $LN23
	DD	imagerel $LN23+312
	DD	imagerel $unwind$ucs2_to_utf8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$utf8_to_ucs2 DD imagerel $LN34
	DD	imagerel $LN34+226
	DD	imagerel $unwind$utf8_to_ucs2
;	COMDAT xdata
xdata	SEGMENT
$unwind$utf8_to_ucs2 DD 081901H
	DD	087419H
	DD	076419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ucs2_to_utf8 DD 0a1c01H
	DD	0b641cH
	DD	09541cH
	DD	08341cH
	DD	0f018321cH
	DD	07014e016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$timeSpanString2Seconds DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getOptionArgumentInt DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$win_strerror DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parseAddress DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$randomNumberInit DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OutOfMemory DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vlmcsd_malloc DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vlmcsd_strdup DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$hex2bin DD 061401H
	DD	076414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getArgumentBool DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dataFileReadError DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$dataFileFormatError DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getExeName DD 020701H
	DD	0450107H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getDefaultDataFile DD 020701H
	DD	0670107H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$loadKmsData DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$exitOnWarningLevel DD 010401H
	DD	04204H
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT utf8_to_ucs2_char
_TEXT	SEGMENT
input$ = 8
end_ptr$ = 16
utf8_to_ucs2_char PROC					; COMDAT

; 64   : 	*end_ptr = input;
; 65   : 	if (input[0] == 0)
; 66   : 		return (WCHAR)~0;
; 67   : 
; 68   : 	if (input[0] < 0x80) {

  00000	80 39 80	 cmp	 BYTE PTR [rcx], 128	; 00000080H
  00003	73 0b		 jae	 SHORT $LN6@utf8_to_uc

; 69   : 		*end_ptr = input + 1;

  00005	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00009	48 89 02	 mov	 QWORD PTR [rdx], rax

; 70   : 		return LE16(input[0]);

  0000c	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 97   : }

  0000f	c3		 ret	 0
$LN6@utf8_to_uc:

; 71   : 	}
; 72   : 
; 73   : 	if ((input[0] & 0xE0) == 0xE0) {

  00010	8a 01		 mov	 al, BYTE PTR [rcx]
  00012	24 e0		 and	 al, 224			; 000000e0H
  00014	3c e0		 cmp	 al, 224			; 000000e0H
  00016	75 2e		 jne	 SHORT $LN5@utf8_to_uc

; 74   : 
; 75   : 		if (input[1] == 0 || input[2] == 0)

  00018	80 79 01 00	 cmp	 BYTE PTR [rcx+1], 0
  0001c	74 50		 je	 SHORT $LN2@utf8_to_uc
  0001e	44 8a 41 02	 mov	 r8b, BYTE PTR [rcx+2]
  00022	45 84 c0	 test	 r8b, r8b
  00025	74 47		 je	 SHORT $LN2@utf8_to_uc

; 76   : 			return (WCHAR)~0;
; 77   : 
; 78   : 		*end_ptr = input + 3;

  00027	48 8d 41 03	 lea	 rax, QWORD PTR [rcx+3]
  0002b	48 89 02	 mov	 QWORD PTR [rdx], rax

; 79   : 
; 80   : 		return
; 81   : 			LE16((input[0] & 0x0F) << 12 |
; 82   : 			(input[1] & 0x3F) << 6 |
; 83   : 				(input[2] & 0x3F));

  0002e	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00031	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00035	83 e0 0f	 and	 eax, 15
  00038	83 e1 3f	 and	 ecx, 63			; 0000003fH
  0003b	c1 e0 06	 shl	 eax, 6
  0003e	0b c1		 or	 eax, ecx
  00040	41 0f b6 c8	 movzx	 ecx, r8b
  00044	eb 1f		 jmp	 SHORT $LN13@utf8_to_uc
$LN5@utf8_to_uc:

; 84   : 	}
; 85   : 
; 86   : 	if ((input[0] & 0xC0) == 0xC0) {

  00046	8a 01		 mov	 al, BYTE PTR [rcx]
  00048	24 c0		 and	 al, 192			; 000000c0H
  0004a	3c c0		 cmp	 al, 192			; 000000c0H
  0004c	75 20		 jne	 SHORT $LN2@utf8_to_uc

; 87   : 		if (input[1] == 0)

  0004e	80 79 01 00	 cmp	 BYTE PTR [rcx+1], 0
  00052	74 1a		 je	 SHORT $LN2@utf8_to_uc

; 88   : 			return (WCHAR)~0;
; 89   : 
; 90   : 		*end_ptr = input + 2;

  00054	48 8d 41 02	 lea	 rax, QWORD PTR [rcx+2]
  00058	48 89 02	 mov	 QWORD PTR [rdx], rax

; 91   : 
; 92   : 		return
; 93   : 			LE16((input[0] & 0x1F) << 6 |
; 94   : 			(input[1] & 0x3F));

  0005b	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0005e	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00062	83 e0 1f	 and	 eax, 31
$LN13@utf8_to_uc:
  00065	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00068	c1 e0 06	 shl	 eax, 6
  0006b	0b c1		 or	 eax, ecx

; 97   : }

  0006d	c3		 ret	 0
$LN2@utf8_to_uc:

; 95   : 	}
; 96   : 	return (WCHAR)~0;

  0006e	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH

; 97   : }

  00073	c3		 ret	 0
utf8_to_ucs2_char ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT ucs2_to_utf8_char
_TEXT	SEGMENT
ucs2_le$ = 8
utf8$ = 16
ucs2_to_utf8_char PROC					; COMDAT

; 104  : 	const WCHAR ucs2 = LE16(ucs2_le);
; 105  : 
; 106  : 	if (ucs2 < 0x80) {

  00000	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  00005	66 3b c8	 cmp	 cx, ax
  00008	73 0c		 jae	 SHORT $LN8@ucs2_to_ut

; 107  : 		utf8[0] = (char)ucs2;

  0000a	88 0a		 mov	 BYTE PTR [rdx], cl

; 108  : 		utf8[1] = '\0';

  0000c	c6 42 01 00	 mov	 BYTE PTR [rdx+1], 0

; 109  : 		return 1;

  00010	b8 01 00 00 00	 mov	 eax, 1

; 134  : }

  00015	c3		 ret	 0
$LN8@ucs2_to_ut:

; 110  : 	}
; 111  : 
; 112  : 	if (ucs2 >= 0x80 && ucs2 < 0x800) {

  00016	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  0001b	66 3b c8	 cmp	 cx, ax
  0001e	73 1e		 jae	 SHORT $LN7@ucs2_to_ut

; 113  : 		utf8[0] = (char)((ucs2 >> 6) | 0xC0);

  00020	0f b7 c1	 movzx	 eax, cx

; 114  : 		utf8[1] = (char)((ucs2 & 0x3F) | 0x80);

  00023	80 e1 3f	 and	 cl, 63			; 0000003fH

; 115  : 		utf8[2] = '\0';

  00026	c6 42 02 00	 mov	 BYTE PTR [rdx+2], 0
  0002a	66 c1 e8 06	 shr	 ax, 6
  0002e	0c c0		 or	 al, -64			; ffffffffffffffc0H
  00030	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  00033	88 02		 mov	 BYTE PTR [rdx], al
  00035	88 4a 01	 mov	 BYTE PTR [rdx+1], cl

; 116  : 		return 2;

  00038	b8 02 00 00 00	 mov	 eax, 2

; 134  : }

  0003d	c3		 ret	 0
$LN7@ucs2_to_ut:

; 117  : 	}
; 118  : 
; 119  : 	if (ucs2 >= 0x800 && ucs2 < 0xFFFF) {

  0003e	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00043	66 3b c8	 cmp	 cx, ax
  00046	73 3f		 jae	 SHORT $LN2@ucs2_to_ut

; 120  : 
; 121  : 		if (ucs2 >= 0xD800 && ucs2 <= 0xDFFF) {

  00048	b8 00 28 00 00	 mov	 eax, 10240		; 00002800H
  0004d	41 b8 ff 07 00
	00		 mov	 r8d, 2047		; 000007ffH
  00053	03 c1		 add	 eax, ecx
  00055	66 41 3b c0	 cmp	 ax, r8w
  00059	76 2c		 jbe	 SHORT $LN2@ucs2_to_ut

; 122  : 			/* Ill-formed (UTF-16 ouside of BMP) */
; 123  : 			return -1;
; 124  : 		}
; 125  : 
; 126  : 		utf8[0] = ((ucs2 >> 12)) | 0xE0;

  0005b	0f b7 c1	 movzx	 eax, cx

; 127  : 		utf8[1] = ((ucs2 >> 6) & 0x3F) | 0x80;
; 128  : 		utf8[2] = ((ucs2) & 0x3F) | 0x80;
; 129  : 		utf8[3] = '\0';

  0005e	c6 42 03 00	 mov	 BYTE PTR [rdx+3], 0
  00062	66 c1 e8 0c	 shr	 ax, 12
  00066	0c e0		 or	 al, -32			; ffffffffffffffe0H
  00068	88 02		 mov	 BYTE PTR [rdx], al
  0006a	0f b7 c1	 movzx	 eax, cx
  0006d	80 e1 3f	 and	 cl, 63			; 0000003fH
  00070	66 c1 e8 06	 shr	 ax, 6
  00074	24 3f		 and	 al, 63			; 0000003fH
  00076	0c 80		 or	 al, -128		; ffffffffffffff80H
  00078	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  0007b	88 42 01	 mov	 BYTE PTR [rdx+1], al
  0007e	88 4a 02	 mov	 BYTE PTR [rdx+2], cl

; 130  : 		return 3;

  00081	b8 03 00 00 00	 mov	 eax, 3

; 134  : }

  00086	c3		 ret	 0
$LN2@ucs2_to_ut:

; 131  : 	}
; 132  : 
; 133  : 	return -1;

  00087	83 c8 ff	 or	 eax, -1

; 134  : }

  0008a	c3		 ret	 0
ucs2_to_utf8_char ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT utf8_to_ucs2
_TEXT	SEGMENT
ucs2_le$ = 48
utf8$ = 56
maxucs2$dead$ = 64
maxutf8$dead$ = 72
current_utf8$ = 72
utf8_to_ucs2 PROC					; COMDAT

; 139  : {

$LN34:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  0000b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0000f	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 141  : 	WCHAR* current_ucs2_le = ucs2_le;
; 142  : 
; 143  : 	for (; *current_utf8; current_ucs2_le++)

  00019	33 f6		 xor	 esi, esi
  0001b	48 8b da	 mov	 rbx, rdx
  0001e	4c 8b d1	 mov	 r10, rcx
  00021	4c 8b c2	 mov	 r8, rdx
  00024	48 89 50 20	 mov	 QWORD PTR [rax+32], rdx
  00028	4c 8b c9	 mov	 r9, rcx
  0002b	40 38 32	 cmp	 BYTE PTR [rdx], sil
  0002e	0f 84 89 00 00
	00		 je	 $LN6@utf8_to_uc

; 140  : 	const unsigned char* current_utf8 = (unsigned char*)utf8;

  00034	48 8d 7e fe	 lea	 rdi, QWORD PTR [rsi-2]
  00038	41 be ff ff 00
	00		 mov	 r14d, 65535		; 0000ffffH
  0003e	48 2b f9	 sub	 rdi, rcx
$LL8@utf8_to_uc:

; 144  : 	{
; 145  : 		size_t size = (char*)current_utf8 - utf8;

  00041	49 8b c8	 mov	 rcx, r8
  00044	48 2b cb	 sub	 rcx, rbx

; 146  : 
; 147  : 		if (size >= maxutf8) return (size_t)-1;

  00047	48 81 f9 c0 00
	00 00		 cmp	 rcx, 192		; 000000c0H
  0004e	0f 83 88 00 00
	00		 jae	 $LN24@utf8_to_uc

; 148  : 		if (((*current_utf8 & 0xc0) == 0xc0) && (size >= maxutf8 - 1)) return (size_t)-1;

  00054	41 8a 00	 mov	 al, BYTE PTR [r8]
  00057	24 c0		 and	 al, 192			; 000000c0H
  00059	3c c0		 cmp	 al, 192			; 000000c0H
  0005b	75 09		 jne	 SHORT $LN4@utf8_to_uc
  0005d	48 81 f9 bf 00
	00 00		 cmp	 rcx, 191		; 000000bfH
  00064	73 76		 jae	 SHORT $LN24@utf8_to_uc
$LN4@utf8_to_uc:

; 149  : 		if (((*current_utf8 & 0xe0) == 0xe0) && (size >= maxutf8 - 2)) return (size_t)-1;

  00066	41 8a 00	 mov	 al, BYTE PTR [r8]
  00069	24 e0		 and	 al, 224			; 000000e0H
  0006b	3c e0		 cmp	 al, 224			; 000000e0H
  0006d	75 09		 jne	 SHORT $LN3@utf8_to_uc
  0006f	48 81 f9 be 00
	00 00		 cmp	 rcx, 190		; 000000beH
  00076	73 64		 jae	 SHORT $LN24@utf8_to_uc
$LN3@utf8_to_uc:

; 150  : 		if (current_ucs2_le - ucs2_le >= (intptr_t)maxucs2 - 1) return (size_t)-1;

  00078	4d 8d 59 02	 lea	 r11, QWORD PTR [r9+2]
  0007c	4a 8d 04 1f	 lea	 rax, QWORD PTR [rdi+r11]
  00080	48 83 e0 fe	 and	 rax, -2
  00084	48 83 f8 7e	 cmp	 rax, 126		; 0000007eH
  00088	7d 52		 jge	 SHORT $LN24@utf8_to_uc

; 151  : 
; 152  : 		*current_ucs2_le = utf8_to_ucs2_char(current_utf8, &current_utf8);

  0008a	41 38 30	 cmp	 BYTE PTR [r8], sil
  0008d	75 06		 jne	 SHORT $LN22@utf8_to_uc
  0008f	41 0f b7 c6	 movzx	 eax, r14w
  00093	eb 12		 jmp	 SHORT $LN18@utf8_to_uc
$LN22@utf8_to_uc:
  00095	48 8d 54 24 48	 lea	 rdx, QWORD PTR current_utf8$[rsp]
  0009a	49 8b c8	 mov	 rcx, r8
  0009d	e8 00 00 00 00	 call	 utf8_to_ucs2_char
  000a2	4c 8b 44 24 48	 mov	 r8, QWORD PTR current_utf8$[rsp]
$LN18@utf8_to_uc:
  000a7	66 41 89 01	 mov	 WORD PTR [r9], ax

; 153  : 		current_ucs2_le[1] = 0;

  000ab	66 41 89 33	 mov	 WORD PTR [r11], si

; 154  : 
; 155  : 		if (*current_ucs2_le == (WCHAR)-1) return (size_t)-1;

  000af	66 45 39 31	 cmp	 WORD PTR [r9], r14w
  000b3	74 27		 je	 SHORT $LN24@utf8_to_uc

; 141  : 	WCHAR* current_ucs2_le = ucs2_le;
; 142  : 
; 143  : 	for (; *current_utf8; current_ucs2_le++)

  000b5	4d 8b cb	 mov	 r9, r11
  000b8	41 38 30	 cmp	 BYTE PTR [r8], sil
  000bb	75 84		 jne	 SHORT $LL8@utf8_to_uc
$LN6@utf8_to_uc:

; 156  : 	}
; 157  : 	return current_ucs2_le - ucs2_le;

  000bd	4d 2b ca	 sub	 r9, r10
  000c0	49 d1 f9	 sar	 r9, 1
  000c3	49 8b c1	 mov	 rax, r9
$LN9@utf8_to_uc:

; 158  : }

  000c6	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000cb	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000d0	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	41 5e		 pop	 r14
  000db	c3		 ret	 0
$LN24@utf8_to_uc:

; 146  : 
; 147  : 		if (size >= maxutf8) return (size_t)-1;

  000dc	48 83 c8 ff	 or	 rax, -1
  000e0	eb e4		 jmp	 SHORT $LN9@utf8_to_uc
utf8_to_ucs2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT ucs2_to_utf8
_TEXT	SEGMENT
ucs2_le$ = 64
utf8$ = 72
maxucs2$dead$ = 80
utf8_char$ = 80
maxutf8$ = 88
ucs2_to_utf8 PROC					; COMDAT

; 162  : {

$LN23:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  00013	57		 push	 rdi
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 163  : 	char utf8_char[4];
; 164  : 	const WCHAR* current_ucs2 = ucs2_le;
; 165  : 	unsigned int index_utf8 = 0;

  0001c	45 33 ff	 xor	 r15d, r15d
  0001f	49 8b e9	 mov	 rbp, r9
  00022	4c 8b f2	 mov	 r14, rdx

; 166  : 
; 167  : 	for (*utf8 = 0; *current_ucs2; current_ucs2++)

  00025	44 88 3a	 mov	 BYTE PTR [rdx], r15b
  00028	48 8b d9	 mov	 rbx, rcx
  0002b	41 8b f7	 mov	 esi, r15d
  0002e	66 44 39 39	 cmp	 WORD PTR [rcx], r15w
  00032	0f 84 de 00 00
	00		 je	 $LN3@ucs2_to_ut
  00038	48 8b f9	 mov	 rdi, rcx
  0003b	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00040	48 f7 df	 neg	 rdi
$LL5@ucs2_to_ut:

; 168  : 	{
; 169  : 		if (current_ucs2 - ucs2_le > (intptr_t)maxucs2) return FALSE;

  00043	48 8d 04 1f	 lea	 rax, QWORD PTR [rdi+rbx]
  00047	48 83 e0 fe	 and	 rax, -2
  0004b	48 3b c2	 cmp	 rax, rdx
  0004e	0f 8f e0 00 00
	00		 jg	 $LN15@ucs2_to_ut

; 170  : 		int len = ucs2_to_utf8_char(*current_ucs2, utf8_char);

  00054	0f b7 0b	 movzx	 ecx, WORD PTR [rbx]
  00057	66 3b ca	 cmp	 cx, dx
  0005a	73 10		 jae	 SHORT $LN21@ucs2_to_ut
  0005c	88 4c 24 50	 mov	 BYTE PTR utf8_char$[rsp], cl
  00060	44 88 7c 24 51	 mov	 BYTE PTR utf8_char$[rsp+1], r15b
  00065	b9 01 00 00 00	 mov	 ecx, 1
  0006a	eb 7d		 jmp	 SHORT $LN12@ucs2_to_ut
$LN21@ucs2_to_ut:
  0006c	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  00071	66 3b c8	 cmp	 cx, ax
  00074	73 23		 jae	 SHORT $LN20@ucs2_to_ut
  00076	0f b7 c1	 movzx	 eax, cx
  00079	80 e1 3f	 and	 cl, 63			; 0000003fH
  0007c	44 88 7c 24 52	 mov	 BYTE PTR utf8_char$[rsp+2], r15b
  00081	66 c1 e8 06	 shr	 ax, 6
  00085	0c c0		 or	 al, -64			; ffffffffffffffc0H
  00087	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  0008a	88 4c 24 51	 mov	 BYTE PTR utf8_char$[rsp+1], cl
  0008e	b9 02 00 00 00	 mov	 ecx, 2
  00093	88 44 24 50	 mov	 BYTE PTR utf8_char$[rsp], al
  00097	eb 50		 jmp	 SHORT $LN12@ucs2_to_ut
$LN20@ucs2_to_ut:
  00099	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0009e	66 3b c8	 cmp	 cx, ax
  000a1	73 43		 jae	 SHORT $LN9@ucs2_to_ut
  000a3	b8 00 28 00 00	 mov	 eax, 10240		; 00002800H
  000a8	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  000ad	03 c1		 add	 eax, ecx
  000af	66 3b c2	 cmp	 ax, dx
  000b2	76 32		 jbe	 SHORT $LN9@ucs2_to_ut
  000b4	0f b7 c1	 movzx	 eax, cx
  000b7	44 88 7c 24 53	 mov	 BYTE PTR utf8_char$[rsp+3], r15b
  000bc	66 c1 e8 0c	 shr	 ax, 12
  000c0	0c e0		 or	 al, -32			; ffffffffffffffe0H
  000c2	88 44 24 50	 mov	 BYTE PTR utf8_char$[rsp], al
  000c6	0f b7 c1	 movzx	 eax, cx
  000c9	80 e1 3f	 and	 cl, 63			; 0000003fH
  000cc	66 c1 e8 06	 shr	 ax, 6
  000d0	24 3f		 and	 al, 63			; 0000003fH
  000d2	0c 80		 or	 al, -128		; ffffffffffffff80H
  000d4	80 c9 80	 or	 cl, -128		; ffffffffffffff80H
  000d7	88 4c 24 52	 mov	 BYTE PTR utf8_char$[rsp+2], cl
  000db	b9 03 00 00 00	 mov	 ecx, 3
  000e0	88 44 24 51	 mov	 BYTE PTR utf8_char$[rsp+1], al
  000e4	eb 03		 jmp	 SHORT $LN12@ucs2_to_ut
$LN9@ucs2_to_ut:
  000e6	83 c9 ff	 or	 ecx, -1
$LN12@ucs2_to_ut:

; 171  : 		if (index_utf8 + len > maxutf8) return FALSE;

  000e9	03 f1		 add	 esi, ecx
  000eb	8b c6		 mov	 eax, esi
  000ed	48 3b c5	 cmp	 rax, rbp
  000f0	77 42		 ja	 SHORT $LN15@ucs2_to_ut

; 172  : 		strncat(utf8, utf8_char, len);

  000f2	4c 63 c1	 movsxd	 r8, ecx
  000f5	48 8d 54 24 50	 lea	 rdx, QWORD PTR utf8_char$[rsp]
  000fa	49 8b ce	 mov	 rcx, r14
  000fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat
  00103	48 83 c3 02	 add	 rbx, 2
  00107	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  0010c	66 44 39 3b	 cmp	 WORD PTR [rbx], r15w
  00110	0f 85 2d ff ff
	ff		 jne	 $LL5@ucs2_to_ut
$LN3@ucs2_to_ut:

; 173  : 		index_utf8 += len;
; 174  : 	}
; 175  : 
; 176  : 	return TRUE;

  00116	b8 01 00 00 00	 mov	 eax, 1
$LN6@ucs2_to_ut:

; 177  : }

  0011b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00120	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00125	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0012a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0012e	41 5f		 pop	 r15
  00130	41 5e		 pop	 r14
  00132	5f		 pop	 rdi
  00133	c3		 ret	 0
$LN15@ucs2_to_ut:

; 168  : 	{
; 169  : 		if (current_ucs2 - ucs2_le > (intptr_t)maxucs2) return FALSE;

  00134	33 c0		 xor	 eax, eax
  00136	eb e3		 jmp	 SHORT $LN6@ucs2_to_ut
ucs2_to_utf8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT stringToInt
_TEXT	SEGMENT
min$ = 8
max$ = 16
value$ = 24
$T1 = 32
result$ = 40
stringToInt PROC					; COMDAT

; 185  : 	char *nextchar;
; 186  : 
; 187  : 	errno = 0;
; 188  : 	long long result = vlmcsd_strtoll(szValue, &nextchar, 10);
; 189  : 
; 190  : 	if (errno || result < (long long)min || result >(long long)max || *nextchar)

  00000	8b c1		 mov	 eax, ecx
  00002	48 8b 4c 24 28	 mov	 rcx, QWORD PTR result$[rsp]
  00007	48 3b c8	 cmp	 rcx, rax
  0000a	7c 18		 jl	 SHORT $LN5@stringToIn
  0000c	8b c2		 mov	 eax, edx
  0000e	48 3b c8	 cmp	 rcx, rax
  00011	7f 11		 jg	 SHORT $LN5@stringToIn
  00013	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00016	80 38 00	 cmp	 BYTE PTR [rax], 0
  00019	75 09		 jne	 SHORT $LN5@stringToIn

; 193  : 	}
; 194  : 
; 195  : 	*value = (unsigned int)result;

  0001b	41 89 08	 mov	 DWORD PTR [r8], ecx

; 196  : 	return TRUE;

  0001e	b8 01 00 00 00	 mov	 eax, 1

; 197  : }

  00023	c3		 ret	 0
$LN5@stringToIn:

; 191  : 	{
; 192  : 		return FALSE;

  00024	33 c0		 xor	 eax, eax

; 197  : }

  00026	c3		 ret	 0
stringToInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT timeSpanString2Seconds
_TEXT	SEGMENT
argument$ = 48
unitId$ = 56
timeSpanString2Seconds PROC				; COMDAT

; 234  : {

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 235  : 	char *unitId;
; 236  : 
; 237  : 	long long val = vlmcsd_strtoll(argument, &unitId, 10);

  00006	48 8d 54 24 38	 lea	 rdx, QWORD PTR unitId$[rsp]
  0000b	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strtoi64
  00017	48 8b d8	 mov	 rbx, rax

; 238  : 
; 239  : 	switch (toupper((int)*unitId))

  0001a	48 8b 44 24 38	 mov	 rax, QWORD PTR unitId$[rsp]
  0001f	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00028	85 c0		 test	 eax, eax
  0002a	74 2d		 je	 SHORT $LN5@timeSpanSt
  0002c	83 f8 44	 cmp	 eax, 68			; 00000044H
  0002f	74 1c		 je	 SHORT $LN7@timeSpanSt
  00031	83 f8 48	 cmp	 eax, 72			; 00000048H
  00034	74 1f		 je	 SHORT $LN6@timeSpanSt
  00036	83 f8 4d	 cmp	 eax, 77			; 0000004dH
  00039	74 1e		 je	 SHORT $LN5@timeSpanSt
  0003b	83 f8 53	 cmp	 eax, 83			; 00000053H
  0003e	74 1d		 je	 SHORT $LN4@timeSpanSt
  00040	83 f8 57	 cmp	 eax, 87			; 00000057H
  00043	74 04		 je	 SHORT $LN8@timeSpanSt
$LN13@timeSpanSt:

; 250  : 	case 'S':
; 251  : 		break;
; 252  : 	default:
; 253  : 		return 0;

  00045	33 c0		 xor	 eax, eax
  00047	eb 32		 jmp	 SHORT $LN11@timeSpanSt
$LN8@timeSpanSt:

; 240  : 	{
; 241  : 	case 'W':
; 242  : 		val *= 7;

  00049	48 6b db 07	 imul	 rbx, rbx, 7
$LN7@timeSpanSt:

; 243  : 	case 'D':
; 244  : 		val *= 24;

  0004d	48 8d 1c 5b	 lea	 rbx, QWORD PTR [rbx+rbx*2]
  00051	48 c1 e3 03	 shl	 rbx, 3
$LN6@timeSpanSt:

; 245  : 	case 'H':
; 246  : 		val *= 60;

  00055	48 6b db 3c	 imul	 rbx, rbx, 60		; 0000003cH
$LN5@timeSpanSt:

; 247  : 	case 0:
; 248  : 	case 'M':
; 249  : 		val *= 60;

  00059	48 6b db 3c	 imul	 rbx, rbx, 60		; 0000003cH
$LN4@timeSpanSt:

; 254  : 	}
; 255  : 
; 256  : 	if (*unitId && unitId[1]) return 0;

  0005d	48 8b 44 24 38	 mov	 rax, QWORD PTR unitId$[rsp]
  00062	80 38 00	 cmp	 BYTE PTR [rax], 0
  00065	74 06		 je	 SHORT $LN2@timeSpanSt
  00067	80 78 01 00	 cmp	 BYTE PTR [rax+1], 0
  0006b	75 d8		 jne	 SHORT $LN13@timeSpanSt
$LN2@timeSpanSt:

; 257  : 	if (val < 1) val = 1;

  0006d	b8 01 00 00 00	 mov	 eax, 1
  00072	48 3b d8	 cmp	 rbx, rax
  00075	48 0f 4c d8	 cmovl	 rbx, rax

; 258  : 	return (DWORD)(val & UINT_MAX);

  00079	8b c3		 mov	 eax, ebx
$LN11@timeSpanSt:

; 259  : }

  0007b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007f	5b		 pop	 rbx
  00080	c3		 ret	 0
timeSpanString2Seconds ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT getOptionArgumentInt
_TEXT	SEGMENT
o$ = 48
min$ = 56
max$ = 64
nextchar$1 = 72
getOptionArgumentInt PROC				; COMDAT

; 265  : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 266  : 	unsigned int result;
; 267  : 
; 268  : 	if (!stringToInt(optarg, min, max, &result))

  00014	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR optarg
  0001b	41 8b f8	 mov	 edi, r8d
  0001e	8b f2		 mov	 esi, edx
  00020	40 8a e9	 mov	 bpl, cl
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00029	48 8d 54 24 48	 lea	 rdx, QWORD PTR nextchar$1[rsp]
  0002e	83 20 00	 and	 DWORD PTR [rax], 0
  00031	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00037	48 8b cb	 mov	 rcx, rbx
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strtoi64
  00040	48 8b d8	 mov	 rbx, rax
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00049	83 38 00	 cmp	 DWORD PTR [rax], 0
  0004c	75 2b		 jne	 SHORT $LN4@getOptionA
  0004e	48 3b de	 cmp	 rbx, rsi
  00051	7c 26		 jl	 SHORT $LN4@getOptionA
  00053	48 3b df	 cmp	 rbx, rdi
  00056	7f 21		 jg	 SHORT $LN4@getOptionA
  00058	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nextchar$1[rsp]
  0005d	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00060	75 17		 jne	 SHORT $LN4@getOptionA

; 272  : 	}
; 273  : 
; 274  : 	return result;
; 275  : }

  00062	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00067	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0006c	8b c3		 mov	 eax, ebx
  0006e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0

; 266  : 	unsigned int result;
; 267  : 
; 268  : 	if (!stringToInt(optarg, min, max, &result))

$LN4@getOptionA:

; 269  : 	{
; 270  : 		printerrorf("Fatal: Option \"-%c\" must be numeric between %u and %u.\n", o, min, max);

  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DI@HIOFNDD@Fatal?3?5Option?5?$CC?9?$CFc?$CC?5must?5be?5nume@
  00080	40 0f be d5	 movsx	 edx, bpl
  00084	44 8b cf	 mov	 r9d, edi
  00087	44 8b c6	 mov	 r8d, esi
  0008a	e8 00 00 00 00	 call	 printerrorf

; 271  : 		exit(VLMCSD_EINVAL);

  0008f	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0009a	cc		 int	 3
$LN9@getOptionA:
getOptionArgumentInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT optReset
_TEXT	SEGMENT
optReset PROC						; COMDAT

; 280  : #if __minix__ || defined(__BSD__) || defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__DragonFly__) || defined(__OpenBSD__)
; 281  : 	optind = 1;
; 282  : 	optreset = 1; // Makes newer BSD getopt happy
; 283  : #elif defined(__UCLIBC__) // uClibc headers also define __GLIBC__ so be careful here
; 284  : 	optind = 0; // uClibc seeks compatibility with GLIBC
; 285  : #elif defined(__GLIBC__)
; 286  : 	optind = 0; // Makes GLIBC getopt happy
; 287  : #else // Standard for most systems
; 288  : 	optind = 1;

  00000	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR optind, 1

; 289  : #endif
; 290  : }

  0000a	c3		 ret	 0
optReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT win_strerror
_TEXT	SEGMENT
message$ = 80
win_strerror PROC					; COMDAT

; 297  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 298  : #define STRERROR_BUFFER_SIZE 256
; 299  : 	static char buffer[STRERROR_BUFFER_SIZE];
; 300  : 
; 301  : 	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_MAX_WIDTH_MASK, NULL, message, 0, buffer, STRERROR_BUFFER_SIZE, NULL);

  00006	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  0000c	44 8b c1	 mov	 r8d, ecx
  0000f	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?buffer@?1??win_strerror@@9@9
  00016	45 33 c9	 xor	 r9d, r9d
  00019	33 d2		 xor	 edx, edx
  0001b	b9 ff 12 00 00	 mov	 ecx, 4863		; 000012ffH
  00020	c7 44 24 28 00
	01 00 00	 mov	 DWORD PTR [rsp+40], 256	; 00000100H
  00028	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageA

; 302  : 	return buffer;

  00033	48 8b c3	 mov	 rax, rbx

; 303  : }

  00036	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
win_strerror ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT parseAddress
_TEXT	SEGMENT
addr$ = 48
szHost$ = 56
szPort$ = 64
parseAddress PROC					; COMDAT

; 313  : {

$LN9:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 314  : 	*szHost = addr;
; 315  : 
; 316  : #	ifndef NO_SOCKETS
; 317  : 	*szPort = (char*)defaultport;

  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR defaultport
  00020	4c 8b f2	 mov	 r14, rdx
  00023	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 318  : #	else // NO_SOCKETS
; 319  : 	*szPort = "1688";
; 320  : #	endif // NO_SOCKETS
; 321  : 
; 322  : 	char *lastcolon = strrchr(addr, ':');

  00026	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  0002b	49 8b f0	 mov	 rsi, r8
  0002e	48 8b d9	 mov	 rbx, rcx
  00031	49 89 00	 mov	 QWORD PTR [r8], rax
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr

; 323  : 	char *firstcolon = strchr(addr, ':');

  0003a	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	48 8b e8	 mov	 rbp, rax
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr

; 324  : 	char *closingbracket = strrchr(addr, ']');

  0004b	ba 5d 00 00 00	 mov	 edx, 93			; 0000005dH
  00050	48 8b cb	 mov	 rcx, rbx
  00053	48 8b f8	 mov	 rdi, rax
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr

; 325  : 
; 326  : 	if (*addr == '[' && closingbracket) //Address in brackets

  0005c	80 3b 5b	 cmp	 BYTE PTR [rbx], 91	; 0000005bH
  0005f	75 17		 jne	 SHORT $LN4@parseAddre
  00061	48 85 c0	 test	 rax, rax
  00064	74 12		 je	 SHORT $LN4@parseAddre

; 327  : 	{
; 328  : 		*closingbracket = 0;
; 329  : 		(*szHost)++;

  00066	49 ff 06	 inc	 QWORD PTR [r14]
  00069	c6 00 00	 mov	 BYTE PTR [rax], 0

; 330  : 
; 331  : 		if (closingbracket[1] == ':')

  0006c	80 78 01 3a	 cmp	 BYTE PTR [rax+1], 58	; 0000003aH
  00070	75 1a		 jne	 SHORT $LN1@parseAddre

; 332  : 			*szPort = closingbracket + 2;

  00072	48 83 c0 02	 add	 rax, 2

; 333  : 	}
; 334  : 	else if (firstcolon && firstcolon == lastcolon) //IPv4 address or hostname with port

  00076	eb 11		 jmp	 SHORT $LN7@parseAddre
$LN4@parseAddre:
  00078	48 85 ff	 test	 rdi, rdi
  0007b	74 0f		 je	 SHORT $LN1@parseAddre
  0007d	48 3b fd	 cmp	 rdi, rbp
  00080	75 0a		 jne	 SHORT $LN1@parseAddre

; 335  : 	{
; 336  : 		*firstcolon = 0;

  00082	c6 07 00	 mov	 BYTE PTR [rdi], 0

; 337  : 		*szPort = firstcolon + 1;

  00085	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]
$LN7@parseAddre:
  00089	48 89 06	 mov	 QWORD PTR [rsi], rax
$LN1@parseAddre:

; 338  : 	}
; 339  : }

  0008c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00091	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00096	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000a0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a4	41 5e		 pop	 r14
  000a6	c3		 ret	 0
parseAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT randomNumberInit
_TEXT	SEGMENT
randomNumberInit PROC					; COMDAT

; 344  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 345  : #	if _MSC_VER
; 346  : 	srand(GetTickCount());

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  0000a	8b c8		 mov	 ecx, eax

; 347  : #	else
; 348  : 	struct timeval tv;
; 349  : 	gettimeofday(&tv, NULL);
; 350  : 	srand((unsigned int)(tv.tv_sec ^ tv.tv_usec));
; 351  : #	endif
; 352  : }

  0000c	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 345  : #	if _MSC_VER
; 346  : 	srand(GetTickCount());

  00010	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_srand
randomNumberInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT OutOfMemory
_TEXT	SEGMENT
OutOfMemory PROC					; COMDAT

; 357  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 358  : 	errorout("Fatal: Out of memory");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  0000b	e8 00 00 00 00	 call	 errorout

; 359  : 	exit(VLMCSD_ENOMEM);

  00010	b9 0e 00 00 00	 mov	 ecx, 14
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0001b	cc		 int	 3
$LN3@OutOfMemor:
OutOfMemory ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT vlmcsd_malloc
_TEXT	SEGMENT
len$ = 48
vlmcsd_malloc PROC					; COMDAT

; 364  : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 365  : 	void* buf = malloc(len);

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 366  : 	if (!buf) OutOfMemory();

  0000a	48 85 c0	 test	 rax, rax
  0000d	75 18		 jne	 SHORT $LN1@vlmcsd_mal
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  00016	e8 00 00 00 00	 call	 errorout
  0001b	b9 0e 00 00 00	 mov	 ecx, 14
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00026	cc		 int	 3
$LN1@vlmcsd_mal:

; 367  : 	return buf;
; 368  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
$LN8@vlmcsd_mal:
vlmcsd_malloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT vlmcsd_strdup
_TEXT	SEGMENT
vlmcsd_strdup PROC					; COMDAT

; 371  : {

$LN13:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 372  : #	if _MSC_VER
; 373  : 	char* dst = _strdup(src);
; 374  : #	else // !_MSC_VER
; 375  : 	char* dst = strdup(src);
; 376  : #	endif
; 377  : 
; 378  : 	if (!dst) OutOfMemory();

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  0000b	e8 00 00 00 00	 call	 errorout
  00010	b9 0e 00 00 00	 mov	 ecx, 14
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0001b	cc		 int	 3
$LN12@vlmcsd_str:
vlmcsd_strdup ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT hex2bin
_TEXT	SEGMENT
bin$ = 48
hex$ = 56
maxbin$dead$ = 64
nextchar$ = 64
hex2bin	PROC						; COMDAT

; 388  : {

$LN29:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b c2	 mov	 rax, rdx
  00017	48 8b f9	 mov	 rdi, rcx

; 389  : 	static const char *const hexdigits = "0123456789ABCDEF";
; 390  : 	char* nextchar;
; 391  : 	size_t i;
; 392  : 
; 393  : 	for (i = 0; (i < 16) && utf8_to_ucs2_char((const unsigned char*)hex, (const unsigned char**)&nextchar) != (WCHAR)-1; hex = nextchar)

  0001a	33 db		 xor	 ebx, ebx
  0001c	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:??_C@_0BB@JGGOGLEG@0123456789ABCDEF?$AA@
$LL7@hex2bin:
  00023	44 8a 08	 mov	 r9b, BYTE PTR [rax]
  00026	48 89 44 24 40	 mov	 QWORD PTR nextchar$[rsp], rax
  0002b	45 84 c9	 test	 r9b, r9b
  0002e	74 7b		 je	 SHORT $LN27@hex2bin
  00030	48 8d 54 24 40	 lea	 rdx, QWORD PTR nextchar$[rsp]
  00035	48 8b c8	 mov	 rcx, rax
  00038	e8 00 00 00 00	 call	 utf8_to_ucs2_char
  0003d	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00042	66 3b c1	 cmp	 ax, cx
  00045	74 64		 je	 SHORT $LN27@hex2bin

; 394  : 	{
; 395  : 		const char* pos = strchr(hexdigits, toupper((int)*hex));

  00047	41 0f be c9	 movsx	 ecx, r9b
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00051	48 8b ce	 mov	 rcx, rsi
  00054	8b d0		 mov	 edx, eax
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr

; 396  : 		if (!pos) continue;

  0005c	48 85 c0	 test	 rax, rax
  0005f	74 3b		 je	 SHORT $LN6@hex2bin

; 397  : 
; 398  : 		if (!(i & 1)) bin[i >> 1] = 0;

  00061	48 8b d3	 mov	 rdx, rbx
  00064	83 e2 01	 and	 edx, 1
  00067	75 09		 jne	 SHORT $LN3@hex2bin
  00069	48 8b cb	 mov	 rcx, rbx
  0006c	48 d1 e9	 shr	 rcx, 1
  0006f	88 14 39	 mov	 BYTE PTR [rcx+rdi], dl
$LN3@hex2bin:

; 399  : 		bin[i >> 1] |= (char)(pos - hexdigits);

  00072	40 2a c6	 sub	 al, sil
  00075	48 8b cb	 mov	 rcx, rbx
  00078	48 d1 e9	 shr	 rcx, 1
  0007b	08 04 39	 or	 BYTE PTR [rcx+rdi], al
  0007e	8a 04 39	 mov	 al, BYTE PTR [rcx+rdi]

; 400  : 		if (!(i & 1)) bin[i >> 1] <<= 4;

  00081	48 85 d2	 test	 rdx, rdx
  00084	75 06		 jne	 SHORT $LN2@hex2bin
  00086	c0 e0 04	 shl	 al, 4
  00089	88 04 39	 mov	 BYTE PTR [rcx+rdi], al
$LN2@hex2bin:

; 401  : 		i++;

  0008c	48 ff c3	 inc	 rbx

; 402  : 		if (i >> 1 > maxbin) break;

  0008f	48 8b c3	 mov	 rax, rbx
  00092	48 83 e0 fe	 and	 rax, -2
  00096	48 83 f8 10	 cmp	 rax, 16
  0009a	77 0f		 ja	 SHORT $LN27@hex2bin
$LN6@hex2bin:

; 389  : 	static const char *const hexdigits = "0123456789ABCDEF";
; 390  : 	char* nextchar;
; 391  : 	size_t i;
; 392  : 
; 393  : 	for (i = 0; (i < 16) && utf8_to_ucs2_char((const unsigned char*)hex, (const unsigned char**)&nextchar) != (WCHAR)-1; hex = nextchar)

  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR nextchar$[rsp]
  000a1	48 83 fb 10	 cmp	 rbx, 16
  000a5	0f 82 78 ff ff
	ff		 jb	 $LL7@hex2bin
$LN27@hex2bin:

; 403  : 	}
; 404  : }

  000ab	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b0	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000b5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b9	5f		 pop	 rdi
  000ba	c3		 ret	 0
hex2bin	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT getArgumentBool
_TEXT	SEGMENT
result$ = 48
argument$ = 56
getArgumentBool PROC					; COMDAT

; 408  : {

$LN10:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b da	 mov	 rbx, rdx
  00012	48 8b f9	 mov	 rdi, rcx

; 409  : 	if (
; 410  : 		!strncasecmp(argument, "true", 4) ||
; 411  : 		!strncasecmp(argument, "on", 2) ||
; 412  : 		!strncasecmp(argument, "yes", 3) ||
; 413  : 		!strncasecmp(argument, "1", 1)
; 414  : 		)

  00015	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04LOAJBDKD@true?$AA@
  0001c	48 8b cb	 mov	 rcx, rbx
  0001f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0002b	be 01 00 00 00	 mov	 esi, 1
  00030	85 c0		 test	 eax, eax
  00032	0f 84 b3 00 00
	00		 je	 $LN4@getArgumen
  00038	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LIELOMNJ@on?$AA@
  00043	48 8b cb	 mov	 rcx, rbx
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0004c	85 c0		 test	 eax, eax
  0004e	0f 84 97 00 00
	00		 je	 $LN4@getArgumen
  00054	44 8d 46 02	 lea	 r8d, QWORD PTR [rsi+2]
  00058	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03ICICOMAL@yes?$AA@
  0005f	48 8b cb	 mov	 rcx, rbx
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00068	85 c0		 test	 eax, eax
  0006a	74 7f		 je	 SHORT $LN4@getArgumen
  0006c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01HIHLOKLC@1?$AA@
  00073	44 8b c6	 mov	 r8d, esi
  00076	48 8b cb	 mov	 rcx, rbx
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0007f	85 c0		 test	 eax, eax
  00081	74 68		 je	 SHORT $LN4@getArgumen

; 418  : 	}
; 419  : 	else if (
; 420  : 		!strncasecmp(argument, "false", 5) ||
; 421  : 		!strncasecmp(argument, "off", 3) ||
; 422  : 		!strncasecmp(argument, "no", 2) ||
; 423  : 		!strncasecmp(argument, "0", 1)
; 424  : 		)

  00083	44 8d 46 04	 lea	 r8d, QWORD PTR [rsi+4]
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LAPONLG@false?$AA@
  0008e	48 8b cb	 mov	 rcx, rbx
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00097	85 c0		 test	 eax, eax
  00099	74 4b		 je	 SHORT $LN1@getArgumen
  0009b	44 8d 46 02	 lea	 r8d, QWORD PTR [rsi+2]
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03MCADLMAF@off?$AA@
  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000af	85 c0		 test	 eax, eax
  000b1	74 33		 je	 SHORT $LN1@getArgumen
  000b3	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KAJCLHKP@no?$AA@
  000be	48 8b cb	 mov	 rcx, rbx
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000c7	85 c0		 test	 eax, eax
  000c9	74 1b		 je	 SHORT $LN1@getArgumen
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  000d2	44 8b c6	 mov	 r8d, esi
  000d5	48 8b cb	 mov	 rcx, rbx
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  000de	85 c0		 test	 eax, eax
  000e0	74 04		 je	 SHORT $LN1@getArgumen

; 428  : 	}
; 429  : 
; 430  : 	return FALSE;

  000e2	33 c0		 xor	 eax, eax
  000e4	eb 0a		 jmp	 SHORT $LN6@getArgumen
$LN1@getArgumen:

; 425  : 	{
; 426  : 		*result = FALSE;

  000e6	c6 07 00	 mov	 BYTE PTR [rdi], 0

; 427  : 		return TRUE;

  000e9	eb 03		 jmp	 SHORT $LN8@getArgumen
$LN4@getArgumen:

; 415  : 	{
; 416  : 		*result = TRUE;

  000eb	40 88 37	 mov	 BYTE PTR [rdi], sil
$LN8@getArgumen:

; 417  : 		return TRUE;

  000ee	8b c6		 mov	 eax, esi
$LN6@getArgumen:

; 431  : }

  000f0	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000f5	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000fa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fe	5f		 pop	 rdi
  000ff	c3		 ret	 0
getArgumentBool ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT dataFileReadError
_TEXT	SEGMENT
dataFileReadError PROC					; COMDAT

; 436  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 437  : 	int error = errno;

  00006	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000c	8b 18		 mov	 ebx, DWORD PTR [rax]

; 438  : 	errorout("Fatal: Could not read %s: %s\n", fn_data, strerror(error));

  0000e	8b cb		 mov	 ecx, ebx
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00016	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_data
  0001d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@DINIIKCC@Fatal?3?5Could?5not?5read?5?$CFs?3?5?$CFs?6?$AA@
  00024	4c 8b c0	 mov	 r8, rax
  00027	e8 00 00 00 00	 call	 errorout

; 439  : 	exit(error);

  0002c	8b cb		 mov	 ecx, ebx
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00034	cc		 int	 3
$LN3@dataFileRe:
dataFileReadError ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT dataFileFormatError
_TEXT	SEGMENT
dataFileFormatError PROC				; COMDAT

; 443  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 444  : 	errorout("Fatal: %s is not a KMS data file\n", fn_data);

  00004	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_data
  0000b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@
  00012	e8 00 00 00 00	 call	 errorout

; 445  : 	exit(VLMCSD_EINVAL);

  00017	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00022	cc		 int	 3
$LN3@dataFileFo:
dataFileFormatError ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT getExeName
_TEXT	SEGMENT
path$ = 32
getExeName PROC						; COMDAT

; 451  : {

$LN13:
  00000	48 81 ec 28 02
	00 00		 sub	 rsp, 552		; 00000228H

; 452  : 	if (fn_exe != NULL) return;

  00007	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR fn_exe, 0
  0000f	75 53		 jne	 SHORT $LN2@getExeName

; 453  : 
; 454  : #	if (__GLIBC__ || __linux__) && defined(USE_AUXV)
; 455  : 
; 456  : 	fn_exe = (char*)getauxval(AT_EXECFN);
; 457  : 
; 458  : #	elif (__ANDROID__ && __ANDROID_API__ < 16) || (__UCLIBC__ && __UCLIBC_MAJOR__ < 1 && !defined(NO_PROCFS)) // Workaround for older uclibc
; 459  : 
; 460  : 	char temp[PATH_MAX + 1];
; 461  : 
; 462  : 	if (realpath("/proc/self/exe", temp) == temp)
; 463  : 	{
; 464  : 		fn_exe = vlmcsd_strdup(temp);
; 465  : 	}
; 466  : 
; 467  : #	elif (__linux__ || __CYGWIN__) && !defined(NO_PROCFS)
; 468  : 
; 469  : 	fn_exe = realpath("/proc/self/exe", NULL);
; 470  : 
; 471  : #	elif (__FreeBSD__ || __FreeBSD_kernel__)
; 472  : 
; 473  : 	int mib[4];
; 474  : 	mib[0] = CTL_KERN;
; 475  : 	mib[1] = KERN_PROC;
; 476  : 	mib[2] = KERN_PROC_PATHNAME;
; 477  : 	mib[3] = -1;
; 478  : 	char path[PATH_MAX + 1];
; 479  : 	size_t cb = sizeof(path);
; 480  : 
; 481  : 	if (!sysctl(mib, 4, path, &cb, NULL, 0))
; 482  : 	{
; 483  : 		fn_exe = vlmcsd_strdup(path);
; 484  : 	}
; 485  : 
; 486  : #	elif (__DragonFly__) && !defined(NO_PROCFS)
; 487  : 
; 488  : 	fn_exe = realpath("/proc/curproc/file", NULL);
; 489  : 
; 490  : #	elif __NetBSD__ && !defined(NO_PROCFS)
; 491  : 
; 492  : 	fn_exe = realpath("/proc/curproc/exe", NULL);
; 493  : 
; 494  : #	elif __sun__
; 495  : 
; 496  : 	fn_exe = getexecname();
; 497  : 
; 498  : #	elif __APPLE__
; 499  : 
; 500  : 	char path[PATH_MAX + 1];
; 501  : 	uint32_t size = sizeof(path);
; 502  : 
; 503  : 	if (_NSGetExecutablePath(path, &size) == 0)
; 504  : 	{
; 505  : 		fn_exe = vlmcsd_strdup(path);
; 506  : 	}
; 507  : 
; 508  : #	elif _WIN32
; 509  : 
; 510  : 	char path[512];
; 511  : 	GetModuleFileName(GetModuleHandle(NULL), path, 512);

  00011	33 c9		 xor	 ecx, ecx
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  00019	48 8d 54 24 20	 lea	 rdx, QWORD PTR path$[rsp]
  0001e	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00024	48 8b c8	 mov	 rcx, rax
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameA

; 512  : 	path[511] = 0;
; 513  : 	fn_exe = vlmcsd_strdup(path);

  0002d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR path$[rsp]
  00032	c6 84 24 1f 02
	00 00 00	 mov	 BYTE PTR path$[rsp+511], 0
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  00040	48 85 c0	 test	 rax, rax
  00043	75 18		 jne	 SHORT $LN4@getExeName
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  0004c	e8 00 00 00 00	 call	 errorout
  00051	b9 0e 00 00 00	 mov	 ecx, 14
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0005c	cc		 int	 3
$LN4@getExeName:
  0005d	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_exe, rax
$LN2@getExeName:

; 514  : 
; 515  : #	else
; 516  : 	// Sorry no exe detection
; 517  : #	endif
; 518  : }

  00064	48 81 c4 28 02
	00 00		 add	 rsp, 552		; 00000228H
  0006b	c3		 ret	 0
$LN12@getExeName:
getExeName ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT getDefaultDataFile
_TEXT	SEGMENT
fileName$ = 32
path$1 = 304
getDefaultDataFile PROC					; COMDAT

; 524  : {

  00000	48 81 ec 38 03
	00 00		 sub	 rsp, 824		; 00000338H

; 525  : 	char fileName[MAX_PATH];
; 526  : 	getExeName();

  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR fn_exe
  0000e	48 85 c0	 test	 rax, rax
  00011	75 59		 jne	 SHORT $LN4@getDefault
  00013	33 c9		 xor	 ecx, ecx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  0001b	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR path$1[rsp]
  00023	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00029	48 8b c8	 mov	 rcx, rax
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameA
  00032	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR path$1[rsp]
  0003a	c6 84 24 2f 03
	00 00 00	 mov	 BYTE PTR path$1[rsp+511], 0
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  00048	48 85 c0	 test	 rax, rax
  0004b	75 18		 jne	 SHORT $LN6@getDefault
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  00054	e8 00 00 00 00	 call	 errorout
  00059	b9 0e 00 00 00	 mov	 ecx, 14
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00064	cc		 int	 3
$LN6@getDefault:
  00065	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_exe, rax
$LN4@getDefault:

; 527  : 	strncpy(fileName, fn_exe, MAX_PATH);

  0006c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR fileName$[rsp]
  00071	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00077	48 8b d0	 mov	 rdx, rax
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 528  : 	PathRemoveFileSpec(fileName);

  00080	48 8d 4c 24 20	 lea	 rcx, QWORD PTR fileName$[rsp]
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PathRemoveFileSpecA

; 529  : 	strncat(fileName, "\\vlmcsd.kmd", MAX_PATH);

  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OPCADLF@?2vlmcsd?4kmd?$AA@
  00092	48 8d 4c 24 20	 lea	 rcx, QWORD PTR fileName$[rsp]
  00097	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat

; 530  : 	fn_data = vlmcsd_strdup(fileName);

  000a3	48 8d 4c 24 20	 lea	 rcx, QWORD PTR fileName$[rsp]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  000ae	48 85 c0	 test	 rax, rax
  000b1	75 18		 jne	 SHORT $LN14@getDefault
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  000ba	e8 00 00 00 00	 call	 errorout
  000bf	b9 0e 00 00 00	 mov	 ecx, 14
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  000ca	cc		 int	 3
$LN14@getDefault:
  000cb	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_data, rax

; 531  : }

  000d2	48 81 c4 38 03
	00 00		 add	 rsp, 824		; 00000338H
  000d9	c3		 ret	 0
$LN21@getDefault:
getDefaultDataFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT loadKmsData
_TEXT	SEGMENT
loadKmsData PROC					; COMDAT

; 554  : {

$LN72:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 555  : #	ifndef NO_INTERNAL_DATA
; 556  : 	KmsData = (PVlmcsdHeader_t)DefaultKmsData;
; 557  : #	endif // NO_INTERNAL_DATA
; 558  : 
; 559  : #	ifndef NO_EXTERNAL_DATA
; 560  : 	long size;
; 561  : #	ifndef NO_INTERNAL_DATA
; 562  : 	size = (long)getDefaultKmsDataSize();
; 563  : #	endif // NO_INTERNAL_DATA
; 564  : 
; 565  : #	ifndef DATA_FILE
; 566  : 	if (!fn_data) getDefaultDataFile();

  00015	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR fn_data
  0001c	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:DefaultKmsData
  00023	be 4a 05 00 00	 mov	 esi, 1354		; 0000054aH
  00028	48 89 1d 00 00
	00 00		 mov	 QWORD PTR KmsData, rbx
  0002f	48 85 ff	 test	 rdi, rdi
  00032	75 13		 jne	 SHORT $LN30@loadKmsDat
  00034	e8 00 00 00 00	 call	 getDefaultDataFile
  00039	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR KmsData
  00040	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR fn_data
$LN30@loadKmsDat:

; 567  : #	endif // DATA_FILE
; 568  : 
; 569  : 	if (strcmp(fn_data, "-"))

  00047	8a 07		 mov	 al, BYTE PTR [rdi]
  00049	41 be 01 00 00
	00		 mov	 r14d, 1
  0004f	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JOAMLHOP@?9?$AA@
  00055	75 0f		 jne	 SHORT $LN63@loadKmsDat
  00057	8a 47 01	 mov	 al, BYTE PTR [rdi+1]
  0005a	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JOAMLHOP@?9?$AA@+1
  00060	0f 84 e4 00 00
	00		 je	 $LN20@loadKmsDat
$LN63@loadKmsDat:

; 570  : 	{
; 571  : 		FILE *file = fopen(fn_data, "rb");

  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02JDPG@rb?$AA@
  0006d	48 8b cf	 mov	 rcx, rdi
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00076	48 8b d8	 mov	 rbx, rax

; 572  : 
; 573  : 		if (!file)

  00079	48 85 c0	 test	 rax, rax
  0007c	75 11		 jne	 SHORT $LN28@loadKmsDat

; 574  : 		{
; 575  : #			ifndef NO_INTERNAL_DATA
; 576  : 			if (ExplicitDataLoad)

  0007e	38 05 00 00 00
	00		 cmp	 BYTE PTR ExplicitDataLoad, al
  00084	0f 84 99 00 00
	00		 je	 $LN21@loadKmsDat
  0008a	e9 86 02 00 00	 jmp	 $LN66@loadKmsDat
$LN28@loadKmsDat:

; 580  : 			}
; 581  : 		}
; 582  : 		else
; 583  : 		{
; 584  : 			if (fseek(file, 0, SEEK_END)) dataFileReadError();

  0008f	33 d2		 xor	 edx, edx
  00091	48 8b c8	 mov	 rcx, rax
  00094	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
  0009e	85 c0		 test	 eax, eax
  000a0	0f 85 75 02 00
	00		 jne	 $LN68@loadKmsDat

; 585  : 			size = ftell(file);

  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  000af	48 63 f0	 movsxd	 rsi, eax

; 586  : 			if (size == -1L) dataFileReadError();

  000b2	83 fe ff	 cmp	 esi, -1
  000b5	0f 84 66 02 00
	00		 je	 $LN69@loadKmsDat

; 587  : 
; 588  : 			KmsData = (PVlmcsdHeader_t)vlmcsd_malloc(size);

  000bb	48 8b ce	 mov	 rcx, rsi
  000be	e8 00 00 00 00	 call	 vlmcsd_malloc

; 589  : 			if (fseek(file, 0, SEEK_SET)) dataFileReadError();

  000c3	45 33 c0	 xor	 r8d, r8d
  000c6	33 d2		 xor	 edx, edx
  000c8	48 8b cb	 mov	 rcx, rbx
  000cb	48 89 05 00 00
	00 00		 mov	 QWORD PTR KmsData, rax
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
  000d8	85 c0		 test	 eax, eax
  000da	0f 85 47 02 00
	00		 jne	 $LN70@loadKmsDat

; 590  : 
; 591  : 			size_t bytesRead = fread(KmsData, 1, size, file);

  000e0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsData
  000e7	4c 8b cb	 mov	 r9, rbx
  000ea	4c 8b c6	 mov	 r8, rsi
  000ed	49 8b d6	 mov	 rdx, r14
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread

; 592  : 			if ((long)bytesRead != size) dataFileReadError();

  000f6	3b c6		 cmp	 eax, esi
  000f8	0f 85 2f 02 00
	00		 jne	 $LN71@loadKmsDat

; 593  : 			fclose(file);

  000fe	48 8b cb	 mov	 rcx, rbx
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 594  : 
; 595  : #			if !defined(NO_LOG) && !defined(NO_SOCKETS)
; 596  : 			if (!InetdMode) logger("Read KMS data file %s\n", fn_data);

  00107	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  0010e	75 13		 jne	 SHORT $LN21@loadKmsDat
  00110	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_data
  00117	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@GJJJGOK@Read?5KMS?5data?5file?5?$CFs?6?$AA@
  0011e	e8 00 00 00 00	 call	 logger
$LN21@loadKmsDat:

; 597  : #			endif // NO_LOG
; 598  : 		}
; 599  : 
; 600  : 		if (KmsData->CsvlkCount < MIN_CSVLK)

  00123	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR KmsData
  0012a	80 7b 08 05	 cmp	 BYTE PTR [rbx+8], 5
  0012e	73 13		 jae	 SHORT $LN64@loadKmsDat

; 601  : 		{
; 602  : 			printerrorf("Warning: Legacy database: Some products are missing.\n");

  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DG@EIKFJMME@Warning?3?5Legacy?5database?3?5Some?5p@
  00137	e8 00 00 00 00	 call	 printerrorf
  0013c	48 8b 1d 00 00
	00 00		 mov	 rbx, QWORD PTR KmsData
$LN64@loadKmsDat:
  00143	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR fn_data
$LN20@loadKmsDat:

; 603  : 		}
; 604  : 	}
; 605  : 
; 606  : 
; 607  : #	endif // NO_EXTERNAL_DATA
; 608  : 
; 609  : #	if !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 610  : 
; 611  : 	if (KmsData->CsvlkCount > MIN_CSVLK)

  0014a	80 7b 08 05	 cmp	 BYTE PTR [rbx+8], 5
  0014e	76 5c		 jbe	 SHORT $LN19@loadKmsDat

; 612  : 	{
; 613  : 		KmsResponseParameters = (KmsResponseParam_t*)realloc(KmsResponseParameters, KmsData->CsvlkCount * sizeof(KmsResponseParam_t));

  00150	0f b6 43 08	 movzx	 eax, BYTE PTR [rbx+8]
  00154	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
  0015b	48 8d 14 40	 lea	 rdx, QWORD PTR [rax+rax*2]
  0015f	48 c1 e2 03	 shl	 rdx, 3
  00163	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  00169	48 8b c8	 mov	 rcx, rax
  0016c	48 89 05 00 00
	00 00		 mov	 QWORD PTR KmsResponseParameters, rax

; 614  : 		if (!KmsResponseParameters) OutOfMemory();

  00173	48 85 c0	 test	 rax, rax
  00176	75 18		 jne	 SHORT $LN18@loadKmsDat
  00178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  0017f	e8 00 00 00 00	 call	 errorout
  00184	b9 0e 00 00 00	 mov	 ecx, 14
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0018f	cc		 int	 3
$LN18@loadKmsDat:

; 615  : 		memset(KmsResponseParameters + MIN_CSVLK, 0, (KmsData->CsvlkCount - MIN_CSVLK) * sizeof(KmsResponseParam_t));

  00190	0f b6 43 08	 movzx	 eax, BYTE PTR [rbx+8]
  00194	48 83 c1 78	 add	 rcx, 120		; 00000078H
  00198	33 d2		 xor	 edx, edx
  0019a	83 e8 05	 sub	 eax, 5
  0019d	48 98		 cdqe
  0019f	4c 8d 04 40	 lea	 r8, QWORD PTR [rax+rax*2]
  001a3	49 c1 e0 03	 shl	 r8, 3
  001a7	e8 00 00 00 00	 call	 memset
$LN19@loadKmsDat:

; 616  : 	}
; 617  : 
; 618  : #	endif // !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 619  : 
; 620  : #	ifndef UNSAFE_DATA_LOAD
; 621  : 	if (((BYTE*)KmsData)[size - 1] != 0) dataFileFormatError();

  001ac	4c 63 c6	 movsxd	 r8, esi
  001af	4d 8d 14 18	 lea	 r10, QWORD PTR [r8+rbx]
  001b3	41 80 7a ff 00	 cmp	 BYTE PTR [r10-1], 0
  001b8	74 1b		 je	 SHORT $LN17@loadKmsDat
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@
  001c1	48 8b d7	 mov	 rdx, rdi
  001c4	e8 00 00 00 00	 call	 errorout
  001c9	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  001d4	cc		 int	 3
$LN17@loadKmsDat:

; 622  : #	endif // UNSAFE_DATA_LOAD
; 623  : 
; 624  : 	KmsData->MajorVer = LE16(KmsData->MajorVer);
; 625  : 	KmsData->MinorVer = LE16(KmsData->MinorVer);
; 626  : 	KmsData->AppItemCount = LE32(KmsData->AppItemCount);
; 627  : 	KmsData->KmsItemCount = LE32(KmsData->KmsItemCount);
; 628  : 	KmsData->SkuItemCount = LE32(KmsData->SkuItemCount);
; 629  : 
; 630  : 	uint32_t i;
; 631  : 
; 632  : 	for (i = 0; i < vlmcsd_countof(KmsData->Datapointers); i++)

  001d5	33 c9		 xor	 ecx, ecx
  001d7	48 8d 43 18	 lea	 rax, QWORD PTR [rbx+24]
$LL16@loadKmsDat:

; 633  : 	{
; 634  : 		KmsData->Datapointers[i].Pointer = (BYTE*)KmsData + LE64(KmsData->Datapointers[i].Offset);

  001db	48 01 18	 add	 QWORD PTR [rax], rbx

; 635  : #		ifndef UNSAFE_DATA_LOAD
; 636  : 		if ((BYTE*)KmsData->Datapointers[i].Pointer > (BYTE*)KmsData + size) dataFileFormatError();

  001de	4c 39 10	 cmp	 QWORD PTR [rax], r10
  001e1	0f 87 13 01 00
	00		 ja	 $LN51@loadKmsDat

; 622  : #	endif // UNSAFE_DATA_LOAD
; 623  : 
; 624  : 	KmsData->MajorVer = LE16(KmsData->MajorVer);
; 625  : 	KmsData->MinorVer = LE16(KmsData->MinorVer);
; 626  : 	KmsData->AppItemCount = LE32(KmsData->AppItemCount);
; 627  : 	KmsData->KmsItemCount = LE32(KmsData->KmsItemCount);
; 628  : 	KmsData->SkuItemCount = LE32(KmsData->SkuItemCount);
; 629  : 
; 630  : 	uint32_t i;
; 631  : 
; 632  : 	for (i = 0; i < vlmcsd_countof(KmsData->Datapointers); i++)

  001e7	41 03 ce	 add	 ecx, r14d
  001ea	48 83 c0 08	 add	 rax, 8
  001ee	83 f9 03	 cmp	 ecx, 3
  001f1	72 e8		 jb	 SHORT $LL16@loadKmsDat

; 637  : #		endif // UNSAFE_DATA_LOAD
; 638  : 	}
; 639  : 
; 640  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  001f3	33 d2		 xor	 edx, edx
  001f5	38 53 08	 cmp	 BYTE PTR [rbx+8], dl
  001f8	76 23		 jbe	 SHORT $LN10@loadKmsDat
$LL12@loadKmsDat:

; 641  : 	{
; 642  : 		PCsvlkData_t csvlkData = &KmsData->CsvlkData[i];

  001fa	8b c2		 mov	 eax, edx
  001fc	48 83 c0 02	 add	 rax, 2
  00200	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]

; 643  : 		csvlkData->EPid = (char*)KmsData + LE64(csvlkData->EPidOffset);

  00204	48 01 1c cb	 add	 QWORD PTR [rbx+rcx*8], rbx

; 644  : #		ifndef UNSAFE_DATA_LOAD
; 645  : 		if (csvlkData->EPid > (char*)KmsData + size) dataFileFormatError();

  00208	4c 39 14 cb	 cmp	 QWORD PTR [rbx+rcx*8], r10
  0020c	0f 87 97 00 00
	00		 ja	 $LN52@loadKmsDat

; 637  : #		endif // UNSAFE_DATA_LOAD
; 638  : 	}
; 639  : 
; 640  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  00212	0f b6 43 08	 movzx	 eax, BYTE PTR [rbx+8]
  00216	41 03 d6	 add	 edx, r14d
  00219	3b d0		 cmp	 edx, eax
  0021b	72 dd		 jb	 SHORT $LL12@loadKmsDat
$LN10@loadKmsDat:

; 646  : #		endif // UNSAFE_DATA_LOAD
; 647  : 
; 648  : #		ifndef NO_RANDOM_EPID
; 649  : 		csvlkData->GroupId = LE32(csvlkData->GroupId);
; 650  : 		csvlkData->MinKeyId = LE32(csvlkData->MinKeyId);
; 651  : 		csvlkData->MaxKeyId = LE32(csvlkData->MaxKeyId);
; 652  : #		endif // NO_RANDOM_EPID
; 653  : 	}
; 654  : 
; 655  : 	uint32_t totalItemCount = KmsData->AppItemCount + KmsData->KmsItemCount + KmsData->SkuItemCount;

  0021d	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]

; 656  : 
; 657  : #	ifndef NO_EXTERNAL_DATA
; 658  : 	if (
; 659  : 		memcmp(KmsData->Magic, "KMD", sizeof(KmsData->Magic)) ||
; 660  : 		KmsData->MajorVer != 1
; 661  : #		ifndef UNSAFE_DATA_LOAD
; 662  : 		||
; 663  : 		sizeof(VlmcsdHeader_t) + totalItemCount * sizeof(VlmcsdData_t) >= ((uint64_t)size)
; 664  : #		endif //UNSAFE_DATA_LOAD
; 665  : 		)

  00220	8b 03		 mov	 eax, DWORD PTR [rbx]
  00222	03 53 14	 add	 edx, DWORD PTR [rbx+20]
  00225	03 53 0c	 add	 edx, DWORD PTR [rbx+12]
  00228	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ??_C@_03HOPJGLEN@KMD?$AA@
  0022e	0f 85 ab 00 00
	00		 jne	 $LN7@loadKmsDat
  00234	66 44 39 73 06	 cmp	 WORD PTR [rbx+6], r14w
  00239	0f 85 a0 00 00
	00		 jne	 $LN7@loadKmsDat
  0023f	8b c2		 mov	 eax, edx
  00241	48 c1 e0 05	 shl	 rax, 5
  00245	48 83 c0 48	 add	 rax, 72			; 00000048H
  00249	49 3b c0	 cmp	 rax, r8
  0024c	0f 83 8d 00 00
	00		 jae	 $LN7@loadKmsDat

; 668  : 	}
; 669  : #	endif // NO_EXTERNAL_DATA
; 670  : 
; 671  : 	for (i = 0; i < totalItemCount; i++)

  00252	45 33 c9	 xor	 r9d, r9d
  00255	85 d2		 test	 edx, edx
  00257	74 3a		 je	 SHORT $LN4@loadKmsDat
  00259	33 c9		 xor	 ecx, ecx
$LL6@loadKmsDat:

; 672  : 	{
; 673  : 		PVlmcsdData_t item = &KmsData->AppItemList[i];

  0025b	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]

; 674  : 		item->Name = (char*)KmsData + LE64(item->NameOffset);

  0025f	4a 01 5c 01 10	 add	 QWORD PTR [rcx+r8+16], rbx

; 675  : 
; 676  : #		ifndef UNSAFE_DATA_LOAD
; 677  : 		if (
; 678  : 			item->Name >= (char*)KmsData + (uint64_t)size ||
; 679  : 			(KmsData->AppItemCount && item->AppIndex >= KmsData->AppItemCount) ||
; 680  : 			item->KmsIndex >= KmsData->KmsItemCount
; 681  : 			)

  00264	4e 39 54 01 10	 cmp	 QWORD PTR [rcx+r8+16], r10
  00269	73 59		 jae	 SHORT $LN53@loadKmsDat
  0026b	83 7b 0c 00	 cmp	 DWORD PTR [rbx+12], 0
  0026f	74 0b		 je	 SHORT $LN1@loadKmsDat
  00271	42 0f b6 44 01
	18		 movzx	 eax, BYTE PTR [rcx+r8+24]
  00277	3b 43 0c	 cmp	 eax, DWORD PTR [rbx+12]
  0027a	7d 48		 jge	 SHORT $LN53@loadKmsDat
$LN1@loadKmsDat:
  0027c	42 0f b6 44 01
	19		 movzx	 eax, BYTE PTR [rcx+r8+25]
  00282	3b 43 10	 cmp	 eax, DWORD PTR [rbx+16]
  00285	7d 3d		 jge	 SHORT $LN53@loadKmsDat

; 668  : 	}
; 669  : #	endif // NO_EXTERNAL_DATA
; 670  : 
; 671  : 	for (i = 0; i < totalItemCount; i++)

  00287	45 03 ce	 add	 r9d, r14d
  0028a	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0028e	44 3b ca	 cmp	 r9d, edx
  00291	72 c8		 jb	 SHORT $LL6@loadKmsDat
$LN4@loadKmsDat:

; 684  : 		}
; 685  : #		endif // UNSAFE_DATA_LOAD
; 686  : 	}
; 687  : }

  00293	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00298	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0029d	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  002a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  002a6	41 5e		 pop	 r14
  002a8	c3		 ret	 0
$LN52@loadKmsDat:

; 644  : #		ifndef UNSAFE_DATA_LOAD
; 645  : 		if (csvlkData->EPid > (char*)KmsData + size) dataFileFormatError();

  002a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@
  002b0	48 8b d7	 mov	 rdx, rdi
  002b3	e8 00 00 00 00	 call	 errorout
  002b8	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  002bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  002c3	cc		 int	 3
$LN53@loadKmsDat:

; 682  : 		{
; 683  : 			dataFileFormatError();

  002c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@
  002cb	48 8b d7	 mov	 rdx, rdi
  002ce	e8 00 00 00 00	 call	 errorout
  002d3	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  002de	cc		 int	 3
$LN7@loadKmsDat:

; 666  : 	{
; 667  : 		dataFileFormatError();

  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@
  002e6	48 8b d7	 mov	 rdx, rdi
  002e9	e8 00 00 00 00	 call	 errorout
  002ee	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  002f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  002f9	cc		 int	 3
$LN51@loadKmsDat:

; 635  : #		ifndef UNSAFE_DATA_LOAD
; 636  : 		if ((BYTE*)KmsData->Datapointers[i].Pointer > (BYTE*)KmsData + size) dataFileFormatError();

  002fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CC@KJJBHHPI@Fatal?3?5?$CFs?5is?5not?5a?5KMS?5data?5file@
  00301	48 8b d7	 mov	 rdx, rdi
  00304	e8 00 00 00 00	 call	 errorout
  00309	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  0030e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00314	cc		 int	 3
$LN66@loadKmsDat:

; 577  : #			endif // NO_INTERNAL_DATA
; 578  : 			{
; 579  : 				dataFileReadError();

  00315	e8 00 00 00 00	 call	 dataFileReadError
  0031a	cc		 int	 3
$LN68@loadKmsDat:

; 580  : 			}
; 581  : 		}
; 582  : 		else
; 583  : 		{
; 584  : 			if (fseek(file, 0, SEEK_END)) dataFileReadError();

  0031b	e8 00 00 00 00	 call	 dataFileReadError
  00320	cc		 int	 3
$LN69@loadKmsDat:

; 586  : 			if (size == -1L) dataFileReadError();

  00321	e8 00 00 00 00	 call	 dataFileReadError
  00326	cc		 int	 3
$LN70@loadKmsDat:

; 589  : 			if (fseek(file, 0, SEEK_SET)) dataFileReadError();

  00327	e8 00 00 00 00	 call	 dataFileReadError
  0032c	cc		 int	 3
$LN71@loadKmsDat:

; 592  : 			if ((long)bytesRead != size) dataFileReadError();

  0032d	e8 00 00 00 00	 call	 dataFileReadError
  00332	cc		 int	 3
$LN65@loadKmsDat:
loadKmsData ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\helpers.c
;	COMDAT exitOnWarningLevel
_TEXT	SEGMENT
level$dead$ = 48
exitOnWarningLevel PROC					; COMDAT

; 691  : {

$LN6:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 692  : 	if (ExitLevel >= level)

  00004	8a 05 00 00 00
	00		 mov	 al, BYTE PTR ExitLevel
  0000a	3c 01		 cmp	 al, 1
  0000c	7c 19		 jl	 SHORT $LN1@exitOnWarn

; 693  : 	{
; 694  : 		printerrorf("Fatal: Exiting on warning level %i or greater\n", (int)ExitLevel);

  0000e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level?5@
  00015	0f be d0	 movsx	 edx, al
  00018	e8 00 00 00 00	 call	 printerrorf

; 695  : 		exit(-1);

  0001d	83 c9 ff	 or	 ecx, -1
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00026	cc		 int	 3
$LN1@exitOnWarn:

; 696  : 	}
; 697  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
$LN5@exitOnWarn:
exitOnWarningLevel ENDP
_TEXT	ENDS
END
