; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_07NBCGADJA@Unknown?$AA@			; `string'
PUBLIC	??_C@_01FGNFDNOH@?$CF?$AA@			; `string'
PUBLIC	??_C@_01OMGOGALD@u?$AA@				; `string'
PUBLIC	??_C@_04PGKABKNA@?903?9?$AA@			; `string'
PUBLIC	??_C@_06KMCAJKLF@?40000?9?$AA@			; `string'
PUBLIC	??_C@_0BM@KDKADHPB@randomized?5at?5program?5start?$AA@ ; `string'
PUBLIC	??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5?$CF@ ; `string'
PUBLIC	??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request?$AA@ ; `string'
PUBLIC	??_C@_0P@CACDFLGA@vlmcsd?5default?$AA@		; `string'
PUBLIC	??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sourc@ ; `string'
PUBLIC	??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5than@ ; `string'
PUBLIC	??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54?5@ ; `string'
PUBLIC	??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product?5@ ; `string'
PUBLIC	??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC004@ ; `string'
PUBLIC	??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect?5@ ; `string'
PUBLIC	??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients?5@ ; `string'
PUBLIC	CreateResponseBase
EXTRN	__imp__time64:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_memmove:PROC
EXTRN	__imp__gmtime64:PROC
EXTRN	__imp_sprintf:PROC
EXTRN	__imp__stricmp:PROC
ZeroGuid DB	010H DUP (?)
COMM	mutex:QWORD
_DATA	ENDS
_DATA	ENDS
;	COMDAT ??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients?5@
CONST	SEGMENT
??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients?5@ DB 'Rejecting m'
	DB	'ore than 671 clients (0xC004D104)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect?5@
CONST	SEGMENT
??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect?5@ DB 'Refusing pro'
	DB	'duct with incorrect Application ID (0xC004F042)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC004@
CONST	SEGMENT
??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC004@ DB 'Refusing u'
	DB	'nknown product (0xC004F042)', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product?5@
CONST	SEGMENT
??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product?5@ DB 'Refusing re'
	DB	'tail or beta product (0xC004F042)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54?5@
CONST	SEGMENT
??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54?5@ DB 'Client tim'
	DB	'e differs more than 4 hours from system time (0xC004F06C)', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5than@
CONST	SEGMENT
??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5than@ DB 'Rejecting re'
	DB	'quest with more than 1000 minimum clients (0x8007000D)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sourc@
CONST	SEGMENT
??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sourc@ DB '>>'
	DB	'> Sending response, ePID source = %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6?$AA@ DB 'Sendi'
	DB	'ng ePID (%s): %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CACDFLGA@vlmcsd?5default?$AA@
CONST	SEGMENT
??_C@_0P@CACDFLGA@vlmcsd?5default?$AA@ DB 'vlmcsd default', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request?$AA@
CONST	SEGMENT
??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request?$AA@ DB 'randomized on '
	DB	'every request', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5?$CF@
CONST	SEGMENT
??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5?$CF@ DB 'K'
	DB	'MS v%i.%i request from %s for %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6?$AA@
CONST	SEGMENT
??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6?$AA@ DB '<<< In'
	DB	'coming KMS request', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@KDKADHPB@randomized?5at?5program?5start?$AA@
CONST	SEGMENT
??_C@_0BM@KDKADHPB@randomized?5at?5program?5start?$AA@ DB 'randomized at '
	DB	'program start', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_06KMCAJKLF@?40000?9?$AA@
CONST	SEGMENT
??_C@_06KMCAJKLF@?40000?9?$AA@ DB '.0000-', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PGKABKNA@?903?9?$AA@
CONST	SEGMENT
??_C@_04PGKABKNA@?903?9?$AA@ DB '-03-', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01OMGOGALD@u?$AA@
CONST	SEGMENT
??_C@_01OMGOGALD@u?$AA@ DB 'u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FGNFDNOH@?$CF?$AA@
CONST	SEGMENT
??_C@_01FGNFDNOH@?$CF?$AA@ DB '%', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07NBCGADJA@Unknown?$AA@
CONST	SEGMENT
??_C@_07NBCGADJA@Unknown?$AA@ DB 'Unknown', 00H		; `string'
?DefaultHwid@?1??CreateResponseV6@@9@9 DB 03aH		; `CreateResponseV6'::`2'::DefaultHwid
	DB	01cH
	DB	04H
	DB	096H
	DB	00H
	DB	0b6H
	DB	00H
	DB	076H
HostOS	DW	0d701H
	DW	01772H
	DW	0d701H
	DW	01db1H
	DW	01532H
	DW	023f0H
	DW	01901H
	DW	02580H
	DW	0e1cH
	DW	03839H
	ORG $+4
LcidList DW	0436H
	DW	041cH
	DW	0401H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01401H
	DW	01801H
	DW	01c01H
	DW	02001H
	DW	02401H
	DW	02801H
	DW	02c01H
	DW	03001H
	DW	03401H
	DW	03801H
	DW	03c01H
	DW	04001H
	DW	042bH
	DW	042cH
	DW	082cH
	DW	042dH
	DW	0423H
	DW	0445H
	DW	0141aH
	DW	0402H
	DW	0403H
	DW	0404H
	DW	0804H
	DW	0c04H
	DW	01004H
	DW	01404H
	DW	041aH
	DW	0101aH
	DW	0405H
	DW	0406H
	DW	0465H
	DW	0413H
	DW	0813H
	DW	0409H
	DW	0809H
	DW	0c09H
	DW	01009H
	DW	01409H
	DW	01809H
	DW	01c09H
	DW	02009H
	DW	02409H
	DW	02809H
	DW	02c09H
	DW	03009H
	DW	03409H
	DW	0425H
	DW	0438H
	DW	0429H
	DW	040bH
	DW	040cH
	DW	080cH
	DW	0c0cH
	DW	0100cH
	DW	0140cH
	DW	0180cH
	DW	0437H
	DW	0456H
	DW	0407H
	DW	0807H
	DW	0c07H
	DW	01007H
	DW	01407H
	DW	0408H
	DW	0447H
	DW	040dH
	DW	0439H
	DW	040eH
	DW	040fH
	DW	0421H
	DW	0410H
	DW	0810H
	DW	0411H
	DW	044bH
	DW	043fH
	DW	0457H
	DW	0412H
	DW	0440H
	DW	0426H
	DW	0427H
	DW	042fH
	DW	043eH
	DW	083eH
	DW	044cH
	DW	043aH
	DW	0481H
	DW	044eH
	DW	0450H
	DW	0414H
	DW	0814H
	DW	0415H
	DW	0416H
	DW	0816H
	DW	0446H
	DW	046bH
	DW	086bH
	DW	0c6bH
	DW	0418H
	DW	0419H
	DW	0243bH
	DW	0103bH
	DW	0143bH
	DW	0c3bH
	DW	043bH
	DW	083bH
	DW	0203bH
	DW	0183bH
	DW	01c3bH
	DW	044fH
	DW	081aH
	DW	0181aH
	DW	0c1aH
	DW	01c1aH
	DW	041bH
	DW	0424H
	DW	040aH
	DW	080aH
	DW	0c0aH
	DW	0100aH
	DW	0140aH
	DW	0180aH
	DW	01c0aH
	DW	0200aH
	DW	0240aH
	DW	0280aH
	DW	02c0aH
	DW	0300aH
	DW	0340aH
	DW	0380aH
	DW	03c0aH
	DW	0400aH
	DW	0440aH
	DW	0480aH
	DW	04c0aH
	DW	0500aH
	DW	0441H
	DW	041dH
	DW	081dH
	DW	045aH
	DW	0449H
	DW	0444H
	DW	044aH
	DW	041eH
	DW	0432H
	DW	0422H
	DW	0420H
	DW	0443H
	DW	0843H
	DW	042aH
	DW	0452H
	DW	0434H
	DW	0435H
	ORG $+4
CreateResponseBase DQ FLAT:CreateResponseBaseCallback
PUBLIC	CreateResponseV6
PUBLIC	CreateResponseV4
PUBLIC	get16RandomBytes
PUBLIC	randomPidInit
PUBLIC	InitializeClientLists
PUBLIC	CleanUpClientLists
PUBLIC	fileTimeToUnixTime
PUBLIC	getProductIndex
ClientLists DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateResponseV6 DD imagerel $LN17
	DD	imagerel $LN17+388
	DD	imagerel $unwind$CreateResponseV6
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateV6Hmac DD imagerel CreateV6Hmac
	DD	imagerel CreateV6Hmac+462
	DD	imagerel $unwind$CreateV6Hmac
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateResponseV4 DD imagerel $LN5
	DD	imagerel $LN5+96
	DD	imagerel $unwind$CreateResponseV4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get16RandomBytes DD imagerel $LN11
	DD	imagerel $LN11+81
	DD	imagerel $unwind$get16RandomBytes
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateResponseBaseCallback DD imagerel CreateResponseBaseCallback
	DD	imagerel CreateResponseBaseCallback+1564
	DD	imagerel $unwind$CreateResponseBaseCallback
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$logResponse DD imagerel logResponse
	DD	imagerel logResponse+127
	DD	imagerel $unwind$logResponse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getEpid DD imagerel getEpid
	DD	imagerel getEpid+376
	DD	imagerel $unwind$getEpid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getEpidFromString DD imagerel getEpidFromString
	DD	imagerel getEpidFromString+228
	DD	imagerel $unwind$getEpidFromString
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$logRequest DD imagerel logRequest
	DD	imagerel logRequest+300
	DD	imagerel $unwind$logRequest
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getProductIndexFromAllLists DD imagerel getProductIndexFromAllLists
	DD	imagerel getProductIndexFromAllLists+46
	DD	imagerel $unwind$getProductIndexFromAllLists
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$randomPidInit DD imagerel $LN24
	DD	imagerel $LN24+255
	DD	imagerel $unwind$randomPidInit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$generateRandomPid DD imagerel generateRandomPid
	DD	imagerel generateRandomPid+919
	DD	imagerel $unwind$generateRandomPid
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getRandomServerType DD imagerel getRandomServerType
	DD	imagerel getRandomServerType+120
	DD	imagerel $unwind$getRandomServerType
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$itoc DD	imagerel itoc
	DD	imagerel itoc+95
	DD	imagerel $unwind$itoc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$InitializeClientLists DD imagerel $LN23
	DD	imagerel $LN23+248
	DD	imagerel $unwind$InitializeClientLists
;	COMDAT xdata
xdata	SEGMENT
$unwind$InitializeClientLists DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$itoc DD	020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getRandomServerType DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$generateRandomPid DD 0c1f01H
	DD	011741fH
	DD	010641fH
	DD	0e341fH
	DD	0f018721fH
	DD	0d014e016H
	DD	05010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$randomPidInit DD 0a1901H
	DD	0117419H
	DD	0106419H
	DD	0f5419H
	DD	0e3419H
	DD	0e015b219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getProductIndexFromAllLists DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$logRequest DD 035091e01H
	DD	013741eH
	DD	012641aH
	DD	0103416H
	DD	0d206330bH
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getEpidFromString DD 081201H
	DD	0a5412H
	DD	093412H
	DD	0f00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getEpid DD 0a1801H
	DD	0136418H
	DD	0125418H
	DD	0113418H
	DD	0e014b218H
	DD	07010c012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$logResponse DD 071201H
	DD	01f6412H
	DD	01e3412H
	DD	01c0112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateResponseBaseCallback DD 0d2401H
	DD	0377424H
	DD	0366424H
	DD	0353424H
	DD	02e0124H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get16RandomBytes DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateResponseV4 DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateV6Hmac DD 071701H
	DD	0140117H
	DD	07009e00bH
	DD	030076008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateResponseV6 DD 0b1901H
	DD	0265419H
	DD	0253419H
	DD	01e0119H
	DD	0e010f012H
	DD	0700cc00eH
	DD	0600bH
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
;	COMDAT gmtime
_TEXT	SEGMENT
_Time$ = 8
gmtime	PROC						; COMDAT

; 101  : #pragma warning( push )
; 102  : #pragma warning( disable : 4996 )
; 103  :     return _gmtime64(_Time);

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__gmtime64
gmtime	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft visual studio 12.0\vc\include\time.inl
;	COMDAT time
_TEXT	SEGMENT
_Time$ = 8
time	PROC						; COMDAT

; 133  :     return _time64(_Time);

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__time64
time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT getProductIndex
_TEXT	SEGMENT
guid$ = 8
list$ = 16
count$ = 24
name$ = 32
ePid$ = 40
getProductIndex PROC					; COMDAT

; 48   : 	int i;
; 49   : 
; 50   : 	for (i = count - 1; i >= 0; i--)

  00000	41 ff c8	 dec	 r8d
$LN18@getProduct:
  00003	78 62		 js	 SHORT $LN17@getProduct

; 51   : 	{
; 52   : 		if (IsEqualGUID(guid, &list[i].Guid))

  00005	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00008	4d 63 d0	 movsxd	 r10, r8d
  0000b	49 c1 e2 05	 shl	 r10, 5
  0000f	49 3b 04 12	 cmp	 rax, QWORD PTR [r10+rdx]
  00013	75 0b		 jne	 SHORT $LN16@getProduct
  00015	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00019	49 3b 44 12 08	 cmp	 rax, QWORD PTR [r10+rdx+8]
  0001e	74 05		 je	 SHORT $LN12@getProduct
$LN16@getProduct:

; 48   : 	int i;
; 49   : 
; 50   : 	for (i = count - 1; i >= 0; i--)

  00020	41 ff c8	 dec	 r8d
  00023	eb de		 jmp	 SHORT $LN18@getProduct
$LN12@getProduct:

; 53   : 		{
; 54   : 			if (name) *name = list[i].Name;

  00025	4d 85 c9	 test	 r9, r9
  00028	74 0f		 je	 SHORT $LN4@getProduct
  0002a	49 63 c0	 movsxd	 rax, r8d
  0002d	48 c1 e0 05	 shl	 rax, 5
  00031	48 8b 44 10 10	 mov	 rax, QWORD PTR [rax+rdx+16]
  00036	49 89 01	 mov	 QWORD PTR [r9], rax
$LN4@getProduct:

; 55   : 			if (ePid) *ePid = KmsData->CsvlkData[list[i].EPidIndex].EPid;

  00039	48 8b 44 24 28	 mov	 rax, QWORD PTR ePid$[rsp]
  0003e	48 85 c0	 test	 rax, rax
  00041	74 4b		 je	 SHORT $LN1@getProduct
  00043	49 63 c8	 movsxd	 rcx, r8d
  00046	48 c1 e1 05	 shl	 rcx, 5
  0004a	0f b6 54 11 1e	 movzx	 edx, BYTE PTR [rcx+rdx+30]
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsData
  00056	48 83 c2 02	 add	 rdx, 2
  0005a	48 8d 14 52	 lea	 rdx, QWORD PTR [rdx+rdx*2]
  0005e	48 8b 14 d1	 mov	 rdx, QWORD PTR [rcx+rdx*8]
  00062	48 89 10	 mov	 QWORD PTR [rax], rdx

; 56   : 			return i;

  00065	eb 27		 jmp	 SHORT $LN1@getProduct
$LN17@getProduct:

; 57   : 		}
; 58   : 	}
; 59   : 
; 60   : 	if (name) *name = "Unknown";

  00067	4d 85 c9	 test	 r9, r9
  0006a	74 0a		 je	 SHORT $LN2@getProduct
  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_07NBCGADJA@Unknown?$AA@
  00073	49 89 01	 mov	 QWORD PTR [r9], rax
$LN2@getProduct:

; 61   : 	if (ePid) *ePid = KmsData->CsvlkData[EPID_INDEX_WINDOWS].EPid;

  00076	48 8b 54 24 28	 mov	 rdx, QWORD PTR ePid$[rsp]
  0007b	48 85 d2	 test	 rdx, rdx
  0007e	74 0e		 je	 SHORT $LN1@getProduct
  00080	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KmsData
  00087	48 8b 48 30	 mov	 rcx, QWORD PTR [rax+48]
  0008b	48 89 0a	 mov	 QWORD PTR [rdx], rcx
$LN1@getProduct:

; 62   : 	return i;

  0008e	41 8b c0	 mov	 eax, r8d

; 63   : }

  00091	c3		 ret	 0
getProductIndex ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT fileTimeToUnixTime
_TEXT	SEGMENT
ts$ = 8
fileTimeToUnixTime PROC					; COMDAT

; 121  : 	return GET_UA64LE(ts) / 10000000LL - 11644473600LL;

  00000	48 b8 bd 42 7a
	e5 d5 94 bf d6	 mov	 rax, -2972493582642298179 ; d6bf94d5e57a42bdH
  0000a	48 f7 21	 mul	 QWORD PTR [rcx]
  0000d	48 b8 00 91 10
	b6 02 00 00 00	 mov	 rax, 11644473600	; 00000002b6109100H
  00017	48 c1 ea 17	 shr	 rdx, 23
  0001b	48 2b d0	 sub	 rdx, rax
  0001e	48 8b c2	 mov	 rax, rdx

; 122  : }

  00021	c3		 ret	 0
fileTimeToUnixTime ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT CleanUpClientLists
_TEXT	SEGMENT
CleanUpClientLists PROC					; COMDAT

; 155  : #	ifndef USE_THREADS
; 156  : 	shmctl(shmid_clients, IPC_RMID, NULL);
; 157  : #	endif // !USE_THREADS
; 158  : }

  00000	c2 00 00	 ret	 0
CleanUpClientLists ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT InitializeClientLists
_TEXT	SEGMENT
InitializeClientLists PROC				; COMDAT

; 161  : {

$LN23:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 162  : 	int_fast8_t i;
; 163  : 	int_fast16_t j;
; 164  : 
; 165  : #	ifndef USE_THREADS
; 166  : 	if (
; 167  : 		(shmid_clients = shmget(IPC_PRIVATE, sizeof(ClientList_t) * KmsData->AppItemCount + mutex_size, IPC_CREAT | 0600)) < 0 ||
; 168  : 		(mutex = (mutex_t*)shmat(shmid_clients, NULL, 0)) == (mutex_t*)-1
; 169  : 		)
; 170  : 	{
; 171  : 		int errno_save = errno;
; 172  : 		printerrorf("Warning: CMID lists disabled. Could not create shared memory: %s\n", vlmcsd_strerror(errno_save));
; 173  : 		if (shmid_clients >= 0) shmctl(shmid_clients, IPC_RMID, NULL);
; 174  : 		MaintainClients = FALSE;
; 175  : 		return;
; 176  : 	}
; 177  : 
; 178  : 	ClientLists = (PClientList_t)((BYTE*)mutex + mutex_size);
; 179  : 
; 180  : #	if __CYGWIN__
; 181  : 	InitializeCriticalSection(mutex);
; 182  : #	else // !__CYGWIN__
; 183  : 	pthread_mutexattr_t mutex_attr;
; 184  : 	pthread_mutexattr_init(&mutex_attr);
; 185  : 	pthread_mutexattr_setpshared(&mutex_attr, PTHREAD_PROCESS_SHARED);
; 186  : 	pthread_mutex_init(mutex, &mutex_attr);
; 187  : 
; 188  : #	endif // !__CYGWIN__
; 189  : 
; 190  : #	else // USE_THREADS
; 191  : 
; 192  : 	ClientLists = (PClientList_t)vlmcsd_malloc(sizeof(ClientList_t) * KmsData->AppItemCount);

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KmsData
  0001c	48 63 48 0c	 movsxd	 rcx, DWORD PTR [rax+12]
  00020	48 69 c9 fc 29
	00 00		 imul	 rcx, rcx, 10748		; 000029fcH
  00027	e8 00 00 00 00	 call	 vlmcsd_malloc

; 193  : 	mutex = (mutex_t*)vlmcsd_malloc(sizeof(mutex_t));

  0002c	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00031	48 89 05 00 00
	00 00		 mov	 QWORD PTR ClientLists, rax
  00038	e8 00 00 00 00	 call	 vlmcsd_malloc

; 194  : 
; 195  : #	if !_WIN32 && !__CYGWIN__
; 196  : 	pthread_mutex_init(mutex, NULL);
; 197  : #	else //_WIN32 || __CYGWIN__
; 198  : 	InitializeCriticalSection(mutex);

  0003d	48 8b c8	 mov	 rcx, rax
  00040	48 89 05 00 00
	00 00		 mov	 QWORD PTR mutex, rax
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 199  : #   endif //_WIN32 || __CYGWIN__
; 200  : 
; 201  : #	endif // USE_THREADS
; 202  : 
; 203  : 	memset(ClientLists, 0, sizeof(ClientList_t) * KmsData->AppItemCount);

  0004d	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR KmsData
  00054	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ClientLists
  0005b	48 63 46 0c	 movsxd	 rax, DWORD PTR [rsi+12]
  0005f	33 d2		 xor	 edx, edx
  00061	48 8b cf	 mov	 rcx, rdi
  00064	4c 69 c0 fc 29
	00 00		 imul	 r8, rax, 10748		; 000029fcH
  0006b	e8 00 00 00 00	 call	 memset

; 204  : 
; 205  : 	if (!StartEmpty)

  00070	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR StartEmpty, 0
  00077	75 69		 jne	 SHORT $LN4@Initialize

; 206  : 	{
; 207  : 		for (i = 0; i < KmsData->AppItemCount; i++)

  00079	32 db		 xor	 bl, bl
  0007b	83 7e 0c 00	 cmp	 DWORD PTR [rsi+12], 0
  0007f	7e 61		 jle	 SHORT $LN4@Initialize
$LL6@Initialize:

; 208  : 		{
; 209  : 			uint8_t maxCount = KmsData->AppItemList[i].NCountPolicy;

  00081	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  00085	4c 0f be c3	 movsx	 r8, bl
  00089	49 8b c8	 mov	 rcx, r8
  0008c	48 c1 e1 05	 shl	 rcx, 5

; 210  : 			ClientLists[i].CurrentCount = (maxCount >> 1) - 1;

  00090	4d 69 f0 fc 29
	00 00		 imul	 r14, r8, 10748		; 000029fcH
  00097	0f b6 54 01 1b	 movzx	 edx, BYTE PTR [rcx+rax+27]
  0009c	8b c2		 mov	 eax, edx

; 211  : 			ClientLists[i].MaxCount = maxCount;

  0009e	41 89 94 3e f4
	29 00 00	 mov	 DWORD PTR [r14+rdi+10740], edx
  000a6	d1 e8		 shr	 eax, 1
  000a8	ff c8		 dec	 eax
  000aa	41 89 84 3e f0
	29 00 00	 mov	 DWORD PTR [r14+rdi+10736], eax

; 212  : 
; 213  : 			for (j = 0; j < (maxCount >> 1) - 1; j++)

  000b2	85 c0		 test	 eax, eax
  000b4	7e 22		 jle	 SHORT $LN5@Initialize

; 208  : 		{
; 209  : 			uint8_t maxCount = KmsData->AppItemList[i].NCountPolicy;

  000b6	8b f0		 mov	 esi, eax
$LL3@Initialize:

; 214  : 			{
; 215  : 				get16RandomBytes(&ClientLists[i].Guid[j]);

  000b8	49 8d 0c 3e	 lea	 rcx, QWORD PTR [r14+rdi]
  000bc	e8 00 00 00 00	 call	 get16RandomBytes
  000c1	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR ClientLists
  000c8	4d 8d 76 10	 lea	 r14, QWORD PTR [r14+16]
  000cc	48 ff ce	 dec	 rsi
  000cf	75 e7		 jne	 SHORT $LL3@Initialize

; 212  : 
; 213  : 			for (j = 0; j < (maxCount >> 1) - 1; j++)

  000d1	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR KmsData
$LN5@Initialize:

; 206  : 	{
; 207  : 		for (i = 0; i < KmsData->AppItemCount; i++)

  000d8	fe c3		 inc	 bl
  000da	0f be c3	 movsx	 eax, bl
  000dd	3b 46 0c	 cmp	 eax, DWORD PTR [rsi+12]
  000e0	7c 9f		 jl	 SHORT $LL6@Initialize
$LN4@Initialize:

; 216  : 			}
; 217  : 		}
; 218  : 	}
; 219  : }

  000e2	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000e7	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ec	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000f1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f5	41 5e		 pop	 r14
  000f7	c3		 ret	 0
InitializeClientLists ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT itoc
_TEXT	SEGMENT
formatString$ = 48
c$ = 48
i$ = 56
digits$ = 64
itoc	PROC						; COMDAT

; 226  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 227  : 	char formatString[8];
; 228  : 	if (digits > 9) digits = 0;
; 229  : 	strcpy(formatString, "%");

  00006	b8 25 00 00 00	 mov	 eax, 37			; 00000025H
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	66 89 44 24 30	 mov	 WORD PTR formatString$[rsp], ax

; 230  : 
; 231  : 	if (digits)

  00013	45 84 c0	 test	 r8b, r8b
  00016	74 13		 je	 SHORT $LN1@itoc

; 232  : 	{
; 233  : 		formatString[1] = '0';
; 234  : 		formatString[2] = digits | 0x30;

  00018	41 80 c8 30	 or	 r8b, 48			; 00000030H
  0001c	c6 44 24 31 30	 mov	 BYTE PTR formatString$[rsp+1], 48 ; 00000030H

; 235  : 		formatString[3] = 0;

  00021	c6 44 24 33 00	 mov	 BYTE PTR formatString$[rsp+3], 0
  00026	44 88 44 24 32	 mov	 BYTE PTR formatString$[rsp+2], r8b
$LN1@itoc:

; 236  : 	}
; 237  : 
; 238  : 	strcat(formatString, "u");

  0002b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR formatString$[rsp]
  00030	48 ff c9	 dec	 rcx
$LL5@itoc:
  00033	48 ff c1	 inc	 rcx
  00036	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00039	75 f8		 jne	 SHORT $LL5@itoc
  0003b	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01OMGOGALD@u?$AA@

; 239  : 	sprintf(c, formatString, i);

  00042	44 8b c2	 mov	 r8d, edx
  00045	48 8d 54 24 30	 lea	 rdx, QWORD PTR formatString$[rsp]
  0004a	66 89 01	 mov	 WORD PTR [rcx], ax
  0004d	48 8b cb	 mov	 rcx, rbx
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 240  : 	return c;

  00056	48 8b c3	 mov	 rax, rbx

; 241  : }

  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5b		 pop	 rbx
  0005e	c3		 ret	 0
itoc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT getRandomServerType
_TEXT	SEGMENT
getRandomServerType PROC				; COMDAT

; 244  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 245  : #	if defined(USE_MSRPC) || defined(SIMPLE_RPC)
; 246  : 
; 247  : 	return rand() % (int)vlmcsd_countof(HostOS);
; 248  : 
; 249  : #	else // !defined(USE_MSRPC) && !defined(SIMPLE_RPC)
; 250  : 	if (!UseServerRpcBTFN)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR UseServerRpcBTFN, 0
  0000b	75 25		 jne	 SHORT $LN2@getRandomS

; 251  : 	{
; 252  : 		// This isn't possible at all, e.g. KMS host on XP
; 253  : 		return rand() % (int)vlmcsd_countof(HostOS);

  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00013	44 8b c0	 mov	 r8d, eax
  00016	b8 67 66 66 66	 mov	 eax, 1717986919		; 66666667H
  0001b	41 f7 e8	 imul	 r8d
  0001e	d1 fa		 sar	 edx, 1
  00020	8b ca		 mov	 ecx, edx
  00022	c1 e9 1f	 shr	 ecx, 31
  00025	03 d1		 add	 edx, ecx
  00027	8d 0c 92	 lea	 ecx, DWORD PTR [rdx+rdx*4]
  0002a	44 2b c1	 sub	 r8d, ecx
  0002d	41 8b c0	 mov	 eax, r8d
  00030	eb 41		 jmp	 SHORT $LN5@getRandomS
$LN2@getRandomS:

; 254  : 	}
; 255  : 
; 256  : 	// return 9200/9600/14393 if NDR64 is in use, otherwise 6002/7601
; 257  : 	if (UseServerRpcNDR64) return (rand() % 3) + 2;

  00032	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR UseServerRpcNDR64, 0
  00039	74 24		 je	 SHORT $LN1@getRandomS
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00041	44 8b c0	 mov	 r8d, eax
  00044	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00049	41 f7 e8	 imul	 r8d
  0004c	8b ca		 mov	 ecx, edx
  0004e	c1 e9 1f	 shr	 ecx, 31
  00051	03 d1		 add	 edx, ecx
  00053	8d 0c 52	 lea	 ecx, DWORD PTR [rdx+rdx*2]
  00056	44 2b c1	 sub	 r8d, ecx
  00059	41 8d 40 02	 lea	 eax, DWORD PTR [r8+2]
  0005d	eb 14		 jmp	 SHORT $LN5@getRandomS
$LN1@getRandomS:

; 258  : 	return (rand() % 2);

  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00065	25 01 00 00 80	 and	 eax, -2147483647	; ffffffff80000001H
  0006a	7d 07		 jge	 SHORT $LN5@getRandomS
  0006c	ff c8		 dec	 eax
  0006e	83 c8 fe	 or	 eax, -2
  00071	ff c0		 inc	 eax
$LN5@getRandomS:

; 259  : 
; 260  : #	endif // !defined(USE_MSRPC) && !defined(SIMPLE_RPC)
; 261  : }

  00073	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00077	c3		 ret	 0
getRandomServerType ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT generateRandomPid
_TEXT	SEGMENT
kmsTime$ = 32
numberBuffer$ = 40
index$ = 112
maxTime$ = 120
szPid$ = 120
serverType$ = 128
lang$ = 136
generateRandomPid PROC					; COMDAT

; 268  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0001f	45 0f b7 f1	 movzx	 r14d, r9w
  00023	41 8b c0	 mov	 eax, r8d
  00026	48 8b f2	 mov	 rsi, rdx
  00029	48 63 d9	 movsxd	 rbx, ecx
  0002c	41 83 f8 04	 cmp	 r8d, 4
  00030	76 05		 jbe	 SHORT $LN4@generateRa

; 269  : 	char numberBuffer[12];
; 270  : 
; 271  : 	if (serverType < 0 || serverType >= (int)vlmcsd_countof(HostOS))
; 272  : 	{
; 273  : 		serverType = getRandomServerType();

  00032	e8 00 00 00 00	 call	 getRandomServerType
$LN4@generateRa:

; 274  : 	}
; 275  : 
; 276  : 	strcpy(szPid, itoc(numberBuffer, HostOS[serverType].Type, 5));

  00037	4c 63 e8	 movsxd	 r13, eax
  0003a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  00041	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  00045	42 0f b7 94 a8
	00 00 00 00	 movzx	 edx, WORD PTR HostOS[rax+r13*4]
  0004e	41 b0 05	 mov	 r8b, 5
  00051	e8 00 00 00 00	 call	 itoc
  00056	48 8b d6	 mov	 rdx, rsi
  00059	48 2b d0	 sub	 rdx, rax
  0005c	33 ff		 xor	 edi, edi
$LL7@generateRa:
  0005e	8a 08		 mov	 cl, BYTE PTR [rax]
  00060	88 0c 02	 mov	 BYTE PTR [rdx+rax], cl
  00063	48 ff c0	 inc	 rax
  00066	84 c9		 test	 cl, cl
  00068	75 f4		 jne	 SHORT $LL7@generateRa

; 277  : 	strcat(szPid, "-");

  0006a	48 8d 4e ff	 lea	 rcx, QWORD PTR [rsi-1]
$LL35@generateRa:
  0006e	48 ff c1	 inc	 rcx
  00071	40 38 39	 cmp	 BYTE PTR [rcx], dil
  00074	75 f8		 jne	 SHORT $LL35@generateRa
  00076	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@

; 278  : 
; 279  : 	//if (index > 3) index = 0;
; 280  : 
; 281  : 	PCsvlkData_t csvlkData = &KmsData->CsvlkData[index];

  0007d	4c 8b 25 00 00
	00 00		 mov	 r12, QWORD PTR KmsData

; 282  : 	strcat(szPid, itoc(numberBuffer, csvlkData->GroupId, 5));

  00084	41 b0 05	 mov	 r8b, 5
  00087	66 89 01	 mov	 WORD PTR [rcx], ax
  0008a	48 8d 43 02	 lea	 rax, QWORD PTR [rbx+2]
  0008e	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  00092	4c 8d 3c 40	 lea	 r15, QWORD PTR [rax+rax*2]
  00096	43 8b 54 fc 08	 mov	 edx, DWORD PTR [r12+r15*8+8]
  0009b	e8 00 00 00 00	 call	 itoc
  000a0	48 8d 4e ff	 lea	 rcx, QWORD PTR [rsi-1]
  000a4	4c 8b c0	 mov	 r8, rax
$LL33@generateRa:
  000a7	48 ff c1	 inc	 rcx
  000aa	40 38 39	 cmp	 BYTE PTR [rcx], dil
  000ad	75 f8		 jne	 SHORT $LL33@generateRa
  000af	33 d2		 xor	 edx, edx
$LL34@generateRa:
  000b1	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  000b5	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  000b8	48 ff c2	 inc	 rdx
  000bb	84 c0		 test	 al, al
  000bd	75 f2		 jne	 SHORT $LL34@generateRa

; 283  : 	strcat(szPid, "-");

  000bf	48 8d 4e ff	 lea	 rcx, QWORD PTR [rsi-1]
$LL32@generateRa:
  000c3	48 ff c1	 inc	 rcx
  000c6	40 38 39	 cmp	 BYTE PTR [rcx], dil
  000c9	75 f8		 jne	 SHORT $LL32@generateRa
  000cb	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@
  000d2	66 89 01	 mov	 WORD PTR [rcx], ax

; 284  : 
; 285  : 	int keyId = (rand32() % (csvlkData->MaxKeyId - csvlkData->MinKeyId)) + csvlkData->MinKeyId;

  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  000db	8b d8		 mov	 ebx, eax
  000dd	c1 e3 0f	 shl	 ebx, 15
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  000e6	43 8b 7c fc 0c	 mov	 edi, DWORD PTR [r12+r15*8+12]
  000eb	0b d8		 or	 ebx, eax
  000ed	c1 e3 02	 shl	 ebx, 2
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  000f6	43 8b 4c fc 10	 mov	 ecx, DWORD PTR [r12+r15*8+16]
  000fb	83 e0 03	 and	 eax, 3
  000fe	2b cf		 sub	 ecx, edi
  00100	33 d2		 xor	 edx, edx
  00102	0b c3		 or	 eax, ebx

; 286  : 	strcat(szPid, itoc(numberBuffer, keyId / 1000000, 3));

  00104	41 b0 03	 mov	 r8b, 3
  00107	f7 f1		 div	 ecx
  00109	b8 83 de 1b 43	 mov	 eax, 1125899907		; 431bde83H
  0010e	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  00112	8d 1c 17	 lea	 ebx, DWORD PTR [rdi+rdx]
  00115	f7 eb		 imul	 ebx
  00117	8b fa		 mov	 edi, edx
  00119	c1 ff 12	 sar	 edi, 18
  0011c	8b c7		 mov	 eax, edi
  0011e	c1 e8 1f	 shr	 eax, 31
  00121	03 f8		 add	 edi, eax
  00123	8b d7		 mov	 edx, edi
  00125	e8 00 00 00 00	 call	 itoc
  0012a	4c 8b c6	 mov	 r8, rsi
  0012d	41 bf 01 00 00
	00		 mov	 r15d, 1
  00133	4d 2b c7	 sub	 r8, r15
  00136	48 8b d0	 mov	 rdx, rax
  00139	66 45 33 e4	 xor	 r12w, r12w
$LL30@generateRa:
  0013d	4d 03 c7	 add	 r8, r15
  00140	45 38 20	 cmp	 BYTE PTR [r8], r12b
  00143	75 f8		 jne	 SHORT $LL30@generateRa
  00145	33 c9		 xor	 ecx, ecx
$LL31@generateRa:
  00147	8a 04 0a	 mov	 al, BYTE PTR [rdx+rcx]
  0014a	41 88 04 08	 mov	 BYTE PTR [r8+rcx], al
  0014e	48 ff c1	 inc	 rcx
  00151	84 c0		 test	 al, al
  00153	75 f2		 jne	 SHORT $LL31@generateRa

; 287  : 	strcat(szPid, "-");

  00155	48 8b ce	 mov	 rcx, rsi
  00158	49 2b cf	 sub	 rcx, r15
$LL29@generateRa:
  0015b	49 03 cf	 add	 rcx, r15
  0015e	44 38 21	 cmp	 BYTE PTR [rcx], r12b
  00161	75 f8		 jne	 SHORT $LL29@generateRa
  00163	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@

; 288  : 	strcat(szPid, itoc(numberBuffer, keyId % 1000000, 6));

  0016a	41 b0 06	 mov	 r8b, 6
  0016d	66 89 01	 mov	 WORD PTR [rcx], ax
  00170	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  00174	69 c7 40 42 0f
	00		 imul	 eax, edi, 1000000	; 000f4240H
  0017a	2b d8		 sub	 ebx, eax
  0017c	8b d3		 mov	 edx, ebx
  0017e	e8 00 00 00 00	 call	 itoc
  00183	48 8b ce	 mov	 rcx, rsi
  00186	4c 8b c0	 mov	 r8, rax
  00189	49 2b cf	 sub	 rcx, r15
$LL27@generateRa:
  0018c	49 03 cf	 add	 rcx, r15
  0018f	44 38 21	 cmp	 BYTE PTR [rcx], r12b
  00192	75 f8		 jne	 SHORT $LL27@generateRa
  00194	33 d2		 xor	 edx, edx
$LL28@generateRa:
  00196	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  0019a	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  0019d	48 ff c2	 inc	 rdx
  001a0	84 c0		 test	 al, al
  001a2	75 f2		 jne	 SHORT $LL28@generateRa

; 289  : 	strcat(szPid, "-03-");

  001a4	48 8b ce	 mov	 rcx, rsi
  001a7	49 2b cf	 sub	 rcx, r15
$LL26@generateRa:
  001aa	49 03 cf	 add	 rcx, r15
  001ad	44 38 21	 cmp	 BYTE PTR [rcx], r12b
  001b0	75 f8		 jne	 SHORT $LL26@generateRa
  001b2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_04PGKABKNA@?903?9?$AA@
  001b8	89 01		 mov	 DWORD PTR [rcx], eax
  001ba	8a 05 04 00 00
	00		 mov	 al, BYTE PTR ??_C@_04PGKABKNA@?903?9?$AA@+4
  001c0	88 41 04	 mov	 BYTE PTR [rcx+4], al

; 290  : 
; 291  : 	if (lang < 0) lang = LcidList[rand() % vlmcsd_countof(LcidList)];

  001c3	66 45 3b f4	 cmp	 r14w, r12w
  001c7	7d 36		 jge	 SHORT $LN36@generateRa
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  001cf	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
  001d6	48 63 c8	 movsxd	 rcx, eax
  001d9	48 b8 75 64 cf
	40 54 3a b2 67	 mov	 rax, 7472098865300071541 ; 67b23a5440cf6475H
  001e3	48 f7 e1	 mul	 rcx
  001e6	48 c1 ea 06	 shr	 rdx, 6
  001ea	48 69 c2 9e 00
	00 00		 imul	 rax, rdx, 158		; 0000009eH
  001f1	48 2b c8	 sub	 rcx, rax
  001f4	44 0f b7 b4 4b
	00 00 00 00	 movzx	 r14d, WORD PTR LcidList[rbx+rcx*2]
  001fd	eb 07		 jmp	 SHORT $LN2@generateRa
$LN36@generateRa:
  001ff	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:__ImageBase
$LN2@generateRa:

; 292  : 	strcat(szPid, itoc(numberBuffer, lang, 0));

  00206	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  0020a	41 0f bf d6	 movsx	 edx, r14w
  0020e	45 33 c0	 xor	 r8d, r8d
  00211	e8 00 00 00 00	 call	 itoc
  00216	48 8b ce	 mov	 rcx, rsi
  00219	4c 8b c0	 mov	 r8, rax
  0021c	49 2b cf	 sub	 rcx, r15
$LL24@generateRa:
  0021f	49 03 cf	 add	 rcx, r15
  00222	44 38 21	 cmp	 BYTE PTR [rcx], r12b
  00225	75 f8		 jne	 SHORT $LL24@generateRa
  00227	33 d2		 xor	 edx, edx
$LL25@generateRa:
  00229	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  0022d	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  00230	48 ff c2	 inc	 rdx
  00233	84 c0		 test	 al, al
  00235	75 f2		 jne	 SHORT $LL25@generateRa

; 293  : 	strcat(szPid, "-");

  00237	48 8b ce	 mov	 rcx, rsi
  0023a	49 2b cf	 sub	 rcx, r15
$LL23@generateRa:
  0023d	49 03 cf	 add	 rcx, r15
  00240	44 38 21	 cmp	 BYTE PTR [rcx], r12b
  00243	75 f8		 jne	 SHORT $LL23@generateRa
  00245	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_01JOAMLHOP@?9?$AA@

; 294  : 
; 295  : 	strcat(szPid, itoc(numberBuffer, HostOS[serverType].Build, 0));

  0024c	45 33 c0	 xor	 r8d, r8d
  0024f	66 89 01	 mov	 WORD PTR [rcx], ax
  00252	42 0f b7 94 ab
	02 00 00 00	 movzx	 edx, WORD PTR HostOS[rbx+r13*4+2]
  0025b	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  0025f	e8 00 00 00 00	 call	 itoc
  00264	48 8b ce	 mov	 rcx, rsi
  00267	4c 8b c0	 mov	 r8, rax
  0026a	49 2b cf	 sub	 rcx, r15
$LL21@generateRa:
  0026d	49 03 cf	 add	 rcx, r15
  00270	44 38 21	 cmp	 BYTE PTR [rcx], r12b
  00273	75 f8		 jne	 SHORT $LL21@generateRa
  00275	33 d2		 xor	 edx, edx
$LL22@generateRa:
  00277	41 8a 04 10	 mov	 al, BYTE PTR [r8+rdx]
  0027b	88 04 11	 mov	 BYTE PTR [rcx+rdx], al
  0027e	48 ff c2	 inc	 rdx
  00281	84 c0		 test	 al, al
  00283	75 f2		 jne	 SHORT $LL22@generateRa

; 296  : 	strcat(szPid, ".0000-");

  00285	48 8b ce	 mov	 rcx, rsi
  00288	49 2b cf	 sub	 rcx, r15
$LL20@generateRa:
  0028b	49 03 cf	 add	 rcx, r15
  0028e	44 38 21	 cmp	 BYTE PTR [rcx], r12b
  00291	75 f8		 jne	 SHORT $LL20@generateRa
  00293	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ??_C@_06KMCAJKLF@?40000?9?$AA@
  00299	89 01		 mov	 DWORD PTR [rcx], eax
  0029b	0f b7 05 04 00
	00 00		 movzx	 eax, WORD PTR ??_C@_06KMCAJKLF@?40000?9?$AA@+4
  002a2	66 89 41 04	 mov	 WORD PTR [rcx+4], ax
  002a6	8a 05 06 00 00
	00		 mov	 al, BYTE PTR ??_C@_06KMCAJKLF@?40000?9?$AA@+6
  002ac	88 41 06	 mov	 BYTE PTR [rcx+6], al

; 297  : 
; 298  : #	define minTime ((time_t)1470175200) /* Release Date Win 2016 */
; 299  : 
; 300  : 	time_t maxTime;
; 301  : 	time(&maxTime);

  002af	48 8d 4d 38	 lea	 rcx, QWORD PTR maxTime$[rbp-64]
  002b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 302  : 
; 303  : #	ifndef BUILD_TIME
; 304  : #	define BUILD_TIME 1481079869
; 305  : #   endif
; 306  : 
; 307  : 	if (maxTime < (time_t)BUILD_TIME) // Just in case the system time is < 10/17/2013 1:00 pm

  002b9	48 8b 45 38	 mov	 rax, QWORD PTR maxTime$[rbp-64]
  002bd	b9 3d 7c 47 58	 mov	 ecx, 1481079869		; 58477c3dH
  002c2	48 3b c1	 cmp	 rax, rcx
  002c5	48 0f 4c c1	 cmovl	 rax, rcx
  002c9	48 89 45 38	 mov	 QWORD PTR maxTime$[rbp-64], rax

; 308  : 		maxTime = (time_t)BUILD_TIME;
; 309  : 
; 310  : 	time_t kmsTime = (rand32() % (maxTime - minTime)) + minTime;

  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  002d3	8b d8		 mov	 ebx, eax
  002d5	c1 e3 0f	 shl	 ebx, 15
  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  002de	0b d8		 or	 ebx, eax
  002e0	c1 e3 02	 shl	 ebx, 2
  002e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  002e9	48 8b 4d 38	 mov	 rcx, QWORD PTR maxTime$[rbp-64]
  002ed	83 e0 03	 and	 eax, 3
  002f0	48 81 c1 20 e8
	5e a8		 add	 rcx, -1470175200	; ffffffffa85ee820H
  002f7	48 0b c3	 or	 rax, rbx
  002fa	48 99		 cdq
  002fc	48 f7 f9	 idiv	 rcx

; 311  : 	struct tm *pidTime = gmtime(&kmsTime);

  002ff	48 8d 4d e0	 lea	 rcx, QWORD PTR kmsTime$[rbp-64]
  00303	48 81 c2 e0 17
	a1 57		 add	 rdx, 1470175200		; 57a117e0H
  0030a	48 89 55 e0	 mov	 QWORD PTR kmsTime$[rbp-64], rdx
  0030e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__gmtime64

; 312  : 
; 313  : 	strcat(szPid, itoc(numberBuffer, pidTime->tm_yday, 3));

  00314	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  00318	8b 50 1c	 mov	 edx, DWORD PTR [rax+28]
  0031b	41 b0 03	 mov	 r8b, 3
  0031e	48 8b d8	 mov	 rbx, rax
  00321	e8 00 00 00 00	 call	 itoc
  00326	48 8b d6	 mov	 rdx, rsi
  00329	4c 8b c8	 mov	 r9, rax
  0032c	49 2b d7	 sub	 rdx, r15
$LL18@generateRa:
  0032f	49 03 d7	 add	 rdx, r15
  00332	44 38 22	 cmp	 BYTE PTR [rdx], r12b
  00335	75 f8		 jne	 SHORT $LL18@generateRa
  00337	33 c9		 xor	 ecx, ecx
$LL19@generateRa:
  00339	41 8a 04 09	 mov	 al, BYTE PTR [r9+rcx]
  0033d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00340	48 ff c1	 inc	 rcx
  00343	84 c0		 test	 al, al
  00345	75 f2		 jne	 SHORT $LL19@generateRa

; 314  : 	strcat(szPid, itoc(numberBuffer, pidTime->tm_year + 1900, 4));

  00347	8b 53 14	 mov	 edx, DWORD PTR [rbx+20]
  0034a	48 8d 4d e8	 lea	 rcx, QWORD PTR numberBuffer$[rbp-64]
  0034e	41 b0 04	 mov	 r8b, 4
  00351	81 c2 6c 07 00
	00		 add	 edx, 1900		; 0000076cH
  00357	e8 00 00 00 00	 call	 itoc
  0035c	49 2b f7	 sub	 rsi, r15
  0035f	48 8b d0	 mov	 rdx, rax
$LL16@generateRa:
  00362	49 03 f7	 add	 rsi, r15
  00365	44 38 26	 cmp	 BYTE PTR [rsi], r12b
  00368	75 f8		 jne	 SHORT $LL16@generateRa
  0036a	33 c9		 xor	 ecx, ecx
$LL17@generateRa:
  0036c	8a 04 0a	 mov	 al, BYTE PTR [rdx+rcx]
  0036f	88 04 0e	 mov	 BYTE PTR [rsi+rcx], al
  00372	48 ff c1	 inc	 rcx
  00375	84 c0		 test	 al, al
  00377	75 f3		 jne	 SHORT $LL17@generateRa

; 315  : }

  00379	4c 8d 5c 24 40	 lea	 r11, QWORD PTR [rsp+64]
  0037e	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00382	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00386	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  0038a	49 8b e3	 mov	 rsp, r11
  0038d	41 5f		 pop	 r15
  0038f	41 5e		 pop	 r14
  00391	41 5d		 pop	 r13
  00393	41 5c		 pop	 r12
  00395	5d		 pop	 rbp
  00396	c3		 ret	 0
generateRandomPid ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT randomPidInit
_TEXT	SEGMENT
Epid$1 = 32
randomPidInit PROC					; COMDAT

; 323  : {

$LN24:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 324  : 	uint32_t i;
; 325  : 
; 326  : 	int serverType = getRandomServerType();

  00019	e8 00 00 00 00	 call	 getRandomServerType

; 327  : 	int16_t lang = Lcid ? Lcid : LcidList[rand() % vlmcsd_countof(LcidList)];

  0001e	0f b7 3d 00 00
	00 00		 movzx	 edi, WORD PTR Lcid
  00025	45 33 f6	 xor	 r14d, r14d
  00028	8b e8		 mov	 ebp, eax
  0002a	66 85 ff	 test	 di, di
  0002d	75 2f		 jne	 SHORT $LN8@randomPidI
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00035	48 63 c8	 movsxd	 rcx, eax
  00038	48 b8 75 64 cf
	40 54 3a b2 67	 mov	 rax, 7472098865300071541 ; 67b23a5440cf6475H
  00042	48 f7 e1	 mul	 rcx
  00045	48 c1 ea 06	 shr	 rdx, 6
  00049	48 69 c2 9e 00
	00 00		 imul	 rax, rdx, 158		; 0000009eH
  00050	48 2b c8	 sub	 rcx, rax
  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:LcidList
  0005a	0f b7 3c 48	 movzx	 edi, WORD PTR [rax+rcx*2]
$LN8@randomPidI:

; 328  : 
; 329  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  0005e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsData
  00065	41 8b de	 mov	 ebx, r14d
  00068	44 38 71 08	 cmp	 BYTE PTR [rcx+8], r14b
  0006c	76 5e		 jbe	 SHORT $LN21@randomPidI
  0006e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR KmsResponseParameters
$LL4@randomPidI:

; 330  : 	{
; 331  : 		if (KmsResponseParameters[i].Epid) continue;

  00075	8b c3		 mov	 eax, ebx
  00077	48 8d 34 40	 lea	 rsi, QWORD PTR [rax+rax*2]
  0007b	4c 39 34 f2	 cmp	 QWORD PTR [rdx+rsi*8], r14
  0007f	75 41		 jne	 SHORT $LN3@randomPidI

; 332  : 
; 333  : 		char Epid[PID_BUFFER_SIZE];
; 334  : 
; 335  : 		generateRandomPid(i, Epid, serverType, lang);

  00081	48 8d 54 24 20	 lea	 rdx, QWORD PTR Epid$1[rsp]
  00086	44 0f b7 cf	 movzx	 r9d, di
  0008a	44 8b c5	 mov	 r8d, ebp
  0008d	8b cb		 mov	 ecx, ebx
  0008f	e8 00 00 00 00	 call	 generateRandomPid

; 336  : 		KmsResponseParameters[i].Epid = (const char*)vlmcsd_strdup(Epid);

  00094	48 8d 4c 24 20	 lea	 rcx, QWORD PTR Epid$1[rsp]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  0009f	48 85 c0	 test	 rax, rax
  000a2	74 43		 je	 SHORT $LN17@randomPidI
  000a4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR KmsResponseParameters

; 337  : 
; 338  : #ifndef NO_LOG
; 339  : 		KmsResponseParameters[i].EpidSource = "randomized at program start";

  000ab	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsData
  000b2	48 89 04 f2	 mov	 QWORD PTR [rdx+rsi*8], rax
  000b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@KDKADHPB@randomized?5at?5program?5start?$AA@
  000bd	48 89 44 f2 10	 mov	 QWORD PTR [rdx+rsi*8+16], rax
$LN3@randomPidI:

; 328  : 
; 329  : 	for (i = 0; i < KmsData->CsvlkCount; i++)

  000c2	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]
  000c6	ff c3		 inc	 ebx
  000c8	3b d8		 cmp	 ebx, eax
  000ca	72 a9		 jb	 SHORT $LL4@randomPidI
$LN21@randomPidI:

; 340  : #endif // NO_LOG
; 341  : 	}
; 342  : }

  000cc	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  000d1	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000d5	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  000d9	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000dd	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  000e1	49 8b e3	 mov	 rsp, r11
  000e4	41 5e		 pop	 r14
  000e6	c3		 ret	 0
$LN17@randomPidI:

; 336  : 		KmsResponseParameters[i].Epid = (const char*)vlmcsd_strdup(Epid);

  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  000ee	e8 00 00 00 00	 call	 errorout
  000f3	b9 0e 00 00 00	 mov	 ecx, 14
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  000fe	cc		 int	 3
$LN23@randomPidI:
randomPidInit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT getProductIndexFromAllLists
_TEXT	SEGMENT
guid$ = 64
productName$ = 72
getProductIndexFromAllLists PROC			; COMDAT

; 349  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 350  : 	return getProductIndex(guid, KmsData->AppItemList, KmsData->AppItemCount + KmsData->KmsItemCount + KmsData->SkuItemCount, productName, NULL);

  00004	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0000a	4c 8b ca	 mov	 r9, rdx
  0000d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR KmsData
  00014	44 8b 42 14	 mov	 r8d, DWORD PTR [rdx+20]
  00018	44 03 42 10	 add	 r8d, DWORD PTR [rdx+16]
  0001c	44 03 42 0c	 add	 r8d, DWORD PTR [rdx+12]
  00020	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00024	e8 00 00 00 00	 call	 getProductIndex

; 351  : }

  00029	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002d	c3		 ret	 0
getProductIndexFromAllLists ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT logRequest
_TEXT	SEGMENT
clientname$ = 0
baseRequest$ = 80
productName$ = 88
logRequest PROC						; COMDAT

; 357  : {

  00000	40 55		 push	 rbp
  00002	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00006	48 8d 6c 24 30	 lea	 rbp, QWORD PTR [rsp+48]

; 358  : #ifndef NO_VERBOSE_LOG
; 359  : 	if (logverbose)

  0000b	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR logverbose, 0
  00012	48 89 5d 50	 mov	 QWORD PTR [rbp+80], rbx
  00016	48 89 75 60	 mov	 QWORD PTR [rbp+96], rsi
  0001a	48 89 7d 68	 mov	 QWORD PTR [rbp+104], rdi
  0001e	48 8b d9	 mov	 rbx, rcx
  00021	74 19		 je	 SHORT $LN5@logRequest

; 360  : 	{
; 361  : 		logger("<<< Incoming KMS request\n");

  00023	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@PGELFKLD@?$DM?$DM?$DM?5Incoming?5KMS?5request?6?$AA@
  0002a	e8 00 00 00 00	 call	 logger

; 362  : 		logRequestVerbose(baseRequest, &logger);

  0002f	48 8b cb	 mov	 rcx, rbx
  00032	e8 00 00 00 00	 call	 logRequestVerbose

; 363  : 		return;

  00037	e9 de 00 00 00	 jmp	 $LN6@logRequest
$LN5@logRequest:

; 364  : 	}
; 365  : #endif // NO_VERBOSE_LOG
; 366  : 
; 367  : 	char *productName;
; 368  : 	char clientname[64];
; 369  : 
; 370  : 	int32_t index = getProductIndexFromAllLists(&baseRequest->ActID, &productName);

  0003c	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR KmsData
  00043	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00049	4c 8d 4d 58	 lea	 r9, QWORD PTR productName$[rbp]
  0004d	45 8b 43 10	 mov	 r8d, DWORD PTR [r11+16]
  00051	49 8b 53 18	 mov	 rdx, QWORD PTR [r11+24]
  00055	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00059	45 03 43 14	 add	 r8d, DWORD PTR [r11+20]
  0005d	45 03 43 0c	 add	 r8d, DWORD PTR [r11+12]
  00061	e8 00 00 00 00	 call	 getProductIndex

; 371  : 	if (index < 0) index = getProductIndexFromAllLists(&baseRequest->KMSID, &productName);

  00066	85 c0		 test	 eax, eax
  00068	79 4e		 jns	 SHORT $LN14@logRequest
  0006a	45 8b 43 10	 mov	 r8d, DWORD PTR [r11+16]
  0006e	49 8b 53 18	 mov	 rdx, QWORD PTR [r11+24]
  00072	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00078	45 03 43 14	 add	 r8d, DWORD PTR [r11+20]
  0007c	48 8d 4b 30	 lea	 rcx, QWORD PTR [rbx+48]
  00080	4c 8d 4d 58	 lea	 r9, QWORD PTR productName$[rbp]
  00084	45 03 43 0c	 add	 r8d, DWORD PTR [r11+12]
  00088	e8 00 00 00 00	 call	 getProductIndex

; 372  : 	if (index < 0) index = getProductIndexFromAllLists(&baseRequest->AppID, &productName);

  0008d	85 c0		 test	 eax, eax
  0008f	79 27		 jns	 SHORT $LN14@logRequest
  00091	45 8b 43 10	 mov	 r8d, DWORD PTR [r11+16]
  00095	49 8b 53 18	 mov	 rdx, QWORD PTR [r11+24]
  00099	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  0009f	45 03 43 14	 add	 r8d, DWORD PTR [r11+20]
  000a3	48 8d 4b 10	 lea	 rcx, QWORD PTR [rbx+16]
  000a7	4c 8d 4d 58	 lea	 r9, QWORD PTR productName$[rbp]
  000ab	45 03 43 0c	 add	 r8d, DWORD PTR [r11+12]
  000af	e8 00 00 00 00	 call	 getProductIndex

; 373  : 
; 374  : 	if (index < 0 || !strcasecmp(productName, "Unknown"))

  000b4	85 c0		 test	 eax, eax
  000b6	78 18		 js	 SHORT $LN1@logRequest
$LN14@logRequest:
  000b8	48 8b 7d 58	 mov	 rdi, QWORD PTR productName$[rbp]
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07NBCGADJA@Unknown?$AA@
  000c3	48 8b cf	 mov	 rcx, rdi
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000cc	85 c0		 test	 eax, eax
  000ce	75 1a		 jne	 SHORT $LN2@logRequest
$LN1@logRequest:

; 375  : 	{
; 376  : 		productName = (char*)alloca(GUID_STRING_LENGTH + 1);

  000d0	8b 04 24	 mov	 eax, DWORD PTR [rsp]
  000d3	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  000d7	48 8d 7c 24 30	 lea	 rdi, QWORD PTR [rsp+48]
  000dc	8b 07		 mov	 eax, DWORD PTR [rdi]

; 377  : 		uuid2StringLE(&baseRequest->ActID, productName);

  000de	48 8d 4b 20	 lea	 rcx, QWORD PTR [rbx+32]
  000e2	48 8b d7	 mov	 rdx, rdi
  000e5	e8 00 00 00 00	 call	 uuid2StringLE
$LN2@logRequest:

; 378  : 	}
; 379  : 
; 380  : 	ucs2_to_utf8(baseRequest->WorkstationName, clientname, 64, 64);

  000ea	48 8d 4b 6c	 lea	 rcx, QWORD PTR [rbx+108]
  000ee	48 8d 55 00	 lea	 rdx, QWORD PTR clientname$[rbp]
  000f2	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  000f8	e8 00 00 00 00	 call	 ucs2_to_utf8

; 381  : 	logger("KMS v%i.%i request from %s for %s\n", LE16(baseRequest->MajorVer), LE16(baseRequest->MinorVer), clientname, productName);

  000fd	44 0f b7 03	 movzx	 r8d, WORD PTR [rbx]
  00101	0f b7 53 02	 movzx	 edx, WORD PTR [rbx+2]
  00105	4c 8d 4d 00	 lea	 r9, QWORD PTR clientname$[rbp]
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@NIMMPCGA@KMS?5v?$CFi?4?$CFi?5request?5from?5?$CFs?5for?5?$CF@
  00110	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00115	e8 00 00 00 00	 call	 logger
$LN6@logRequest:

; 382  : }

  0011a	48 8b 5d 50	 mov	 rbx, QWORD PTR [rbp+80]
  0011e	48 8b 75 60	 mov	 rsi, QWORD PTR [rbp+96]
  00122	48 8b 7d 68	 mov	 rdi, QWORD PTR [rbp+104]
  00126	48 8d 65 40	 lea	 rsp, QWORD PTR [rbp+64]
  0012a	5d		 pop	 rbp
  0012b	c3		 ret	 0
logRequest ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT getEpidFromString
_TEXT	SEGMENT
current_utf8$1 = 64
Response$ = 64
pid$ = 72
getEpidFromString PROC					; COMDAT

; 391  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 57		 push	 r15
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 392  : 	size_t length = utf8_to_ucs2(Response->KmsPID, pid, PID_BUFFER_SIZE, PID_BUFFER_SIZE * 3);

  00012	4c 8d 51 08	 lea	 r10, QWORD PTR [rcx+8]
  00016	33 ed		 xor	 ebp, ebp
  00018	4c 8b da	 mov	 r11, rdx
  0001b	48 8b f9	 mov	 rdi, rcx
  0001e	4c 8b c2	 mov	 r8, rdx
  00021	48 89 54 24 40	 mov	 QWORD PTR current_utf8$1[rsp], rdx
  00026	4d 8b ca	 mov	 r9, r10
  00029	40 38 2a	 cmp	 BYTE PTR [rdx], bpl
  0002c	0f 84 88 00 00
	00		 je	 $LN8@getEpidFro
  00032	48 8d 75 fe	 lea	 rsi, QWORD PTR [rbp-2]
  00036	41 bf ff ff 00
	00		 mov	 r15d, 65535		; 0000ffffH
  0003c	49 2b f2	 sub	 rsi, r10
$LL10@getEpidFro:
  0003f	49 8b c8	 mov	 rcx, r8
  00042	49 2b cb	 sub	 rcx, r11
  00045	48 81 f9 c0 00
	00 00		 cmp	 rcx, 192		; 000000c0H
  0004c	0f 83 8c 00 00
	00		 jae	 $LN26@getEpidFro
  00052	41 8a 00	 mov	 al, BYTE PTR [r8]
  00055	24 c0		 and	 al, 192			; 000000c0H
  00057	3c c0		 cmp	 al, 192			; 000000c0H
  00059	75 09		 jne	 SHORT $LN6@getEpidFro
  0005b	48 81 f9 bf 00
	00 00		 cmp	 rcx, 191		; 000000bfH
  00062	73 7a		 jae	 SHORT $LN26@getEpidFro
$LN6@getEpidFro:
  00064	41 8a 00	 mov	 al, BYTE PTR [r8]
  00067	24 e0		 and	 al, 224			; 000000e0H
  00069	3c e0		 cmp	 al, 224			; 000000e0H
  0006b	75 09		 jne	 SHORT $LN5@getEpidFro
  0006d	48 81 f9 be 00
	00 00		 cmp	 rcx, 190		; 000000beH
  00074	73 68		 jae	 SHORT $LN26@getEpidFro
$LN5@getEpidFro:
  00076	49 8d 59 02	 lea	 rbx, QWORD PTR [r9+2]
  0007a	48 8d 04 1e	 lea	 rax, QWORD PTR [rsi+rbx]
  0007e	48 83 e0 fe	 and	 rax, -2
  00082	48 83 f8 7e	 cmp	 rax, 126		; 0000007eH
  00086	7d 56		 jge	 SHORT $LN26@getEpidFro
  00088	41 38 28	 cmp	 BYTE PTR [r8], bpl
  0008b	75 06		 jne	 SHORT $LN24@getEpidFro
  0008d	41 0f b7 c7	 movzx	 eax, r15w
  00091	eb 12		 jmp	 SHORT $LN20@getEpidFro
$LN24@getEpidFro:
  00093	48 8d 54 24 40	 lea	 rdx, QWORD PTR current_utf8$1[rsp]
  00098	49 8b c8	 mov	 rcx, r8
  0009b	e8 00 00 00 00	 call	 utf8_to_ucs2_char
  000a0	4c 8b 44 24 40	 mov	 r8, QWORD PTR current_utf8$1[rsp]
$LN20@getEpidFro:
  000a5	66 41 89 01	 mov	 WORD PTR [r9], ax
  000a9	66 89 2b	 mov	 WORD PTR [rbx], bp
  000ac	66 45 39 39	 cmp	 WORD PTR [r9], r15w
  000b0	74 2c		 je	 SHORT $LN26@getEpidFro
  000b2	4c 8b cb	 mov	 r9, rbx
  000b5	41 38 28	 cmp	 BYTE PTR [r8], bpl
  000b8	75 85		 jne	 SHORT $LL10@getEpidFro
$LN8@getEpidFro:
  000ba	4d 2b ca	 sub	 r9, r10
  000bd	49 d1 f9	 sar	 r9, 1
$LN11@getEpidFro:

; 393  : 	Response->PIDSize = LE32(((unsigned int)length + 1) << 1);
; 394  : }

  000c0	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000c5	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000ca	42 8d 04 4d 02
	00 00 00	 lea	 eax, DWORD PTR [r9*2+2]
  000d2	89 47 04	 mov	 DWORD PTR [rdi+4], eax
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	41 5f		 pop	 r15
  000db	5f		 pop	 rdi
  000dc	5e		 pop	 rsi
  000dd	c3		 ret	 0
$LN26@getEpidFro:

; 392  : 	size_t length = utf8_to_ucs2(Response->KmsPID, pid, PID_BUFFER_SIZE, PID_BUFFER_SIZE * 3);

  000de	49 83 c9 ff	 or	 r9, -1
  000e2	eb dc		 jmp	 SHORT $LN11@getEpidFro
getEpidFromString ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT getEpid
_TEXT	SEGMENT
szPid$1 = 32
current_utf8$2 = 128
baseResponse$ = 128
EpidSource$ = 136
index$ = 144
HwId$ = 152
defaultEPid$ = 160
getEpid	PROC						; COMDAT

; 401  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 56		 push	 r14
  00014	48 83 ec 60	 sub	 rsp, 96			; 00000060H

; 402  : 	#if !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 403  : 	const char* pid;
; 404  : 	if (KmsResponseParameters[index].Epid == NULL)

  00018	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR KmsResponseParameters
  0001f	49 63 f0	 movsxd	 rsi, r8d
  00022	48 8b fa	 mov	 rdi, rdx
  00025	48 8d 14 76	 lea	 rdx, QWORD PTR [rsi+rsi*2]
  00029	48 83 cb ff	 or	 rbx, -1
  0002d	45 33 f6	 xor	 r14d, r14d
  00030	4d 8b 14 d3	 mov	 r10, QWORD PTR [r11+rdx*8]
  00034	48 8b e9	 mov	 rbp, rcx
  00037	4d 85 d2	 test	 r10, r10
  0003a	75 49		 jne	 SHORT $LN5@getEpid

; 405  : 	{
; 406  : 		#ifndef NO_RANDOM_EPID
; 407  : 		if (RandomizationLevel == 2)

  0003c	80 3d 00 00 00
	00 02		 cmp	 BYTE PTR RandomizationLevel, 2
  00043	75 2f		 jne	 SHORT $LN4@getEpid

; 408  : 		{
; 409  : 			char szPid[PID_BUFFER_SIZE];
; 410  : 			generateRandomPid(index, szPid, -1, Lcid ? Lcid : -1);

  00045	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR Lcid
  0004c	44 8b cb	 mov	 r9d, ebx
  0004f	48 8d 54 24 20	 lea	 rdx, QWORD PTR szPid$1[rsp]
  00054	66 85 c0	 test	 ax, ax
  00057	44 8b c3	 mov	 r8d, ebx
  0005a	8b ce		 mov	 ecx, esi
  0005c	66 44 0f 45 c8	 cmovne	 r9w, ax
  00061	e8 00 00 00 00	 call	 generateRandomPid

; 411  : 			pid = szPid;

  00066	4c 8d 54 24 20	 lea	 r10, QWORD PTR szPid$1[rsp]

; 412  : 
; 413  : 			#ifndef NO_LOG
; 414  : 			*EpidSource = "randomized on every request";

  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request?$AA@

; 415  : 			#endif // NO_LOG
; 416  : 		}
; 417  : 		else

  00072	eb 2b		 jmp	 SHORT $LN42@getEpid
$LN4@getEpid:

; 418  : 		#endif // NO_RANDOM_EPID
; 419  : 		{
; 420  : 			pid = defaultEPid;

  00074	4c 8b 94 24 a0
	00 00 00	 mov	 r10, QWORD PTR defaultEPid$[rsp]

; 421  : 			#ifndef NO_LOG
; 422  : 			*EpidSource = "vlmcsd default";

  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0P@CACDFLGA@vlmcsd?5default?$AA@

; 423  : 			#endif // NO_LOG
; 424  : 		}
; 425  : 	}
; 426  : 	else

  00083	eb 1a		 jmp	 SHORT $LN42@getEpid
$LN5@getEpid:

; 427  : 	{
; 428  : 		pid = KmsResponseParameters[index].Epid;
; 429  : 
; 430  : 		if (HwId && KmsResponseParameters[index].HwId != NULL)

  00085	4d 85 c9	 test	 r9, r9
  00088	74 10		 je	 SHORT $LN1@getEpid
  0008a	49 8b 44 d3 08	 mov	 rax, QWORD PTR [r11+rdx*8+8]
  0008f	48 85 c0	 test	 rax, rax
  00092	74 06		 je	 SHORT $LN1@getEpid

; 431  : 			memcpy(HwId, KmsResponseParameters[index].HwId, sizeof(((RESPONSE_V6 *)0)->HwId));

  00094	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00097	49 89 01	 mov	 QWORD PTR [r9], rax
$LN1@getEpid:

; 432  : 
; 433  : 		#ifndef NO_LOG
; 434  : 		*EpidSource = KmsResponseParameters[index].EpidSource;

  0009a	49 8b 44 d3 10	 mov	 rax, QWORD PTR [r11+rdx*8+16]
$LN42@getEpid:

; 435  : 		#endif // NO_LOG
; 436  : 	}
; 437  : 
; 438  : 	getEpidFromString(baseResponse, pid);

  0009f	4c 8d 5d 08	 lea	 r11, QWORD PTR [rbp+8]
  000a3	48 89 07	 mov	 QWORD PTR [rdi], rax
  000a6	4d 8b c2	 mov	 r8, r10
  000a9	4c 89 94 24 80
	00 00 00	 mov	 QWORD PTR current_utf8$2[rsp], r10
  000b1	4d 8b cb	 mov	 r9, r11
  000b4	45 38 32	 cmp	 BYTE PTR [r10], r14b
  000b7	0f 84 8e 00 00
	00		 je	 $LN15@getEpid
  000bd	48 c7 c6 fe ff
	ff ff		 mov	 rsi, -2
  000c4	41 bc ff ff 00
	00		 mov	 r12d, 65535		; 0000ffffH
  000ca	49 2b f3	 sub	 rsi, r11
$LL17@getEpid:
  000cd	49 8b c8	 mov	 rcx, r8
  000d0	49 2b ca	 sub	 rcx, r10
  000d3	48 81 f9 c0 00
	00 00		 cmp	 rcx, 192		; 000000c0H
  000da	73 78		 jae	 SHORT $LN18@getEpid
  000dc	41 8a 00	 mov	 al, BYTE PTR [r8]
  000df	24 c0		 and	 al, 192			; 000000c0H
  000e1	3c c0		 cmp	 al, 192			; 000000c0H
  000e3	75 09		 jne	 SHORT $LN13@getEpid
  000e5	48 81 f9 bf 00
	00 00		 cmp	 rcx, 191		; 000000bfH
  000ec	73 66		 jae	 SHORT $LN18@getEpid
$LN13@getEpid:
  000ee	41 8a 00	 mov	 al, BYTE PTR [r8]
  000f1	24 e0		 and	 al, 224			; 000000e0H
  000f3	3c e0		 cmp	 al, 224			; 000000e0H
  000f5	75 09		 jne	 SHORT $LN12@getEpid
  000f7	48 81 f9 be 00
	00 00		 cmp	 rcx, 190		; 000000beH
  000fe	73 54		 jae	 SHORT $LN18@getEpid
$LN12@getEpid:
  00100	49 8d 79 02	 lea	 rdi, QWORD PTR [r9+2]
  00104	48 8d 04 3e	 lea	 rax, QWORD PTR [rsi+rdi]
  00108	48 83 e0 fe	 and	 rax, -2
  0010c	48 83 f8 7e	 cmp	 rax, 126		; 0000007eH
  00110	7d 42		 jge	 SHORT $LN18@getEpid
  00112	45 38 30	 cmp	 BYTE PTR [r8], r14b
  00115	75 06		 jne	 SHORT $LN31@getEpid
  00117	41 0f b7 c4	 movzx	 eax, r12w
  0011b	eb 18		 jmp	 SHORT $LN27@getEpid
$LN31@getEpid:
  0011d	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR current_utf8$2[rsp]
  00125	49 8b c8	 mov	 rcx, r8
  00128	e8 00 00 00 00	 call	 utf8_to_ucs2_char
  0012d	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR current_utf8$2[rsp]
$LN27@getEpid:
  00135	66 41 89 01	 mov	 WORD PTR [r9], ax
  00139	66 44 89 37	 mov	 WORD PTR [rdi], r14w
  0013d	66 45 39 21	 cmp	 WORD PTR [r9], r12w
  00141	74 11		 je	 SHORT $LN18@getEpid
  00143	4c 8b cf	 mov	 r9, rdi
  00146	45 38 30	 cmp	 BYTE PTR [r8], r14b
  00149	75 82		 jne	 SHORT $LL17@getEpid
$LN15@getEpid:
  0014b	49 8b d9	 mov	 rbx, r9
  0014e	49 2b db	 sub	 rbx, r11
  00151	48 d1 fb	 sar	 rbx, 1
$LN18@getEpid:

; 439  : 
; 440  : 	#else // defined(NO_RANDOM_EPID) && defined(NO_CL_PIDS) && !defined(NO_INI_FILE)
; 441  : 
; 442  : 	getEpidFromString(baseResponse, defaultEPid);
; 443  : 
; 444  : #	ifndef NO_LOG
; 445  : 	*EpidSource = "vlmcsd default";
; 446  : #	endif // NO_LOG
; 447  : 
; 448  : 	#endif // defined(NO_RANDOM_EPID) && defined(NO_CL_PIDS) && !defined(NO_INI_FILE)
; 449  : }

  00154	4c 8d 5c 24 60	 lea	 r11, QWORD PTR [rsp+96]
  00159	8d 04 5d 02 00
	00 00		 lea	 eax, DWORD PTR [rbx*2+2]
  00160	49 8b 5b 28	 mov	 rbx, QWORD PTR [r11+40]
  00164	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  00168	89 45 04	 mov	 DWORD PTR [rbp+4], eax
  0016b	49 8b 6b 30	 mov	 rbp, QWORD PTR [r11+48]
  0016f	49 8b e3	 mov	 rsp, r11
  00172	41 5e		 pop	 r14
  00174	41 5c		 pop	 r12
  00176	5f		 pop	 rdi
  00177	c3		 ret	 0
getEpid	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT logResponse
_TEXT	SEGMENT
utf8pid$ = 32
baseResponse$ = 240
hwId$ = 248
EpidSource$ = 256
logResponse PROC					; COMDAT

; 486  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b f9	 mov	 rdi, rcx

; 487  : 	char utf8pid[PID_BUFFER_SIZE * 3];
; 488  : 	ucs2_to_utf8(baseResponse->KmsPID, utf8pid, PID_BUFFER_SIZE, PID_BUFFER_SIZE * 3);

  00018	48 8d 54 24 20	 lea	 rdx, QWORD PTR utf8pid$[rsp]
  0001d	48 83 c1 08	 add	 rcx, 8
  00021	41 b9 c0 00 00
	00		 mov	 r9d, 192		; 000000c0H
  00027	49 8b d8	 mov	 rbx, r8
  0002a	e8 00 00 00 00	 call	 ucs2_to_utf8

; 489  : 
; 490  : #ifndef NO_VERBOSE_LOG
; 491  : 	if (!logverbose)

  0002f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR logverbose, 0

; 492  : 	{
; 493  : #endif // NO_VERBOSE_LOG
; 494  : 		logger("Sending ePID (%s): %s\n", EpidSource, utf8pid);

  00036	48 8b d3	 mov	 rdx, rbx
  00039	75 13		 jne	 SHORT $LN2@logRespons
  0003b	4c 8d 44 24 20	 lea	 r8, QWORD PTR utf8pid$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6?$AA@
  00047	e8 00 00 00 00	 call	 logger

; 495  : #ifndef NO_VERBOSE_LOG
; 496  : 	}
; 497  : 	else

  0004c	eb 1c		 jmp	 SHORT $LN1@logRespons
$LN2@logRespons:

; 498  : 	{
; 499  : 		logger(">>> Sending response, ePID source = %s\n", EpidSource);

  0004e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sourc@
  00055	e8 00 00 00 00	 call	 logger

; 500  : 		logResponseVerbose(utf8pid, hwId, baseResponse, &logger);

  0005a	48 8d 4c 24 20	 lea	 rcx, QWORD PTR utf8pid$[rsp]
  0005f	4c 8b c7	 mov	 r8, rdi
  00062	48 8b d6	 mov	 rdx, rsi
  00065	e8 00 00 00 00	 call	 logResponseVerbose
$LN1@logRespons:

; 501  : 	}
; 502  : #endif // NO_VERBOSE_LOG
; 503  : 
; 504  : }

  0006a	4c 8d 9c 24 e0
	00 00 00	 lea	 r11, QWORD PTR [rsp+224]
  00072	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00076	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  0007a	49 8b e3	 mov	 rsp, r11
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
logResponse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT CreateResponseBaseCallback
_TEXT	SEGMENT
guidBuffer$1 = 48
szPid$2 = 48
mbstr$3 = 112
utf8pid$4 = 176
st$5 = 416
current_utf8$6 = 416
ePid$ = 416
baseRequest$ = 416
baseResponse$ = 424
hwId$ = 432
ipstr_unused$ = 440
CreateResponseBaseCallback PROC				; COMDAT

; 518  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8d 6c 24 90	 lea	 rbp, QWORD PTR [rsp-112]
  0001d	48 81 ec 70 01
	00 00		 sub	 rsp, 368		; 00000170H
  00024	4d 8b e8	 mov	 r13, r8
  00027	48 8b f2	 mov	 rsi, rdx
  0002a	4c 8b f9	 mov	 r15, rcx

; 519  : 	const char* EpidSource;
; 520  : #ifndef NO_LOG
; 521  : 	logRequest(baseRequest);

  0002d	e8 00 00 00 00	 call	 logRequest

; 522  : #ifdef _PEDANTIC
; 523  : 	CheckRequest(baseRequest);
; 524  : #endif // _PEDANTIC
; 525  : #endif // NO_LOG
; 526  : 
; 527  : 	char* ePid;
; 528  : 	DWORD minClients = LE32(baseRequest->N_Policy);

  00032	41 8b 47 50	 mov	 eax, DWORD PTR [r15+80]

; 529  : 	DWORD required_clients = minClients < 1 ? 1 : minClients << 1;
; 530  : 
; 531  : 	int32_t index = getProductIndex(&baseRequest->KMSID, KmsData->KmsItemList, KmsData->KmsItemCount, NULL, &ePid);

  00036	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR KmsData
  0003d	45 8b 43 10	 mov	 r8d, DWORD PTR [r11+16]
  00041	49 8b 53 20	 mov	 rdx, QWORD PTR [r11+32]
  00045	44 8d 34 00	 lea	 r14d, DWORD PTR [rax+rax]
  00049	bb 01 00 00 00	 mov	 ebx, 1
  0004e	49 8d 4f 30	 lea	 rcx, QWORD PTR [r15+48]
  00052	3b c3		 cmp	 eax, ebx
  00054	48 8d 85 a0 00
	00 00		 lea	 rax, QWORD PTR ePid$[rbp-256]
  0005b	44 0f 42 f3	 cmovb	 r14d, ebx
  0005f	45 33 c9	 xor	 r9d, r9d
  00062	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00067	e8 00 00 00 00	 call	 getProductIndex
  0006c	48 63 f8	 movsxd	 rdi, eax

; 532  : 
; 533  : #	ifndef NO_STRICT_MODES
; 534  : 
; 535  : 	if (required_clients > 2000)

  0006f	41 81 fe d0 07
	00 00		 cmp	 r14d, 2000		; 000007d0H
  00076	76 16		 jbe	 SHORT $LN23@CreateResp

; 536  : 	{
; 537  : #		ifndef NO_LOG
; 538  : 		logger("Rejecting request with more than 1000 minimum clients (0x8007000D)\n");

  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EE@GPFGCDIC@Rejecting?5request?5with?5more?5than@
  0007f	e8 00 00 00 00	 call	 logger

; 539  : #		endif
; 540  : 
; 541  : 		return 0x8007000D;

  00084	b8 0d 00 07 80	 mov	 eax, -2147024883	; ffffffff8007000dH
  00089	e9 6d 05 00 00	 jmp	 $LN24@CreateResp
$LN23@CreateResp:

; 542  : 	}
; 543  : 
; 544  : 	if (CheckClientTime)

  0008e	45 33 d2	 xor	 r10d, r10d
  00091	48 b8 bd 42 7a
	e5 d5 94 bf d6	 mov	 rax, -2972493582642298179 ; d6bf94d5e57a42bdH
  0009b	48 b9 00 91 10
	b6 02 00 00 00	 mov	 rcx, 11644473600	; 00000002b6109100H
  000a5	44 38 15 00 00
	00 00		 cmp	 BYTE PTR CheckClientTime, r10b
  000ac	74 50		 je	 SHORT $LN21@CreateResp

; 545  : 	{
; 546  : 		time_t requestTime = (time_t)fileTimeToUnixTime(&baseRequest->ClientTime);

  000ae	49 f7 67 54	 mul	 QWORD PTR [r15+84]
  000b2	48 8b da	 mov	 rbx, rdx
  000b5	48 c1 eb 17	 shr	 rbx, 23
  000b9	48 2b d9	 sub	 rbx, rcx

; 547  : 
; 548  : 		if (llabs(requestTime - time(NULL)) > 60 * 60 * 4)

  000bc	33 c9		 xor	 ecx, ecx
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64
  000c4	48 2b d8	 sub	 rbx, rax
  000c7	48 8b c3	 mov	 rax, rbx
  000ca	48 99		 cdq
  000cc	48 33 c2	 xor	 rax, rdx
  000cf	48 2b c2	 sub	 rax, rdx
  000d2	48 3d 40 38 00
	00		 cmp	 rax, 14400		; 00003840H
  000d8	7e 16		 jle	 SHORT $LN108@CreateResp

; 549  : 		{
; 550  : #			ifndef NO_LOG
; 551  : 			logger("Client time differs more than 4 hours from system time (0xC004F06C)\n");

  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0EF@NBMAOLBH@Client?5time?5differs?5more?5than?54?5@
  000e1	e8 00 00 00 00	 call	 logger

; 552  : #			endif // !NO_LOG
; 553  : 
; 554  : 			return 0xC004F06C;

  000e6	b8 6c f0 04 c0	 mov	 eax, -1073418132	; ffffffffc004f06cH
  000eb	e9 0b 05 00 00	 jmp	 $LN24@CreateResp
$LN108@CreateResp:
  000f0	4c 8b 1d 00 00
	00 00		 mov	 r11, QWORD PTR KmsData
  000f7	45 33 d2	 xor	 r10d, r10d
  000fa	41 8d 5a 01	 lea	 ebx, QWORD PTR [r10+1]
$LN21@CreateResp:

; 555  : 		}
; 556  : 	}
; 557  : 
; 558  : 	if (WhitelistingLevel & 2)

  000fe	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR WhitelistingLevel
  00104	f6 c2 02	 test	 dl, 2
  00107	74 33		 je	 SHORT $LN19@CreateResp

; 559  : 	{
; 560  : 		if (index >= 0 && (KmsData->KmsItemList[index].IsPreview || KmsData->KmsItemList[index].IsRetail))

  00109	85 ff		 test	 edi, edi
  0010b	78 2f		 js	 SHORT $LN19@CreateResp
  0010d	49 8b 4b 20	 mov	 rcx, QWORD PTR [r11+32]
  00111	48 8b c7	 mov	 rax, rdi
  00114	48 c1 e0 05	 shl	 rax, 5
  00118	44 38 54 08 1d	 cmp	 BYTE PTR [rax+rcx+29], r10b
  0011d	75 07		 jne	 SHORT $LN18@CreateResp
  0011f	44 38 54 08 1c	 cmp	 BYTE PTR [rax+rcx+28], r10b
  00124	74 16		 je	 SHORT $LN19@CreateResp
$LN18@CreateResp:

; 561  : 		{
; 562  : #			ifndef NO_LOG
; 563  : 			logger("Refusing retail or beta product (0xC004F042)\n");

  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@GEBKAAHB@Refusing?5retail?5or?5beta?5product?5@
$LN113@CreateResp:
  0012d	e8 00 00 00 00	 call	 logger

; 564  : #			endif // !NO_LOG
; 565  : 
; 566  : 			return 0xC004F042;

  00132	b8 42 f0 04 c0	 mov	 eax, -1073418174	; ffffffffc004f042H
  00137	e9 bf 04 00 00	 jmp	 $LN24@CreateResp
$LN19@CreateResp:

; 567  : 		}
; 568  : 	}
; 569  : 
; 570  : 	if ((WhitelistingLevel & 1) && index < 0)

  0013c	23 d3		 and	 edx, ebx
  0013e	74 0d		 je	 SHORT $LN17@CreateResp
  00140	85 ff		 test	 edi, edi
  00142	79 12		 jns	 SHORT $LN26@CreateResp

; 571  : 	{
; 572  : #		ifndef NO_LOG
; 573  : 		logger("Refusing unknown product (0xC004F042)\n");

  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@OKECOFDM@Refusing?5unknown?5product?5?$CI0xC004@

; 574  : #		endif // !NO_LOG
; 575  : 
; 576  : 		return 0xC004F042;

  0014b	eb e0		 jmp	 SHORT $LN113@CreateResp
$LN17@CreateResp:

; 577  : 	}
; 578  : 
; 579  : #	ifndef NO_CLIENT_LIST
; 580  : 	int32_t appIndex = index < 0 ? 0 : KmsData->KmsItemList[index].AppIndex;

  0014d	85 ff		 test	 edi, edi
  0014f	79 05		 jns	 SHORT $LN26@CreateResp
  00151	41 8b da	 mov	 ebx, r10d
  00154	eb 10		 jmp	 SHORT $LN27@CreateResp
$LN26@CreateResp:
  00156	49 8b 43 20	 mov	 rax, QWORD PTR [r11+32]
  0015a	48 8b cf	 mov	 rcx, rdi
  0015d	48 c1 e1 05	 shl	 rcx, 5
  00161	0f b6 5c 01 18	 movzx	 ebx, BYTE PTR [rcx+rax+24]
$LN27@CreateResp:

; 581  : #	endif // NO_CLIENT_LIST
; 582  : 
; 583  : #	endif // !NO_STRICT_MODES
; 584  : 
; 585  : 	int32_t ePidIndex = index < 0 ? 0 : KmsData->KmsItemList[index].EPidIndex;

  00166	85 ff		 test	 edi, edi
  00168	79 05		 jns	 SHORT $LN28@CreateResp
  0016a	45 8b e2	 mov	 r12d, r10d
  0016d	eb 11		 jmp	 SHORT $LN29@CreateResp
$LN28@CreateResp:
  0016f	49 8b 43 20	 mov	 rax, QWORD PTR [r11+32]
  00173	48 8b cf	 mov	 rcx, rdi
  00176	48 c1 e1 05	 shl	 rcx, 5
  0017a	44 0f b6 64 01
	1e		 movzx	 r12d, BYTE PTR [rcx+rax+30]
$LN29@CreateResp:

; 586  : 
; 587  : #	if !defined(NO_STRICT_MODES)
; 588  : 
; 589  : 	if ((WhitelistingLevel & 1) && index >= 0 && !IsEqualGUID(&KmsData->AppItemList[KmsData->KmsItemList[index].AppIndex].Guid, &baseRequest->AppID))

  00180	85 d2		 test	 edx, edx
  00182	74 3b		 je	 SHORT $LN16@CreateResp
  00184	85 ff		 test	 edi, edi
  00186	78 37		 js	 SHORT $LN16@CreateResp
  00188	49 8b 43 20	 mov	 rax, QWORD PTR [r11+32]
  0018c	48 8b cf	 mov	 rcx, rdi
  0018f	48 c1 e1 05	 shl	 rcx, 5
  00193	0f b6 54 01 18	 movzx	 edx, BYTE PTR [rcx+rax+24]
  00198	48 c1 e2 05	 shl	 rdx, 5
  0019c	49 03 53 18	 add	 rdx, QWORD PTR [r11+24]
  001a0	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  001a3	49 3b 47 10	 cmp	 rax, QWORD PTR [r15+16]
  001a7	75 0a		 jne	 SHORT $LN107@CreateResp
  001a9	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  001ad	49 3b 47 18	 cmp	 rax, QWORD PTR [r15+24]
  001b1	74 0c		 je	 SHORT $LN16@CreateResp
$LN107@CreateResp:

; 590  : 	{
; 591  : #		ifndef NO_LOG
; 592  : 		logger("Refusing product with incorrect Application ID (0xC004F042)\n");

  001b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DN@KPFNIABO@Refusing?5product?5with?5incorrect?5@

; 593  : #		endif // NO_LOG
; 594  : 		return 0xC004F042;

  001ba	e9 6e ff ff ff	 jmp	 $LN113@CreateResp
$LN16@CreateResp:

; 595  : 	}
; 596  : 
; 597  : #	ifndef NO_CLIENT_LIST
; 598  : 	if (MaintainClients)

  001bf	44 38 15 00 00
	00 00		 cmp	 BYTE PTR MaintainClients, r10b
  001c6	0f 84 68 01 00
	00		 je	 $LN15@CreateResp

; 599  : 	{
; 600  : 		lock_client_lists();

  001cc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR mutex
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 601  : 
; 602  : 		int_fast16_t i;
; 603  : 		int_fast8_t isKnownClient = FALSE;
; 604  : 
; 605  : 		if (required_clients > (DWORD)ClientLists[appIndex].MaxCount) ClientLists[appIndex].MaxCount = required_clients;

  001d9	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR ClientLists
  001e0	48 63 c3	 movsxd	 rax, ebx
  001e3	4c 69 c0 fc 29
	00 00		 imul	 r8, rax, 10748		; 000029fcH
  001ea	47 3b b4 08 f4
	29 00 00	 cmp	 r14d, DWORD PTR [r8+r9+10740]
  001f2	76 08		 jbe	 SHORT $LN14@CreateResp
  001f4	47 89 b4 08 f4
	29 00 00	 mov	 DWORD PTR [r8+r9+10740], r14d
$LN14@CreateResp:

; 606  : 
; 607  : 		for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  001fc	47 8b 94 08 f4
	29 00 00	 mov	 r10d, DWORD PTR [r8+r9+10740]
  00204	45 33 db	 xor	 r11d, r11d
  00207	41 8b d3	 mov	 edx, r11d
  0020a	45 85 d2	 test	 r10d, r10d
  0020d	7e 2a		 jle	 SHORT $LN109@CreateResp
$LL13@CreateResp:

; 608  : 		{
; 609  : 			if (IsEqualGUID(&ClientLists[appIndex].Guid[i], &baseRequest->CMID))

  0020f	48 63 ca	 movsxd	 rcx, edx
  00212	48 c1 e1 04	 shl	 rcx, 4
  00216	49 03 c8	 add	 rcx, r8
  00219	4a 8b 04 09	 mov	 rax, QWORD PTR [rcx+r9]
  0021d	49 3b 47 40	 cmp	 rax, QWORD PTR [r15+64]
  00221	75 0f		 jne	 SHORT $LN106@CreateResp
  00223	4a 8b 44 09 08	 mov	 rax, QWORD PTR [rcx+r9+8]
  00228	49 3b 47 48	 cmp	 rax, QWORD PTR [r15+72]
  0022c	0f 84 e5 00 00
	00		 je	 $LN88@CreateResp
$LN106@CreateResp:

; 606  : 
; 607  : 		for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  00232	ff c2		 inc	 edx
  00234	41 3b d2	 cmp	 edx, r10d
  00237	7c d6		 jl	 SHORT $LL13@CreateResp
$LN109@CreateResp:

; 610  : 			{
; 611  : 				isKnownClient = TRUE;
; 612  : 				break;
; 613  : 			}
; 614  : 		}
; 615  : 
; 616  : 		if (isKnownClient)
; 617  : 		{
; 618  : 			baseResponse->Count = LE32(ClientLists[appIndex].CurrentCount);
; 619  : 		}
; 620  : 		else
; 621  : 		{
; 622  : 			for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  00239	41 8b cb	 mov	 ecx, r11d
  0023c	bb 9f 02 00 00	 mov	 ebx, 671		; 0000029fH
  00241	45 85 d2	 test	 r10d, r10d
  00244	0f 8e 87 00 00
	00		 jle	 $LN110@CreateResp
  0024a	48 8b 15 08 00
	00 00		 mov	 rdx, QWORD PTR ZeroGuid+8
  00251	4c 8b 15 00 00
	00 00		 mov	 r10, QWORD PTR ZeroGuid
$LL7@CreateResp:

; 623  : 			{
; 624  : 				if (IsEqualGUID(ZeroGuid, &ClientLists[appIndex].Guid[i]))

  00258	48 63 c1	 movsxd	 rax, ecx
  0025b	48 c1 e0 04	 shl	 rax, 4
  0025f	49 03 c0	 add	 rax, r8
  00262	4e 3b 14 08	 cmp	 r10, QWORD PTR [rax+r9]
  00266	75 07		 jne	 SHORT $LN105@CreateResp
  00268	4a 3b 54 08 08	 cmp	 rdx, QWORD PTR [rax+r9+8]
  0026d	74 0e		 je	 SHORT $LN89@CreateResp
$LN105@CreateResp:

; 610  : 			{
; 611  : 				isKnownClient = TRUE;
; 612  : 				break;
; 613  : 			}
; 614  : 		}
; 615  : 
; 616  : 		if (isKnownClient)
; 617  : 		{
; 618  : 			baseResponse->Count = LE32(ClientLists[appIndex].CurrentCount);
; 619  : 		}
; 620  : 		else
; 621  : 		{
; 622  : 			for (i = 0; i < ClientLists[appIndex].MaxCount; i++)

  0026f	ff c1		 inc	 ecx
  00271	43 3b 8c 08 f4
	29 00 00	 cmp	 ecx, DWORD PTR [r8+r9+10740]
  00279	7d 60		 jge	 SHORT $LN112@CreateResp
  0027b	eb db		 jmp	 SHORT $LL7@CreateResp
$LN89@CreateResp:

; 625  : 				{
; 626  : 					if (ClientLists[appIndex].CurrentCount >= MAX_CLIENTS)

  0027d	43 8b 84 08 f0
	29 00 00	 mov	 eax, DWORD PTR [r8+r9+10736]
  00285	3b c3		 cmp	 eax, ebx
  00287	7c 23		 jl	 SHORT $LN3@CreateResp

; 627  : 					{
; 628  : #						ifndef NO_LOG
; 629  : 						logger("Rejecting more than 671 clients (0xC004D104)\n");

  00289	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CO@CIIKPOBH@Rejecting?5more?5than?5671?5clients?5@
  00290	e8 00 00 00 00	 call	 logger

; 630  : #						endif // !NO_LOG
; 631  : 
; 632  : 						unlock_client_lists();

  00295	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR mutex
  0029c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 633  : 						return 0xC004D104;

  002a2	b8 04 d1 04 c0	 mov	 eax, -1073426172	; ffffffffc004d104H
  002a7	e9 4f 03 00 00	 jmp	 $LN24@CreateResp
$LN3@CreateResp:

; 634  : 					}
; 635  : 
; 636  : 					baseResponse->Count = LE32(++ClientLists[appIndex].CurrentCount);

  002ac	ff c0		 inc	 eax
  002ae	43 89 84 08 f0
	29 00 00	 mov	 DWORD PTR [r8+r9+10736], eax
  002b6	89 86 a0 00 00
	00		 mov	 DWORD PTR [rsi+160], eax

; 637  : 					memcpy(&ClientLists[appIndex].Guid[i], &baseRequest->CMID, sizeof(GUID));

  002bc	48 63 c1	 movsxd	 rax, ecx
  002bf	41 0f 10 47 40	 movups	 xmm0, XMMWORD PTR [r15+64]
  002c4	48 c1 e0 04	 shl	 rax, 4
  002c8	49 03 c0	 add	 rax, r8
  002cb	f3 42 0f 7f 04
	08		 movdqu	 XMMWORD PTR [rax+r9], xmm0
$LN110@CreateResp:

; 638  : 					break;
; 639  : 				}
; 640  : 			}
; 641  : 
; 642  : 			if (i >= ClientLists[appIndex].MaxCount)

  002d1	43 3b 8c 08 f4
	29 00 00	 cmp	 ecx, DWORD PTR [r8+r9+10740]
  002d9	7c 4a		 jl	 SHORT $LN2@CreateResp
$LN112@CreateResp:

; 643  : 			{
; 644  : 				memcpy(&ClientLists[appIndex].Guid[ClientLists[appIndex].CurrentPosition], &baseRequest->CMID, sizeof(GUID));

  002db	4b 63 84 08 f8
	29 00 00	 movsxd	 rax, DWORD PTR [r8+r9+10744]
  002e3	41 0f 10 47 40	 movups	 xmm0, XMMWORD PTR [r15+64]
  002e8	48 c1 e0 04	 shl	 rax, 4
  002ec	49 03 c0	 add	 rax, r8
  002ef	f3 42 0f 7f 04
	08		 movdqu	 XMMWORD PTR [rax+r9], xmm0

; 645  : 				ClientLists[appIndex].CurrentPosition = (ClientLists[appIndex].CurrentPosition + 1) % (ClientLists[appIndex].MaxCount > MAX_CLIENTS ? MAX_CLIENTS : ClientLists[appIndex].MaxCount);

  002f5	43 8b 8c 08 f4
	29 00 00	 mov	 ecx, DWORD PTR [r8+r9+10740]
  002fd	43 8b 84 08 f8
	29 00 00	 mov	 eax, DWORD PTR [r8+r9+10744]
  00305	3b cb		 cmp	 ecx, ebx
  00307	0f 4f cb	 cmovg	 ecx, ebx
  0030a	ff c0		 inc	 eax
  0030c	99		 cdq
  0030d	f7 f9		 idiv	 ecx
  0030f	43 89 94 08 f8
	29 00 00	 mov	 DWORD PTR [r8+r9+10744], edx
$LN88@CreateResp:

; 646  : 				baseResponse->Count = LE32(ClientLists[appIndex].CurrentCount);

  00317	43 8b 84 08 f0
	29 00 00	 mov	 eax, DWORD PTR [r8+r9+10736]
  0031f	89 86 a0 00 00
	00		 mov	 DWORD PTR [rsi+160], eax
$LN2@CreateResp:

; 647  : 			}
; 648  : 		}
; 649  : 
; 650  : 		unlock_client_lists();

  00325	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR mutex
  0032c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 651  : 	}
; 652  : 	else

  00332	eb 1a		 jmp	 SHORT $LN1@CreateResp
$LN15@CreateResp:

; 653  : #	endif // !NO_CLIENT_LIST
; 654  : #	endif // !defined(NO_STRICT_MODES)
; 655  : 	{
; 656  : 		uint8_t minimum_answer_clients = (uint8_t)KmsData->CsvlkData[ePidIndex].MinActiveClients;

  00334	49 63 c4	 movsxd	 rax, r12d
  00337	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]

; 657  : 		baseResponse->Count = LE32(required_clients > minimum_answer_clients ? required_clients : minimum_answer_clients);

  0033b	41 0f b6 44 cb
	44		 movzx	 eax, BYTE PTR [r11+rcx*8+68]
  00341	44 3b f0	 cmp	 r14d, eax
  00344	41 0f 47 c6	 cmova	 eax, r14d
  00348	89 86 a0 00 00
	00		 mov	 DWORD PTR [rsi+160], eax
$LN1@CreateResp:

; 658  : 		//if (LE32(baseRequest->N_Policy) > LE32(baseResponse->Count)) baseResponse->Count = LE32(LE32(baseRequest->N_Policy) << 1);
; 659  : 	}
; 660  : 
; 661  : 	getEpid(baseResponse, &EpidSource, ePidIndex, hwId, ePid);

  0034e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR KmsResponseParameters
  00355	49 63 c4	 movsxd	 rax, r12d
  00358	48 83 cb ff	 or	 rbx, -1
  0035c	48 8d 14 40	 lea	 rdx, QWORD PTR [rax+rax*2]
  00360	4d 8b 0c d0	 mov	 r9, QWORD PTR [r8+rdx*8]
  00364	4d 85 c9	 test	 r9, r9
  00367	75 49		 jne	 SHORT $LN47@CreateResp
  00369	80 3d 00 00 00
	00 02		 cmp	 BYTE PTR RandomizationLevel, 2
  00370	75 30		 jne	 SHORT $LN46@CreateResp
  00372	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR Lcid
  00379	44 8b cb	 mov	 r9d, ebx
  0037c	48 8d 54 24 30	 lea	 rdx, QWORD PTR szPid$2[rsp]
  00381	66 85 c0	 test	 ax, ax
  00384	44 8b c3	 mov	 r8d, ebx
  00387	41 8b cc	 mov	 ecx, r12d
  0038a	66 44 0f 45 c8	 cmovne	 r9w, ax
  0038f	e8 00 00 00 00	 call	 generateRandomPid
  00394	4c 8d 4c 24 30	 lea	 r9, QWORD PTR szPid$2[rsp]
  00399	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0BM@JLIHBDJL@randomized?5on?5every?5request?$AA@
  003a0	eb 2b		 jmp	 SHORT $LN44@CreateResp
$LN46@CreateResp:
  003a2	4c 8b 8d a0 00
	00 00		 mov	 r9, QWORD PTR ePid$[rbp-256]
  003a9	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_0P@CACDFLGA@vlmcsd?5default?$AA@
  003b0	eb 1b		 jmp	 SHORT $LN44@CreateResp
$LN47@CreateResp:
  003b2	4d 85 ed	 test	 r13, r13
  003b5	74 11		 je	 SHORT $LN43@CreateResp
  003b7	49 8b 44 d0 08	 mov	 rax, QWORD PTR [r8+rdx*8+8]
  003bc	48 85 c0	 test	 rax, rax
  003bf	74 07		 je	 SHORT $LN43@CreateResp
  003c1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003c4	49 89 45 00	 mov	 QWORD PTR [r13], rax
$LN43@CreateResp:
  003c8	49 8b 7c d0 10	 mov	 rdi, QWORD PTR [r8+rdx*8+16]
$LN44@CreateResp:
  003cd	4c 8d 76 08	 lea	 r14, QWORD PTR [rsi+8]
  003d1	33 d2		 xor	 edx, edx
  003d3	4d 8b c1	 mov	 r8, r9
  003d6	4d 8b d6	 mov	 r10, r14
  003d9	4c 89 8d a0 00
	00 00		 mov	 QWORD PTR current_utf8$6[rbp-256], r9
  003e0	41 38 11	 cmp	 BYTE PTR [r9], dl
  003e3	0f 84 93 00 00
	00		 je	 $LN57@CreateResp
  003e9	4c 8d 62 fe	 lea	 r12, QWORD PTR [rdx-2]
  003ed	4d 2b e6	 sub	 r12, r14
$LL59@CreateResp:
  003f0	49 8b c8	 mov	 rcx, r8
  003f3	49 2b c9	 sub	 rcx, r9
  003f6	48 81 f9 c0 00
	00 00		 cmp	 rcx, 192		; 000000c0H
  003fd	0f 83 82 00 00
	00		 jae	 $LN60@CreateResp
  00403	41 8a 00	 mov	 al, BYTE PTR [r8]
  00406	24 c0		 and	 al, 192			; 000000c0H
  00408	3c c0		 cmp	 al, 192			; 000000c0H
  0040a	75 09		 jne	 SHORT $LN55@CreateResp
  0040c	48 81 f9 bf 00
	00 00		 cmp	 rcx, 191		; 000000bfH
  00413	73 70		 jae	 SHORT $LN60@CreateResp
$LN55@CreateResp:
  00415	41 8a 00	 mov	 al, BYTE PTR [r8]
  00418	24 e0		 and	 al, 224			; 000000e0H
  0041a	3c e0		 cmp	 al, 224			; 000000e0H
  0041c	75 09		 jne	 SHORT $LN54@CreateResp
  0041e	48 81 f9 be 00
	00 00		 cmp	 rcx, 190		; 000000beH
  00425	73 5e		 jae	 SHORT $LN60@CreateResp
$LN54@CreateResp:
  00427	4d 8d 5a 02	 lea	 r11, QWORD PTR [r10+2]
  0042b	4b 8d 04 1c	 lea	 rax, QWORD PTR [r12+r11]
  0042f	48 83 e0 fe	 and	 rax, -2
  00433	48 83 f8 7e	 cmp	 rax, 126		; 0000007eH
  00437	7d 4c		 jge	 SHORT $LN60@CreateResp
  00439	41 38 10	 cmp	 BYTE PTR [r8], dl
  0043c	75 07		 jne	 SHORT $LN73@CreateResp
  0043e	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00443	eb 18		 jmp	 SHORT $LN69@CreateResp
$LN73@CreateResp:
  00445	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR current_utf8$6[rbp-256]
  0044c	49 8b c8	 mov	 rcx, r8
  0044f	e8 00 00 00 00	 call	 utf8_to_ucs2_char
  00454	4c 8b 85 a0 00
	00 00		 mov	 r8, QWORD PTR current_utf8$6[rbp-256]
  0045b	33 d2		 xor	 edx, edx
$LN69@CreateResp:
  0045d	66 41 89 02	 mov	 WORD PTR [r10], ax
  00461	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00466	66 41 89 13	 mov	 WORD PTR [r11], dx
  0046a	66 41 39 02	 cmp	 WORD PTR [r10], ax
  0046e	74 15		 je	 SHORT $LN60@CreateResp
  00470	4d 8b d3	 mov	 r10, r11
  00473	41 38 10	 cmp	 BYTE PTR [r8], dl
  00476	0f 85 74 ff ff
	ff		 jne	 $LL59@CreateResp
$LN57@CreateResp:
  0047c	49 8b da	 mov	 rbx, r10
  0047f	49 2b de	 sub	 rbx, r14
  00482	48 d1 fb	 sar	 rbx, 1
$LN60@CreateResp:
  00485	8d 04 5d 02 00
	00 00		 lea	 eax, DWORD PTR [rbx*2+2]

; 662  : 
; 663  : 	baseResponse->Version = baseRequest->Version;
; 664  : 
; 665  : 	memcpy(&baseResponse->CMID, &baseRequest->CMID, sizeof(GUID));

  0048c	48 8d 9e 88 00
	00 00		 lea	 rbx, QWORD PTR [rsi+136]

; 666  : 	memcpy(&baseResponse->ClientTime, &baseRequest->ClientTime, sizeof(FILETIME));
; 667  : 
; 668  : 	baseResponse->VLActivationInterval = LE32(VLActivationInterval);
; 669  : 	baseResponse->VLRenewalInterval = LE32(VLRenewalInterval);
; 670  : 
; 671  : #ifndef NO_LOG
; 672  : 	logResponse(baseResponse, hwId, EpidSource);

  00493	48 8d 55 b0	 lea	 rdx, QWORD PTR utf8pid$4[rbp-256]
  00497	89 46 04	 mov	 DWORD PTR [rsi+4], eax
  0049a	41 8b 07	 mov	 eax, DWORD PTR [r15]
  0049d	41 b9 c0 00 00
	00		 mov	 r9d, 192		; 000000c0H
  004a3	89 06		 mov	 DWORD PTR [rsi], eax
  004a5	49 8b ce	 mov	 rcx, r14
  004a8	41 0f 10 47 40	 movups	 xmm0, XMMWORD PTR [r15+64]
  004ad	f3 0f 7f 03	 movdqu	 XMMWORD PTR [rbx], xmm0
  004b1	49 8b 47 54	 mov	 rax, QWORD PTR [r15+84]
  004b5	48 89 86 98 00
	00 00		 mov	 QWORD PTR [rsi+152], rax
  004bc	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR VLActivationInterval
  004c2	89 86 a4 00 00
	00		 mov	 DWORD PTR [rsi+164], eax
  004c8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR VLRenewalInterval
  004ce	89 86 a8 00 00
	00		 mov	 DWORD PTR [rsi+168], eax
  004d4	e8 00 00 00 00	 call	 ucs2_to_utf8
  004d9	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR logverbose, 0
  004e0	48 8b d7	 mov	 rdx, rdi
  004e3	75 15		 jne	 SHORT $LN75@CreateResp
  004e5	4c 8d 45 b0	 lea	 r8, QWORD PTR utf8pid$4[rbp-256]
  004e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@ECOFGFLJ@Sending?5ePID?5?$CI?$CFs?$CJ?3?5?$CFs?6?$AA@
  004f0	e8 00 00 00 00	 call	 logger
  004f5	e9 ff 00 00 00	 jmp	 $LN79@CreateResp
$LN75@CreateResp:
  004fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@NLELAFGA@?$DO?$DO?$DO?5Sending?5response?0?5ePID?5sourc@
  00501	e8 00 00 00 00	 call	 logger
  00506	44 0f b7 06	 movzx	 r8d, WORD PTR [rsi]
  0050a	0f b7 56 02	 movzx	 edx, WORD PTR [rsi+2]
  0050e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@KEHOAAGG@Protocol?5version?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
  00515	e8 00 00 00 00	 call	 logger
  0051a	48 8d 55 b0	 lea	 rdx, QWORD PTR utf8pid$4[rbp-256]
  0051e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@CKMBAHPA@KMS?5host?5extended?5PID?5?5?5?5?5?5?5?5?5?5?5@
  00525	e8 00 00 00 00	 call	 logger
  0052a	66 83 7e 02 05	 cmp	 WORD PTR [rsi+2], 5
  0052f	76 13		 jbe	 SHORT $LN78@CreateResp
  00531	49 8b 55 00	 mov	 rdx, QWORD PTR [r13]
  00535	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CM@BGLDHKHD@KMS?5host?5Hardware?5ID?5?5?5?5?5?5?5?5?5?5?5?5@
  0053c	48 0f ca	 bswap	 rdx
  0053f	e8 00 00 00 00	 call	 logger
$LN78@CreateResp:
  00544	48 8d 54 24 30	 lea	 rdx, QWORD PTR guidBuffer$1[rsp]
  00549	48 8b cb	 mov	 rcx, rbx
  0054c	e8 00 00 00 00	 call	 uuid2StringLE
  00551	48 8d 54 24 30	 lea	 rdx, QWORD PTR guidBuffer$1[rsp]
  00556	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@NAJADCGN@Client?5machine?5ID?5?5?5?5?5?5?5?5?5?5?5?5?5?5?5@
  0055d	e8 00 00 00 00	 call	 logger
  00562	48 b8 bd 42 7a
	e5 d5 94 bf d6	 mov	 rax, -2972493582642298179 ; d6bf94d5e57a42bdH
  0056c	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR st$5[rbp-256]
  00573	48 f7 a6 98 00
	00 00		 mul	 QWORD PTR [rsi+152]
  0057a	48 c1 ea 17	 shr	 rdx, 23
  0057e	48 b8 00 91 10
	b6 02 00 00 00	 mov	 rax, 11644473600	; 00000002b6109100H
  00588	48 2b d0	 sub	 rdx, rax
  0058b	48 89 95 a0 00
	00 00		 mov	 QWORD PTR st$5[rbp-256], rdx
  00592	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__gmtime64
  00598	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0M@EHAPGNAC@?$CFY?9?$CFm?9?$CFd?5?$CFX?$AA@
  0059f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR mbstr$3[rsp]
  005a4	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  005a9	4c 8b c8	 mov	 r9, rax
  005ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strftime
  005b2	48 8d 54 24 70	 lea	 rdx, QWORD PTR mbstr$3[rsp]
  005b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@CCLOIHMC@Client?5request?5timestamp?5?$CIUTC?$CJ?5?5@
  005be	e8 00 00 00 00	 call	 logger
  005c3	8b 96 a0 00 00
	00		 mov	 edx, DWORD PTR [rsi+160]
  005c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@CKOEJNCP@KMS?5host?5current?5active?5clients?5@
  005d0	e8 00 00 00 00	 call	 logger
  005d5	8b 96 a8 00 00
	00		 mov	 edx, DWORD PTR [rsi+168]
  005db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@HGDBGCN@Renewal?5interval?5policy?5?5?5?5?5?5?5?5?5@
  005e2	e8 00 00 00 00	 call	 logger
  005e7	8b 96 a4 00 00
	00		 mov	 edx, DWORD PTR [rsi+164]
  005ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CG@EIDEKNCG@Activation?5interval?5policy?5?5?5?5?5?5@
  005f4	e8 00 00 00 00	 call	 logger
$LN79@CreateResp:

; 673  : #endif // NO_LOG
; 674  : 
; 675  : 	return S_OK;

  005f9	33 c0		 xor	 eax, eax
$LN24@CreateResp:

; 676  : }

  005fb	4c 8d 9c 24 70
	01 00 00	 lea	 r11, QWORD PTR [rsp+368]
  00603	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00607	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  0060b	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  0060f	49 8b e3	 mov	 rsp, r11
  00612	41 5f		 pop	 r15
  00614	41 5e		 pop	 r14
  00616	41 5d		 pop	 r13
  00618	41 5c		 pop	 r12
  0061a	5d		 pop	 rbp
  0061b	c3		 ret	 0
CreateResponseBaseCallback ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT get16RandomBytes
_TEXT	SEGMENT
ptr$ = 48
get16RandomBytes PROC					; COMDAT

; 689  : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f1	 mov	 rsi, rcx

; 690  : 	int i;
; 691  : 	for (i = 0; i < 4; i++)	((DWORD*)ptr)[i] = rand32();

  00012	33 ff		 xor	 edi, edi
$LL3@get16Rando:
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  0001a	8b d8		 mov	 ebx, eax
  0001c	c1 e3 0f	 shl	 ebx, 15
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00025	0b d8		 or	 ebx, eax
  00027	c1 e3 02	 shl	 ebx, 2
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00030	83 e0 03	 and	 eax, 3
  00033	0b c3		 or	 eax, ebx
  00035	89 04 be	 mov	 DWORD PTR [rsi+rdi*4], eax
  00038	48 ff c7	 inc	 rdi
  0003b	48 83 ff 04	 cmp	 rdi, 4
  0003f	7c d3		 jl	 SHORT $LL3@get16Rando

; 692  : }

  00041	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00046	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
get16RandomBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT CreateResponseV4
_TEXT	SEGMENT
request_v4$ = 48
responseBuffer$ = 56
ipstr$ = 64
CreateResponseV4 PROC					; COMDAT

; 698  : {

$LN5:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 699  : 	RESPONSE_V4* Response = (RESPONSE_V4*)responseBuffer;
; 700  : 
; 701  : 	HRESULT hResult;
; 702  : 	if (FAILED(hResult = CreateResponseBase(&request_v4->RequestBase, &Response->ResponseBase, NULL, ipstr))) return hResult;

  0000a	4d 8b c8	 mov	 r9, r8
  0000d	45 33 c0	 xor	 r8d, r8d
  00010	48 8b fa	 mov	 rdi, rdx
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR CreateResponseBase
  00019	85 c0		 test	 eax, eax
  0001b	79 04		 jns	 SHORT $LN1@CreateResp
  0001d	48 98		 cdqe
  0001f	eb 34		 jmp	 SHORT $LN2@CreateResp
$LN1@CreateResp:

; 703  : 
; 704  : 	DWORD pidSize = LE32(Response->ResponseBase.PIDSize);
; 705  : 	BYTE* postEpidPtr = responseBuffer + V4_PRE_EPID_SIZE + pidSize;

  00021	8b 5f 04	 mov	 ebx, DWORD PTR [rdi+4]
  00024	48 8d 4f 08	 lea	 rcx, QWORD PTR [rdi+8]

; 706  : 	memmove(postEpidPtr, &Response->ResponseBase.CMID, V4_POST_EPID_SIZE);

  00028	48 8d 97 88 00
	00 00		 lea	 rdx, QWORD PTR [rdi+136]
  0002f	48 03 cb	 add	 rcx, rbx
  00032	41 b8 24 00 00
	00		 mov	 r8d, 36			; 00000024H
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 707  : 
; 708  : 	size_t encryptSize = V4_PRE_EPID_SIZE + V4_POST_EPID_SIZE + pidSize;

  0003e	48 83 c3 2c	 add	 rbx, 44			; 0000002cH

; 709  : 	AesCmacV4(responseBuffer, encryptSize, responseBuffer + encryptSize);

  00042	48 8b cf	 mov	 rcx, rdi
  00045	4c 8d 04 3b	 lea	 r8, QWORD PTR [rbx+rdi]
  00049	48 8b d3	 mov	 rdx, rbx
  0004c	e8 00 00 00 00	 call	 AesCmacV4

; 710  : 
; 711  : 	return encryptSize + sizeof(Response->MAC);

  00051	48 8d 43 10	 lea	 rax, QWORD PTR [rbx+16]
$LN2@CreateResp:

; 712  : }

  00055	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5f		 pop	 rdi
  0005f	c3		 ret	 0
CreateResponseV4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT CreateV6Hmac
_TEXT	SEGMENT
hmackeyblob$1 = 48
hash$ = 80
HmacInfo$2 = 112
hHmacHash$3 = 208
timeSlot$ = 208
encrypt_start$ = 208
hKey$4 = 216
encryptSize$ = 216
dwHmacSize$5 = 224
tolerance$dead$ = 224
CreateV6Hmac PROC					; COMDAT

; 729  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	55		 push	 rbp
  00006	53		 push	 rbx
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 56		 push	 r14
  0000b	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  00010	48 81 ec a0 00
	00 00		 sub	 rsp, 160		; 000000a0H
  00017	48 8b fa	 mov	 rdi, rdx
  0001a	48 8b f1	 mov	 rsi, rcx

; 730  : 	BYTE hash[32];
; 731  : 	const uint8_t halfHashSize = sizeof(hash) >> 1;
; 732  : 	BYTE *responseEnd = encrypt_start + encryptSize;
; 733  : 
; 734  : 	// This is the time from the response
; 735  : 	FILETIME* ft = (FILETIME*)(responseEnd - V6_POST_EPID_SIZE + sizeof(((RESPONSE*)0)->CMID));
; 736  : 
; 737  : 	// Generate a time slot that changes every 4.11 hours.
; 738  : 	// Request and repsonse time must match +/- 1 slot.
; 739  : 	// When generating a response tolerance must be 0.
; 740  : 	// If verifying the hash, try tolerance -1, 0 and +1. One of them must match.
; 741  : 
; 742  : 	uint64_t timeSlot = LE64((GET_UA64LE(ft) / TIME_C1 * TIME_C2 + TIME_C3) + (tolerance * TIME_C1));

  0001d	33 d2		 xor	 edx, edx
  0001f	48 8b 44 39 94	 mov	 rax, QWORD PTR [rcx+rdi-108]
  00024	48 b9 bd 89 68
	81 22 00 00 00	 mov	 rcx, 148199999933	; 00000022816889bdH

; 743  : 
; 744  : 	// The time slot is hashed with SHA256 so it is not so obvious that it is time
; 745  : 	Sha256((BYTE*)&timeSlot, sizeof(timeSlot), hash);

  0002e	4c 8d 45 e7	 lea	 r8, QWORD PTR hash$[rbp-105]
  00032	48 f7 f1	 div	 rcx
  00035	48 b9 ed b5 ba
	8c 20 00 00 00	 mov	 rcx, 139799999981	; 000000208cbab5edH
  0003f	ba 08 00 00 00	 mov	 edx, 8
  00044	48 0f af c1	 imul	 rax, rcx
  00048	48 b9 7a 47 28
	c6 5a cd 56 31	 mov	 rcx, 3555254745610864506 ; 3156cd5ac628477aH
  00052	48 03 c1	 add	 rax, rcx
  00055	48 8d 4d 67	 lea	 rcx, QWORD PTR timeSlot$[rbp-105]
  00059	48 89 45 67	 mov	 QWORD PTR timeSlot$[rbp-105], rax
  0005d	e8 00 00 00 00	 call	 Sha256

; 746  : 
; 747  : 	// The last 16 bytes of the hashed time slot are the actual HMAC key
; 748  : 	if (!Sha256Hmac
; 749  : 	(
; 750  : 		hash + halfHashSize,									// Use last 16 bytes of SHA256 as HMAC key
; 751  : 		encrypt_start,											// hash only the encrypted part of the v6 response
; 752  : 		(DWORD)(encryptSize - sizeof(((RESPONSE_V6*)0)->HMAC)),	// encryptSize minus the HMAC itself
; 753  : 		hash													// use same buffer for resulting hash where the key came from
; 754  : 	))

  00062	33 c0		 xor	 eax, eax
  00064	8d 58 20	 lea	 ebx, QWORD PTR [rax+32]
  00067	45 33 f6	 xor	 r14d, r14d
  0006a	48 8d 4d 0f	 lea	 rcx, QWORD PTR HmacInfo$2[rbp-97]
  0006e	33 d2		 xor	 edx, edx
  00070	44 8b c3	 mov	 r8d, ebx
  00073	c7 45 c7 08 02
	00 00		 mov	 DWORD PTR hmackeyblob$1[rbp-105], 520 ; 00000208H
  0007a	c7 45 cb 02 66
	00 00		 mov	 DWORD PTR hmackeyblob$1[rbp-101], 26114 ; 00006602H
  00081	c7 45 cf 10 00
	00 00		 mov	 DWORD PTR hmackeyblob$1[rbp-97], 16
  00088	48 89 45 d3	 mov	 QWORD PTR hmackeyblob$1[rbp-93], rax
  0008c	48 89 45 db	 mov	 QWORD PTR hmackeyblob$1[rbp-85], rax
  00090	4c 89 75 6f	 mov	 QWORD PTR hKey$4[rbp-105], r14
  00094	4c 89 75 67	 mov	 QWORD PTR hHmacHash$3[rbp-105], r14
  00098	e8 00 00 00 00	 call	 memset
  0009d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hRsaAesProvider
  000a4	89 5d 77	 mov	 DWORD PTR dwHmacSize$5[rbp-105], ebx
  000a7	0f 10 45 f7	 movups	 xmm0, XMMWORD PTR hash$[rbp-89]
  000ab	c7 45 07 0c 80
	00 00		 mov	 DWORD PTR HmacInfo$2[rbp-105], 32780 ; 0000800cH
  000b2	f3 0f 7f 45 d3	 movdqu	 XMMWORD PTR hmackeyblob$1[rbp-93], xmm0
  000b7	48 85 c9	 test	 rcx, rcx
  000ba	75 27		 jne	 SHORT $LN10@CreateV6Hm
  000bc	45 8d 4e 18	 lea	 r9d, QWORD PTR [r14+24]
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:hRsaAesProvider
  000c7	45 33 c0	 xor	 r8d, r8d
  000ca	33 d2		 xor	 edx, edx
  000cc	c7 44 24 20 00
	00 00 f0	 mov	 DWORD PTR [rsp+32], -268435456 ; f0000000H
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptAcquireContextW
  000da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hRsaAesProvider
  000e1	eb 02		 jmp	 SHORT $LN11@CreateV6Hm
$LN10@CreateV6Hm:
  000e3	b0 01		 mov	 al, 1
$LN11@CreateV6Hm:
  000e5	84 c0		 test	 al, al
  000e7	0f 84 9f 00 00
	00		 je	 $LN13@CreateV6Hm
  000ed	45 33 c9	 xor	 r9d, r9d
  000f0	48 8d 45 6f	 lea	 rax, QWORD PTR hKey$4[rbp-105]
  000f4	48 8d 55 c7	 lea	 rdx, QWORD PTR hmackeyblob$1[rbp-105]
  000f8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000fd	45 8d 41 1c	 lea	 r8d, QWORD PTR [r9+28]
  00101	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptImportKey
  0010c	85 c0		 test	 eax, eax
  0010e	74 7c		 je	 SHORT $LN13@CreateV6Hm
  00110	4c 8b 45 6f	 mov	 r8, QWORD PTR hKey$4[rbp-105]
  00114	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hRsaAesProvider
  0011b	48 8d 45 67	 lea	 rax, QWORD PTR hHmacHash$3[rbp-105]
  0011f	45 33 c9	 xor	 r9d, r9d
  00122	ba 09 80 00 00	 mov	 edx, 32777		; 00008009H
  00127	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptCreateHash
  00132	85 c0		 test	 eax, eax
  00134	74 56		 je	 SHORT $LN13@CreateV6Hm
  00136	48 8b 4d 67	 mov	 rcx, QWORD PTR hHmacHash$3[rbp-105]
  0013a	45 33 c9	 xor	 r9d, r9d
  0013d	4c 8d 45 07	 lea	 r8, QWORD PTR HmacInfo$2[rbp-105]
  00141	41 8d 51 05	 lea	 edx, QWORD PTR [r9+5]
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptSetHashParam
  0014b	85 c0		 test	 eax, eax
  0014d	74 3d		 je	 SHORT $LN13@CreateV6Hm
  0014f	48 8b 4d 67	 mov	 rcx, QWORD PTR hHmacHash$3[rbp-105]
  00153	44 8d 47 f0	 lea	 r8d, DWORD PTR [rdi-16]
  00157	45 33 c9	 xor	 r9d, r9d
  0015a	48 8b d6	 mov	 rdx, rsi
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptHashData
  00163	85 c0		 test	 eax, eax
  00165	74 25		 je	 SHORT $LN13@CreateV6Hm
  00167	48 8b 4d 67	 mov	 rcx, QWORD PTR hHmacHash$3[rbp-105]
  0016b	4c 8d 4d 77	 lea	 r9, QWORD PTR dwHmacSize$5[rbp-105]
  0016f	4c 8d 45 e7	 lea	 r8, QWORD PTR hash$[rbp-105]
  00173	ba 02 00 00 00	 mov	 edx, 2
  00178	44 89 74 24 20	 mov	 DWORD PTR [rsp+32], r14d
  0017d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptGetHashParam
  00183	bb 01 00 00 00	 mov	 ebx, 1
  00188	85 c0		 test	 eax, eax
  0018a	75 03		 jne	 SHORT $LN9@CreateV6Hm
$LN13@CreateV6Hm:
  0018c	41 8b de	 mov	 ebx, r14d
$LN9@CreateV6Hm:
  0018f	48 8b 4d 6f	 mov	 rcx, QWORD PTR hKey$4[rbp-105]
  00193	48 85 c9	 test	 rcx, rcx
  00196	74 06		 je	 SHORT $LN5@CreateV6Hm
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptDestroyKey
$LN5@CreateV6Hm:
  0019e	48 8b 4d 67	 mov	 rcx, QWORD PTR hHmacHash$3[rbp-105]
  001a2	48 85 c9	 test	 rcx, rcx
  001a5	74 06		 je	 SHORT $LN4@CreateV6Hm
  001a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CryptDestroyHash
$LN4@CreateV6Hm:
  001ad	84 db		 test	 bl, bl
  001af	75 04		 jne	 SHORT $LN1@CreateV6Hm

; 755  : 	{
; 756  : 		return FALSE;

  001b1	32 c0		 xor	 al, al
  001b3	eb 0b		 jmp	 SHORT $LN2@CreateV6Hm
$LN1@CreateV6Hm:

; 757  : 	}
; 758  : 
; 759  : 	memcpy(responseEnd - sizeof(((RESPONSE_V6*)0)->HMAC), hash + halfHashSize, halfHashSize);

  001b5	0f 10 45 f7	 movups	 xmm0, XMMWORD PTR hash$[rbp-89]

; 760  : 	return TRUE;

  001b9	b0 01		 mov	 al, 1
  001bb	0f 11 44 3e f0	 movups	 XMMWORD PTR [rsi+rdi-16], xmm0
$LN2@CreateV6Hm:

; 761  : }

  001c0	48 81 c4 a0 00
	00 00		 add	 rsp, 160		; 000000a0H
  001c7	41 5e		 pop	 r14
  001c9	5f		 pop	 rdi
  001ca	5e		 pop	 rsi
  001cb	5b		 pop	 rbx
  001cc	5d		 pop	 rbp
  001cd	c3		 ret	 0
CreateV6Hmac ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\kms.c
;	COMDAT CreateResponseV6
_TEXT	SEGMENT
aesCtx$ = 32
encryptSize$ = 288
request_v6$ = 288
responseBuffer$ = 296
ipstr$ = 304
CreateResponseV6 PROC					; COMDAT

; 768  : {

$LN17:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 81 ec f0 00
	00 00		 sub	 rsp, 240		; 000000f0H

; 769  : 	// The response will be created in a fixed sized struct to
; 770  : 	// avoid unaligned access macros and packed structs on RISC systems
; 771  : 	// which largely increase code size.
; 772  : 	//
; 773  : 	// The fixed sized struct with 64 WCHARs for the ePID will be converted
; 774  : 	// to a variable sized struct later and requires unaligned access macros.
; 775  : 
; 776  : 	RESPONSE_V6* Response = (RESPONSE_V6*)responseBuffer;
; 777  : 	RESPONSE* baseResponse = &Response->ResponseBase;
; 778  : 
; 779  : #ifdef _DEBUG
; 780  : 	// ReSharper disable once CppEntityNeverUsed
; 781  : 	RESPONSE_V6_DEBUG* xxx_unused = (RESPONSE_V6_DEBUG*)responseBuffer;
; 782  : #endif
; 783  : 
; 784  : 	static const BYTE DefaultHwid[8] = { HWID };
; 785  : 	int_fast8_t v6 = LE16(request_v6->MajorVer) > 5;

  00019	66 83 79 02 05	 cmp	 WORD PTR [rcx+2], 5
  0001e	48 8b f2	 mov	 rsi, rdx

; 786  : 	AesCtx aesCtx;
; 787  : 
; 788  : 	AesInitKey(&aesCtx, v6 ? AesKeyV6 : AesKeyV5, v6, AES_KEY_BYTES);

  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:AesKeyV6
  00028	41 0f 97 c6	 seta	 r14b
  0002c	48 8b f9	 mov	 rdi, rcx
  0002f	4d 8b e0	 mov	 r12, r8
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:AesKeyV5
  00039	45 84 f6	 test	 r14b, r14b
  0003c	48 8d 4c 24 20	 lea	 rcx, QWORD PTR aesCtx$[rsp]
  00041	41 b9 10 00 00
	00		 mov	 r9d, 16
  00047	45 8a c6	 mov	 r8b, r14b
  0004a	48 0f 45 d0	 cmovne	 rdx, rax
  0004e	e8 00 00 00 00	 call	 AesInitKey

; 789  : 	AesDecryptCbc(&aesCtx, NULL, request_v6->IV, V6_DECRYPT_SIZE);

  00053	4c 8d 47 04	 lea	 r8, QWORD PTR [rdi+4]
  00057	48 8d 4c 24 20	 lea	 rcx, QWORD PTR aesCtx$[rsp]
  0005c	e8 00 00 00 00	 call	 AesDecryptCbc

; 790  : 
; 791  : 	// get random salt and SHA256 it
; 792  : 	get16RandomBytes(Response->RandomXoredIVs);

  00061	48 8d 9e c0 00
	00 00		 lea	 rbx, QWORD PTR [rsi+192]
  00068	48 8b cb	 mov	 rcx, rbx
  0006b	e8 00 00 00 00	 call	 get16RandomBytes

; 793  : 	Sha256(Response->RandomXoredIVs, sizeof(Response->RandomXoredIVs), Response->Hash);

  00070	4c 8d 86 d0 00
	00 00		 lea	 r8, QWORD PTR [rsi+208]
  00077	ba 10 00 00 00	 mov	 edx, 16
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 Sha256

; 794  : 
; 795  : 	if (v6) // V6 specific stuff

  00084	45 84 f6	 test	 r14b, r14b
  00087	74 29		 je	 SHORT $LN4@CreateResp

; 796  : 	{
; 797  : 		// In v6 a random IV is generated
; 798  : 		Response->Version = request_v6->Version;

  00089	8b 07		 mov	 eax, DWORD PTR [rdi]

; 799  : 		get16RandomBytes(Response->IV);

  0008b	48 8d 4e 04	 lea	 rcx, QWORD PTR [rsi+4]
  0008f	89 06		 mov	 DWORD PTR [rsi], eax
  00091	e8 00 00 00 00	 call	 get16RandomBytes

; 800  : 
; 801  : 		// pre-fill with default HwId (not required for v5)
; 802  : 		memcpy(Response->HwId, DefaultHwid, sizeof(Response->HwId));

  00096	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?DefaultHwid@?1??CreateResponseV6@@9@9

; 803  : 
; 804  : 		// Just copy decrypted request IV (using Null IV) here. Note this is identical
; 805  : 		// to XORing non-decrypted request and reponse IVs
; 806  : 		memcpy(Response->XoredIVs, request_v6->IV, sizeof(Response->XoredIVs));

  0009d	0f 10 47 04	 movups	 xmm0, XMMWORD PTR [rdi+4]
  000a1	48 89 86 f0 00
	00 00		 mov	 QWORD PTR [rsi+240], rax
  000a8	f3 0f 7f 86 f8
	00 00 00	 movdqu	 XMMWORD PTR [rsi+248], xmm0

; 807  : 	}
; 808  : 	else // V5 specific stuff

  000b0	eb 0c		 jmp	 SHORT $LN3@CreateResp
$LN4@CreateResp:

; 809  : 	{
; 810  : 		// In v5 IVs of request and response must be identical (MS client checks this)
; 811  : 		// The following memcpy copies Version and IVs at once
; 812  : 		memcpy(Response, request_v6, V6_UNENCRYPTED_SIZE);

  000b2	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]
  000b5	8b 47 10	 mov	 eax, DWORD PTR [rdi+16]
  000b8	0f 11 06	 movups	 XMMWORD PTR [rsi], xmm0
  000bb	89 46 10	 mov	 DWORD PTR [rsi+16], eax
$LN3@CreateResp:

; 813  : 	}
; 814  : 
; 815  : 	// Xor Random bytes with decrypted request IV
; 816  : 	XorBlock(request_v6->IV, Response->RandomXoredIVs);

  000be	48 8b cf	 mov	 rcx, rdi
  000c1	ba 04 00 00 00	 mov	 edx, 4
  000c6	48 2b cb	 sub	 rcx, rbx
$LL9@CreateResp:
  000c9	8b 44 19 04	 mov	 eax, DWORD PTR [rcx+rbx+4]
  000cd	31 03		 xor	 DWORD PTR [rbx], eax
  000cf	48 8d 5b 04	 lea	 rbx, QWORD PTR [rbx+4]
  000d3	48 ff ca	 dec	 rdx
  000d6	75 f1		 jne	 SHORT $LL9@CreateResp

; 817  : 
; 818  : 	// Get the base response
; 819  : 	HRESULT hResult;
; 820  : 	if (FAILED(hResult = CreateResponseBase(&request_v6->RequestBase, baseResponse, Response->HwId, ipstr))) return hResult;

  000d8	4c 8d 86 f0 00
	00 00		 lea	 r8, QWORD PTR [rsi+240]
  000df	48 8d 4f 14	 lea	 rcx, QWORD PTR [rdi+20]
  000e3	48 8d 56 14	 lea	 rdx, QWORD PTR [rsi+20]
  000e7	4d 8b cc	 mov	 r9, r12
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR CreateResponseBase
  000f0	85 c0		 test	 eax, eax
  000f2	79 04		 jns	 SHORT $LN2@CreateResp
  000f4	48 98		 cdqe
  000f6	eb 70		 jmp	 SHORT $LN5@CreateResp
$LN2@CreateResp:

; 821  : 
; 822  : 	// Convert the fixed sized struct into variable sized
; 823  : 	DWORD pidSize = LE32(baseResponse->PIDSize);
; 824  : 	BYTE* postEpidPtr = responseBuffer + V6_PRE_EPID_SIZE + pidSize;

  000f8	8b 5e 18	 mov	 ebx, DWORD PTR [rsi+24]

; 825  : 	size_t post_epid_size = v6 ? V6_POST_EPID_SIZE : V5_POST_EPID_SIZE;

  000fb	41 8a c6	 mov	 al, r14b
  000fe	48 8d 4e 1c	 lea	 rcx, QWORD PTR [rsi+28]
  00102	f6 d8		 neg	 al

; 826  : 
; 827  : 	memmove(postEpidPtr, &baseResponse->CMID, post_epid_size);

  00104	48 8d 96 9c 00
	00 00		 lea	 rdx, QWORD PTR [rsi+156]
  0010b	48 1b ff	 sbb	 rdi, rdi
  0010e	48 03 cb	 add	 rcx, rbx
  00111	83 e7 28	 and	 edi, 40			; 00000028H
  00114	48 83 c7 54	 add	 rdi, 84			; 00000054H
  00118	4c 8b c7	 mov	 r8, rdi
  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 828  : 
; 829  : 	// number of bytes to encrypt
; 830  : 	size_t encryptSize =
; 831  : 		V6_PRE_EPID_SIZE
; 832  : 		- sizeof(Response->Version)
; 833  : 		+ pidSize
; 834  : 		+ post_epid_size;

  00121	48 8d 53 18	 lea	 rdx, QWORD PTR [rbx+24]
  00125	48 03 d7	 add	 rdx, rdi
  00128	48 89 94 24 20
	01 00 00	 mov	 QWORD PTR encryptSize$[rsp], rdx

; 835  : 
; 836  : 	//AesDecryptBlock(&aesCtx, Response->IV);
; 837  : 	if (v6 && !CreateV6Hmac(Response->IV, encryptSize, 0)) return 0;

  00130	45 84 f6	 test	 r14b, r14b
  00133	74 11		 je	 SHORT $LN1@CreateResp
  00135	48 8d 4e 04	 lea	 rcx, QWORD PTR [rsi+4]
  00139	e8 00 00 00 00	 call	 CreateV6Hmac
  0013e	84 c0		 test	 al, al
  00140	75 04		 jne	 SHORT $LN1@CreateResp
  00142	33 c0		 xor	 eax, eax
  00144	eb 22		 jmp	 SHORT $LN5@CreateResp
$LN1@CreateResp:

; 838  : 
; 839  : 	// Padding auto handled by encryption func
; 840  : 	AesEncryptCbc(&aesCtx, NULL, Response->IV, &encryptSize);

  00146	4c 8d 46 04	 lea	 r8, QWORD PTR [rsi+4]
  0014a	4c 8d 8c 24 20
	01 00 00	 lea	 r9, QWORD PTR encryptSize$[rsp]
  00152	48 8d 4c 24 20	 lea	 rcx, QWORD PTR aesCtx$[rsp]
  00157	e8 00 00 00 00	 call	 AesEncryptCbc

; 841  : 
; 842  : 	return encryptSize + sizeof(Response->Version);

  0015c	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR encryptSize$[rsp]
  00164	48 83 c0 04	 add	 rax, 4
$LN5@CreateResp:

; 843  : }

  00168	4c 8d 9c 24 f0
	00 00 00	 lea	 r11, QWORD PTR [rsp+240]
  00170	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00174	49 8b 6b 40	 mov	 rbp, QWORD PTR [r11+64]
  00178	49 8b e3	 mov	 rsp, r11
  0017b	41 5f		 pop	 r15
  0017d	41 5e		 pop	 r14
  0017f	41 5c		 pop	 r12
  00181	5f		 pop	 rdi
  00182	5e		 pop	 rsi
  00183	c3		 ret	 0
CreateResponseV6 ENDP
_TEXT	ENDS
END
