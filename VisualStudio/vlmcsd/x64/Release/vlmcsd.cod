; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0EN@OAFFBID@N?3B?3m?3t?3w?30?33?36?3H?3A?3R?3u?3G?3g?3L?3p?3@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_07LDLFNPGN@Windows?$AA@			; `string'
PUBLIC	??_C@_0L@NOKOPGDB@Office2010?$AA@		; `string'
PUBLIC	??_C@_0L@PFIDKFPC@Office2013?$AA@		; `string'
PUBLIC	??_C@_0L@IIPEFBLH@Office2016?$AA@		; `string'
PUBLIC	??_C@_0M@HIMAJJKJ@WinChinaGov?$AA@		; `string'
PUBLIC	??_C@_09BIFGJFAC@ExitLevel?$AA@			; `string'
PUBLIC	??_C@_03DCJLDMKG@VPN?$AA@			; `string'
PUBLIC	??_C@_07IIAKFIOC@KmsData?$AA@			; `string'
PUBLIC	??_C@_0BC@IJCDKLCC@WhiteListingLevel?$AA@	; `string'
PUBLIC	??_C@_0BA@PHKIMFI@CheckClientTime?$AA@		; `string'
PUBLIC	??_C@_0L@MPMBKNGK@StartEmpty?$AA@		; `string'
PUBLIC	??_C@_0BA@PFAJBMD@MaintainClients?$AA@		; `string'
PUBLIC	??_C@_0BD@BOJJAJAF@RandomizationLevel?$AA@	; `string'
PUBLIC	??_C@_04MGCBHGDH@LCID?$AA@			; `string'
PUBLIC	??_C@_04HOKNCALA@Port?$AA@			; `string'
PUBLIC	??_C@_06CBIOIDCI@Listen?$AA@			; `string'
PUBLIC	??_C@_0L@CJHAKJAH@MaxWorkers?$AA@		; `string'
PUBLIC	??_C@_0BC@JIAPHOFH@ConnectionTimeout?$AA@	; `string'
PUBLIC	??_C@_0BN@MMGPMACK@DisconnectClientsImmediately?$AA@ ; `string'
PUBLIC	??_C@_08LIILCCDA@UseNDR64?$AA@			; `string'
PUBLIC	??_C@_07HOBDIJEO@UseBTFN?$AA@			; `string'
PUBLIC	??_C@_07ECHLBDEG@PIDFile?$AA@			; `string'
PUBLIC	??_C@_0P@DLGBEDLC@LogDateAndTime?$AA@		; `string'
PUBLIC	??_C@_07EEDKEMBM@LogFile?$AA@			; `string'
PUBLIC	??_C@_0L@JCGDMJPB@LogVerbose?$AA@		; `string'
PUBLIC	??_C@_0BD@NEDPHNH@ActivationInterval?$AA@	; `string'
PUBLIC	??_C@_0BA@MJJIHAAL@RenewalInterval?$AA@		; `string'
PUBLIC	??_C@_0BI@DFILPCOB@PublicIPProtectionLevel?$AA@	; `string'
PUBLIC	??_C@_0IHN@EKOFFKCI@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5option@ ; `string'
PUBLIC	??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4?$AA@	; `string'
PUBLIC	??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5specif@ ; `string'
PUBLIC	??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5o@ ; `string'
PUBLIC	??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5?$CF@ ; `string'
PUBLIC	??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4?$AA@ ; `string'
PUBLIC	??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4?$AA@ ; `string'
PUBLIC	??_C@_0BB@MJCPHOFN@Unknown?5keyword?4?$AA@	; `string'
PUBLIC	??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4?$AA@ ; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Wind@ ; `string'
PUBLIC	??_C@_0N@BACOLJMI@command?5line?$AA@		; `string'
PUBLIC	??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6?$AA@ ; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_02GMHACPFF@?$CFu?$AA@			; `string'
PUBLIC	??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5?8@ ; `string'
PUBLIC	??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6?$AA@ ; `string'
PUBLIC	??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semaph@ ; `string'
PUBLIC	??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_02MOLJINC@?3?3?$AA@			; `string'
PUBLIC	??_C@_07OHKHACFK@0?40?40?40?$AA@		; `string'
PUBLIC	??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5s@ ; `string'
PUBLIC	??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Wind@ ; `string'
PUBLIC	??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6?$AA@ ; `string'
PUBLIC	IniFileErrorBuffer
PUBLIC	tapArgument
EXTRN	__imp_CommandLineToArgvW:PROC
EXTRN	__imp_DeleteFileA:PROC
EXTRN	__imp_GetCurrentProcessId:PROC
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_SetConsoleCtrlHandler:PROC
EXTRN	__imp_ferror:PROC
EXTRN	__imp_fgets:PROC
EXTRN	__imp_CreateSemaphoreA:PROC
EXTRN	__imp_WideCharToMultiByte:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_StartServiceCtrlDispatcherA:PROC
EXTRN	__imp_GetCommandLineW:PROC
	ALIGN	8

IniFileErrorBuffer DQ 01H DUP (?)
fn_pid	DQ	01H DUP (?)
ServiceUser DQ	01H DUP (?)
maxsockets DB	01H DUP (?)
	ALIGN	8

fn_ini	DQ	01H DUP (?)
installService DB 01H DUP (?)
	ALIGN	8

tapArgument DQ	01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6?$AA@
CONST	SEGMENT
??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6?$AA@ DB 'vlmcsd'
	DB	' %s started successfully', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Wind@
CONST	SEGMENT
??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Wind@ DB 'Fatal: Coul'
	DB	'd not initialize Windows sockets (Error: %d).', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5s@
CONST	SEGMENT
??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5s@ DB 'Fatal: Co'
	DB	'uld not listen on any socket.', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHKHACFK@0?40?40?40?$AA@
CONST	SEGMENT
??_C@_07OHKHACFK@0?40?40?40?$AA@ DB '0.0.0.0', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02MOLJINC@?3?3?$AA@
CONST	SEGMENT
??_C@_02MOLJINC@?3?3?$AA@ DB '::', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6?$AA@ DB 'War'
	DB	'ning: Can''t read %s: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semaph@
CONST	SEGMENT
??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semaph@ DB 'Warning: Co'
	DB	'uld not create semaphore: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6?$AA@
CONST	SEGMENT
??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6?$AA@ DB 'vlmcsd %s was '
	DB	'shutdown', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5?8@
CONST	SEGMENT
??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5?8@ DB 'Warning: '
	DB	'Cannot write pid file ''%s''. %s.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02GMHACPFF@?$CFu?$AA@
CONST	SEGMENT
??_C@_02GMHACPFF@?$CFu?$AA@ DB '%u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6?$AA@
CONST	SEGMENT
??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6?$AA@ DB 'vlmcsd %s %i-bit', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BACOLJMI@command?5line?$AA@
CONST	SEGMENT
??_C@_0N@BACOLJMI@command?5line?$AA@ DB 'command line', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Wind@
CONST	SEGMENT
??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Wind@ DB 'Warning: Co'
	DB	'uld not register Windows signal handler: Error %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6?$AA@ DB 'Read ini file %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6?$AA@ DB 'W'
	DB	'arning: %s line %u: "%s". %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4?$AA@
CONST	SEGMENT
??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4?$AA@ DB 'Cannot listen on '
	DB	'%s.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MJCPHOFN@Unknown?5keyword?4?$AA@
CONST	SEGMENT
??_C@_0BB@MJCPHOFN@Unknown?5keyword?4?$AA@ DB 'Unknown keyword.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4?$AA@
CONST	SEGMENT
??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4?$AA@ DB 'missing '
	DB	'argument after ''=''.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4?$AA@
CONST	SEGMENT
??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4?$AA@ DB '''='' re'
	DB	'quired after keyword.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5?$CF@
CONST	SEGMENT
??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5?$CF@ DB 'Must'
	DB	' be integer between %u and %u', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5o@
CONST	SEGMENT
??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5o@ DB 'Argument '
	DB	'must be true/on/yes/1 or false/off/no/0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5specif@
CONST	SEGMENT
??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5specif@ DB 'Fatal: No '
	DB	'valid time span specified in option -%c.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4?$AA@
CONST	SEGMENT
??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4?$AA@ DB 'Incorrect time span.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IHN@EKOFFKCI@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5option@
CONST	SEGMENT
??_C@_0IHN@EKOFFKCI@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5option@ DB 'v'
	DB	'lmcsd %s', 0aH, 0aH, 'Usage:', 0aH, '   %s [ options ]', 0aH, 0aH
	DB	'Where:', 0aH, '  -w <ePID>', 09H, 09H, 'always use <ePID> for'
	DB	' Windows', 0aH, '  -0 <ePID>', 09H, 09H, 'always use <ePID> f'
	DB	'or Office2010', 0aH, '  -3 <ePID>', 09H, 09H, 'always use <eP'
	DB	'ID> for Office2013', 0aH, '  -6 <ePID>', 09H, 09H, 'always us'
	DB	'e <ePID> for Office2016', 0aH, '  -G <ePID>', 09H, 09H, 'alwa'
	DB	'ys use <ePID> for Win China Gov', 0aH, '  -H <HwId>', 09H, 09H
	DB	'always use hardware Id <HwId>', 0aH, '  -r 0|1|2', 09H, 09H, 's'
	DB	'et ePID randomization level (default 1)', 0aH, '  -C <LCID>', 09H
	DB	09H, 'use fixed <LCID> in random ePIDs', 0aH, '  -o 0|1|2|3', 09H
	DB	09H, 'set protection level against clients with public IP addr'
	DB	'esses (default 0)', 0aH, '  -O <v>[=<a>][/<c>]', 09H, 'use VP'
	DB	'N adapter <v> with IPv4 address <a> and CIDR <c>', 0aH, '  -x'
	DB	' <level>', 09H, 09H, 'exit if warning <level> reached (defaul'
	DB	't 0)', 0aH, '  -L <address>[:<port>]', 09H, 'listen on IP add'
	DB	'ress <address> with optional <port>', 0aH, '  -P <port>', 09H
	DB	09H, 'set TCP port <port> for subsequent -L statements (defaul'
	DB	't 1688)', 0aH, '  -m <clients>', 09H, 09H, 'Handle max. <clie'
	DB	'nts> simultaneously (default no limit)', 0aH, '  -s', 09H, 09H
	DB	09H, 'install vlmcsd as an NT service. Ignores -e', 0aH, '  -S'
	DB	09H, 09H, 09H, 'remove vlmcsd service. Ignores all other optio'
	DB	'ns', 0aH, '  -U <username>', 09H, 09H, 'run NT service as <us'
	DB	'ername>. Must be used with -s', 0aH, '  -W <password>', 09H, 09H
	DB	'optional <password> for -U. Must be used with -s', 0aH, '  -e'
	DB	09H, 09H, 09H, 'log to stdout', 0aH, '  -D', 09H, 09H, 09H, 'd'
	DB	'oes nothing. Provided for compatibility with POSIX versions o'
	DB	'nly', 0aH, '  -K 0|1|2|3', 09H, 09H, 'set whitelisting level '
	DB	'for KMS IDs (default -K0)', 0aH, '  -c0, -c1', 09H, 09H, 'dis'
	DB	'able/enable client time checking (default -c0)', 0aH, '  -M0,'
	DB	' -M1', 09H, 09H, 'disable/enable maintaining clients (default'
	DB	' -M0)', 0aH, '  -E0, -E1', 09H, 09H, 'disable/enable start wi'
	DB	'th empty client list (default -E0, ignored if -M0)', 0aH, '  '
	DB	'-t <seconds>', 09H, 09H, 'disconnect clients after <seconds> '
	DB	'of inactivity (default 30)', 0aH, '  -d', 09H, 09H, 09H, 'dis'
	DB	'connect clients after each request', 0aH, '  -k', 09H, 09H, 09H
	DB	'don''t disconnect clients after each request (default)', 0aH, ' '
	DB	' -N0, -N1', 09H, 09H, 'disable/enable NDR64', 0aH, '  -B0, -B'
	DB	'1', 09H, 09H, 'disable/enable bind time feature negotiation', 0aH
	DB	'  -p <file>', 09H, 09H, 'write pid to <file>', 0aH, '  -i <fi'
	DB	'le>', 09H, 09H, 'use config file <file>', 0aH, '  -j <file>', 09H
	DB	09H, 'use KMS data file <file>', 0aH, '  -R <interval>', 09H, 09H
	DB	'renew activation every <interval> (default 1w)', 0aH, '  -A <'
	DB	'interval>', 09H, 09H, 'retry activation every <interval> (def'
	DB	'ault 2h)', 0aH, '  -l <file>', 09H, 09H, 'log to <file>', 0aH
	DB	'  -T0, -T1', 09H, 09H, 'disable/enable logging with time and '
	DB	'date (default -T1)', 0aH, '  -v', 09H, 09H, 09H, 'log verbose'
	DB	0aH, '  -q', 09H, 09H, 09H, 'don''t log verbose (default)', 0aH
	DB	'  -V', 09H, 09H, 09H, 'display version information and exit', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DFILPCOB@PublicIPProtectionLevel?$AA@
CONST	SEGMENT
??_C@_0BI@DFILPCOB@PublicIPProtectionLevel?$AA@ DB 'PublicIPProtectionLev'
	DB	'el', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MJJIHAAL@RenewalInterval?$AA@
CONST	SEGMENT
??_C@_0BA@MJJIHAAL@RenewalInterval?$AA@ DB 'RenewalInterval', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@NEDPHNH@ActivationInterval?$AA@
CONST	SEGMENT
??_C@_0BD@NEDPHNH@ActivationInterval?$AA@ DB 'ActivationInterval', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JCGDMJPB@LogVerbose?$AA@
CONST	SEGMENT
??_C@_0L@JCGDMJPB@LogVerbose?$AA@ DB 'LogVerbose', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07EEDKEMBM@LogFile?$AA@
CONST	SEGMENT
??_C@_07EEDKEMBM@LogFile?$AA@ DB 'LogFile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DLGBEDLC@LogDateAndTime?$AA@
CONST	SEGMENT
??_C@_0P@DLGBEDLC@LogDateAndTime?$AA@ DB 'LogDateAndTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07ECHLBDEG@PIDFile?$AA@
CONST	SEGMENT
??_C@_07ECHLBDEG@PIDFile?$AA@ DB 'PIDFile', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07HOBDIJEO@UseBTFN?$AA@
CONST	SEGMENT
??_C@_07HOBDIJEO@UseBTFN?$AA@ DB 'UseBTFN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LIILCCDA@UseNDR64?$AA@
CONST	SEGMENT
??_C@_08LIILCCDA@UseNDR64?$AA@ DB 'UseNDR64', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MMGPMACK@DisconnectClientsImmediately?$AA@
CONST	SEGMENT
??_C@_0BN@MMGPMACK@DisconnectClientsImmediately?$AA@ DB 'DisconnectClient'
	DB	'sImmediately', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@JIAPHOFH@ConnectionTimeout?$AA@
CONST	SEGMENT
??_C@_0BC@JIAPHOFH@ConnectionTimeout?$AA@ DB 'ConnectionTimeout', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@CJHAKJAH@MaxWorkers?$AA@
CONST	SEGMENT
??_C@_0L@CJHAKJAH@MaxWorkers?$AA@ DB 'MaxWorkers', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_06CBIOIDCI@Listen?$AA@
CONST	SEGMENT
??_C@_06CBIOIDCI@Listen?$AA@ DB 'Listen', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HOKNCALA@Port?$AA@
CONST	SEGMENT
??_C@_04HOKNCALA@Port?$AA@ DB 'Port', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MGCBHGDH@LCID?$AA@
CONST	SEGMENT
??_C@_04MGCBHGDH@LCID?$AA@ DB 'LCID', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BOJJAJAF@RandomizationLevel?$AA@
CONST	SEGMENT
??_C@_0BD@BOJJAJAF@RandomizationLevel?$AA@ DB 'RandomizationLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PFAJBMD@MaintainClients?$AA@
CONST	SEGMENT
??_C@_0BA@PFAJBMD@MaintainClients?$AA@ DB 'MaintainClients', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@MPMBKNGK@StartEmpty?$AA@
CONST	SEGMENT
??_C@_0L@MPMBKNGK@StartEmpty?$AA@ DB 'StartEmpty', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@PHKIMFI@CheckClientTime?$AA@
CONST	SEGMENT
??_C@_0BA@PHKIMFI@CheckClientTime?$AA@ DB 'CheckClientTime', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IJCDKLCC@WhiteListingLevel?$AA@
CONST	SEGMENT
??_C@_0BC@IJCDKLCC@WhiteListingLevel?$AA@ DB 'WhiteListingLevel', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07IIAKFIOC@KmsData?$AA@
CONST	SEGMENT
??_C@_07IIAKFIOC@KmsData?$AA@ DB 'KmsData', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DCJLDMKG@VPN?$AA@
CONST	SEGMENT
??_C@_03DCJLDMKG@VPN?$AA@ DB 'VPN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_09BIFGJFAC@ExitLevel?$AA@
CONST	SEGMENT
??_C@_09BIFGJFAC@ExitLevel?$AA@ DB 'ExitLevel', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HIMAJJKJ@WinChinaGov?$AA@
CONST	SEGMENT
??_C@_0M@HIMAJJKJ@WinChinaGov?$AA@ DB 'WinChinaGov', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IIPEFBLH@Office2016?$AA@
CONST	SEGMENT
??_C@_0L@IIPEFBLH@Office2016?$AA@ DB 'Office2016', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@PFIDKFPC@Office2013?$AA@
CONST	SEGMENT
??_C@_0L@PFIDKFPC@Office2013?$AA@ DB 'Office2013', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NOKOPGDB@Office2010?$AA@
CONST	SEGMENT
??_C@_0L@NOKOPGDB@Office2010?$AA@ DB 'Office2010', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07LDLFNPGN@Windows?$AA@
CONST	SEGMENT
??_C@_07LDLFNPGN@Windows?$AA@ DB 'Windows', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@OAFFBID@N?3B?3m?3t?3w?30?33?36?3H?3A?3R?3u?3G?3g?3L?3p?3@
CONST	SEGMENT
??_C@_0EN@OAFFBID@N?3B?3m?3t?3w?30?33?36?3H?3A?3R?3u?3G?3g?3L?3p?3@ DB 'N'
	DB	':B:m:t:w:0:3:6:H:A:R:u:G:g:L:p:i:P:l:r:U:W:C:c:F:O:o:x:T:K:E:'
	DB	'M:j:SseDdVvqkZ', 00H			; `string'
IniFileErrorMessage DQ FLAT:??_C@_00CNPNBAHC@?$AA@
ServicePassword DQ FLAT:??_C@_00CNPNBAHC@?$AA@
IniFileParameterList DQ FLAT:??_C@_07LDLFNPGN@Windows?$AA@
	DB	014H
	ORG $+7
	DQ	FLAT:??_C@_0L@NOKOPGDB@Office2010?$AA@
	DB	015H
	ORG $+7
	DQ	FLAT:??_C@_0L@PFIDKFPC@Office2013?$AA@
	DB	016H
	ORG $+7
	DQ	FLAT:??_C@_0L@IIPEFBLH@Office2016?$AA@
	DB	017H
	ORG $+7
	DQ	FLAT:??_C@_0M@HIMAJJKJ@WinChinaGov?$AA@
	DB	01fH
	ORG $+7
	DQ	FLAT:??_C@_09BIFGJFAC@ExitLevel?$AA@
	DB	01eH
	ORG $+7
	DQ	FLAT:??_C@_03DCJLDMKG@VPN?$AA@
	DB	01dH
	ORG $+7
	DQ	FLAT:??_C@_07IIAKFIOC@KmsData?$AA@
	DB	01cH
	ORG $+7
	DQ	FLAT:??_C@_0BC@IJCDKLCC@WhiteListingLevel?$AA@
	DB	018H
	ORG $+7
	DQ	FLAT:??_C@_0BA@PHKIMFI@CheckClientTime?$AA@
	DB	019H
	ORG $+7
	DQ	FLAT:??_C@_0L@MPMBKNGK@StartEmpty?$AA@
	DB	01bH
	ORG $+7
	DQ	FLAT:??_C@_0BA@PFAJBMD@MaintainClients?$AA@
	DB	01aH
	ORG $+7
	DQ	FLAT:??_C@_0BD@BOJJAJAF@RandomizationLevel?$AA@
	DB	01H
	ORG $+7
	DQ	FLAT:??_C@_04MGCBHGDH@LCID?$AA@
	DB	02H
	ORG $+7
	DQ	FLAT:??_C@_04HOKNCALA@Port?$AA@
	DB	0eH
	ORG $+7
	DQ	FLAT:??_C@_06CBIOIDCI@Listen?$AA@
	DB	03H
	ORG $+7
	DQ	FLAT:??_C@_0L@CJHAKJAH@MaxWorkers?$AA@
	DB	04H
	ORG $+7
	DQ	FLAT:??_C@_0BC@JIAPHOFH@ConnectionTimeout?$AA@
	DB	05H
	ORG $+7
	DQ	FLAT:??_C@_0BN@MMGPMACK@DisconnectClientsImmediately?$AA@
	DB	0bH
	ORG $+7
	DQ	FLAT:??_C@_08LIILCCDA@UseNDR64?$AA@
	DB	0fH
	ORG $+7
	DQ	FLAT:??_C@_07HOBDIJEO@UseBTFN?$AA@
	DB	010H
	ORG $+7
	DQ	FLAT:??_C@_07ECHLBDEG@PIDFile?$AA@
	DB	06H
	ORG $+7
	DQ	FLAT:??_C@_0P@DLGBEDLC@LogDateAndTime?$AA@
	DB	013H
	ORG $+7
	DQ	FLAT:??_C@_07EEDKEMBM@LogFile?$AA@
	DB	07H
	ORG $+7
	DQ	FLAT:??_C@_0L@JCGDMJPB@LogVerbose?$AA@
	DB	08H
	ORG $+7
	DQ	FLAT:??_C@_0BD@NEDPHNH@ActivationInterval?$AA@
	DB	09H
	ORG $+7
	DQ	FLAT:??_C@_0BA@MJJIHAAL@RenewalInterval?$AA@
	DB	0aH
	ORG $+7
	DQ	FLAT:??_C@_0BI@DFILPCOB@PublicIPProtectionLevel?$AA@
	DB	012H
	ORG $+7
optstring DQ	FLAT:??_C@_0EN@OAFFBID@N?3B?3m?3t?3w?30?33?36?3H?3A?3R?3u?3G?3g?3L?3p?3@
CONST	ENDS
PUBLIC	WinStartUp
PUBLIC	main
PUBLIC	setupListeningSockets
PUBLIC	newmain
PUBLIC	cleanup
;	COMDAT pdata
pdata	SEGMENT
$pdata$WinStartUp DD imagerel $LN14
	DD	imagerel $LN14+263
	DD	imagerel $unwind$WinStartUp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN9
	DD	imagerel $LN9+34
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setupListeningSockets DD imagerel $LN39
	DD	imagerel $LN39+503
	DD	imagerel $unwind$setupListeningSockets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$allocateSemaphore DD imagerel allocateSemaphore
	DD	imagerel allocateSemaphore+96
	DD	imagerel $unwind$allocateSemaphore
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$writePidFile DD imagerel writePidFile
	DD	imagerel writePidFile+130
	DD	imagerel $unwind$writePidFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$parseGeneralArguments DD imagerel parseGeneralArguments
	DD	imagerel parseGeneralArguments+1580
	DD	imagerel $unwind$parseGeneralArguments
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$daemonizeAndSetSignalAction DD imagerel daemonizeAndSetSignalAction
	DD	imagerel daemonizeAndSetSignalAction+53
	DD	imagerel $unwind$daemonizeAndSetSignalAction
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$terminationHandler DD imagerel terminationHandler
	DD	imagerel terminationHandler+38
	DD	imagerel $unwind$terminationHandler
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$readIniFile DD imagerel readIniFile
	DD	imagerel readIniFile+683
	DD	imagerel $unwind$readIniFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setupListeningSocketsFromIniFile DD imagerel setupListeningSocketsFromIniFile
	DD	imagerel setupListeningSocketsFromIniFile+126
	DD	imagerel $unwind$setupListeningSocketsFromIniFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$handleIniFileParameter DD imagerel handleIniFileParameter
	DD	imagerel handleIniFileParameter+160
	DD	imagerel $unwind$handleIniFileParameter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getIniFileArgument DD imagerel getIniFileArgument
	DD	imagerel getIniFileArgument+125
	DD	imagerel $unwind$getIniFileArgument
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setIniFileParameter DD imagerel setIniFileParameter
	DD	imagerel setIniFileParameter+1476
	DD	imagerel $unwind$setIniFileParameter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setEpidFromIniFileLine DD imagerel setEpidFromIniFileLine
	DD	imagerel setEpidFromIniFileLine+195
	DD	imagerel $unwind$setEpidFromIniFileLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$setHwIdFromIniFileLine DD imagerel setHwIdFromIniFileLine
	DD	imagerel setHwIdFromIniFileLine+112
	DD	imagerel $unwind$setHwIdFromIniFileLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$iniFileLineNextWord DD imagerel iniFileLineNextWord
	DD	imagerel iniFileLineNextWord+47
	DD	imagerel $unwind$iniFileLineNextWord
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getIniFileArgumentInt DD imagerel getIniFileArgumentInt
	DD	imagerel getIniFileArgumentInt+57
	DD	imagerel $unwind$getIniFileArgumentInt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTimeSpanFromCommandLine DD imagerel getTimeSpanFromCommandLine
	DD	imagerel getTimeSpanFromCommandLine+71
	DD	imagerel $unwind$getTimeSpanFromCommandLine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getTimeSpanFromIniFile DD imagerel getTimeSpanFromIniFile
	DD	imagerel getTimeSpanFromIniFile+64
	DD	imagerel $unwind$getTimeSpanFromIniFile
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$usage DD	imagerel usage
	DD	imagerel usage+45
	DD	imagerel $unwind$usage
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$newmain DD imagerel $LN59
	DD	imagerel $LN59+798
	DD	imagerel $unwind$newmain
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$cleanup DD imagerel $LN18
	DD	imagerel $LN18+110
	DD	imagerel $unwind$cleanup
;	COMDAT xdata
xdata	SEGMENT
$unwind$cleanup DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$newmain DD 071201H
	DD	03b6412H
	DD	03a3412H
	DD	0380112H
	DD	0700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$usage DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTimeSpanFromIniFile DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getTimeSpanFromCommandLine DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getIniFileArgumentInt DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$iniFileLineNextWord DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setHwIdFromIniFileLine DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setEpidFromIniFileLine DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setIniFileParameter DD 061201H
	DD	097412H
	DD	083412H
	DD	0500b3212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getIniFileArgument DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$handleIniFileParameter DD 061401H
	DD	086414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setupListeningSocketsFromIniFile DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$readIniFile DD 0d2301H
	DD	02f7423H
	DD	02e6423H
	DD	02c3423H
	DD	0260123H
	DD	0e016f018H
	DD	0c012d014H
	DD	05010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$terminationHandler DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$daemonizeAndSetSignalAction DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parseGeneralArguments DD 040b01H
	DD	06340bH
	DD	0f007320bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$writePidFile DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$allocateSemaphore DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$setupListeningSockets DD 081301H
	DD	0b5413H
	DD	0a3413H
	DD	0e00f3213H
	DD	0600c700dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WinStartUp DD 081201H
	DD	0e5412H
	DD	0d3412H
	DD	0e00e7212H
	DD	0600b700cH
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT cleanup
_TEXT	SEGMENT
cleanup	PROC						; COMDAT

; 1475 : {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1476 : 	if (!InetdMode)

  0000a	33 db		 xor	 ebx, ebx
  0000c	38 1d 00 00 00
	00		 cmp	 BYTE PTR InetdMode, bl
  00012	75 4f		 jne	 SHORT $LN3@cleanup

; 1477 : 	{
; 1478 : #		ifndef NO_CLIENT_LIST
; 1479 : 		if (MaintainClients) CleanUpClientLists();
; 1480 : #		endif // !NO_CLIENT_LIST
; 1481 : 
; 1482 : #		ifndef NO_PID_FILE
; 1483 : 		if (fn_pid) vlmcsd_unlink(fn_pid);

  00014	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fn_pid
  0001b	48 85 c9	 test	 rcx, rcx
  0001e	74 06		 je	 SHORT $LN1@cleanup
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteFileA
$LN1@cleanup:

; 1484 : #		endif // NO_PID_FILE
; 1485 : 		closeAllListeningSockets();

  00026	39 1d 00 00 00
	00		 cmp	 DWORD PTR numsockets, ebx
  0002c	7e 22		 jle	 SHORT $LN8@cleanup
  0002e	48 8b fb	 mov	 rdi, rbx
$LL10@cleanup:
  00031	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR SocketList
  00038	48 8b 0c 0f	 mov	 rcx, QWORD PTR [rdi+rcx]
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  00042	ff c3		 inc	 ebx
  00044	48 8d 7f 08	 lea	 rdi, QWORD PTR [rdi+8]
  00048	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR numsockets
  0004e	7c e1		 jl	 SHORT $LL10@cleanup
$LN8@cleanup:

; 1486 : 
; 1487 : #		if !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !defined(_WIN32) && !__minix__
; 1488 : 		sem_unlink("/vlmcsd");
; 1489 : #		if !defined(USE_THREADS) && !defined(CYGWIN)
; 1490 : 		if (shmid >= 0)
; 1491 : 		{
; 1492 : 			if (MaxTaskSemaphore != (sem_t*)-1) shmdt(MaxTaskSemaphore);
; 1493 : 			shmctl(shmid, IPC_RMID, NULL);
; 1494 : 		}
; 1495 : #		endif // !defined(USE_THREADS) && !defined(CYGWIN)
; 1496 : #		endif // !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !defined(_WIN32) && !__minix__
; 1497 : 
; 1498 : #		ifndef NO_LOG
; 1499 : 		logger("vlmcsd %s was shutdown\n", Version);

  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@LEPLNMP@private?5build?$AA@
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@LGLPDEEC@vlmcsd?5?$CFs?5was?5shutdown?6?$AA@
  0005e	e8 00 00 00 00	 call	 logger
$LN3@cleanup:

; 1500 : #		endif // NO_LOG
; 1501 : 	}
; 1502 : }

  00063	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00068	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
cleanup	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT newmain
_TEXT	SEGMENT
wsadata$ = 32
newmain	PROC						; COMDAT

; 1702 : {

$LN59:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec c0 01
	00 00		 sub	 rsp, 448		; 000001c0H

; 1703 : #	if !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 1704 : 	KmsResponseParameters = (KmsResponseParam_t*)vlmcsd_malloc(sizeof(KmsResponseParam_t) * MIN_CSVLK);//malloc动态内存分配

  00012	bb 78 00 00 00	 mov	 ebx, 120		; 00000078H
  00017	8b cb		 mov	 ecx, ebx
  00019	e8 00 00 00 00	 call	 vlmcsd_malloc

; 1705 : 	memset(KmsResponseParameters, 0, sizeof(KmsResponseParam_t) * MIN_CSVLK);//memset因某些编译器分配空间时，内存中默认值并不为0

  0001e	44 8b c3	 mov	 r8d, ebx
  00021	33 d2		 xor	 edx, edx
  00023	48 8b c8	 mov	 rcx, rax
  00026	48 89 05 00 00
	00 00		 mov	 QWORD PTR KmsResponseParameters, rax
  0002d	e8 00 00 00 00	 call	 memset

; 1706 : #	endif // !defined(NO_RANDOM_EPID) || !defined(NO_CL_PIDS) || !defined(NO_INI_FILE)
; 1707 : 
; 1708 : 	// Initialize thread synchronization objects for Windows and Cygwin
; 1709 : #	ifdef USE_THREADS
; 1710 : 
; 1711 : #	ifndef NO_LOG
; 1712 : // Initialize the Critical Section for proper logging
; 1713 : // 初始化关键部分以进行正确的日志记录
; 1714 : #	if _WIN32 || __CYGWIN__
; 1715 : 	InitializeCriticalSection(&logmutex);//程序调度

  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logmutex
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 1716 : #	endif // _WIN32 || __CYGWIN__
; 1717 : #	endif // NO_LOG
; 1718 : 
; 1719 : #	endif // USE_THREADS
; 1720 : 
; 1721 : #	ifdef _WIN32
; 1722 : 
; 1723 : #	ifndef USE_MSRPC
; 1724 : 	WSADATA wsadata;
; 1725 : 	{
; 1726 : 		// Windows Sockets must be initialized
; 1727 : 		// Windows套接字必须被初始化
; 1728 : 		int error;
; 1729 : 		if ((error = WSAStartup(0x0202, &wsadata)))//WSAStartup，即WSA(Windows Sockets Asynchronous，Windows异步套接字)的启动命令

  0003f	48 8d 54 24 20	 lea	 rdx, QWORD PTR wsadata$[rsp]
  00044	b9 02 02 00 00	 mov	 ecx, 514		; 00000202H
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAStartup
  0004f	33 db		 xor	 ebx, ebx
  00051	8b f8		 mov	 edi, eax
  00053	85 c0		 test	 eax, eax
  00055	74 13		 je	 SHORT $LN14@newmain

; 1730 : 		{
; 1731 : 			printerrorf("Fatal: Could not initialize Windows sockets (Error: %d).\n", error);

  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DK@DEOGKNEK@Fatal?3?5Could?5not?5initialize?5Wind@
  0005e	8b d0		 mov	 edx, eax
  00060	e8 00 00 00 00	 call	 printerrorf

; 1732 : 			return error;

  00065	e9 9d 02 00 00	 jmp	 $LN53@newmain
$LN14@newmain:

; 1733 : 		}
; 1734 : 	}
; 1735 : #	endif // USE_MSRPC
; 1736 : 
; 1737 : 	// Windows can never daemonize
; 1738 : 	//nodaemon = 1;
; 1739 : 
; 1740 : #	else // __CYGWIN__
; 1741 : 
; 1742 : 	// Do not daemonize if we are a Windows service
; 1743 : #	ifdef _NTSERVICE 
; 1744 : 	if (IsNTService) nodaemon = 1;
; 1745 : #	endif
; 1746 : 
; 1747 : #	endif // _WIN32 / __CYGWIN__
; 1748 : 
; 1749 : 	parseGeneralArguments(); // Does not return if an error occurs

  0006a	e8 00 00 00 00	 call	 parseGeneralArguments

; 1750 : 
; 1751 : #	if !defined(_WIN32) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1752 : 
; 1753 : 	struct stat statbuf;
; 1754 : 	fstat(STDIN_FILENO, &statbuf);
; 1755 : 
; 1756 : 	if (S_ISSOCK(statbuf.st_mode))
; 1757 : 	{
; 1758 : 		InetdMode = 1;
; 1759 : #		ifndef NO_CLIENT_LIST
; 1760 : 		MaintainClients = FALSE;
; 1761 : #		endif // !NO_CLIENT_LIST
; 1762 : 		nodaemon = 1;
; 1763 : #		ifndef SIMPLE_SOCKETS
; 1764 : 		maxsockets = 0;
; 1765 : #		endif // !SIMPLE_SOCKETS
; 1766 : #		ifndef NO_LOG
; 1767 : 		logstdout = 0;
; 1768 : #		endif // !NO_LOG
; 1769 : 	}
; 1770 : 
; 1771 : #	endif // !defined(_WIN32) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1772 : 
; 1773 : #	ifndef NO_INI_FILE
; 1774 : 
; 1775 : 	if (fn_ini && !readIniFile(INI_FILE_PASS_1))

  0006f	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR fn_ini, rbx
  00076	be 01 00 00 00	 mov	 esi, 1
  0007b	74 30		 je	 SHORT $LN13@newmain
  0007d	40 8a ce	 mov	 cl, sil
  00080	e8 00 00 00 00	 call	 readIniFile
  00085	85 c0		 test	 eax, eax
  00087	75 24		 jne	 SHORT $LN13@newmain

; 1776 : 	{
; 1777 : #		ifdef INI_FILE
; 1778 : 		if (strcmp(fn_ini, INI_FILE))
; 1779 : #		endif // INI_FILE
; 1780 : 			printerrorf("Warning: Can't read %s: %s\n", fn_ini, strerror(errno));

  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00097	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_ini
  0009e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6?$AA@
  000a5	4c 8b c0	 mov	 r8, rax
  000a8	e8 00 00 00 00	 call	 printerrorf
$LN13@newmain:

; 1781 : 	}
; 1782 : 
; 1783 : #	endif // NO_INI_FILE
; 1784 : 
; 1785 : 	loadKmsData();

  000ad	e8 00 00 00 00	 call	 loadKmsData

; 1786 : 
; 1787 : #	ifndef NO_CLIENT_LIST
; 1788 : 	if (MaintainClients) InitializeClientLists();

  000b2	38 1d 00 00 00
	00		 cmp	 BYTE PTR MaintainClients, bl
  000b8	74 05		 je	 SHORT $LN12@newmain
  000ba	e8 00 00 00 00	 call	 InitializeClientLists
$LN12@newmain:

; 1789 : #	endif // !NO_CLIENT_LIST
; 1790 : 
; 1791 : #	if defined(USE_MSRPC) && !defined(NO_PRIVATE_IP_DETECT)
; 1792 : 	if (PublicIPProtectionLevel)
; 1793 : 	{
; 1794 : 		printerrorf("Warning: Public IP address protection using MS RPC is poor. See vlmcsd.8\n");
; 1795 : 	}
; 1796 : #	endif // defined(USE_MSRPC) && !defined(NO_PRIVATE_IP_DETECT)
; 1797 : 
; 1798 : #	if !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !__minix__ && !defined(USE_MSRPC)
; 1799 : 	allocateSemaphore();

  000bf	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR MaxTasks
  000c5	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  000ca	3b d7		 cmp	 edx, edi
  000cc	73 44		 jae	 SHORT $LN55@newmain
  000ce	38 1d 00 00 00
	00		 cmp	 BYTE PTR InetdMode, bl
  000d4	75 3c		 jne	 SHORT $LN55@newmain
  000d6	45 33 c9	 xor	 r9d, r9d
  000d9	44 8b c2	 mov	 r8d, edx
  000dc	33 c9		 xor	 ecx, ecx
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateSemaphoreA
  000e4	48 89 05 00 00
	00 00		 mov	 QWORD PTR MaxTaskSemaphore, rax
  000eb	48 85 c0	 test	 rax, rax
  000ee	75 22		 jne	 SHORT $LN55@newmain
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  000f6	8b c8		 mov	 ecx, eax
  000f8	e8 00 00 00 00	 call	 win_strerror
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semaph@
  00104	48 8b d0	 mov	 rdx, rax
  00107	e8 00 00 00 00	 call	 printerrorf
  0010c	89 3d 00 00 00
	00		 mov	 DWORD PTR MaxTasks, edi
$LN55@newmain:

; 1800 : #	endif // !defined(NO_LIMIT) && !defined(NO_SOCKETS) && __minix__
; 1801 : 
; 1802 : #	ifdef _NTSERVICE
; 1803 : 	if (installService)

  00112	8a 05 00 00 00
	00		 mov	 al, BYTE PTR installService
  00118	84 c0		 test	 al, al
  0011a	74 6e		 je	 SHORT $LN11@newmain

; 1804 : 		return NtServiceInstallation(installService, ServiceUser, ServicePassword);

  0011c	38 1d 00 00 00
	00		 cmp	 BYTE PTR IsNTService, bl
  00122	75 5f		 jne	 SHORT $LN24@newmain
  00124	40 3a c6	 cmp	 al, sil
  00127	75 15		 jne	 SHORT $LN27@newmain
  00129	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ServicePassword
  00130	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ServiceUser
  00137	e8 00 00 00 00	 call	 ServiceInstaller
  0013c	eb 45		 jmp	 SHORT $LN24@newmain
$LN27@newmain:
  0013e	3c 02		 cmp	 al, 2
  00140	75 41		 jne	 SHORT $LN24@newmain
  00142	33 d2		 xor	 edx, edx
  00144	33 c9		 xor	 ecx, ecx
  00146	e8 00 00 00 00	 call	 OpenAndRemoveService
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03HLHKOPNL@KMS?$AA@
  00152	0f b6 c8	 movzx	 ecx, al
  00155	84 c0		 test	 al, al
  00157	74 1c		 je	 SHORT $LN23@newmain
  00159	ff c9		 dec	 ecx
  0015b	74 09		 je	 SHORT $LN22@newmain
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@NOKEGPBL@?$LH?$PO?N?q?5?$CFs?$LC?$LL?$LE?f?T?Z?4?6?$AA@
  00164	eb 16		 jmp	 SHORT $LN57@newmain
$LN22@newmain:
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@DBLMEHIF@?$LH?$PO?N?q?5?$CFs?5?$LD?I?$LJ?$KG?R?F?$LD?$PN?4?6?$AA@
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
  00173	eb 0e		 jmp	 SHORT $LN24@newmain
$LN23@newmain:
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@HFJNIJEE@?$LE?m?N?s?5?I?$LO?$LD?$PN?$LH?$PO?N?q?4?5?$CFs?6?$AA@
$LN57@newmain:
  0017c	e8 00 00 00 00	 call	 errorout
  00181	8b de		 mov	 ebx, esi
$LN24@newmain:
  00183	8b c3		 mov	 eax, ebx
  00185	e9 7f 01 00 00	 jmp	 $LN15@newmain
$LN11@newmain:

; 1805 : #	endif // _NTSERVICE
; 1806 : 
; 1807 : #	ifndef NO_TAP
; 1808 : 	if (tapArgument && !InetdMode) startTap(tapArgument);

  0018a	48 39 1d 00 00
	00 00		 cmp	 QWORD PTR tapArgument, rbx
  00191	74 0d		 je	 SHORT $LN10@newmain
  00193	38 1d 00 00 00
	00		 cmp	 BYTE PTR InetdMode, bl
  00199	75 1a		 jne	 SHORT $LN8@newmain
  0019b	e8 00 00 00 00	 call	 startTap
$LN10@newmain:

; 1809 : #	endif // NO_TAP
; 1810 : 
; 1811 : #	if !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1812 : 	if (!InetdMode)

  001a0	38 1d 00 00 00
	00		 cmp	 BYTE PTR InetdMode, bl
  001a6	75 0d		 jne	 SHORT $LN8@newmain

; 1813 : 	{
; 1814 : 		int error;
; 1815 : #		ifdef SIMPLE_SOCKETS
; 1816 : 		if ((error = listenOnAllAddresses())) return error;
; 1817 : #		else // !SIMPLE_SOCKETS
; 1818 : 		if ((error = setupListeningSockets())) return error;

  001a8	e8 00 00 00 00	 call	 setupListeningSockets
  001ad	85 c0		 test	 eax, eax
  001af	0f 85 54 01 00
	00		 jne	 $LN15@newmain
$LN8@newmain:

; 1819 : #		endif // !SIMPLE_SOCKETS
; 1820 : 	}
; 1821 : #	endif // !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1822 : 
; 1823 : 	// After sockets have been set up, we may switch to a lower privileged user
; 1824 : #	if !defined(_WIN32) && !defined(NO_USER_SWITCH)
; 1825 : 
; 1826 : #	ifndef NO_SIGHUP
; 1827 : 	if (!IsRestarted)
; 1828 : 	{
; 1829 : #	endif // NO_SIGHUP
; 1830 : 		if (gid != INVALID_GID)
; 1831 : 		{
; 1832 : 			if (setgid(gid))
; 1833 : 			{
; 1834 : 				printerrorf("Fatal: %s for %s failed: %s\n", "setgid", gname, strerror(errno));
; 1835 : 				return errno;
; 1836 : 			}
; 1837 : 
; 1838 : 			if (setgroups(1, &gid))
; 1839 : 			{
; 1840 : 				printerrorf("Fatal: %s for %s failed: %s\n", "setgroups", gname, strerror(errno));
; 1841 : 				return errno;
; 1842 : 			}
; 1843 : 		}
; 1844 : 
; 1845 : 		if (uid != INVALID_UID && setuid(uid))
; 1846 : 		{
; 1847 : 			printerrorf("Fatal: %s for %s failed: %s\n", "setuid", uname, strerror(errno));
; 1848 : 			return errno;
; 1849 : 		}
; 1850 : #	ifndef NO_SIGHUP
; 1851 : 	}
; 1852 : #	endif // NO_SIGHUP
; 1853 : 
; 1854 : #	endif // !defined(_WIN32) && !defined(NO_USER_SWITCH)
; 1855 : 
; 1856 : 	randomNumberInit();

  001b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  001bb	8b c8		 mov	 ecx, eax
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_srand

; 1857 : 
; 1858 : 	// Randomization Level 1 means generate ePIDs at startup and use them during
; 1859 : 	// the lifetime of the process. So we generate them now
; 1860 : #	ifndef NO_RANDOM_EPID
; 1861 : 	if (RandomizationLevel == 1) randomPidInit();

  001c3	40 38 35 00 00
	00 00		 cmp	 BYTE PTR RandomizationLevel, sil
  001ca	75 05		 jne	 SHORT $LN7@newmain
  001cc	e8 00 00 00 00	 call	 randomPidInit
$LN7@newmain:

; 1862 : #	endif
; 1863 : 
; 1864 : #	if !defined(NO_SOCKETS)
; 1865 : #	ifdef _WIN32
; 1866 : 	if (!IsNTService)

  001d1	38 1d 00 00 00
	00		 cmp	 BYTE PTR IsNTService, bl
  001d7	75 27		 jne	 SHORT $LN56@newmain

; 1867 : 	{
; 1868 : #	endif // _WIN32
; 1869 : 		int error;
; 1870 : 		if ((error = daemonizeAndSetSignalAction())) return error;

  001d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:terminationHandler
  001e0	8b d6		 mov	 edx, esi
  001e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCtrlHandler
  001e8	85 c0		 test	 eax, eax
  001ea	75 14		 jne	 SHORT $LN56@newmain
  001ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  001f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Wind@
  001f9	8b d0		 mov	 edx, eax
  001fb	e8 00 00 00 00	 call	 logger
$LN56@newmain:

; 1871 : #	ifdef _WIN32
; 1872 : 	}
; 1873 : #	endif // _WIN32
; 1874 : #	endif // !defined(NO_SOCKETS)
; 1875 : 
; 1876 : 	writePidFile();

  00200	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fn_pid
  00207	48 85 c9	 test	 rcx, rcx
  0020a	74 65		 je	 SHORT $LN36@newmain
  0020c	38 1d 00 00 00
	00		 cmp	 BYTE PTR InetdMode, bl
  00212	75 78		 jne	 SHORT $LN4@newmain
  00214	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00221	48 8b f8	 mov	 rdi, rax
  00224	48 85 c0	 test	 rax, rax
  00227	74 24		 je	 SHORT $LN37@newmain
  00229	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcessId
  0022f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02GMHACPFF@?$CFu?$AA@
  00236	48 8b cf	 mov	 rcx, rdi
  00239	44 8b c0	 mov	 r8d, eax
  0023c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf
  00242	48 8b cf	 mov	 rcx, rdi
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  0024b	eb 24		 jmp	 SHORT $LN36@newmain
$LN37@newmain:
  0024d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00253	8b 08		 mov	 ecx, DWORD PTR [rax]
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  0025b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_pid
  00262	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5?8@
  00269	4c 8b c0	 mov	 r8, rax
  0026c	e8 00 00 00 00	 call	 logger
$LN36@newmain:

; 1877 : 
; 1878 : #	if !defined(NO_LOG) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1879 : 	if (!InetdMode)

  00271	38 1d 00 00 00
	00		 cmp	 BYTE PTR InetdMode, bl
  00277	75 13		 jne	 SHORT $LN4@newmain

; 1880 : 		logger("vlmcsd %s started successfully\n", Version);

  00279	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@LEPLNMP@private?5build?$AA@
  00280	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@NLOBOCBL@vlmcsd?5?$CFs?5started?5successfully?6?$AA@
  00287	e8 00 00 00 00	 call	 logger
$LN4@newmain:

; 1881 : #	endif // !defined(NO_LOG) && !defined(NO_SOCKETS) && !defined(USE_MSRPC)
; 1882 : 
; 1883 : #	if defined(_NTSERVICE) && !defined(USE_MSRPC)
; 1884 : 	if (IsNTService) ReportServiceStatus(SERVICE_RUNNING, NO_ERROR, 200);

  0028c	38 1d 00 00 00
	00		 cmp	 BYTE PTR IsNTService, bl
  00292	74 35		 je	 SHORT $LN46@newmain
  00294	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gSvcStatusHandle
  0029b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gSvcStatus
  002a2	c7 05 04 00 00
	00 04 00 00 00	 mov	 DWORD PTR gSvcStatus+4, 4
  002ac	48 89 35 08 00
	00 00		 mov	 QWORD PTR gSvcStatus+8, rsi
  002b3	c7 05 18 00 00
	00 c8 00 00 00	 mov	 DWORD PTR gSvcStatus+24, 200 ; 000000c8H
  002bd	89 1d 14 00 00
	00		 mov	 DWORD PTR gSvcStatus+20, ebx
  002c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetServiceStatus
$LN46@newmain:

; 1885 : #	endif // defined(_NTSERVICE) && !defined(USE_MSRPC)
; 1886 : 
; 1887 : 	int rc;
; 1888 : 	rc = runServer();//到这里停止了

  002c9	e8 00 00 00 00	 call	 runServer

; 1889 : 
; 1890 : 	// Clean up things and exit
; 1891 : #	ifdef _NTSERVICE
; 1892 : 	if (!ServiceShutdown)

  002ce	38 1d 00 00 00
	00		 cmp	 BYTE PTR ServiceShutdown, bl
  002d4	8b f8		 mov	 edi, eax
  002d6	75 07		 jne	 SHORT $LN2@newmain

; 1893 : #	endif
; 1894 : 		cleanup();

  002d8	e8 00 00 00 00	 call	 cleanup

; 1895 : #	ifdef _NTSERVICE
; 1896 : 	else

  002dd	eb 28		 jmp	 SHORT $LN53@newmain
$LN2@newmain:

; 1897 : 		ReportServiceStatus(SERVICE_STOPPED, NO_ERROR, 0);

  002df	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR gSvcStatusHandle
  002e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:gSvcStatus
  002ed	89 35 04 00 00
	00		 mov	 DWORD PTR gSvcStatus+4, esi
  002f3	48 89 35 08 00
	00 00		 mov	 QWORD PTR gSvcStatus+8, rsi
  002fa	48 89 1d 14 00
	00 00		 mov	 QWORD PTR gSvcStatus+20, rbx
  00301	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetServiceStatus
$LN53@newmain:

; 1898 : #	endif
; 1899 : 
; 1900 : 	return rc;

  00307	8b c7		 mov	 eax, edi
$LN15@newmain:

; 1901 : }

  00309	4c 8d 9c 24 c0
	01 00 00	 lea	 r11, QWORD PTR [rsp+448]
  00311	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  00315	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00319	49 8b e3	 mov	 rsp, r11
  0031c	5f		 pop	 rdi
  0031d	c3		 ret	 0
newmain	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT usage
_TEXT	SEGMENT
usage	PROC						; COMDAT

; 268  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  : 	printerrorf("vlmcsd %s\n"
; 270  : 		"\nUsage:\n"
; 271  : 		"   %s [ options ]\n\n"
; 272  : 		"Where:\n"
; 273  : #		ifndef NO_CL_PIDS
; 274  : 		"  -w <ePID>\t\talways use <ePID> for Windows\n"
; 275  : 		"  -0 <ePID>\t\talways use <ePID> for Office2010\n"
; 276  : 		"  -3 <ePID>\t\talways use <ePID> for Office2013\n"
; 277  : 		"  -6 <ePID>\t\talways use <ePID> for Office2016\n"
; 278  : 		"  -G <ePID>\t\talways use <ePID> for Win China Gov\n"
; 279  : 		"  -H <HwId>\t\talways use hardware Id <HwId>\n"
; 280  : #		endif // NO_CL_PIDS
; 281  : #		if !defined(_WIN32) && !defined(NO_USER_SWITCH)
; 282  : 		"  -u <user>\t\tset uid to <user>\n"
; 283  : 		"  -g <group>\t\tset gid to <group>\n"
; 284  : #		endif // !defined(_WIN32) && !defined(NO_USER_SWITCH)
; 285  : #		ifndef NO_RANDOM_EPID
; 286  : 		"  -r 0|1|2\t\tset ePID randomization level (default 1)\n"
; 287  : 		"  -C <LCID>\t\tuse fixed <LCID> in random ePIDs\n"
; 288  : #		endif // NO_RANDOM_EPID
; 289  : #		if !defined(NO_PRIVATE_IP_DETECT)
; 290  : #		if HAVE_GETIFADDR
; 291  : 		"  -o 0|1|2|3\t\tset protection level against clients with public IP addresses (default 0)\n"
; 292  : #		else // !HAVE_GETIFADDR
; 293  : #		ifndef USE_MSRPC
; 294  : 		"  -o 0|2\t\tset protection level against clients with public IP addresses (default 0)\n"
; 295  : #		else // USE_MSRPC
; 296  : 		"  -o 0|2\t\tset protection level against clients with public IP addresses (default 0). Limited use with MS RPC\n"
; 297  : #		endif // USE_MSRPC
; 298  : #		endif // !HAVE_GETIFADDR
; 299  : #		endif // !defined(NO_PRIVATE_IP_DETECT)
; 300  : #		ifndef NO_TAP
; 301  : 		"  -O <v>[=<a>][/<c>]\tuse VPN adapter <v> with IPv4 address <a> and CIDR <c>\n"
; 302  : #		endif
; 303  : #		ifndef NO_SOCKETS
; 304  : 		"  -x <level>\t\texit if warning <level> reached (default 0)\n"
; 305  : #		if !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 306  : 		"  -L <address>[:<port>]\tlisten on IP address <address> with optional <port>\n"
; 307  : 		"  -P <port>\t\tset TCP port <port> for subsequent -L statements (default 1688)\n"
; 308  : #		if HAVE_FREEBIND
; 309  : 		"  -F0, -F1\t\tdisable/enable binding to foreign IP addresses\n"
; 310  : #		endif // HAVE_FREEBIND
; 311  : #		else // defined(USE_MSRPC) || defined(SIMPLE_SOCKETS)
; 312  : 		"  -P <port>\t\tuse TCP port <port> (default 1688)\n"
; 313  : #		endif // defined(USE_MSRPC) || defined(SIMPLE_SOCKETS)
; 314  : #		if !defined(NO_LIMIT) && !__minix__
; 315  : 		"  -m <clients>\t\tHandle max. <clients> simultaneously (default no limit)\n"
; 316  : #		endif // !defined(NO_LIMIT) && !__minix__
; 317  : #		ifdef _NTSERVICE
; 318  : 		"  -s\t\t\tinstall vlmcsd as an NT service. Ignores -e"
; 319  : #		ifndef _WIN32
; 320  : 		", -f and -D"
; 321  : #		endif // _WIN32
; 322  : 		"\n"
; 323  : 		"  -S\t\t\tremove vlmcsd service. Ignores all other options\n"
; 324  : 		"  -U <username>\t\trun NT service as <username>. Must be used with -s\n"
; 325  : 		"  -W <password>\t\toptional <password> for -U. Must be used with -s\n"
; 326  : #		endif // _NTSERVICE
; 327  : #		ifndef NO_LOG
; 328  : 		"  -e\t\t\tlog to stdout\n"
; 329  : #		endif // NO_LOG
; 330  : #		ifndef _WIN32 //
; 331  : 		"  -D\t\t\trun in foreground\n"
; 332  : #		else // _WIN32
; 333  : 		"  -D\t\t\tdoes nothing. Provided for compatibility with POSIX versions only\n"
; 334  : #		endif // _WIN32
; 335  : #		endif // NO_SOCKETS
; 336  : #		ifndef NO_STRICT_MODES
; 337  : 		"  -K 0|1|2|3\t\tset whitelisting level for KMS IDs (default -K0)\n"
; 338  : 		"  -c0, -c1\t\tdisable/enable client time checking (default -c0)\n"
; 339  : #		ifndef NO_CLIENT_LIST
; 340  : 		"  -M0, -M1\t\tdisable/enable maintaining clients (default -M0)\n"
; 341  : 		"  -E0, -E1\t\tdisable/enable start with empty client list (default -E0, ignored if -M0)\n"
; 342  : #		endif // !NO_CLIENT_LIST
; 343  : #		endif // !NO_STRICT_MODES
; 344  : #		ifndef USE_MSRPC
; 345  : #		if !defined(NO_TIMEOUT) && !__minix__
; 346  : 		"  -t <seconds>\t\tdisconnect clients after <seconds> of inactivity (default 30)\n"
; 347  : #		endif // !defined(NO_TIMEOUT) && !__minix__
; 348  : 		"  -d\t\t\tdisconnect clients after each request\n"
; 349  : 		"  -k\t\t\tdon't disconnect clients after each request (default)\n"
; 350  : #		ifndef SIMPLE_RPC
; 351  : 		"  -N0, -N1\t\tdisable/enable NDR64\n"
; 352  : 		"  -B0, -B1\t\tdisable/enable bind time feature negotiation\n"
; 353  : #		endif // !SIMPLE_RPC
; 354  : #		endif // USE_MSRPC
; 355  : #		ifndef NO_PID_FILE
; 356  : 		"  -p <file>\t\twrite pid to <file>\n"
; 357  : #		endif // NO_PID_FILE
; 358  : #		ifndef NO_INI_FILE
; 359  : 		"  -i <file>\t\tuse config file <file>\n"
; 360  : #		endif // NO_INI_FILE
; 361  : #		ifndef NO_EXTERNAL_DATA
; 362  : 		"  -j <file>\t\tuse KMS data file <file>\n"
; 363  : #		endif // !NO_EXTERNAL_DATA
; 364  : #		ifndef NO_CUSTOM_INTERVALS
; 365  : 		"  -R <interval>\t\trenew activation every <interval> (default 1w)\n"
; 366  : 		"  -A <interval>\t\tretry activation every <interval> (default 2h)\n"
; 367  : #		endif // NO_CUSTOM_INTERVALS
; 368  : #		ifndef NO_LOG
; 369  : #		ifndef _WIN32
; 370  : 		"  -l syslog		log to syslog\n"
; 371  : #		endif // _WIN32
; 372  : 		"  -l <file>\t\tlog to <file>\n"
; 373  : 		"  -T0, -T1\t\tdisable/enable logging with time and date (default -T1)\n"
; 374  : #		ifndef NO_VERBOSE_LOG
; 375  : 		"  -v\t\t\tlog verbose\n"
; 376  : 		"  -q\t\t\tdon't log verbose (default)\n"
; 377  : #		endif // NO_VERBOSE_LOG
; 378  : #		endif // NO_LOG
; 379  : #		ifndef NO_VERSION_INFORMATION
; 380  : 		"  -V\t\t\tdisplay version information and exit\n"
; 381  : #		endif // NO_VERSION_INFORMATION
; 382  : 		,
; 383  : 		Version, global_argv[0]);

  00004	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR global_argv
  0000b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@LEPLNMP@private?5build?$AA@
  00012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0IHN@EKOFFKCI@vlmcsd?5?$CFs?6?6Usage?3?6?5?5?5?$CFs?5?$FL?5option@
  00019	4d 8b 00	 mov	 r8, QWORD PTR [r8]
  0001c	e8 00 00 00 00	 call	 printerrorf

; 384  : 
; 385  : 	exit(VLMCSD_EINVAL);

  00021	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0002c	cc		 int	 3
$LN3@usage:
usage	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT getTimeSpanFromIniFile
_TEXT	SEGMENT
result$ = 48
argument$ = 56
getTimeSpanFromIniFile PROC				; COMDAT

; 394  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 395  : 	DWORD val = timeSpanString2Minutes(argument);

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	e8 00 00 00 00	 call	 timeSpanString2Seconds
  00011	8b d0		 mov	 edx, eax
  00013	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00018	f7 e2		 mul	 edx
  0001a	c1 ea 05	 shr	 edx, 5

; 396  : 	if (!val)

  0001d	85 d2		 test	 edx, edx
  0001f	75 12		 jne	 SHORT $LN1@getTimeSpa

; 397  : 	{
; 398  : 		IniFileErrorMessage = "Incorrect time span.";

  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4?$AA@
  00028	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax

; 399  : 		return FALSE;

  0002f	33 c0		 xor	 eax, eax
  00031	eb 07		 jmp	 SHORT $LN2@getTimeSpa
$LN1@getTimeSpa:

; 400  : 	}
; 401  : 
; 402  : 	*result = val;

  00033	89 13		 mov	 DWORD PTR [rbx], edx

; 403  : 	return TRUE;

  00035	b8 01 00 00 00	 mov	 eax, 1
$LN2@getTimeSpa:

; 404  : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
getTimeSpanFromIniFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT getTimeSpanFromCommandLine
_TEXT	SEGMENT
arg$dead$ = 48
optchar$ = 56
getTimeSpanFromCommandLine PROC				; COMDAT

; 410  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 411  : 	DWORD val = timeSpanString2Minutes(arg);

  00006	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR optarg
  0000d	8a da		 mov	 bl, dl
  0000f	e8 00 00 00 00	 call	 timeSpanString2Seconds
  00014	8b c8		 mov	 ecx, eax
  00016	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  0001b	f7 e1		 mul	 ecx
  0001d	c1 ea 05	 shr	 edx, 5

; 412  : 
; 413  : 	if (!val)

  00020	85 d2		 test	 edx, edx
  00022	75 1b		 jne	 SHORT $LN1@getTimeSpa

; 414  : 	{
; 415  : 		printerrorf("Fatal: No valid time span specified in option -%c.\n", optchar);

  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5specif@
  0002b	0f be d3	 movsx	 edx, bl
  0002e	e8 00 00 00 00	 call	 printerrorf

; 416  : 		exit(VLMCSD_EINVAL);

  00033	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0003e	cc		 int	 3
$LN1@getTimeSpa:

; 417  : 	}
; 418  : 
; 419  : 	return val;

  0003f	8b c2		 mov	 eax, edx

; 420  : }

  00041	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00045	5b		 pop	 rbx
  00046	c3		 ret	 0
$LN5@getTimeSpa:
getTimeSpanFromCommandLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT ignoreIniFileParameter
_TEXT	SEGMENT
iniFileParameterId$ = 8
ignoreIniFileParameter PROC				; COMDAT

; 428  : 	uint_fast8_t i;
; 429  : 
; 430  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  00000	32 d2		 xor	 dl, dl
  00002	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:IniFileParameterList
$LL4@ignoreIniF:

; 431  : 	{
; 432  : 		if (IniFileParameterList[i].Id != iniFileParameterId) continue;

  00009	0f b6 c2	 movzx	 eax, dl
  0000c	48 03 c0	 add	 rax, rax
  0000f	41 38 4c c0 08	 cmp	 BYTE PTR [r8+rax*8+8], cl
  00014	74 08		 je	 SHORT $LN1@ignoreIniF

; 428  : 	uint_fast8_t i;
; 429  : 
; 430  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  00016	fe c2		 inc	 dl
  00018	80 fa 1c	 cmp	 dl, 28
  0001b	72 ec		 jb	 SHORT $LL4@ignoreIniF

; 434  : 		break;
; 435  : 	}
; 436  : }

  0001d	c3		 ret	 0
$LN1@ignoreIniF:

; 433  : 		IniFileParameterList[i].Id = 0;

  0001e	0f b6 c2	 movzx	 eax, dl
  00021	48 03 c0	 add	 rax, rax
  00024	41 c6 44 c0 08
	00		 mov	 BYTE PTR [r8+rax*8+8], 0

; 434  : 		break;
; 435  : 	}
; 436  : }

  0002a	c3		 ret	 0
ignoreIniFileParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT getIniFileArgumentBool
_TEXT	SEGMENT
result$ = 8
argument$ = 16
getIniFileArgumentBool PROC				; COMDAT

; 445  : 	IniFileErrorMessage = "Argument must be true/on/yes/1 or false/off/no/0";

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5o@
  00007	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax

; 446  : 	return getArgumentBool(result, argument);

  0000e	e9 00 00 00 00	 jmp	 getArgumentBool
getIniFileArgumentBool ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT getIniFileArgumentInt
_TEXT	SEGMENT
min$ = 64
max$ = 72
getIniFileArgumentInt PROC				; COMDAT

; 451  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 452  : 	unsigned int tempResult;
; 453  : 
; 454  : 	if (!stringToInt(argument, min, max, &tempResult))
; 455  : 	{
; 456  : 		vlmcsd_snprintf(IniFileErrorBuffer, INIFILE_ERROR_BUFFERSIZE, "Must be integer between %u and %u", min, max);

  00004	44 8b c9	 mov	 r9d, ecx
  00007	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR IniFileErrorBuffer
  0000e	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  00012	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CC@DKAMOLDO@Must?5be?5integer?5between?5?$CFu?5and?5?$CF@
  00019	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__snprintf

; 457  : 		IniFileErrorMessage = IniFileErrorBuffer;

  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IniFileErrorBuffer
  0002b	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax

; 458  : 		return FALSE;

  00032	33 c0		 xor	 eax, eax

; 459  : 	}
; 460  : 
; 461  : 	*result = tempResult;
; 462  : 	return TRUE;
; 463  : }

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
getIniFileArgumentInt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT isControlCharOrSlash
_TEXT	SEGMENT
c$ = 8
isControlCharOrSlash PROC				; COMDAT

; 468  : 	if ((unsigned char)c < '!') return TRUE;

  00000	80 f9 21	 cmp	 cl, 33			; 00000021H
  00003	73 06		 jae	 SHORT $LN2@isControlC
  00005	b8 01 00 00 00	 mov	 eax, 1

; 470  : 	return FALSE;
; 471  : }

  0000a	c3		 ret	 0
$LN2@isControlC:

; 469  : 	if (c == '/') return TRUE;

  0000b	33 c0		 xor	 eax, eax
  0000d	80 f9 2f	 cmp	 cl, 47			; 0000002fH
  00010	0f 94 c0	 sete	 al

; 470  : 	return FALSE;
; 471  : }

  00013	c3		 ret	 0
isControlCharOrSlash ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT iniFileLineNextWord
_TEXT	SEGMENT
s$ = 48
iniFileLineNextWord PROC				; COMDAT

; 475  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 476  : 	while (**s && isspace((int)**s)) (*s)++;

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	eb 16		 jmp	 SHORT $LN10@iniFileLin
$LL2@iniFileLin:
  0000e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00011	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  0001a	85 c0		 test	 eax, eax
  0001c	74 0b		 je	 SHORT $LN1@iniFileLin
  0001e	48 ff 03	 inc	 QWORD PTR [rbx]
  00021	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN10@iniFileLin:
  00024	80 38 00	 cmp	 BYTE PTR [rax], 0
  00027	75 e5		 jne	 SHORT $LL2@iniFileLin
$LN1@iniFileLin:

; 477  : }

  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5b		 pop	 rbx
  0002e	c3		 ret	 0
iniFileLineNextWord ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT setHwIdFromIniFileLine
_TEXT	SEGMENT
s$ = 48
index$ = 56
setHwIdFromIniFileLine PROC				; COMDAT

; 481  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b da		 mov	 ebx, edx
  00011	48 8b f9	 mov	 rdi, rcx

; 482  : 	iniFileLineNextWord(s);

  00014	e8 00 00 00 00	 call	 iniFileLineNextWord

; 483  : 
; 484  : 	if (**s == '/')

  00019	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0001c	80 38 2f	 cmp	 BYTE PTR [rax], 47	; 0000002fH
  0001f	75 3a		 jne	 SHORT $LN2@setHwIdFro

; 485  : 	{
; 486  : 		if (KmsResponseParameters[index].HwId) return TRUE;

  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KmsResponseParameters
  00028	48 8d 34 5b	 lea	 rsi, QWORD PTR [rbx+rbx*2]
  0002c	48 83 7c f0 08
	00		 cmp	 QWORD PTR [rax+rsi*8+8], 0
  00032	75 27		 jne	 SHORT $LN2@setHwIdFro

; 487  : 
; 488  : 		BYTE* HwId = (BYTE*)vlmcsd_malloc(sizeof(((RESPONSE_V6 *)0)->HwId));

  00034	b9 08 00 00 00	 mov	 ecx, 8
  00039	e8 00 00 00 00	 call	 vlmcsd_malloc

; 489  : 		hex2bin(HwId, *s + 1, sizeof(((RESPONSE_V6 *)0)->HwId));

  0003e	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00041	48 ff c2	 inc	 rdx
  00044	48 8b c8	 mov	 rcx, rax
  00047	48 8b d8	 mov	 rbx, rax
  0004a	e8 00 00 00 00	 call	 hex2bin

; 490  : 		KmsResponseParameters[index].HwId = HwId;

  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
  00056	48 89 5c f1 08	 mov	 QWORD PTR [rcx+rsi*8+8], rbx
$LN2@setHwIdFro:

; 491  : 	}
; 492  : 
; 493  : 	return TRUE;
; 494  : }

  0005b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00060	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00065	b8 01 00 00 00	 mov	 eax, 1
  0006a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
setHwIdFromIniFileLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT setEpidFromIniFileLine
_TEXT	SEGMENT
s$ = 48
index$ = 56
setEpidFromIniFileLine PROC				; COMDAT

; 498  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	8b da		 mov	 ebx, edx
  00016	48 8b f9	 mov	 rdi, rcx

; 499  : 	iniFileLineNextWord(s);

  00019	e8 00 00 00 00	 call	 iniFileLineNextWord

; 500  : 	const char *savedPosition = *s;

  0001e	48 8b 2f	 mov	 rbp, QWORD PTR [rdi]

; 501  : 	uint_fast16_t i;
; 502  : 
; 503  : 	for (i = 0; !isControlCharOrSlash(**s); i++)

  00021	45 33 c9	 xor	 r9d, r9d
$LL7@setEpidFro:
  00024	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  00027	80 39 21	 cmp	 BYTE PTR [rcx], 33	; 00000021H
  0002a	72 21		 jb	 SHORT $LN5@setEpidFro
  0002c	80 39 2f	 cmp	 BYTE PTR [rcx], 47	; 0000002fH
  0002f	74 1c		 je	 SHORT $LN5@setEpidFro

; 504  : 	{
; 505  : 		if (utf8_to_ucs2_char((const unsigned char*)*s, (const unsigned char**)s) == (WCHAR)~0)

  00031	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00034	74 76		 je	 SHORT $LN2@setEpidFro
  00036	48 8b d7	 mov	 rdx, rdi
  00039	e8 00 00 00 00	 call	 utf8_to_ucs2_char
  0003e	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00043	66 3b c1	 cmp	 ax, cx
  00046	74 64		 je	 SHORT $LN2@setEpidFro

; 501  : 	uint_fast16_t i;
; 502  : 
; 503  : 	for (i = 0; !isControlCharOrSlash(**s); i++)

  00048	41 ff c1	 inc	 r9d
  0004b	eb d7		 jmp	 SHORT $LL7@setEpidFro
$LN5@setEpidFro:

; 506  : 		{
; 507  : 			return FALSE;
; 508  : 		}
; 509  : 	}
; 510  : 
; 511  : 	if (i < 1 || i >= PID_BUFFER_SIZE) return FALSE;

  0004d	41 8d 49 ff	 lea	 ecx, DWORD PTR [r9-1]
  00051	83 f9 3e	 cmp	 ecx, 62			; 0000003eH
  00054	77 56		 ja	 SHORT $LN2@setEpidFro

; 512  : 	if (KmsResponseParameters[index].Epid) return TRUE;

  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
  0005d	48 8d 34 5b	 lea	 rsi, QWORD PTR [rbx+rbx*2]
  00061	48 83 3c f1 00	 cmp	 QWORD PTR [rcx+rsi*8], 0
  00066	74 07		 je	 SHORT $LN1@setEpidFro
$LN33@setEpidFro:
  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	eb 3f		 jmp	 SHORT $LN8@setEpidFro
$LN1@setEpidFro:

; 513  : 
; 514  : 	size_t size = *s - savedPosition + 1;

  0006f	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
  00072	48 2b fd	 sub	 rdi, rbp

; 515  : 
; 516  : 	char* epidbuffer = (char*)vlmcsd_malloc(size);

  00075	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
  00079	e8 00 00 00 00	 call	 vlmcsd_malloc

; 517  : 	memcpy(epidbuffer, savedPosition, size - 1);

  0007e	4c 8b c7	 mov	 r8, rdi
  00081	48 8b d5	 mov	 rdx, rbp
  00084	48 8b c8	 mov	 rcx, rax
  00087	48 8b d8	 mov	 rbx, rax
  0008a	e8 00 00 00 00	 call	 memcpy

; 518  : 	epidbuffer[size - 1] = 0;
; 519  : 
; 520  : 	KmsResponseParameters[index].Epid = epidbuffer;

  0008f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters

; 521  : 
; 522  : #ifndef NO_LOG
; 523  : 	KmsResponseParameters[index].EpidSource = fn_ini;

  00096	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR fn_ini
  0009d	c6 04 3b 00	 mov	 BYTE PTR [rbx+rdi], 0
  000a1	48 89 1c f1	 mov	 QWORD PTR [rcx+rsi*8], rbx
  000a5	48 89 44 f1 10	 mov	 QWORD PTR [rcx+rsi*8+16], rax

; 524  : #endif //NO_LOG
; 525  : 
; 526  : 	return TRUE;

  000aa	eb bc		 jmp	 SHORT $LN33@setEpidFro
$LN2@setEpidFro:

; 506  : 		{
; 507  : 			return FALSE;
; 508  : 		}
; 509  : 	}
; 510  : 
; 511  : 	if (i < 1 || i >= PID_BUFFER_SIZE) return FALSE;

  000ac	33 c0		 xor	 eax, eax
$LN8@setEpidFro:

; 527  : }

  000ae	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b3	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b8	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000bd	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c1	5f		 pop	 rdi
  000c2	c3		 ret	 0
setEpidFromIniFileLine ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT setIniFileParameter
_TEXT	SEGMENT
result$ = 48
id$ = 48
nextchar$1 = 56
nextchar$2 = 56
nextchar$3 = 56
nextchar$4 = 56
nextchar$5 = 56
nextchar$6 = 56
nextchar$7 = 56
s$ = 56
iniarg$ = 56
setIniFileParameter PROC				; COMDAT

; 531  : {

  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	55		 push	 rbp
  0000b	48 8b ec	 mov	 rbp, rsp
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 532  : 	unsigned int result;
; 533  : 	BOOL success = TRUE;
; 534  : 	const char *s = (const char*)iniarg;
; 535  : 
; 536  : 	switch (id)

  00012	44 0f b6 c1	 movzx	 r8d, cl
  00016	48 8b fa	 mov	 rdi, rdx
  00019	bb 01 00 00 00	 mov	 ebx, 1
  0001e	48 89 55 18	 mov	 QWORD PTR s$[rbp-32], rdx
  00022	41 83 f8 12	 cmp	 r8d, 18
  00026	0f 8f 6a 03 00
	00		 jg	 $LN38@setIniFile
  0002c	0f 84 14 03 00
	00		 je	 $LN2@setIniFile
  00032	41 83 f8 08	 cmp	 r8d, 8
  00036	0f 8f 31 02 00
	00		 jg	 $LN39@setIniFile
  0003c	0f 84 1f 02 00
	00		 je	 $LN12@setIniFile
  00042	41 ff c8	 dec	 r8d
  00045	0f 84 b8 01 00
	00		 je	 $LN25@setIniFile
  0004b	41 ff c8	 dec	 r8d
  0004e	0f 84 52 01 00
	00		 je	 $LN27@setIniFile
  00054	41 ff c8	 dec	 r8d
  00057	0f 84 3e 01 00
	00		 je	 $LN22@setIniFile
  0005d	41 ff c8	 dec	 r8d
  00060	0f 84 d9 00 00
	00		 je	 $LN21@setIniFile
  00066	41 ff c8	 dec	 r8d
  00069	74 70		 je	 SHORT $LN9@setIniFile
  0006b	41 ff c8	 dec	 r8d
  0006e	74 39		 je	 SHORT $LN20@setIniFile
  00070	41 ff c8	 dec	 r8d
  00073	0f 85 3b 04 00
	00		 jne	 $LN1@setIniFile

; 679  : 
; 680  : #	endif // NO_CLIENT_LIST
; 681  : #	endif // !NO_STRICT_MODES
; 682  : 
; 683  : 
; 684  : #	ifndef  NO_LOG
; 685  : 
; 686  : 	case INI_PARAM_LOG_FILE:
; 687  : 		fn_log = vlmcsd_strdup(iniarg);

  00079	48 8b ca	 mov	 rcx, rdx
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  00082	48 85 c0	 test	 rax, rax
  00085	75 16		 jne	 SHORT $LN108@setIniFile
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  0008e	e8 00 00 00 00	 call	 errorout
  00093	8d 4b 0d	 lea	 ecx, QWORD PTR [rbx+13]
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0009c	cc		 int	 3
$LN108@setIniFile:
  0009d	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_log, rax

; 688  : 		break;

  000a4	e9 09 05 00 00	 jmp	 $LN34@setIniFile
$LN20@setIniFile:

; 639  : 
; 640  : #	endif // !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !__minix__
; 641  : 
; 642  : #	ifndef NO_PID_FILE
; 643  : 
; 644  : 	case INI_PARAM_PID_FILE:
; 645  : 		fn_pid = vlmcsd_strdup(iniarg);

  000a9	48 8b ca	 mov	 rcx, rdx
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  000b2	48 85 c0	 test	 rax, rax
  000b5	75 18		 jne	 SHORT $LN81@setIniFile
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  000be	e8 00 00 00 00	 call	 errorout
  000c3	b9 0e 00 00 00	 mov	 ecx, 14
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  000ce	cc		 int	 3
$LN81@setIniFile:
  000cf	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_pid, rax

; 646  : 		break;

  000d6	e9 d7 04 00 00	 jmp	 $LN34@setIniFile
$LN9@setIniFile:

; 711  : 
; 712  : #	endif // NO_CUSTOM_INTERVALS
; 713  : 
; 714  : #	ifndef USE_MSRPC
; 715  : 
; 716  : #	if !defined(NO_TIMEOUT) && !__minix__
; 717  : 
; 718  : 	case INI_PARAM_CONNECTION_TIMEOUT:
; 719  : 		success = getIniFileArgumentInt(&result, iniarg, 1, 600);

  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e1	48 8d 55 18	 lea	 rdx, QWORD PTR nextchar$3[rbp-32]
  000e5	41 b8 0a 00 00
	00		 mov	 r8d, 10
  000eb	83 20 00	 and	 DWORD PTR [rax], 0
  000ee	48 8b cf	 mov	 rcx, rdi
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strtoi64
  000f7	48 8b f8	 mov	 rdi, rax
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00100	83 38 00	 cmp	 DWORD PTR [rax], 0
  00103	75 16		 jne	 SHORT $LN129@setIniFile
  00105	48 8d 4f ff	 lea	 rcx, QWORD PTR [rdi-1]
  00109	48 81 f9 57 02
	00 00		 cmp	 rcx, 599		; 00000257H
  00110	77 09		 ja	 SHORT $LN129@setIniFile
  00112	48 8b 4d 18	 mov	 rcx, QWORD PTR nextchar$3[rbp-32]
  00116	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00119	74 11		 je	 SHORT $LN125@setIniFile
$LN129@setIniFile:
  0011b	ba 58 02 00 00	 mov	 edx, 600		; 00000258H
  00120	8b cb		 mov	 ecx, ebx
  00122	e8 00 00 00 00	 call	 getIniFileArgumentInt
  00127	8b 7d 10	 mov	 edi, DWORD PTR result$[rbp-32]
  0012a	8b d8		 mov	 ebx, eax
$LN125@setIniFile:

; 720  : 		if (success) ServerTimeout = (DWORD)result;

  0012c	85 db		 test	 ebx, ebx
  0012e	0f 84 7e 04 00
	00		 je	 $LN34@setIniFile
  00134	89 3d 00 00 00
	00		 mov	 DWORD PTR ServerTimeout, edi

; 721  : 		break;

  0013a	e9 73 04 00 00	 jmp	 $LN34@setIniFile
$LN21@setIniFile:

; 628  : 
; 629  : #	endif // !defined(NO_SOCKETS) && !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 630  : #	if !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !__minix__
; 631  : 
; 632  : 	case INI_PARAM_MAX_WORKERS:
; 633  : #		ifdef USE_MSRPC
; 634  : 		success = getIniFileArgumentInt(&MaxTasks, iniarg, 1, RPC_C_LISTEN_MAX_CALLS_DEFAULT);
; 635  : #		else // !USE_MSRPC
; 636  : 		success = getIniFileArgumentInt(&MaxTasks, iniarg, 1, SEM_VALUE_MAX);

  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00145	48 8d 55 18	 lea	 rdx, QWORD PTR nextchar$5[rbp-32]
  00149	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0014f	83 20 00	 and	 DWORD PTR [rax], 0
  00152	48 8b cf	 mov	 rcx, rdi
  00155	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strtoi64
  0015b	48 8b f8	 mov	 rdi, rax
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00164	83 38 00	 cmp	 DWORD PTR [rax], 0
  00167	75 21		 jne	 SHORT $LN77@setIniFile
  00169	48 8d 4f ff	 lea	 rcx, QWORD PTR [rdi-1]
  0016d	48 81 f9 fe ff
	ff 7f		 cmp	 rcx, 2147483646		; 7ffffffeH
  00174	77 14		 ja	 SHORT $LN77@setIniFile
  00176	48 8b 4d 18	 mov	 rcx, QWORD PTR nextchar$5[rbp-32]
  0017a	80 39 00	 cmp	 BYTE PTR [rcx], 0
  0017d	75 0b		 jne	 SHORT $LN77@setIniFile
  0017f	89 3d 00 00 00
	00		 mov	 DWORD PTR MaxTasks, edi

; 637  : #		endif // !USE_MSRPC
; 638  : 		break;

  00185	e9 28 04 00 00	 jmp	 $LN34@setIniFile

; 628  : 
; 629  : #	endif // !defined(NO_SOCKETS) && !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 630  : #	if !defined(NO_LIMIT) && !defined(NO_SOCKETS) && !__minix__
; 631  : 
; 632  : 	case INI_PARAM_MAX_WORKERS:
; 633  : #		ifdef USE_MSRPC
; 634  : 		success = getIniFileArgumentInt(&MaxTasks, iniarg, 1, RPC_C_LISTEN_MAX_CALLS_DEFAULT);
; 635  : #		else // !USE_MSRPC
; 636  : 		success = getIniFileArgumentInt(&MaxTasks, iniarg, 1, SEM_VALUE_MAX);

$LN77@setIniFile:
  0018a	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  0018f	8b cb		 mov	 ecx, ebx
$LN160@setIniFile:
  00191	e8 00 00 00 00	 call	 getIniFileArgumentInt
  00196	e9 15 04 00 00	 jmp	 $LN158@setIniFile
$LN22@setIniFile:

; 620  : 
; 621  : #	endif // (defined(USE_MSRPC) || defined(SIMPLE_SOCKETS) || defined(HAVE_GETIFADDR)) && !defined(NO_SOCKETS)
; 622  : 
; 623  : #	if !defined(NO_SOCKETS) && !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 624  : 
; 625  : 	case INI_PARAM_LISTEN:
; 626  : 		maxsockets++;

  0019b	00 1d 00 00 00
	00		 add	 BYTE PTR maxsockets, bl

; 627  : 		return TRUE;

  001a1	e9 0c 04 00 00	 jmp	 $LN34@setIniFile
$LN27@setIniFile:

; 568  : 
; 569  : #	endif // NO_TAP
; 570  : 
; 571  : #	if !defined(NO_USER_SWITCH) && !_WIN32
; 572  : 
; 573  : 	case INI_PARAM_GID:
; 574  : 	{
; 575  : 		struct group *g;
; 576  : 		IniFileErrorMessage = "Invalid group id or name";
; 577  : 		if (!(gname = vlmcsd_strdup(iniarg))) return FALSE;
; 578  : 
; 579  : 		if ((g = getgrnam(iniarg)))
; 580  : 			gid = g->gr_gid;
; 581  : 		else
; 582  : 			success = !GetNumericId(&gid, iniarg);
; 583  : 		break;
; 584  : 	}
; 585  : 
; 586  : 	case INI_PARAM_UID:
; 587  : 	{
; 588  : 		struct passwd *p;
; 589  : 		IniFileErrorMessage = "Invalid user id or name";
; 590  : 		if (!(uname = vlmcsd_strdup(iniarg))) return FALSE;
; 591  : 
; 592  : 		if ((p = getpwnam(iniarg)))
; 593  : 			uid = p->pw_uid;
; 594  : 		else
; 595  : 			success = !GetNumericId(&uid, iniarg);
; 596  : 		break;
; 597  : 	}
; 598  : 
; 599  : #	endif // !defined(NO_USER_SWITCH) && !defined(_WIN32)
; 600  : 
; 601  : #	ifndef NO_RANDOM_EPID
; 602  : 
; 603  : 	case INI_PARAM_LCID:
; 604  : 		success = getIniFileArgumentInt(&result, iniarg, 0, 32767);

  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ac	48 8d 55 18	 lea	 rdx, QWORD PTR nextchar$7[rbp-32]
  001b0	41 b8 0a 00 00
	00		 mov	 r8d, 10
  001b6	83 20 00	 and	 DWORD PTR [rax], 0
  001b9	48 8b cf	 mov	 rcx, rdi
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strtoi64
  001c2	48 8b f8	 mov	 rdi, rax
  001c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001cb	ba ff 7f 00 00	 mov	 edx, 32767		; 00007fffH
  001d0	83 38 00	 cmp	 DWORD PTR [rax], 0
  001d3	75 0e		 jne	 SHORT $LN53@setIniFile
  001d5	48 3b fa	 cmp	 rdi, rdx
  001d8	77 09		 ja	 SHORT $LN53@setIniFile
  001da	48 8b 4d 18	 mov	 rcx, QWORD PTR nextchar$7[rbp-32]
  001de	80 39 00	 cmp	 BYTE PTR [rcx], 0
  001e1	74 0c		 je	 SHORT $LN49@setIniFile
$LN53@setIniFile:
  001e3	33 c9		 xor	 ecx, ecx
  001e5	e8 00 00 00 00	 call	 getIniFileArgumentInt
  001ea	8b 7d 10	 mov	 edi, DWORD PTR result$[rbp-32]
  001ed	8b d8		 mov	 ebx, eax
$LN49@setIniFile:

; 605  : 		if (success) Lcid = (uint16_t)result;

  001ef	85 db		 test	 ebx, ebx
  001f1	0f 84 bb 03 00
	00		 je	 $LN34@setIniFile
  001f7	66 89 3d 00 00
	00 00		 mov	 WORD PTR Lcid, di

; 606  : 		break;

  001fe	e9 af 03 00 00	 jmp	 $LN34@setIniFile
$LN25@setIniFile:

; 607  : 
; 608  : 	case INI_PARAM_RANDOMIZATION_LEVEL:
; 609  : 		success = getIniFileArgumentInt(&result, iniarg, 0, 2);

  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00209	48 8d 55 18	 lea	 rdx, QWORD PTR nextchar$6[rbp-32]
  0020d	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00213	83 20 00	 and	 DWORD PTR [rax], 0
  00216	48 8b cf	 mov	 rcx, rdi
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strtoi64
  0021f	48 8b f8	 mov	 rdi, rax
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00228	83 38 00	 cmp	 DWORD PTR [rax], 0
  0022b	75 0f		 jne	 SHORT $LN62@setIniFile
  0022d	48 83 ff 02	 cmp	 rdi, 2
  00231	77 09		 ja	 SHORT $LN62@setIniFile
  00233	48 8b 4d 18	 mov	 rcx, QWORD PTR nextchar$6[rbp-32]
  00237	80 39 00	 cmp	 BYTE PTR [rcx], 0
  0023a	74 11		 je	 SHORT $LN58@setIniFile
$LN62@setIniFile:
  0023c	ba 02 00 00 00	 mov	 edx, 2
  00241	33 c9		 xor	 ecx, ecx
  00243	e8 00 00 00 00	 call	 getIniFileArgumentInt
  00248	8b 7d 10	 mov	 edi, DWORD PTR result$[rbp-32]
  0024b	8b d8		 mov	 ebx, eax
$LN58@setIniFile:

; 610  : 		if (success) RandomizationLevel = (int_fast8_t)result;

  0024d	85 db		 test	 ebx, ebx
  0024f	0f 84 5d 03 00
	00		 je	 $LN34@setIniFile
  00255	40 88 3d 00 00
	00 00		 mov	 BYTE PTR RandomizationLevel, dil

; 611  : 		break;

  0025c	e9 51 03 00 00	 jmp	 $LN34@setIniFile
$LN12@setIniFile:

; 693  : 
; 694  : #	ifndef NO_VERBOSE_LOG
; 695  : 	case INI_PARAM_LOG_VERBOSE:
; 696  : 		success = getIniFileArgumentBool(&logverbose, iniarg);

  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:logverbose

; 697  : 		break;

  00268	e9 30 03 00 00	 jmp	 $LN159@setIniFile
$LN39@setIniFile:

; 532  : 	unsigned int result;
; 533  : 	BOOL success = TRUE;
; 534  : 	const char *s = (const char*)iniarg;
; 535  : 
; 536  : 	switch (id)

  0026d	41 83 e8 09	 sub	 r8d, 9
  00271	0f 84 ac 00 00
	00		 je	 $LN11@setIniFile
  00277	41 ff c8	 dec	 r8d
  0027a	74 6f		 je	 SHORT $LN10@setIniFile
  0027c	41 ff c8	 dec	 r8d
  0027f	74 5e		 je	 SHORT $LN7@setIniFile
  00281	41 83 e8 03	 sub	 r8d, 3
  00285	74 26		 je	 SHORT $LN23@setIniFile
  00287	41 ff c8	 dec	 r8d
  0028a	74 15		 je	 SHORT $LN6@setIniFile
  0028c	41 ff c8	 dec	 r8d
  0028f	0f 85 1f 02 00
	00		 jne	 $LN1@setIniFile

; 732  : 
; 733  : 	case INI_PARAM_RPC_BTFN:
; 734  : 		success = getIniFileArgumentBool(&UseServerRpcBTFN, iniarg);

  00295	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UseServerRpcBTFN

; 735  : 		break;

  0029c	e9 fc 02 00 00	 jmp	 $LN159@setIniFile
$LN6@setIniFile:

; 728  : 
; 729  : 	case INI_PARAM_RPC_NDR64:
; 730  : 		success = getIniFileArgumentBool(&UseServerRpcNDR64, iniarg);

  002a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UseServerRpcNDR64

; 731  : 		break;

  002a8	e9 f0 02 00 00	 jmp	 $LN159@setIniFile
$LN23@setIniFile:

; 612  : 
; 613  : #	endif // NO_RANDOM_EPID
; 614  : 
; 615  : #	if (defined(USE_MSRPC) || defined(SIMPLE_SOCKETS) || defined(HAVE_GETIFADDR)) && !defined(NO_SOCKETS)
; 616  : 
; 617  : 	case INI_PARAM_PORT:
; 618  : 		defaultport = vlmcsd_strdup(iniarg);

  002ad	48 8b ca	 mov	 rcx, rdx
  002b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  002b6	48 85 c0	 test	 rax, rax
  002b9	75 18		 jne	 SHORT $LN66@setIniFile
  002bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  002c2	e8 00 00 00 00	 call	 errorout
  002c7	b9 0e 00 00 00	 mov	 ecx, 14
  002cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  002d2	cc		 int	 3
$LN66@setIniFile:
  002d3	48 89 05 00 00
	00 00		 mov	 QWORD PTR defaultport, rax

; 619  : 		break;

  002da	e9 d3 02 00 00	 jmp	 $LN34@setIniFile
$LN7@setIniFile:

; 722  : 
; 723  : #	endif // !defined(NO_TIMEOUT) && !__minix__
; 724  : 
; 725  : 	case INI_PARAM_DISCONNECT_IMMEDIATELY:
; 726  : 		success = getIniFileArgumentBool(&DisconnectImmediately, iniarg);

  002df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DisconnectImmediately

; 727  : 		break;

  002e6	e9 b2 02 00 00	 jmp	 $LN159@setIniFile
$LN10@setIniFile:

; 707  : 
; 708  : 	case INI_PARAM_RENEWAL_INTERVAL:
; 709  : 		success = getTimeSpanFromIniFile(&VLRenewalInterval, iniarg);

  002eb	48 8b ca	 mov	 rcx, rdx
  002ee	e8 00 00 00 00	 call	 timeSpanString2Seconds
  002f3	8b c8		 mov	 ecx, eax
  002f5	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  002fa	f7 e1		 mul	 ecx
  002fc	c1 ea 05	 shr	 edx, 5
  002ff	85 d2		 test	 edx, edx
  00301	75 15		 jne	 SHORT $LN121@setIniFile
$LN162@setIniFile:
  00303	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@DDLEHNLP@Incorrect?5time?5span?4?$AA@
  0030a	33 db		 xor	 ebx, ebx
  0030c	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax
  00313	e9 9a 02 00 00	 jmp	 $LN34@setIniFile
$LN121@setIniFile:
  00318	89 15 00 00 00
	00		 mov	 DWORD PTR VLRenewalInterval, edx

; 710  : 		break;

  0031e	e9 8f 02 00 00	 jmp	 $LN34@setIniFile
$LN11@setIniFile:

; 698  : 
; 699  : #	endif // NO_VERBOSE_LOG
; 700  : #	endif // NO_LOG
; 701  : 
; 702  : #	ifndef NO_CUSTOM_INTERVALS
; 703  : 
; 704  : 	case INI_PARAM_ACTIVATION_INTERVAL:
; 705  : 		success = getTimeSpanFromIniFile(&VLActivationInterval, iniarg);

  00323	48 8b ca	 mov	 rcx, rdx
  00326	e8 00 00 00 00	 call	 timeSpanString2Seconds
  0032b	8b c8		 mov	 ecx, eax
  0032d	b8 89 88 88 88	 mov	 eax, -2004318071	; 88888889H
  00332	f7 e1		 mul	 ecx
  00334	c1 ea 05	 shr	 edx, 5
  00337	85 d2		 test	 edx, edx
  00339	74 c8		 je	 SHORT $LN162@setIniFile
  0033b	89 15 00 00 00
	00		 mov	 DWORD PTR VLActivationInterval, edx

; 706  : 		break;

  00341	e9 6c 02 00 00	 jmp	 $LN34@setIniFile
$LN2@setIniFile:

; 745  : 
; 746  : #	endif // NO_SOCKETS
; 747  : 
; 748  : #	if HAVE_FREEBIND
; 749  : 
; 750  : 	case INI_PARAM_FREEBIND:
; 751  : 		success = getIniFileArgumentBool(&freebind, iniarg);
; 752  : 		break;
; 753  : 
; 754  : #	endif // HAVE_FREEBIND
; 755  : 
; 756  : #	if !defined(NO_PRIVATE_IP_DETECT)
; 757  : 
; 758  : 	case INI_PARAM_PUBLIC_IP_PROTECTION_LEVEL:
; 759  : 		success = getIniFileArgumentInt(&PublicIPProtectionLevel, iniarg, 0, 3);

  00346	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0034c	48 8d 55 18	 lea	 rdx, QWORD PTR nextchar$1[rbp-32]
  00350	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00356	83 20 00	 and	 DWORD PTR [rax], 0
  00359	48 8b cf	 mov	 rcx, rdi
  0035c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strtoi64
  00362	48 8b f8	 mov	 rdi, rax
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0036b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0036e	75 1a		 jne	 SHORT $LN153@setIniFile
  00370	48 83 ff 03	 cmp	 rdi, 3
  00374	77 14		 ja	 SHORT $LN153@setIniFile
  00376	48 8b 4d 18	 mov	 rcx, QWORD PTR nextchar$1[rbp-32]
  0037a	80 39 00	 cmp	 BYTE PTR [rcx], 0
  0037d	75 0b		 jne	 SHORT $LN153@setIniFile
  0037f	89 3d 00 00 00
	00		 mov	 DWORD PTR PublicIPProtectionLevel, edi

; 760  : 
; 761  : #		if !HAVE_GETIFADDR
; 762  : 		if (PublicIPProtectionLevel & 1)
; 763  : 		{
; 764  : 			IniFileErrorMessage = "Must be 0 or 2";
; 765  : 			success = FALSE;
; 766  : 		}
; 767  : #		endif // !HAVE_GETIFADDR
; 768  : 
; 769  : 		break;

  00385	e9 28 02 00 00	 jmp	 $LN34@setIniFile

; 745  : 
; 746  : #	endif // NO_SOCKETS
; 747  : 
; 748  : #	if HAVE_FREEBIND
; 749  : 
; 750  : 	case INI_PARAM_FREEBIND:
; 751  : 		success = getIniFileArgumentBool(&freebind, iniarg);
; 752  : 		break;
; 753  : 
; 754  : #	endif // HAVE_FREEBIND
; 755  : 
; 756  : #	if !defined(NO_PRIVATE_IP_DETECT)
; 757  : 
; 758  : 	case INI_PARAM_PUBLIC_IP_PROTECTION_LEVEL:
; 759  : 		success = getIniFileArgumentInt(&PublicIPProtectionLevel, iniarg, 0, 3);

$LN153@setIniFile:
  0038a	ba 03 00 00 00	 mov	 edx, 3
  0038f	33 c9		 xor	 ecx, ecx
  00391	e9 fb fd ff ff	 jmp	 $LN160@setIniFile
$LN38@setIniFile:

; 532  : 	unsigned int result;
; 533  : 	BOOL success = TRUE;
; 534  : 	const char *s = (const char*)iniarg;
; 535  : 
; 536  : 	switch (id)

  00396	41 83 f8 19	 cmp	 r8d, 25
  0039a	0f 8f e9 00 00
	00		 jg	 $LN40@setIniFile
  003a0	0f 84 d7 00 00
	00		 je	 $LN17@setIniFile
  003a6	41 83 e8 13	 sub	 r8d, 19
  003aa	0f 84 c1 00 00
	00		 je	 $LN13@setIniFile
  003b0	41 ff c8	 dec	 r8d
  003b3	0f 84 9d 00 00
	00		 je	 $LN33@setIniFile
  003b9	41 ff c8	 dec	 r8d
  003bc	0f 84 85 00 00
	00		 je	 $LN32@setIniFile
  003c2	41 ff c8	 dec	 r8d
  003c5	74 6b		 je	 SHORT $LN31@setIniFile
  003c7	41 ff c8	 dec	 r8d
  003ca	74 51		 je	 SHORT $LN30@setIniFile
  003cc	41 ff c8	 dec	 r8d
  003cf	0f 85 df 00 00
	00		 jne	 $LN1@setIniFile

; 658  : 
; 659  : #	endif // NO_EXTERNAL_DATA
; 660  : 
; 661  : #	ifndef NO_STRICT_MODES
; 662  : 
; 663  : 	case INI_PARAM_WHITELISTING_LEVEL:
; 664  : 		success = getIniFileArgumentInt(&WhitelistingLevel, iniarg, 0, 3);

  003d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003db	48 8d 55 18	 lea	 rdx, QWORD PTR nextchar$4[rbp-32]
  003df	41 b8 0a 00 00
	00		 mov	 r8d, 10
  003e5	83 20 00	 and	 DWORD PTR [rax], 0
  003e8	48 8b cf	 mov	 rcx, rdi
  003eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strtoi64
  003f1	48 8b f8	 mov	 rdi, rax
  003f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003fa	83 38 00	 cmp	 DWORD PTR [rax], 0
  003fd	75 8b		 jne	 SHORT $LN153@setIniFile
  003ff	48 83 ff 03	 cmp	 rdi, 3
  00403	77 85		 ja	 SHORT $LN153@setIniFile
  00405	48 8b 4d 18	 mov	 rcx, QWORD PTR nextchar$4[rbp-32]
  00409	80 39 00	 cmp	 BYTE PTR [rcx], 0
  0040c	0f 85 78 ff ff
	ff		 jne	 $LN153@setIniFile
  00412	89 3d 00 00 00
	00		 mov	 DWORD PTR WhitelistingLevel, edi

; 665  : 		break;

  00418	e9 95 01 00 00	 jmp	 $LN34@setIniFile
$LN30@setIniFile:

; 552  : 
; 553  : 	case INI_PARAM_OFFICE2016:
; 554  : 		setEpidFromIniFileLine(&s, EPID_INDEX_OFFICE2016);

  0041d	48 8d 4d 18	 lea	 rcx, QWORD PTR s$[rbp-32]
  00421	ba 03 00 00 00	 mov	 edx, 3
  00426	e8 00 00 00 00	 call	 setEpidFromIniFileLine

; 555  : 		setHwIdFromIniFileLine(&s, EPID_INDEX_OFFICE2016);

  0042b	ba 03 00 00 00	 mov	 edx, 3

; 556  : 		break;

  00430	eb 31		 jmp	 SHORT $LN161@setIniFile
$LN31@setIniFile:

; 547  : 
; 548  : 	case INI_PARAM_OFFICE2013:
; 549  : 		setEpidFromIniFileLine(&s, EPID_INDEX_OFFICE2013);

  00432	48 8d 4d 18	 lea	 rcx, QWORD PTR s$[rbp-32]
  00436	ba 02 00 00 00	 mov	 edx, 2
  0043b	e8 00 00 00 00	 call	 setEpidFromIniFileLine

; 550  : 		setHwIdFromIniFileLine(&s, EPID_INDEX_OFFICE2013);

  00440	ba 02 00 00 00	 mov	 edx, 2

; 551  : 		break;

  00445	eb 1c		 jmp	 SHORT $LN161@setIniFile
$LN32@setIniFile:

; 542  : 
; 543  : 	case INI_PARAM_OFFICE2010:
; 544  : 		setEpidFromIniFileLine(&s, EPID_INDEX_OFFICE2010);

  00447	48 8d 4d 18	 lea	 rcx, QWORD PTR s$[rbp-32]
  0044b	8b d3		 mov	 edx, ebx
  0044d	e8 00 00 00 00	 call	 setEpidFromIniFileLine

; 545  : 		setHwIdFromIniFileLine(&s, EPID_INDEX_OFFICE2010);

  00452	8b d3		 mov	 edx, ebx

; 546  : 		break;

  00454	eb 0d		 jmp	 SHORT $LN161@setIniFile
$LN33@setIniFile:

; 537  : 	{
; 538  : 	case INI_PARAM_WINDOWS:
; 539  : 		setEpidFromIniFileLine(&s, EPID_INDEX_WINDOWS);

  00456	48 8d 4d 18	 lea	 rcx, QWORD PTR s$[rbp-32]
  0045a	33 d2		 xor	 edx, edx
  0045c	e8 00 00 00 00	 call	 setEpidFromIniFileLine

; 540  : 		setHwIdFromIniFileLine(&s, EPID_INDEX_WINDOWS);

  00461	33 d2		 xor	 edx, edx
$LN161@setIniFile:
  00463	48 8d 4d 18	 lea	 rcx, QWORD PTR s$[rbp-32]
  00467	e8 00 00 00 00	 call	 setHwIdFromIniFileLine

; 541  : 		break;

  0046c	e9 41 01 00 00	 jmp	 $LN34@setIniFile
$LN13@setIniFile:

; 689  : 
; 690  : 	case INI_PARAM_LOG_DATE_AND_TIME:
; 691  : 		success = getIniFileArgumentBool(&LogDateAndTime, iniarg);

  00471	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:LogDateAndTime

; 692  : 		break;

  00478	e9 20 01 00 00	 jmp	 $LN159@setIniFile
$LN17@setIniFile:

; 666  : 
; 667  : 	case INI_PARAM_CHECK_CLIENT_TIME:
; 668  : 		success = getIniFileArgumentBool(&CheckClientTime, iniarg);

  0047d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CheckClientTime

; 669  : 		break;

  00484	e9 14 01 00 00	 jmp	 $LN159@setIniFile
$LN40@setIniFile:

; 532  : 	unsigned int result;
; 533  : 	BOOL success = TRUE;
; 534  : 	const char *s = (const char*)iniarg;
; 535  : 
; 536  : 	switch (id)

  00489	41 83 e8 1a	 sub	 r8d, 26
  0048d	0f 84 03 01 00
	00		 je	 $LN16@setIniFile
  00493	41 ff c8	 dec	 r8d
  00496	0f 84 f1 00 00
	00		 je	 $LN15@setIniFile
  0049c	41 ff c8	 dec	 r8d
  0049f	0f 84 b3 00 00
	00		 je	 $LN19@setIniFile
  004a5	41 ff c8	 dec	 r8d
  004a8	74 7f		 je	 SHORT $LN28@setIniFile
  004aa	41 ff c8	 dec	 r8d
  004ad	74 20		 je	 SHORT $LN4@setIniFile
  004af	41 ff c8	 dec	 r8d
  004b2	74 07		 je	 SHORT $LN29@setIniFile
$LN1@setIniFile:

; 770  : 
; 771  : #	endif // !defined(NO_PRIVATE_IP_DETECT)
; 772  : 
; 773  : 	default:
; 774  : 		return FALSE;

  004b4	33 c0		 xor	 eax, eax
  004b6	e9 f9 00 00 00	 jmp	 $LN36@setIniFile
$LN29@setIniFile:

; 557  : 
; 558  : 	case INI_PARAM_WINCHINAGOV:
; 559  : 		setEpidFromIniFileLine(&s, EPID_INDEX_WINCHINAGOV);

  004bb	bf 04 00 00 00	 mov	 edi, 4
  004c0	48 8d 4d 18	 lea	 rcx, QWORD PTR s$[rbp-32]
  004c4	8b d7		 mov	 edx, edi
  004c6	e8 00 00 00 00	 call	 setEpidFromIniFileLine

; 560  : 		setHwIdFromIniFileLine(&s, EPID_INDEX_WINCHINAGOV);

  004cb	8b d7		 mov	 edx, edi

; 561  : 		break;

  004cd	eb 94		 jmp	 SHORT $LN161@setIniFile
$LN4@setIniFile:

; 736  : 
; 737  : #	endif // USE_MSRPC
; 738  : 
; 739  : #	ifndef NO_SOCKETS
; 740  : 
; 741  : 	case INI_PARAM_EXIT_LEVEL:
; 742  : 		success = getIniFileArgumentInt(&result, iniarg, 0, 1);

  004cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004d5	48 8d 55 18	 lea	 rdx, QWORD PTR nextchar$2[rbp-32]
  004d9	41 b8 0a 00 00
	00		 mov	 r8d, 10
  004df	83 20 00	 and	 DWORD PTR [rax], 0
  004e2	48 8b cf	 mov	 rcx, rdi
  004e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strtoi64
  004eb	48 8b f8	 mov	 rdi, rax
  004ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004f4	83 38 00	 cmp	 DWORD PTR [rax], 0
  004f7	75 0e		 jne	 SHORT $LN144@setIniFile
  004f9	48 3b fb	 cmp	 rdi, rbx
  004fc	77 09		 ja	 SHORT $LN144@setIniFile
  004fe	48 8b 4d 18	 mov	 rcx, QWORD PTR nextchar$2[rbp-32]
  00502	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00505	74 0e		 je	 SHORT $LN140@setIniFile
$LN144@setIniFile:
  00507	8b d3		 mov	 edx, ebx
  00509	33 c9		 xor	 ecx, ecx
  0050b	e8 00 00 00 00	 call	 getIniFileArgumentInt
  00510	8b 7d 10	 mov	 edi, DWORD PTR result$[rbp-32]
  00513	8b d8		 mov	 ebx, eax
$LN140@setIniFile:

; 743  : 		if (success) ExitLevel = (int_fast8_t)result;

  00515	85 db		 test	 ebx, ebx
  00517	0f 84 95 00 00
	00		 je	 $LN34@setIniFile
  0051d	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ExitLevel, dil

; 744  : 		break;

  00524	e9 89 00 00 00	 jmp	 $LN34@setIniFile
$LN28@setIniFile:

; 562  : 
; 563  : #	ifndef NO_TAP
; 564  : 
; 565  : 	case INI_PARAM_VPN:
; 566  : 		tapArgument = (char*)vlmcsd_strdup(iniarg);

  00529	48 8b ca	 mov	 rcx, rdx
  0052c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  00532	48 85 c0	 test	 rax, rax
  00535	75 18		 jne	 SHORT $LN41@setIniFile
  00537	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  0053e	e8 00 00 00 00	 call	 errorout
  00543	b9 0e 00 00 00	 mov	 ecx, 14
  00548	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0054e	cc		 int	 3
$LN41@setIniFile:
  0054f	48 89 05 00 00
	00 00		 mov	 QWORD PTR tapArgument, rax

; 567  : 		break;

  00556	eb 5a		 jmp	 SHORT $LN34@setIniFile
$LN19@setIniFile:

; 647  : 
; 648  : #	endif // NO_PID_FILE
; 649  : 
; 650  : #	ifndef NO_EXTERNAL_DATA
; 651  : 
; 652  : 	case INI_PARAM_DATA_FILE:
; 653  : 		fn_data = vlmcsd_strdup(iniarg);

  00558	48 8b ca	 mov	 rcx, rdx
  0055b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  00561	48 85 c0	 test	 rax, rax
  00564	75 18		 jne	 SHORT $LN87@setIniFile
  00566	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  0056d	e8 00 00 00 00	 call	 errorout
  00572	b9 0e 00 00 00	 mov	 ecx, 14
  00577	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0057d	cc		 int	 3
$LN87@setIniFile:
  0057e	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_data, rax

; 654  : #		ifndef NO_INTERNAL_DATA
; 655  : 		ExplicitDataLoad = TRUE;

  00585	88 1d 00 00 00
	00		 mov	 BYTE PTR ExplicitDataLoad, bl

; 656  : #		endif // NO_INTERNAL_DATA
; 657  : 		break;

  0058b	eb 25		 jmp	 SHORT $LN34@setIniFile
$LN15@setIniFile:

; 674  : 		break;
; 675  : 
; 676  : 	case INI_PARAM_START_EMPTY:
; 677  : 		success = getIniFileArgumentBool(&StartEmpty, iniarg);

  0058d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StartEmpty

; 678  : 		break;

  00594	eb 07		 jmp	 SHORT $LN159@setIniFile
$LN16@setIniFile:

; 670  : 
; 671  : #	ifndef NO_CLIENT_LIST
; 672  : 	case INI_PARAM_MAINTAIN_CLIENTS:
; 673  : 		success = getIniFileArgumentBool(&MaintainClients, iniarg);

  00596	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MaintainClients
$LN159@setIniFile:
  0059d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0DB@GHHCGCFM@Argument?5must?5be?5true?1on?1yes?11?5o@
  005a4	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax
  005ab	e8 00 00 00 00	 call	 getArgumentBool
$LN158@setIniFile:
  005b0	8b d8		 mov	 ebx, eax
$LN34@setIniFile:

; 775  : 	}
; 776  : 
; 777  : 	return success;

  005b2	8b c3		 mov	 eax, ebx
$LN36@setIniFile:

; 778  : }

  005b4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  005b9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  005be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  005c2	5d		 pop	 rbp
  005c3	c3		 ret	 0
$LN163@setIniFile:
setIniFileParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT getIniFileArgument
_TEXT	SEGMENT
s$ = 48
getIniFileArgument PROC					; COMDAT

; 782  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 783  : 	while (!isspace((int)**s) && **s != '=' && **s) (*s)++;

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	eb 14		 jmp	 SHORT $LN13@getIniFile
$LL4@getIniFile:
  0000e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00011	8a 01		 mov	 al, BYTE PTR [rcx]
  00013	3c 3d		 cmp	 al, 61			; 0000003dH
  00015	74 18		 je	 SHORT $LN3@getIniFile
  00017	84 c0		 test	 al, al
  00019	74 14		 je	 SHORT $LN3@getIniFile
  0001b	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  0001f	48 89 03	 mov	 QWORD PTR [rbx], rax
$LN13@getIniFile:
  00022	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  0002b	85 c0		 test	 eax, eax
  0002d	74 df		 je	 SHORT $LL4@getIniFile
$LN3@getIniFile:

; 784  : 	iniFileLineNextWord(s);

  0002f	48 8b cb	 mov	 rcx, rbx
  00032	e8 00 00 00 00	 call	 iniFileLineNextWord

; 785  : 
; 786  : 	if (*((*s)++) != '=')

  00037	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003a	8a 08		 mov	 cl, BYTE PTR [rax]
  0003c	48 ff c0	 inc	 rax
  0003f	48 89 03	 mov	 QWORD PTR [rbx], rax
  00042	80 f9 3d	 cmp	 cl, 61			; 0000003dH
  00045	74 12		 je	 SHORT $LN2@getIniFile

; 787  : 	{
; 788  : 		IniFileErrorMessage = "'=' required after keyword.";

  00047	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@OKFKNBIN@?8?$DN?8?5required?5after?5keyword?4?$AA@
$LN14@getIniFile:
  0004e	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax

; 789  : 		return FALSE;

  00055	33 c0		 xor	 eax, eax
  00057	eb 1e		 jmp	 SHORT $LN5@getIniFile
$LN2@getIniFile:

; 790  : 	}
; 791  : 
; 792  : 	iniFileLineNextWord(s);

  00059	48 8b cb	 mov	 rcx, rbx
  0005c	e8 00 00 00 00	 call	 iniFileLineNextWord

; 793  : 
; 794  : 	if (!**s)

  00061	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00064	80 38 00	 cmp	 BYTE PTR [rax], 0
  00067	75 09		 jne	 SHORT $LN1@getIniFile

; 795  : 	{
; 796  : 		IniFileErrorMessage = "missing argument after '='.";

  00069	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@MPPMKLEJ@missing?5argument?5after?5?8?$DN?8?4?$AA@

; 797  : 		return FALSE;

  00070	eb dc		 jmp	 SHORT $LN14@getIniFile
$LN1@getIniFile:

; 798  : 	}
; 799  : 
; 800  : 	return TRUE;

  00072	b8 01 00 00 00	 mov	 eax, 1
$LN5@getIniFile:

; 801  : }

  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5b		 pop	 rbx
  0007c	c3		 ret	 0
getIniFileArgument ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT handleIniFileParameter
_TEXT	SEGMENT
s$ = 48
handleIniFileParameter PROC				; COMDAT

; 805  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b f9	 mov	 rdi, rcx

; 806  : 	uint_fast8_t i;
; 807  : 
; 808  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  00017	32 db		 xor	 bl, bl
  00019	48 8d 35 00 00
	00 00		 lea	 rsi, OFFSET FLAT:IniFileParameterList
$LL6@handleIniF:

; 809  : 	{
; 810  : 		if (strncasecmp(IniFileParameterList[i].Name, s, strlen(IniFileParameterList[i].Name))) continue;

  00020	0f b6 c3	 movzx	 eax, bl
  00023	48 03 c0	 add	 rax, rax
  00026	49 83 c8 ff	 or	 r8, -1
  0002a	48 8b 0c c6	 mov	 rcx, QWORD PTR [rsi+rax*8]
$LL13@handleIniF:
  0002e	49 ff c0	 inc	 r8
  00031	42 80 3c 01 00	 cmp	 BYTE PTR [rcx+r8], 0
  00036	75 f6		 jne	 SHORT $LL13@handleIniF
  00038	48 8b d7	 mov	 rdx, rdi
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00041	85 c0		 test	 eax, eax
  00043	74 17		 je	 SHORT $LN3@handleIniF

; 806  : 	uint_fast8_t i;
; 807  : 
; 808  : 	for (i = 0; i < vlmcsd_countof(IniFileParameterList); i++)

  00045	fe c3		 inc	 bl
  00047	80 fb 1c	 cmp	 bl, 28
  0004a	72 d4		 jb	 SHORT $LL6@handleIniF

; 816  : 	}
; 817  : 
; 818  : 	IniFileErrorMessage = "Unknown keyword.";

  0004c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@MJCPHOFN@Unknown?5keyword?4?$AA@
  00053	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax

; 819  : 	return FALSE;

  0005a	eb 22		 jmp	 SHORT $LN14@handleIniF
$LN3@handleIniF:

; 811  : 		if (!IniFileParameterList[i].Id) return TRUE;

  0005c	0f b6 db	 movzx	 ebx, bl
  0005f	48 03 db	 add	 rbx, rbx
  00062	80 7c de 08 00	 cmp	 BYTE PTR [rsi+rbx*8+8], 0
  00067	75 07		 jne	 SHORT $LN2@handleIniF
  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	eb 20		 jmp	 SHORT $LN7@handleIniF
$LN2@handleIniF:

; 812  : 
; 813  : 		if (!getIniFileArgument(&s)) return FALSE;

  00070	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  00075	e8 00 00 00 00	 call	 getIniFileArgument
  0007a	85 c0		 test	 eax, eax
  0007c	75 04		 jne	 SHORT $LN1@handleIniF
$LN14@handleIniF:
  0007e	33 c0		 xor	 eax, eax
  00080	eb 0e		 jmp	 SHORT $LN7@handleIniF
$LN1@handleIniF:

; 814  : 
; 815  : 		return setIniFileParameter(IniFileParameterList[i].Id, s);

  00082	48 8b 54 24 30	 mov	 rdx, QWORD PTR s$[rsp]
  00087	8a 4c de 08	 mov	 cl, BYTE PTR [rsi+rbx*8+8]
  0008b	e8 00 00 00 00	 call	 setIniFileParameter
$LN7@handleIniF:

; 820  : }

  00090	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00095	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
handleIniFileParameter ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT setupListeningSocketsFromIniFile
_TEXT	SEGMENT
s$ = 48
setupListeningSocketsFromIniFile PROC			; COMDAT

; 825  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 826  : 	if (!maxsockets) return TRUE;

  00009	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR maxsockets, 0
  00010	75 0a		 jne	 SHORT $LN3@setupListe
$LN6@setupListe:
  00012	b8 01 00 00 00	 mov	 eax, 1

; 833  : }

  00017	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001b	c3		 ret	 0
$LN3@setupListe:

; 827  : 	if (strncasecmp("Listen", s, 6)) return TRUE;

  0001c	48 8b d1	 mov	 rdx, rcx
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06CBIOIDCI@Listen?$AA@
  00026	41 b8 06 00 00
	00		 mov	 r8d, 6
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00032	85 c0		 test	 eax, eax
  00034	75 dc		 jne	 SHORT $LN6@setupListe

; 828  : 	if (!getIniFileArgument(&s)) return TRUE;

  00036	48 8d 4c 24 30	 lea	 rcx, QWORD PTR s$[rsp]
  0003b	e8 00 00 00 00	 call	 getIniFileArgument
  00040	85 c0		 test	 eax, eax
  00042	74 ce		 je	 SHORT $LN6@setupListe

; 829  : 
; 830  : 	vlmcsd_snprintf(IniFileErrorBuffer, INIFILE_ERROR_BUFFERSIZE, "Cannot listen on %s.", s);

  00044	4c 8b 4c 24 30	 mov	 r9, QWORD PTR s$[rsp]
  00049	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR IniFileErrorBuffer
  00050	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4?$AA@
  00057	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__snprintf

; 831  : 	IniFileErrorMessage = IniFileErrorBuffer;

  00062	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IniFileErrorBuffer

; 832  : 	return addListeningSocket(s);

  00069	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0006e	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax

; 833  : }

  00075	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 832  : 	return addListeningSocket(s);

  00079	e9 00 00 00 00	 jmp	 addListeningSocket
setupListeningSocketsFromIniFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT readIniFile
_TEXT	SEGMENT
line$ = 48
pass$ = 352
s$ = 360
s$ = 360
s$ = 360
readIniFile PROC					; COMDAT

; 838  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000b	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0000f	55		 push	 rbp
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 8d 68 a8	 lea	 rbp, QWORD PTR [rax-88]
  0001c	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  00023	44 8a f9	 mov	 r15b, cl

; 839  : 	char  line[256];
; 840  : 	const char *s;
; 841  : 	unsigned int lineNumber;
; 842  : 	uint_fast8_t lineParseError;
; 843  : 
; 844  : 	FILE *restrict f;
; 845  : 	BOOL result = TRUE;
; 846  : 
; 847  : 	IniFileErrorBuffer = (char*)vlmcsd_malloc(INIFILE_ERROR_BUFFERSIZE);

  00026	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0002b	e8 00 00 00 00	 call	 vlmcsd_malloc

; 848  : 
; 849  : 	if (!((f = fopen(fn_ini, "r")))) return FALSE;

  00030	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fn_ini
  00037	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KDCPPGHE@r?$AA@
  0003e	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorBuffer, rax
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  0004b	45 33 ed	 xor	 r13d, r13d
  0004e	48 8b f0	 mov	 rsi, rax
  00051	48 85 c0	 test	 rax, rax
  00054	75 07		 jne	 SHORT $LN15@readIniFil
$LN6@readIniFil:
  00056	33 c0		 xor	 eax, eax
  00058	e9 2d 02 00 00	 jmp	 $LN16@readIniFil
$LN15@readIniFil:

; 850  : 
; 851  : 	for (lineNumber = 1; (s = fgets(line, sizeof(line), f)); lineNumber++)

  0005d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR line$[rsp]
  00062	4c 8b c0	 mov	 r8, rax
  00065	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0006a	41 bc 01 00 00
	00		 mov	 r12d, 1
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  00076	48 89 45 68	 mov	 QWORD PTR s$[rbp-256], rax
  0007a	48 85 c0	 test	 rax, rax
  0007d	0f 84 ac 01 00
	00		 je	 $LN12@readIniFil
  00083	4c 8d 74 24 30	 lea	 r14, QWORD PTR line$[rsp]
$LL14@readIniFil:

; 852  : 	{
; 853  : 		line[strlen(line) - 1] = 0;

  00088	48 8d 4c 24 30	 lea	 rcx, QWORD PTR line$[rsp]
  0008d	48 83 c8 ff	 or	 rax, -1
$LL44@readIniFil:
  00091	48 ff c0	 inc	 rax
  00094	44 38 2c 01	 cmp	 BYTE PTR [rcx+rax], r13b
  00098	75 f7		 jne	 SHORT $LL44@readIniFil

; 854  : 
; 855  : 		iniFileLineNextWord(&s);

  0009a	48 8d 4d 68	 lea	 rcx, QWORD PTR s$[rbp-256]
  0009e	46 88 6c 30 ff	 mov	 BYTE PTR [rax+r14-1], r13b
  000a3	e8 00 00 00 00	 call	 iniFileLineNextWord

; 856  : 		if (*s == ';' || *s == '#' || !*s) continue;

  000a8	48 8b 7d 68	 mov	 rdi, QWORD PTR s$[rbp-256]
  000ac	80 3f 3b	 cmp	 BYTE PTR [rdi], 59	; 0000003bH
  000af	77 18		 ja	 SHORT $LN41@readIniFil
  000b1	48 0f be 07	 movsx	 rax, BYTE PTR [rdi]
  000b5	48 b9 01 00 00
	00 08 00 00 08	 mov	 rcx, 576460786663161857	; 0800000800000001H
  000bf	48 0f a3 c1	 bt	 rcx, rax
  000c3	0f 82 43 01 00
	00		 jb	 $LN13@readIniFil
$LN41@readIniFil:

; 857  : 
; 858  : #		ifndef NO_SOCKETS
; 859  : 		if (pass == INI_FILE_PASS_1)

  000c9	41 80 ff 01	 cmp	 r15b, 1
  000cd	0f 85 90 00 00
	00		 jne	 $LN9@readIniFil

; 860  : #		endif // NO_SOCKETS
; 861  : 		{
; 862  : 			if (handleIniFileParameter(s)) continue;

  000d3	48 89 7d 68	 mov	 QWORD PTR s$[rbp-256], rdi
  000d7	41 8a dd	 mov	 bl, r13b
$LL23@readIniFil:
  000da	0f b6 c3	 movzx	 eax, bl
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:IniFileParameterList
  000e4	48 03 c0	 add	 rax, rax
  000e7	49 83 c8 ff	 or	 r8, -1
  000eb	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
$LL43@readIniFil:
  000ef	49 ff c0	 inc	 r8
  000f2	46 38 2c 01	 cmp	 BYTE PTR [rcx+r8], r13b
  000f6	75 f7		 jne	 SHORT $LL43@readIniFil
  000f8	48 8b d7	 mov	 rdx, rdi
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00101	85 c0		 test	 eax, eax
  00103	74 1a		 je	 SHORT $LN20@readIniFil
  00105	fe c3		 inc	 bl
  00107	80 fb 1c	 cmp	 bl, 28
  0010a	72 ce		 jb	 SHORT $LL23@readIniFil
  0010c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BB@MJCPHOFN@Unknown?5keyword?4?$AA@
  00113	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax
  0011a	41 8b c5	 mov	 eax, r13d
  0011d	eb 37		 jmp	 SHORT $LN24@readIniFil
$LN20@readIniFil:
  0011f	0f b6 db	 movzx	 ebx, bl
  00122	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:IniFileParameterList
  00129	48 c1 e3 04	 shl	 rbx, 4
  0012d	44 38 6c 3b 08	 cmp	 BYTE PTR [rbx+rdi+8], r13b
  00132	0f 84 d4 00 00
	00		 je	 $LN13@readIniFil
  00138	48 8d 4d 68	 lea	 rcx, QWORD PTR s$[rbp-256]
  0013c	e8 00 00 00 00	 call	 getIniFileArgument
  00141	85 c0		 test	 eax, eax
  00143	0f 84 9c 00 00
	00		 je	 $LN45@readIniFil
  00149	48 8b 55 68	 mov	 rdx, QWORD PTR s$[rbp-256]
  0014d	8a 4c 3b 08	 mov	 cl, BYTE PTR [rbx+rdi+8]
  00151	e8 00 00 00 00	 call	 setIniFileParameter
$LN24@readIniFil:
  00156	85 c0		 test	 eax, eax
  00158	0f 85 ae 00 00
	00		 jne	 $LN13@readIniFil

; 863  : 
; 864  : 			lineParseError = TRUE;/*!checkGuidInIniFileLine(&s, &appIndex) ||

  0015e	e9 82 00 00 00	 jmp	 $LN45@readIniFil
$LN9@readIniFil:

; 865  : 					!setEpidFromIniFileLine(&s, appIndex) ||
; 866  : 					!setHwIdFromIniFileLine(&s, appIndex);*/
; 867  : 		}
; 868  : #		if !defined(NO_SOCKETS) && !defined(SIMPLE_SOCKETS) && !defined(USE_MSRPC)
; 869  : 		else if (pass == INI_FILE_PASS_2)

  00163	41 80 ff 02	 cmp	 r15b, 2
  00167	0f 85 e9 fe ff
	ff		 jne	 $LN6@readIniFil

; 870  : 		{
; 871  : 			lineParseError = !setupListeningSocketsFromIniFile(s);

  0016d	44 38 2d 00 00
	00 00		 cmp	 BYTE PTR maxsockets, r13b
  00174	48 89 7d 68	 mov	 QWORD PTR s$[rbp-256], rdi
  00178	75 07		 jne	 SHORT $LN28@readIniFil
$LN46@readIniFil:
  0017a	b8 01 00 00 00	 mov	 eax, 1
  0017f	eb 5b		 jmp	 SHORT $LN29@readIniFil
$LN28@readIniFil:
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_06CBIOIDCI@Listen?$AA@
  00188	41 b8 06 00 00
	00		 mov	 r8d, 6
  0018e	48 8b d7	 mov	 rdx, rdi
  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00197	85 c0		 test	 eax, eax
  00199	75 df		 jne	 SHORT $LN46@readIniFil
  0019b	48 8d 4d 68	 lea	 rcx, QWORD PTR s$[rbp-256]
  0019f	e8 00 00 00 00	 call	 getIniFileArgument
  001a4	85 c0		 test	 eax, eax
  001a6	74 d2		 je	 SHORT $LN46@readIniFil
  001a8	4c 8b 4d 68	 mov	 r9, QWORD PTR s$[rbp-256]
  001ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR IniFileErrorBuffer
  001b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BF@GAGAHLAN@Cannot?5listen?5on?5?$CFs?4?$AA@
  001ba	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  001bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__snprintf
  001c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IniFileErrorBuffer
  001cc	48 8b 4d 68	 mov	 rcx, QWORD PTR s$[rbp-256]
  001d0	48 89 05 00 00
	00 00		 mov	 QWORD PTR IniFileErrorMessage, rax
  001d7	e8 00 00 00 00	 call	 addListeningSocket
$LN29@readIniFil:
  001dc	85 c0		 test	 eax, eax
  001de	0f 94 c0	 sete	 al

; 872  : 		}
; 873  : 		else
; 874  : 		{
; 875  : 			return FALSE;
; 876  : 		}
; 877  : #		endif // !defined(NO_SOCKETS) &&  && !defined(SIMPLE_SOCKETS) && !defined(USE_MSRPC)
; 878  : 
; 879  : 		if (lineParseError)

  001e1	84 c0		 test	 al, al
  001e3	74 27		 je	 SHORT $LN13@readIniFil
$LN45@readIniFil:

; 880  : 		{
; 881  : 			printerrorf("Warning: %s line %u: \"%s\". %s\n", fn_ini, lineNumber, line, IniFileErrorMessage);

  001e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR IniFileErrorMessage
  001ec	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_ini
  001f3	4c 8d 4c 24 30	 lea	 r9, QWORD PTR line$[rsp]
  001f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@LIEMBDLF@Warning?3?5?$CFs?5line?5?$CFu?3?5?$CC?$CFs?$CC?4?5?$CFs?6?$AA@
  001ff	45 8b c4	 mov	 r8d, r12d
  00202	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00207	e8 00 00 00 00	 call	 printerrorf
$LN13@readIniFil:

; 850  : 
; 851  : 	for (lineNumber = 1; (s = fgets(line, sizeof(line), f)); lineNumber++)

  0020c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR line$[rsp]
  00211	4c 8b c6	 mov	 r8, rsi
  00214	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00219	41 ff c4	 inc	 r12d
  0021c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  00222	48 89 45 68	 mov	 QWORD PTR s$[rbp-256], rax
  00226	48 85 c0	 test	 rax, rax
  00229	0f 85 59 fe ff
	ff		 jne	 $LL14@readIniFil
$LN12@readIniFil:

; 882  : 			continue;
; 883  : 		}
; 884  : 	}
; 885  : 
; 886  : 	if (ferror(f)) result = FALSE;

  0022f	48 8b ce	 mov	 rcx, rsi
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror

; 887  : 
; 888  : 	free(IniFileErrorBuffer);

  00238	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR IniFileErrorBuffer
  0023f	bb 01 00 00 00	 mov	 ebx, 1
  00244	85 c0		 test	 eax, eax
  00246	41 0f 45 dd	 cmovne	 ebx, r13d
  0024a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 889  : 	fclose(f);

  00250	48 8b ce	 mov	 rcx, rsi
  00253	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 890  : 
; 891  : #	if !defined(NO_SOCKETS) && !defined(NO_LOG)
; 892  : 
; 893  : 	if (pass == INI_FILE_PASS_1 && !InetdMode && result)

  00259	41 80 ff 01	 cmp	 r15b, 1
  0025d	75 29		 jne	 SHORT $LN1@readIniFil
  0025f	44 38 2d 00 00
	00 00		 cmp	 BYTE PTR InetdMode, r13b
  00266	75 20		 jne	 SHORT $LN1@readIniFil
  00268	85 db		 test	 ebx, ebx
  0026a	74 1c		 je	 SHORT $LN1@readIniFil

; 894  : 	{
; 895  : #		ifdef _NTSERVICE
; 896  : 		if (!installService)

  0026c	44 38 2d 00 00
	00 00		 cmp	 BYTE PTR installService, r13b
  00273	75 13		 jne	 SHORT $LN1@readIniFil

; 897  : #		endif // _NTSERVICE
; 898  : 			logger("Read ini file %s\n", fn_ini);

  00275	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_ini
  0027c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@DOBMPJAF@Read?5ini?5file?5?$CFs?6?$AA@
  00283	e8 00 00 00 00	 call	 logger
$LN1@readIniFil:

; 899  : 	}
; 900  : 
; 901  : #	endif // !defined(NO_SOCKETS) && !defined(NO_LOG)
; 902  : 
; 903  : 	return result;

  00288	8b c3		 mov	 eax, ebx
$LN16@readIniFil:

; 904  : }

  0028a	4c 8d 9c 24 30
	01 00 00	 lea	 r11, QWORD PTR [rsp+304]
  00292	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00296	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  0029a	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  0029e	49 8b e3	 mov	 rsp, r11
  002a1	41 5f		 pop	 r15
  002a3	41 5e		 pop	 r14
  002a5	41 5d		 pop	 r13
  002a7	41 5c		 pop	 r12
  002a9	5d		 pop	 rbp
  002aa	c3		 ret	 0
readIniFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT terminationHandler
_TEXT	SEGMENT
fdwCtrlType$ = 48
terminationHandler PROC					; COMDAT

; 1024 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1025 : 	// What a lame substitute for Unix signal handling
; 1026 : 	switch (fdwCtrlType)

  00004	83 f9 02	 cmp	 ecx, 2
  00007	76 0f		 jbe	 SHORT $LN2@terminatio
  00009	8d 41 fb	 lea	 eax, DWORD PTR [rcx-5]
  0000c	83 f8 01	 cmp	 eax, 1
  0000f	76 07		 jbe	 SHORT $LN2@terminatio

; 1035 : 	default:
; 1036 : 		return FALSE;

  00011	33 c0		 xor	 eax, eax

; 1037 : 	}
; 1038 : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
$LN2@terminatio:

; 1027 : 	{
; 1028 : 	case CTRL_C_EVENT:
; 1029 : 	case CTRL_CLOSE_EVENT:
; 1030 : 	case CTRL_BREAK_EVENT:
; 1031 : 	case CTRL_LOGOFF_EVENT:
; 1032 : 	case CTRL_SHUTDOWN_EVENT:
; 1033 : 		cleanup();

  00018	e8 00 00 00 00	 call	 cleanup

; 1034 : 		exit(0);

  0001d	33 c9		 xor	 ecx, ecx
  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00025	cc		 int	 3
$LN8@terminatio:
terminationHandler ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT daemonizeAndSetSignalAction
_TEXT	SEGMENT
daemonizeAndSetSignalAction PROC			; COMDAT

; 1042 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1043 : 	if (!SetConsoleCtrlHandler((PHANDLER_ROUTINE)terminationHandler, TRUE))

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:terminationHandler
  0000b	ba 01 00 00 00	 mov	 edx, 1
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCtrlHandler
  00016	85 c0		 test	 eax, eax
  00018	75 14		 jne	 SHORT $LN1@daemonizeA

; 1044 : 	{
; 1045 : #ifndef NO_LOG
; 1046 : 		DWORD rc = GetLastError();

  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 1047 : 		logger("Warning: Could not register Windows signal handler: Error %u\n", rc);

  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DO@FOGLIAKA@Warning?3?5Could?5not?5register?5Wind@
  00027	8b d0		 mov	 edx, eax
  00029	e8 00 00 00 00	 call	 logger
$LN1@daemonizeA:

; 1048 : #endif // NO_LOG
; 1049 : 	}
; 1050 : 
; 1051 : 	return ERROR_SUCCESS;

  0002e	33 c0		 xor	 eax, eax

; 1052 : }

  00030	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00034	c3		 ret	 0
daemonizeAndSetSignalAction ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT getCommandLineArg
_TEXT	SEGMENT
arg$dead$ = 8
getCommandLineArg PROC					; COMDAT

; 1062 : #	if !__CYGWIN__ || defined(USE_THREADS) || defined(NO_SOCKETS)
; 1063 : 	return arg;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg

; 1064 : #	else
; 1065 : 	if (!IsNTService) return arg;
; 1066 : 
; 1067 : 	return vlmcsd_strdup(arg);
; 1068 : #	endif
; 1069 : }

  00007	c3		 ret	 0
getCommandLineArg ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT parseGeneralArguments
_TEXT	SEGMENT
parseGeneralArguments PROC				; COMDAT

; 1075 : static void parseGeneralArguments() {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	41 57		 push	 r15
  00007	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1076 : 	int o;
; 1077 : 
; 1078 : #ifndef NO_CL_PIDS
; 1079 : 	BYTE* HwId;
; 1080 : #endif // NO_CL_PIDS
; 1081 : 
; 1082 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  0000b	83 25 00 00 00
	00 00		 and	 DWORD PTR opterr, 0
  00012	e8 00 00 00 00	 call	 getopt
  00017	8b c8		 mov	 ecx, eax
  00019	85 c0		 test	 eax, eax
  0001b	0f 8e 96 05 00
	00		 jle	 $LN104@parseGener
  00021	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:??_C@_0N@BACOLJMI@command?5line?$AA@
$LL56@parseGener:
  00028	83 f9 55	 cmp	 ecx, 85			; 00000055H
  0002b	0f 8f a6 02 00
	00		 jg	 $LN59@parseGener
  00031	0f 84 8d 02 00
	00		 je	 $LN31@parseGener
  00037	83 f9 48	 cmp	 ecx, 72			; 00000048H
  0003a	0f 8f 71 01 00
	00		 jg	 $LN60@parseGener
  00040	0f 84 22 01 00
	00		 je	 $LN46@parseGener
  00046	83 e9 30	 sub	 ecx, 48			; 00000030H
  00049	0f 84 fe 00 00
	00		 je	 $LN50@parseGener
  0004f	83 e9 03	 sub	 ecx, 3
  00052	0f 84 da 00 00
	00		 je	 $LN49@parseGener
  00058	83 e9 03	 sub	 ecx, 3
  0005b	0f 84 b6 00 00
	00		 je	 $LN48@parseGener
  00061	83 e9 0b	 sub	 ecx, 11
  00064	0f 84 99 00 00
	00		 je	 $LN12@parseGener
  0006a	ff c9		 dec	 ecx
  0006c	74 73		 je	 SHORT $LN8@parseGener
  0006e	ff c9		 dec	 ecx
  00070	74 52		 je	 SHORT $LN14@parseGener
  00072	ff c9		 dec	 ecx
  00074	0f 84 2e 05 00
	00		 je	 $LN53@parseGener
  0007a	ff c9		 dec	 ecx
  0007c	74 24		 je	 SHORT $LN21@parseGener
  0007e	83 f9 02	 cmp	 ecx, 2
  00081	0f 85 93 05 00
	00		 jne	 $LN108@parseGener

; 1129 : 
; 1130 : 	case 'G':
; 1131 : 		KmsResponseParameters[EPID_INDEX_WINCHINAGOV].Epid = getCommandLineArg(optarg);

  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
  0008e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  00095	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 1132 : #		ifndef NO_LOG
; 1133 : 		KmsResponseParameters[EPID_INDEX_WINCHINAGOV].EpidSource = "command line";

  00099	4c 89 79 70	 mov	 QWORD PTR [rcx+112], r15

; 1134 : #		endif // NO_LOG
; 1135 : 		break;

  0009d	e9 06 05 00 00	 jmp	 $LN53@parseGener
$LN21@parseGener:

; 1293 : 
; 1294 : #	ifndef NO_CLIENT_LIST
; 1295 : 	case 'E':
; 1296 : 		if (!getArgumentBool(&StartEmpty, optarg)) usage();

  000a2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:StartEmpty
  000b0	e8 00 00 00 00	 call	 getArgumentBool
  000b5	85 c0		 test	 eax, eax
  000b7	0f 84 39 05 00
	00		 je	 $LN89@parseGener

; 1297 : 		ignoreIniFileParameter(INI_PARAM_START_EMPTY);

  000bd	b1 1b		 mov	 cl, 27

; 1298 : 		break;

  000bf	e9 79 01 00 00	 jmp	 $LN110@parseGener
$LN14@parseGener:

; 1332 : 
; 1333 : 	case 'C':
; 1334 : 		Lcid = (uint16_t)getOptionArgumentInt((char)o, 0, 32767);

  000c4	33 d2		 xor	 edx, edx
  000c6	41 b8 ff 7f 00
	00		 mov	 r8d, 32767		; 00007fffH
  000cc	b1 43		 mov	 cl, 67			; 00000043H
  000ce	e8 00 00 00 00	 call	 getOptionArgumentInt

; 1335 : 
; 1336 : 		ignoreIniFileParameter(INI_PARAM_LCID);

  000d3	b1 02		 mov	 cl, 2
  000d5	66 89 05 00 00
	00 00		 mov	 WORD PTR Lcid, ax

; 1337 : 
; 1338 : #		ifdef _PEDANTIC
; 1339 : 		if (!IsValidLcid(Lcid))
; 1340 : 		{
; 1341 : 			printerrorf("Warning: %s is not a valid LCID.\n", optarg);
; 1342 : 		}
; 1343 : #		endif // _PEDANTIC
; 1344 : 
; 1345 : 		break;

  000dc	e9 5c 01 00 00	 jmp	 $LN110@parseGener
$LN8@parseGener:

; 1400 : 
; 1401 : 	case 'B':
; 1402 : 		if (!getArgumentBool(&UseServerRpcBTFN, optarg)) usage();

  000e1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UseServerRpcBTFN
  000ef	e8 00 00 00 00	 call	 getArgumentBool
  000f4	85 c0		 test	 eax, eax
  000f6	0f 84 00 05 00
	00		 je	 $LN90@parseGener

; 1403 : 		ignoreIniFileParameter(INI_PARAM_RPC_BTFN);

  000fc	b1 10		 mov	 cl, 16

; 1404 : 		break;

  000fe	e9 3a 01 00 00	 jmp	 $LN110@parseGener
$LN12@parseGener:

; 1381 : 
; 1382 : 	case 'A':
; 1383 : 		VLActivationInterval = getTimeSpanFromCommandLine(optarg, (char)o);

  00103	b2 41		 mov	 dl, 65			; 00000041H
  00105	e8 00 00 00 00	 call	 getTimeSpanFromCommandLine

; 1384 : 		ignoreIniFileParameter(INI_PARAM_ACTIVATION_INTERVAL);

  0010a	b1 09		 mov	 cl, 9
  0010c	89 05 00 00 00
	00		 mov	 DWORD PTR VLActivationInterval, eax

; 1385 : 		break;

  00112	e9 26 01 00 00	 jmp	 $LN110@parseGener
$LN48@parseGener:

; 1122 : 
; 1123 : 	case '6':
; 1124 : 		KmsResponseParameters[EPID_INDEX_OFFICE2016].Epid = getCommandLineArg(optarg);

  00117	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
  0011e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  00125	48 89 41 48	 mov	 QWORD PTR [rcx+72], rax

; 1125 : #		ifndef NO_LOG
; 1126 : 		KmsResponseParameters[EPID_INDEX_OFFICE2016].EpidSource = "command line";

  00129	4c 89 79 58	 mov	 QWORD PTR [rcx+88], r15

; 1127 : #		endif // NO_LOG
; 1128 : 		break;

  0012d	e9 76 04 00 00	 jmp	 $LN53@parseGener
$LN49@parseGener:

; 1115 : 
; 1116 : 	case '3':
; 1117 : 		KmsResponseParameters[EPID_INDEX_OFFICE2013].Epid = getCommandLineArg(optarg);

  00132	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
  00139	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  00140	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 1118 : #		ifndef NO_LOG
; 1119 : 		KmsResponseParameters[EPID_INDEX_OFFICE2013].EpidSource = "command line";

  00144	4c 89 79 40	 mov	 QWORD PTR [rcx+64], r15

; 1120 : #		endif // NO_LOG
; 1121 : 		break;

  00148	e9 5b 04 00 00	 jmp	 $LN53@parseGener
$LN50@parseGener:

; 1108 : 
; 1109 : 	case '0':
; 1110 : 		KmsResponseParameters[EPID_INDEX_OFFICE2010].Epid = getCommandLineArg(optarg);

  0014d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
  00154	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  0015b	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1111 : #		ifndef NO_LOG
; 1112 : 		KmsResponseParameters[EPID_INDEX_OFFICE2010].EpidSource = "command line";

  0015f	4c 89 79 28	 mov	 QWORD PTR [rcx+40], r15

; 1113 : #		endif // NO_LOG
; 1114 : 		break;

  00163	e9 40 04 00 00	 jmp	 $LN53@parseGener
$LN46@parseGener:

; 1136 : 
; 1137 : 	case 'H':
; 1138 : 		HwId = (BYTE*)vlmcsd_malloc(sizeof(((RESPONSE_V6 *)0)->HwId));

  00168	b9 08 00 00 00	 mov	 ecx, 8
  0016d	e8 00 00 00 00	 call	 vlmcsd_malloc

; 1139 : 		hex2bin(HwId, optarg, sizeof(((RESPONSE_V6 *)0)->HwId));

  00172	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  00179	48 8b c8	 mov	 rcx, rax
  0017c	48 8b d8	 mov	 rbx, rax
  0017f	e8 00 00 00 00	 call	 hex2bin
  00184	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR KmsResponseParameters
  0018b	ba 02 00 00 00	 mov	 edx, 2
  00190	48 8d 48 50	 lea	 rcx, QWORD PTR [rax+80]
$LL96@parseGener:

; 1140 : 
; 1141 : 		KmsResponseParameters[EPID_INDEX_WINDOWS].HwId =
; 1142 : 			KmsResponseParameters[EPID_INDEX_OFFICE2010].HwId =
; 1143 : 			KmsResponseParameters[EPID_INDEX_OFFICE2013].HwId =
; 1144 : 			KmsResponseParameters[EPID_INDEX_WINCHINAGOV].HwId =
; 1145 : 			KmsResponseParameters[EPID_INDEX_OFFICE2016].HwId = HwId;

  00194	48 89 19	 mov	 QWORD PTR [rcx], rbx
  00197	48 8d 49 18	 lea	 rcx, QWORD PTR [rcx+24]
  0019b	48 ff ca	 dec	 rdx
  0019e	75 f4		 jne	 SHORT $LL96@parseGener
  001a0	48 89 58 38	 mov	 QWORD PTR [rax+56], rbx
  001a4	48 89 58 20	 mov	 QWORD PTR [rax+32], rbx
  001a8	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx

; 1146 : 		break;

  001ac	e9 f7 03 00 00	 jmp	 $LN53@parseGener
$LN60@parseGener:

; 1076 : 	int o;
; 1077 : 
; 1078 : #ifndef NO_CL_PIDS
; 1079 : 	BYTE* HwId;
; 1080 : #endif // NO_CL_PIDS
; 1081 : 
; 1082 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  001b1	83 e9 4b	 sub	 ecx, 75			; 0000004bH
  001b4	0f 84 ed 00 00
	00		 je	 $LN24@parseGener
  001ba	ff c9		 dec	 ecx
  001bc	0f 84 dd 00 00
	00		 je	 $LN32@parseGener
  001c2	ff c9		 dec	 ecx
  001c4	0f 84 b6 00 00
	00		 je	 $LN19@parseGener
  001ca	ff c9		 dec	 ecx
  001cc	0f 84 8f 00 00
	00		 je	 $LN10@parseGener
  001d2	ff c9		 dec	 ecx
  001d4	74 71		 je	 SHORT $LN52@parseGener
  001d6	ff c9		 dec	 ecx
  001d8	74 5a		 je	 SHORT $LN43@parseGener
  001da	83 e9 02	 sub	 ecx, 2
  001dd	74 44		 je	 SHORT $LN13@parseGener
  001df	ff c9		 dec	 ecx
  001e1	74 27		 je	 SHORT $LN26@parseGener
  001e3	ff c9		 dec	 ecx
  001e5	0f 85 2f 04 00
	00		 jne	 $LN108@parseGener

; 1211 : #	endif
; 1212 : 
; 1213 : #	ifndef NO_LOG
; 1214 : 
; 1215 : 	case 'T':
; 1216 : 		if (!getArgumentBool(&LogDateAndTime, optarg)) usage();

  001eb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  001f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:LogDateAndTime
  001f9	e8 00 00 00 00	 call	 getArgumentBool
  001fe	85 c0		 test	 eax, eax
  00200	0f 84 fc 03 00
	00		 je	 $LN91@parseGener

; 1217 : 		ignoreIniFileParameter(INI_PARAM_LOG_DATE_AND_TIME);

  00206	b1 13		 mov	 cl, 19

; 1218 : 		break;

  00208	eb 33		 jmp	 SHORT $LN110@parseGener
$LN26@parseGener:

; 1276 : 
; 1277 : 	case 'S':
; 1278 : 		if (!IsNTService) installService = 2; // Remove

  0020a	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR IsNTService, 0
  00211	0f 85 91 03 00
	00		 jne	 $LN53@parseGener
  00217	c6 05 00 00 00
	00 02		 mov	 BYTE PTR installService, 2

; 1279 : 		break;

  0021e	e9 85 03 00 00	 jmp	 $LN53@parseGener
$LN13@parseGener:

; 1346 : #	endif // NO_RANDOM_PID
; 1347 : 
; 1348 : #	if !defined(NO_USER_SWITCH) && !defined(_WIN32)
; 1349 : 	case 'g':
; 1350 : 		gname = optarg;
; 1351 : 		ignoreIniFileParameter(INI_PARAM_GID);
; 1352 : #		ifndef NO_SIGHUP
; 1353 : 		if (!IsRestarted)
; 1354 : #		endif // NO_SIGHUP
; 1355 : 			if (GetGid())
; 1356 : 			{
; 1357 : 				printerrorf("Fatal: %s for %s failed: %s\n", "setgid", gname, strerror(errno));
; 1358 : 				exit(errno);
; 1359 : 			}
; 1360 : 		break;
; 1361 : 
; 1362 : 	case 'u':
; 1363 : 		uname = optarg;
; 1364 : 		ignoreIniFileParameter(INI_PARAM_UID);
; 1365 : #		ifndef NO_SIGHUP
; 1366 : 		if (!IsRestarted)
; 1367 : #		endif // NO_SIGHUP
; 1368 : 			if (GetUid())
; 1369 : 			{
; 1370 : 				printerrorf("Fatal: %s for %s failed: %s\n", "setuid", uname, strerror(errno));
; 1371 : 				exit(errno);
; 1372 : 			}
; 1373 : 		break;
; 1374 : #	endif // NO_USER_SWITCH && !_WIN32
; 1375 : 
; 1376 : #	ifndef NO_CUSTOM_INTERVALS
; 1377 : 	case 'R':
; 1378 : 		VLRenewalInterval = getTimeSpanFromCommandLine(optarg, (char)o);

  00223	b2 52		 mov	 dl, 82			; 00000052H
  00225	e8 00 00 00 00	 call	 getTimeSpanFromCommandLine

; 1379 : 		ignoreIniFileParameter(INI_PARAM_RENEWAL_INTERVAL);

  0022a	b1 0a		 mov	 cl, 10
  0022c	89 05 00 00 00
	00		 mov	 DWORD PTR VLRenewalInterval, eax

; 1380 : 		break;

  00232	eb 09		 jmp	 SHORT $LN110@parseGener
$LN43@parseGener:

; 1168 : 
; 1169 : 	case 'P':
; 1170 : 		ignoreIniFileParameter(INI_PARAM_PORT);

  00234	b1 0e		 mov	 cl, 14
  00236	e8 00 00 00 00	 call	 ignoreIniFileParameter
$LN111@parseGener:

; 1171 : #		if !defined(SIMPLE_SOCKETS) && !defined(USE_MSRPC)
; 1172 : 		ignoreIniFileParameter(INI_PARAM_LISTEN);

  0023b	b1 03		 mov	 cl, 3
$LN110@parseGener:
  0023d	e8 00 00 00 00	 call	 ignoreIniFileParameter

; 1173 : #		else
; 1174 : 		defaultport = optarg;
; 1175 : #		endif // !SIMPLE_SOCKETS
; 1176 : 		break;

  00242	e9 61 03 00 00	 jmp	 $LN53@parseGener
$LN52@parseGener:

; 1083 : 	{
; 1084 : #	if !defined(NO_SOCKETS) && !defined(NO_SIGHUP) && !defined(_WIN32)
; 1085 : 	case 'Z':
; 1086 : 		IsRestarted = TRUE;
; 1087 : 		nodaemon = TRUE;
; 1088 : 		break;
; 1089 : #	endif // !defined(NO_SOCKETS) && !defined(NO_SIGHUP) && !defined(_WIN32)
; 1090 : 
; 1091 : #	ifndef NO_TAP
; 1092 : 
; 1093 : 	case 'O':
; 1094 : 		ignoreIniFileParameter(INI_PARAM_VPN);

  00247	b1 1d		 mov	 cl, 29
  00249	e8 00 00 00 00	 call	 ignoreIniFileParameter

; 1095 : 		tapArgument = getCommandLineArg(optarg);

  0024e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR optarg
  00255	48 89 0d 00 00
	00 00		 mov	 QWORD PTR tapArgument, rcx

; 1096 : 		break;

  0025c	e9 47 03 00 00	 jmp	 $LN53@parseGener
$LN10@parseGener:

; 1394 : 
; 1395 : #	ifndef SIMPLE_RPC
; 1396 : 	case 'N':
; 1397 : 		if (!getArgumentBool(&UseServerRpcNDR64, optarg)) usage();

  00261	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:UseServerRpcNDR64
  0026f	e8 00 00 00 00	 call	 getArgumentBool
  00274	85 c0		 test	 eax, eax
  00276	0f 84 8c 03 00
	00		 je	 $LN92@parseGener

; 1398 : 		ignoreIniFileParameter(INI_PARAM_RPC_NDR64);

  0027c	b1 0f		 mov	 cl, 15

; 1399 : 		break;

  0027e	eb bd		 jmp	 SHORT $LN110@parseGener
$LN19@parseGener:

; 1299 : 
; 1300 : 	case 'M':
; 1301 : 		if (!getArgumentBool(&MaintainClients, optarg)) usage();

  00280	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:MaintainClients
  0028e	e8 00 00 00 00	 call	 getArgumentBool
  00293	85 c0		 test	 eax, eax
  00295	0f 84 73 03 00
	00		 je	 $LN93@parseGener

; 1302 : 		ignoreIniFileParameter(INI_PARAM_MAINTAIN_CLIENTS);

  0029b	b1 1a		 mov	 cl, 26

; 1303 : 		break;

  0029d	eb 9e		 jmp	 SHORT $LN110@parseGener
$LN32@parseGener:

; 1239 : 
; 1240 : #		if !HAVE_GETIFADDR
; 1241 : 		if (PublicIPProtectionLevel & 1) usage();
; 1242 : #		endif // !HAVE_GETIFADDR
; 1243 : 
; 1244 : 		break;
; 1245 : #	endif // !defined(NO_PRIVATE_IP_DETECT)
; 1246 : 
; 1247 : #	ifndef NO_SOCKETS
; 1248 : #	if !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 1249 : 	case 'L':
; 1250 : 		maxsockets++;

  0029f	fe 05 00 00 00
	00		 inc	 BYTE PTR maxsockets

; 1251 : 		ignoreIniFileParameter(INI_PARAM_LISTEN);
; 1252 : 		break;

  002a5	eb 94		 jmp	 SHORT $LN111@parseGener
$LN24@parseGener:

; 1280 : #	endif // _NTSERVICE
; 1281 : 
; 1282 : #	ifndef NO_STRICT_MODES
; 1283 : 
; 1284 : 	case 'K':
; 1285 : 		WhitelistingLevel = (int_fast8_t)getOptionArgumentInt((char)o, 0, 3);

  002a7	33 d2		 xor	 edx, edx
  002a9	b1 4b		 mov	 cl, 75			; 0000004bH
  002ab	44 8d 42 03	 lea	 r8d, QWORD PTR [rdx+3]
  002af	e8 00 00 00 00	 call	 getOptionArgumentInt
  002b4	0f be c8	 movsx	 ecx, al
  002b7	89 0d 00 00 00
	00		 mov	 DWORD PTR WhitelistingLevel, ecx

; 1286 : 		ignoreIniFileParameter(INI_PARAM_WHITELISTING_LEVEL);

  002bd	b1 18		 mov	 cl, 24

; 1287 : 		break;

  002bf	e9 79 ff ff ff	 jmp	 $LN110@parseGener
$LN31@parseGener:

; 1253 : #	if HAVE_FREEBIND
; 1254 : 	case 'F':
; 1255 : 		if (!getArgumentBool(&freebind, optarg)) usage();
; 1256 : 		ignoreIniFileParameter(INI_PARAM_FREEBIND);
; 1257 : 		break;
; 1258 : #	endif // HAVE_FREEBIND
; 1259 : #	endif // !defined(USE_MSRPC) && !defined(SIMPLE_SOCKETS)
; 1260 : 
; 1261 : #	ifdef _NTSERVICE
; 1262 : 	case 'U':
; 1263 : 		ServiceUser = optarg;

  002c4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  002cb	48 89 05 00 00
	00 00		 mov	 QWORD PTR ServiceUser, rax

; 1264 : 		break;

  002d2	e9 d1 02 00 00	 jmp	 $LN53@parseGener
$LN59@parseGener:

; 1076 : 	int o;
; 1077 : 
; 1078 : #ifndef NO_CL_PIDS
; 1079 : 	BYTE* HwId;
; 1080 : #endif // NO_CL_PIDS
; 1081 : 
; 1082 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  002d7	83 f9 6d	 cmp	 ecx, 109		; 0000006dH
  002da	0f 8f b7 01 00
	00		 jg	 $LN61@parseGener
  002e0	0f 84 92 01 00
	00		 je	 $LN42@parseGener
  002e6	8b d1		 mov	 edx, ecx
  002e8	83 ea 56	 sub	 edx, 86			; 00000056H
  002eb	0f 84 fa 00 00
	00		 je	 $LN6@parseGener
  002f1	ff ca		 dec	 edx
  002f3	0f 84 df 00 00
	00		 je	 $LN30@parseGener
  002f9	83 ea 0c	 sub	 edx, 12
  002fc	0f 84 b4 00 00
	00		 je	 $LN23@parseGener
  00302	ff ca		 dec	 edx
  00304	0f 84 9b 00 00
	00		 je	 $LN11@parseGener
  0030a	ff ca		 dec	 edx
  0030c	0f 84 87 00 00
	00		 je	 $LN16@parseGener
  00312	83 ea 04	 sub	 edx, 4
  00315	74 4a		 je	 SHORT $LN39@parseGener
  00317	ff ca		 dec	 edx
  00319	74 25		 je	 SHORT $LN45@parseGener
  0031b	ff ca		 dec	 edx
  0031d	0f 84 82 00 00
	00		 je	 $LN11@parseGener
  00323	ff ca		 dec	 edx
  00325	0f 85 ef 02 00
	00		 jne	 $LN108@parseGener

; 1219 : 
; 1220 : 	case 'l':
; 1221 : 		fn_log = getCommandLineArg(optarg);

  0032b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg

; 1222 : 		ignoreIniFileParameter(INI_PARAM_LOG_FILE);

  00332	b1 07		 mov	 cl, 7
  00334	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_log, rax

; 1223 : 		break;

  0033b	e9 fd fe ff ff	 jmp	 $LN110@parseGener
$LN45@parseGener:

; 1147 : 
; 1148 : #	endif // NO_CL_PIDS
; 1149 : 
; 1150 : #	ifndef NO_EXTERNAL_DATA
; 1151 : 
; 1152 : 	case 'j':
; 1153 : 		ignoreIniFileParameter(INI_PARAM_DATA_FILE);

  00340	b1 1c		 mov	 cl, 28
  00342	e8 00 00 00 00	 call	 ignoreIniFileParameter

; 1154 : 		fn_data = getCommandLineArg(optarg);

  00347	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR optarg

; 1155 : #		ifndef NO_INTERNAL_DATA
; 1156 : 		ExplicitDataLoad = TRUE;

  0034e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ExplicitDataLoad, 1
  00355	48 89 0d 00 00
	00 00		 mov	 QWORD PTR fn_data, rcx

; 1157 : #		endif // NO_INTERNAL_DATA
; 1158 : 		break;

  0035c	e9 47 02 00 00	 jmp	 $LN53@parseGener
$LN39@parseGener:

; 1204 : #	endif
; 1205 : 
; 1206 : #	ifndef NO_INI_FILE
; 1207 : 	case 'i':
; 1208 : 		fn_ini = getCommandLineArg(optarg);

  00361	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR optarg
  00368	48 89 0d 00 00
	00 00		 mov	 QWORD PTR fn_ini, rcx

; 1209 : 		if (!strcmp(fn_ini, "-")) fn_ini = NULL;

  0036f	8a 01		 mov	 al, BYTE PTR [rcx]
  00371	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JOAMLHOP@?9?$AA@
  00377	0f 85 2b 02 00
	00		 jne	 $LN53@parseGener
  0037d	8a 41 01	 mov	 al, BYTE PTR [rcx+1]
  00380	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JOAMLHOP@?9?$AA@+1
  00386	0f 85 1c 02 00
	00		 jne	 $LN53@parseGener
  0038c	48 83 25 00 00
	00 00 00	 and	 QWORD PTR fn_ini, 0

; 1210 : 		break;

  00394	e9 0f 02 00 00	 jmp	 $LN53@parseGener
$LN16@parseGener:

; 1304 : 
; 1305 : #	endif // !NO_CLIENT_LIST
; 1306 : #	endif // !NO_STRICT_MODES
; 1307 : 
; 1308 : 	case 'D':
; 1309 : #		ifndef _WIN32
; 1310 : 		nodaemon = 1;
; 1311 : #		else // _WIN32
; 1312 : #		ifdef _PEDANTIC
; 1313 : 		printerrorf("Warning: Option -D has no effect in the Windows version of vlmcsd.\n");
; 1314 : #		endif // _PEDANTIC
; 1315 : #		endif // _WIN32
; 1316 : 		break;
; 1317 : 
; 1318 : #	ifndef NO_LOG
; 1319 : 
; 1320 : 	case 'e':
; 1321 : 		logstdout = 1;

  00399	c6 05 00 00 00
	00 01		 mov	 BYTE PTR logstdout, 1

; 1322 : 		break;

  003a0	e9 03 02 00 00	 jmp	 $LN53@parseGener
$LN11@parseGener:

; 1386 : #	endif // NO_CUSTOM_INTERVALS
; 1387 : 
; 1388 : #	ifndef USE_MSRPC
; 1389 : 	case 'd':
; 1390 : 	case 'k':
; 1391 : 		DisconnectImmediately = o == 'd';

  003a5	83 f9 64	 cmp	 ecx, 100		; 00000064H

; 1392 : 		ignoreIniFileParameter(INI_PARAM_DISCONNECT_IMMEDIATELY);

  003a8	b1 0b		 mov	 cl, 11
  003aa	0f 94 05 00 00
	00 00		 sete	 BYTE PTR DisconnectImmediately

; 1393 : 		break;

  003b1	e9 87 fe ff ff	 jmp	 $LN110@parseGener
$LN23@parseGener:

; 1288 : 
; 1289 : 	case 'c':
; 1290 : 		if (!getArgumentBool(&CheckClientTime, optarg)) usage();

  003b6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR optarg
  003bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:CheckClientTime
  003c4	e8 00 00 00 00	 call	 getArgumentBool
  003c9	85 c0		 test	 eax, eax
  003cb	0f 84 43 02 00
	00		 je	 $LN94@parseGener

; 1291 : 		ignoreIniFileParameter(INI_PARAM_CHECK_CLIENT_TIME);

  003d1	b1 19		 mov	 cl, 25

; 1292 : 		break;

  003d3	e9 65 fe ff ff	 jmp	 $LN110@parseGener
$LN30@parseGener:

; 1265 : 
; 1266 : 	case 'W':
; 1267 : 		ServicePassword = optarg;

  003d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  003df	48 89 05 00 00
	00 00		 mov	 QWORD PTR ServicePassword, rax

; 1268 : 		break;

  003e6	e9 bd 01 00 00	 jmp	 $LN53@parseGener
$LN6@parseGener:

; 1405 : #	endif // !SIMPLE_RPC
; 1406 : #	endif // !USE_MSRPC
; 1407 : 
; 1408 : #	ifndef NO_VERSION_INFORMATION
; 1409 : 	case 'V':
; 1410 : #		ifdef _NTSERVICE
; 1411 : 		if (IsNTService) break;

  003eb	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR IsNTService, 0
  003f2	0f 85 b0 01 00
	00		 jne	 $LN53@parseGener

; 1412 : #		endif
; 1413 : #		if defined(__s390__) && !defined(__zarch__) && !defined(__s390x__)
; 1414 : 		printf("vlmcsd %s %i-bit\n", Version, sizeof(void*) == 4 ? 31 : (int)sizeof(void*) << 3);
; 1415 : #		else
; 1416 : 		printf("vlmcsd %s %i-bit\n", Version, (int)sizeof(void*) << 3);

  003f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@LEPLNMP@private?5build?$AA@
  003ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@OKDFGCCJ@vlmcsd?5?$CFs?5?$CFi?9bit?6?$AA@
  00406	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0040c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 1417 : #		endif // defined(__s390__) && !defined(__zarch__) && !defined(__s390x__)
; 1418 : 		printPlatform();

  00412	45 33 c0	 xor	 r8d, r8d
  00415	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CD@FAKKKCEM@Compiler?3?5VC?$CL?$CL?5?$CF02i?4?$CF02i?5build?5?$CF@
  0041c	41 8d 50 12	 lea	 edx, QWORD PTR [r8+18]
  00420	41 b9 b5 9e 00
	00		 mov	 r9d, 40629		; 00009eb5H
  00426	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf
  0042c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@KEGGAHLA@little?9endian?$AA@
  00433	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@LFPGKPOF@?5Intel?5x86_64?5Windows64?$AA@
  0043a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@MBJNOFCM@Intended?5platform?3?$CFs?5?$CFs?6?$AA@
  00441	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 1419 : 		printCommonFlags();

  00447	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@NGPJLHEC@?5_CRYPTO_WINDOWS?$AA@
  0044e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NGBEHLG@Common?5flags?3?$CFs?6?$AA@
  00455	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 1420 : 		printServerFlags();

  0045b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CO@DNHMBJJK@?5NO_SIGHUP?5THREADS?$DN1?5SUPPORT_WIN@
  00462	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@OGOEBGIP@vlmcsd?5flags?3?$CFs?6?$AA@
  00469	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_printf

; 1421 : 		exit(0);

  0046f	33 c9		 xor	 ecx, ecx
  00471	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00477	cc		 int	 3
$LN42@parseGener:

; 1177 : 
; 1178 : #	if !defined(NO_LIMIT) && !__minix__
; 1179 : 
; 1180 : 	case 'm':
; 1181 : #		ifdef USE_MSRPC
; 1182 : 		MaxTasks = getOptionArgumentInt(o, 1, RPC_C_LISTEN_MAX_CALLS_DEFAULT);
; 1183 : #		else // !USE_MSRPC
; 1184 : 		MaxTasks = getOptionArgumentInt((char)o, 1, SEM_VALUE_MAX);

  00478	ba 01 00 00 00	 mov	 edx, 1
  0047d	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  00483	b1 6d		 mov	 cl, 109			; 0000006dH
  00485	e8 00 00 00 00	 call	 getOptionArgumentInt

; 1185 : #		endif // !USE_MSRPC
; 1186 : 		ignoreIniFileParameter(INI_PARAM_MAX_WORKERS);

  0048a	b1 04		 mov	 cl, 4
  0048c	89 05 00 00 00
	00		 mov	 DWORD PTR MaxTasks, eax

; 1187 : 		break;

  00492	e9 a6 fd ff ff	 jmp	 $LN110@parseGener
$LN61@parseGener:

; 1076 : 	int o;
; 1077 : 
; 1078 : #ifndef NO_CL_PIDS
; 1079 : 	BYTE* HwId;
; 1080 : #endif // NO_CL_PIDS
; 1081 : 
; 1082 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  00497	8b d1		 mov	 edx, ecx
  00499	83 ea 6f	 sub	 edx, 111		; 0000006fH
  0049c	0f 84 ec 00 00
	00		 je	 $LN33@parseGener
  004a2	ff ca		 dec	 edx
  004a4	0f 84 cf 00 00
	00		 je	 $LN40@parseGener
  004aa	ff ca		 dec	 edx
  004ac	0f 84 b6 00 00
	00		 je	 $LN34@parseGener
  004b2	ff ca		 dec	 edx
  004b4	0f 84 94 00 00
	00		 je	 $LN15@parseGener
  004ba	ff ca		 dec	 edx
  004bc	74 71		 je	 SHORT $LN29@parseGener
  004be	ff ca		 dec	 edx
  004c0	74 4e		 je	 SHORT $LN41@parseGener
  004c2	83 ea 02	 sub	 edx, 2
  004c5	0f 84 9d 00 00
	00		 je	 $LN34@parseGener
  004cb	ff ca		 dec	 edx
  004cd	74 27		 je	 SHORT $LN51@parseGener
  004cf	ff ca		 dec	 edx
  004d1	0f 85 43 01 00
	00		 jne	 $LN108@parseGener

; 1159 : 
; 1160 : #	endif // NO_EXTERNAL_DATA
; 1161 : 
; 1162 : #	ifndef NO_SOCKETS
; 1163 : 
; 1164 : 	case 'x':
; 1165 : 		ignoreIniFileParameter(INI_PARAM_EXIT_LEVEL);

  004d7	b1 1e		 mov	 cl, 30
  004d9	e8 00 00 00 00	 call	 ignoreIniFileParameter

; 1166 : 		ExitLevel = (int_fast8_t)getOptionArgumentInt((char)o, 0, 1);

  004de	33 d2		 xor	 edx, edx
  004e0	b1 78		 mov	 cl, 120			; 00000078H
  004e2	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  004e6	e8 00 00 00 00	 call	 getOptionArgumentInt
  004eb	88 05 00 00 00
	00		 mov	 BYTE PTR ExitLevel, al

; 1167 : 		break;

  004f1	e9 b2 00 00 00	 jmp	 $LN53@parseGener
$LN51@parseGener:

; 1097 : 
; 1098 : #	endif // NO_TAP
; 1099 : 
; 1100 : #	ifndef NO_CL_PIDS
; 1101 : 
; 1102 : 	case 'w':
; 1103 : 		KmsResponseParameters[EPID_INDEX_WINDOWS].Epid = getCommandLineArg(optarg);

  004f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR KmsResponseParameters
  004fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  00504	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1104 : #		ifndef NO_LOG
; 1105 : 		KmsResponseParameters[EPID_INDEX_WINDOWS].EpidSource = "command line";

  00507	4c 89 79 10	 mov	 QWORD PTR [rcx+16], r15

; 1106 : #		endif // NO_LOG
; 1107 : 		break;

  0050b	e9 98 00 00 00	 jmp	 $LN53@parseGener
$LN41@parseGener:

; 1188 : 
; 1189 : #		endif // !defined(NO_LIMIT) && !__minix__
; 1190 : #		endif // NO_SOCKETS
; 1191 : 
; 1192 : #	if !defined(NO_TIMEOUT) && !__minix__ && !defined(USE_MSRPC)
; 1193 : 	case 't':
; 1194 : 		ServerTimeout = getOptionArgumentInt((char)o, 1, 600);

  00510	ba 01 00 00 00	 mov	 edx, 1
  00515	41 b8 58 02 00
	00		 mov	 r8d, 600		; 00000258H
  0051b	b1 74		 mov	 cl, 116			; 00000074H
  0051d	e8 00 00 00 00	 call	 getOptionArgumentInt

; 1195 : 		ignoreIniFileParameter(INI_PARAM_CONNECTION_TIMEOUT);

  00522	b1 05		 mov	 cl, 5
  00524	89 05 00 00 00
	00		 mov	 DWORD PTR ServerTimeout, eax

; 1196 : 		break;

  0052a	e9 0e fd ff ff	 jmp	 $LN110@parseGener
$LN29@parseGener:

; 1269 : 
; 1270 : 	case 's':
; 1271 : #		ifndef USE_MSRPC
; 1272 : 		if (InetdMode) usage();

  0052f	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  00536	0f 85 e4 00 00
	00		 jne	 $LN95@parseGener

; 1273 : #		endif // USE_MSRPC
; 1274 : 		if (!IsNTService) installService = 1; // Install

  0053c	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR IsNTService, 0
  00543	75 63		 jne	 SHORT $LN53@parseGener
  00545	c6 05 00 00 00
	00 01		 mov	 BYTE PTR installService, 1

; 1275 : 		break;

  0054c	eb 5a		 jmp	 SHORT $LN53@parseGener
$LN15@parseGener:

; 1323 : 
; 1324 : #	endif // NO_LOG
; 1325 : #	endif // NO_SOCKETS
; 1326 : 
; 1327 : #	ifndef NO_RANDOM_EPID
; 1328 : 	case 'r':
; 1329 : 		RandomizationLevel = (int_fast8_t)getOptionArgumentInt((char)o, 0, 2);

  0054e	33 d2		 xor	 edx, edx
  00550	b1 72		 mov	 cl, 114			; 00000072H
  00552	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  00556	e8 00 00 00 00	 call	 getOptionArgumentInt

; 1330 : 		ignoreIniFileParameter(INI_PARAM_RANDOMIZATION_LEVEL);

  0055b	b1 01		 mov	 cl, 1
  0055d	88 05 00 00 00
	00		 mov	 BYTE PTR RandomizationLevel, al

; 1331 : 		break;

  00563	e9 d5 fc ff ff	 jmp	 $LN110@parseGener
$LN34@parseGener:

; 1224 : 
; 1225 : #	ifndef NO_VERBOSE_LOG
; 1226 : 	case 'v':
; 1227 : 	case 'q':
; 1228 : 		logverbose = o == 'v';

  00568	83 f9 76	 cmp	 ecx, 118		; 00000076H

; 1229 : 		ignoreIniFileParameter(INI_PARAM_LOG_VERBOSE);

  0056b	b1 08		 mov	 cl, 8
  0056d	0f 94 05 00 00
	00 00		 sete	 BYTE PTR logverbose

; 1230 : 		break;

  00574	e9 c4 fc ff ff	 jmp	 $LN110@parseGener
$LN40@parseGener:

; 1197 : #	endif // !defined(NO_TIMEOUT) && !__minix__ && !defined(USE_MSRPC)
; 1198 : 
; 1199 : #	ifndef NO_PID_FILE
; 1200 : 	case 'p':
; 1201 : 		fn_pid = getCommandLineArg(optarg);

  00579	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg

; 1202 : 		ignoreIniFileParameter(INI_PARAM_PID_FILE);

  00580	b1 06		 mov	 cl, 6
  00582	48 89 05 00 00
	00 00		 mov	 QWORD PTR fn_pid, rax

; 1203 : 		break;

  00589	e9 af fc ff ff	 jmp	 $LN110@parseGener
$LN33@parseGener:

; 1231 : 
; 1232 : #	endif // NO_VERBOSE_LOG
; 1233 : #	endif // NO_LOG
; 1234 : 
; 1235 : #	if !defined(NO_PRIVATE_IP_DETECT)
; 1236 : 	case 'o':
; 1237 : 		ignoreIniFileParameter(INI_PARAM_PUBLIC_IP_PROTECTION_LEVEL);

  0058e	b1 12		 mov	 cl, 18
  00590	e8 00 00 00 00	 call	 ignoreIniFileParameter

; 1238 : 		PublicIPProtectionLevel = getOptionArgumentInt((char)o, 0, 3);

  00595	33 d2		 xor	 edx, edx
  00597	b1 6f		 mov	 cl, 111			; 0000006fH
  00599	44 8d 42 03	 lea	 r8d, QWORD PTR [rdx+3]
  0059d	e8 00 00 00 00	 call	 getOptionArgumentInt
  005a2	89 05 00 00 00
	00		 mov	 DWORD PTR PublicIPProtectionLevel, eax
$LN53@parseGener:

; 1076 : 	int o;
; 1077 : 
; 1078 : #ifndef NO_CL_PIDS
; 1079 : 	BYTE* HwId;
; 1080 : #endif // NO_CL_PIDS
; 1081 : 
; 1082 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  005a8	e8 00 00 00 00	 call	 getopt
  005ad	8b c8		 mov	 ecx, eax
  005af	85 c0		 test	 eax, eax
  005b1	0f 8f 71 fa ff
	ff		 jg	 $LL56@parseGener
$LN104@parseGener:

; 1426 : 	}
; 1427 : 
; 1428 : 	// Do not allow non-option arguments
; 1429 : 	if (optind != global_argc)

  005b7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR global_argc
  005bd	39 05 00 00 00
	00		 cmp	 DWORD PTR optind, eax
  005c3	75 2b		 jne	 SHORT $LN112@parseGener
$LN3@parseGener:

; 1431 : 
; 1432 : #	ifdef _NTSERVICE
; 1433 : 	// -U and -W must be used with -s
; 1434 : 	if ((ServiceUser || *ServicePassword) && installService != 1) usage();

  005c5	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ServiceUser, 0
  005cd	75 0c		 jne	 SHORT $LN1@parseGener
  005cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ServicePassword
  005d6	80 38 00	 cmp	 BYTE PTR [rax], 0
  005d9	74 09		 je	 SHORT $LN2@parseGener
$LN1@parseGener:
  005db	80 3d 00 00 00
	00 01		 cmp	 BYTE PTR installService, 1
  005e2	75 42		 jne	 SHORT $LN114@parseGener
$LN2@parseGener:

; 1435 : #	endif // _NTSERVICE
; 1436 : }

  005e4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  005e9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  005ed	41 5f		 pop	 r15
  005ef	c3		 ret	 0
$LN112@parseGener:

; 1430 : 		usage();

  005f0	e8 00 00 00 00	 call	 usage
  005f5	cc		 int	 3
$LN89@parseGener:

; 1293 : 
; 1294 : #	ifndef NO_CLIENT_LIST
; 1295 : 	case 'E':
; 1296 : 		if (!getArgumentBool(&StartEmpty, optarg)) usage();

  005f6	e8 00 00 00 00	 call	 usage
  005fb	cc		 int	 3
$LN90@parseGener:

; 1400 : 
; 1401 : 	case 'B':
; 1402 : 		if (!getArgumentBool(&UseServerRpcBTFN, optarg)) usage();

  005fc	e8 00 00 00 00	 call	 usage
  00601	cc		 int	 3
$LN91@parseGener:

; 1211 : #	endif
; 1212 : 
; 1213 : #	ifndef NO_LOG
; 1214 : 
; 1215 : 	case 'T':
; 1216 : 		if (!getArgumentBool(&LogDateAndTime, optarg)) usage();

  00602	e8 00 00 00 00	 call	 usage
  00607	cc		 int	 3
$LN92@parseGener:

; 1394 : 
; 1395 : #	ifndef SIMPLE_RPC
; 1396 : 	case 'N':
; 1397 : 		if (!getArgumentBool(&UseServerRpcNDR64, optarg)) usage();

  00608	e8 00 00 00 00	 call	 usage
  0060d	cc		 int	 3
$LN93@parseGener:

; 1299 : 
; 1300 : 	case 'M':
; 1301 : 		if (!getArgumentBool(&MaintainClients, optarg)) usage();

  0060e	e8 00 00 00 00	 call	 usage
  00613	cc		 int	 3
$LN94@parseGener:

; 1288 : 
; 1289 : 	case 'c':
; 1290 : 		if (!getArgumentBool(&CheckClientTime, optarg)) usage();

  00614	e8 00 00 00 00	 call	 usage
  00619	cc		 int	 3
$LN108@parseGener:

; 1422 : #	endif // NO_VERSION_INFORMATION
; 1423 : 
; 1424 : 	default:
; 1425 : 		usage();

  0061a	e8 00 00 00 00	 call	 usage
  0061f	cc		 int	 3
$LN95@parseGener:

; 1269 : 
; 1270 : 	case 's':
; 1271 : #		ifndef USE_MSRPC
; 1272 : 		if (InetdMode) usage();

  00620	e8 00 00 00 00	 call	 usage
  00625	cc		 int	 3
$LN114@parseGener:

; 1431 : 
; 1432 : #	ifdef _NTSERVICE
; 1433 : 	// -U and -W must be used with -s
; 1434 : 	if ((ServiceUser || *ServicePassword) && installService != 1) usage();

  00626	e8 00 00 00 00	 call	 usage
  0062b	cc		 int	 3
$LN109@parseGener:
parseGeneralArguments ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT writePidFile
_TEXT	SEGMENT
writePidFile PROC					; COMDAT

; 1441 : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1442 : #	ifndef NO_SIGHUP
; 1443 : 	if (IsRestarted) return;
; 1444 : #	endif // NO_SIGHUP
; 1445 : 
; 1446 : 	if (fn_pid && !InetdMode)

  00006	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR fn_pid
  0000d	48 85 c9	 test	 rcx, rcx
  00010	74 6a		 je	 SHORT $LN1@writePidFi
  00012	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  00019	75 61		 jne	 SHORT $LN1@writePidFi

; 1447 : 	{
; 1448 : 		FILE *file = fopen(fn_pid, "w");

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00028	48 8b d8	 mov	 rbx, rax

; 1449 : 
; 1450 : 		if (file)

  0002b	48 85 c0	 test	 rax, rax
  0002e	74 28		 je	 SHORT $LN2@writePidFi

; 1451 : 		{
; 1452 : #			if _MSC_VER
; 1453 : 			fprintf(file, "%u", (unsigned int)GetCurrentProcessId());

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcessId
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02GMHACPFF@?$CFu?$AA@
  0003d	48 8b cb	 mov	 rcx, rbx
  00040	44 8b c0	 mov	 r8d, eax
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 1454 : #			else
; 1455 : 			fprintf(file, "%u", (unsigned int)getpid());
; 1456 : #			endif
; 1457 : 			fclose(file);

  00049	48 8b cb	 mov	 rcx, rbx

; 1464 : 		}
; 1465 : #		endif // NO_LOG
; 1466 : 	}
; 1467 : }

  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5b		 pop	 rbx

; 1454 : #			else
; 1455 : 			fprintf(file, "%u", (unsigned int)getpid());
; 1456 : #			endif
; 1457 : 			fclose(file);

  00051	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_fclose
$LN2@writePidFi:

; 1458 : 		}
; 1459 : 
; 1460 : #		ifndef NO_LOG
; 1461 : 		else
; 1462 : 		{
; 1463 : 			logger("Warning: Cannot write pid file '%s'. %s.\n", fn_pid, strerror(errno));

  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00066	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_pid
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CK@KCAHIBIN@Warning?3?5Cannot?5write?5pid?5file?5?8@
  00074	4c 8b c0	 mov	 r8, rax
  00077	e8 00 00 00 00	 call	 logger
$LN1@writePidFi:

; 1464 : 		}
; 1465 : #		endif // NO_LOG
; 1466 : 	}
; 1467 : }

  0007c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00080	5b		 pop	 rbx
  00081	c3		 ret	 0
writePidFile ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT allocateSemaphore
_TEXT	SEGMENT
allocateSemaphore PROC					; COMDAT

; 1527 : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1528 : #	ifdef USE_THREADS
; 1529 : #	define sharemode 0
; 1530 : #	else
; 1531 : #	define sharemode 1
; 1532 : #	endif
; 1533 : 
; 1534 : #	ifndef _WIN32
; 1535 : 	sem_unlink("/vlmcsd");
; 1536 : #	endif
; 1537 : 
; 1538 : 	if (MaxTasks < SEM_VALUE_MAX && !InetdMode)

  00004	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR MaxTasks
  0000a	81 fa ff ff ff
	7f		 cmp	 edx, 2147483647		; 7fffffffH
  00010	73 49		 jae	 SHORT $LN1@allocateSe
  00012	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  00019	75 40		 jne	 SHORT $LN1@allocateSe

; 1539 : 	{
; 1540 : #		ifndef _WIN32
; 1541 : 
; 1542 : #		if !defined(USE_THREADS) && !defined(CYGWIN)
; 1543 : 
; 1544 : 		if ((MaxTaskSemaphore = sem_open("/vlmcsd", O_CREAT /*| O_EXCL*/, 0700, MaxTasks)) == SEM_FAILED) // fails on many systems
; 1545 : 		{
; 1546 : 			// We didn't get a named Semaphore (/dev/shm on Linux) so let's try our own shared page
; 1547 : 
; 1548 : 			if (
; 1549 : 				(shmid = shmget(IPC_PRIVATE, sizeof(sem_t), IPC_CREAT | 0600)) < 0 ||
; 1550 : 				(MaxTaskSemaphore = (sem_t*)shmat(shmid, NULL, 0)) == (sem_t*)-1 ||
; 1551 : 				sem_init(MaxTaskSemaphore, 1, MaxTasks) < 0
; 1552 : 				)
; 1553 : 			{
; 1554 : 				int errno_save = errno;
; 1555 : 				if (MaxTaskSemaphore != (sem_t*)-1) shmdt(MaxTaskSemaphore);
; 1556 : 				if (shmid >= 0) shmctl(shmid, IPC_RMID, NULL);
; 1557 : 				printerrorf("Warning: Could not create semaphore: %s\n", vlmcsd_strerror(errno_save));
; 1558 : 				MaxTasks = SEM_VALUE_MAX;
; 1559 : 			}
; 1560 : 		}
; 1561 : 
; 1562 : #		else // THREADS or CYGWIN
; 1563 : 
; 1564 : 		MaxTaskSemaphore = (sem_t*)vlmcsd_malloc(sizeof(sem_t));
; 1565 : 
; 1566 : 		if (sem_init(MaxTaskSemaphore, sharemode, MaxTasks) < 0) // sem_init is not implemented on Darwin (returns ENOSYS)
; 1567 : 		{
; 1568 : 			free(MaxTaskSemaphore);
; 1569 : 
; 1570 : 			if ((MaxTaskSemaphore = sem_open("/vlmcsd", O_CREAT /*| O_EXCL*/, 0700, MaxTasks)) == SEM_FAILED)
; 1571 : 			{
; 1572 : 				printerrorf("Warning: Could not create semaphore: %s\n", vlmcsd_strerror(errno));
; 1573 : 				MaxTasks = SEM_VALUE_MAX;
; 1574 : 			}
; 1575 : 		}
; 1576 : 
; 1577 : #		endif // THREADS or CYGWIN
; 1578 : 
; 1579 : #		else // _WIN32
; 1580 : 
; 1581 : 		if (!((MaxTaskSemaphore = CreateSemaphoreA(NULL, MaxTasks, MaxTasks, NULL))))

  0001b	45 33 c9	 xor	 r9d, r9d
  0001e	44 8b c2	 mov	 r8d, edx
  00021	33 c9		 xor	 ecx, ecx
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateSemaphoreA
  00029	48 89 05 00 00
	00 00		 mov	 QWORD PTR MaxTaskSemaphore, rax
  00030	48 85 c0	 test	 rax, rax
  00033	75 26		 jne	 SHORT $LN1@allocateSe

; 1582 : 		{
; 1583 : 			printerrorf("Warning: Could not create semaphore: %s\n", vlmcsd_strerror(GetLastError()));

  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0003b	8b c8		 mov	 ecx, eax
  0003d	e8 00 00 00 00	 call	 win_strerror
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CJ@LKGGDOJH@Warning?3?5Could?5not?5create?5semaph@
  00049	48 8b d0	 mov	 rdx, rax
  0004c	e8 00 00 00 00	 call	 printerrorf

; 1584 : 			MaxTasks = SEM_VALUE_MAX;

  00051	c7 05 00 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR MaxTasks, 2147483647 ; 7fffffffH
$LN1@allocateSe:

; 1585 : 		}
; 1586 : 
; 1587 : #		endif // _WIN32
; 1588 : 	}
; 1589 : }

  0005b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005f	c3		 ret	 0
allocateSemaphore ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT setupListeningSockets
_TEXT	SEGMENT
numPrivateIPs$ = 64
privateIPList$ = 72
setupListeningSockets PROC				; COMDAT

; 1595 : {

$LN39:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 18	 mov	 QWORD PTR [r11+24], rbx
  00007	49 89 6b 20	 mov	 QWORD PTR [r11+32], rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	41 56		 push	 r14
  0000f	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1596 : 	int o;
; 1597 : #	if HAVE_GETIFADDR
; 1598 : 	char** privateIPList = NULL;
; 1599 : 	int numPrivateIPs = 0;
; 1600 : 	if (PublicIPProtectionLevel & 1) getPrivateIPAddresses(&numPrivateIPs, &privateIPList);

  00013	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PublicIPProtectionLevel
  00019	33 f6		 xor	 esi, esi
  0001b	33 ff		 xor	 edi, edi
  0001d	49 89 73 10	 mov	 QWORD PTR [r11+16], rsi
  00021	89 7c 24 40	 mov	 DWORD PTR numPrivateIPs$[rsp], edi
  00025	a8 01		 test	 al, 1
  00027	74 1c		 je	 SHORT $LN18@setupListe
  00029	49 8d 53 10	 lea	 rdx, QWORD PTR [r11+16]
  0002d	49 8d 4b 08	 lea	 rcx, QWORD PTR [r11+8]
  00031	e8 00 00 00 00	 call	 getPrivateIPAddresses
  00036	48 8b 74 24 48	 mov	 rsi, QWORD PTR privateIPList$[rsp]
  0003b	8b 7c 24 40	 mov	 edi, DWORD PTR numPrivateIPs$[rsp]
  0003f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PublicIPProtectionLevel
$LN18@setupListe:

; 1601 : 	uint_fast8_t allocsockets = (uint_fast8_t)(maxsockets ? (maxsockets + numPrivateIPs) : ((PublicIPProtectionLevel & 1) ? numPrivateIPs : 2));

  00045	44 8a 0d 00 00
	00 00		 mov	 r9b, BYTE PTR maxsockets
  0004c	a8 01		 test	 al, 1
  0004e	40 0f b6 c7	 movzx	 eax, dil
  00052	b9 02 00 00 00	 mov	 ecx, 2
  00057	46 8d 04 0f	 lea	 r8d, DWORD PTR [rdi+r9]
  0005b	0f 45 c8	 cmovne	 ecx, eax
  0005e	41 0f b6 c0	 movzx	 eax, r8b
  00062	45 84 c9	 test	 r9b, r9b
  00065	0f b6 d1	 movzx	 edx, cl
  00068	0f 45 d0	 cmovne	 edx, eax

; 1602 : #	else // !HAVE_GETIFADDR
; 1603 : 	uint_fast8_t allocsockets = maxsockets ? maxsockets : 2;
; 1604 : #	endif // !HAVE_GETIFADDR
; 1605 : 
; 1606 : 	SocketList = (SOCKET*)vlmcsd_malloc((size_t)allocsockets * sizeof(SOCKET));

  0006b	0f b6 ca	 movzx	 ecx, dl
  0006e	48 c1 e1 03	 shl	 rcx, 3
  00072	e8 00 00 00 00	 call	 vlmcsd_malloc

; 1607 : 
; 1608 : 	int_fast8_t haveIPv4Stack = checkProtocolStack(AF_INET);

  00077	45 33 c0	 xor	 r8d, r8d
  0007a	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  0007e	48 89 05 00 00
	00 00		 mov	 QWORD PTR SocketList, rax
  00085	8d 4a 01	 lea	 ecx, QWORD PTR [rdx+1]
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket
  0008e	48 8b c8	 mov	 rcx, rax
  00091	48 8b d8	 mov	 rbx, rax
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  0009a	48 83 fb ff	 cmp	 rbx, -1
  0009e	40 0f 95 c5	 setne	 bpl

; 1609 : 	int_fast8_t haveIPv6Stack = checkProtocolStack(AF_INET6);

  000a2	45 33 c0	 xor	 r8d, r8d
  000a5	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  000a9	8d 4a 16	 lea	 ecx, QWORD PTR [rdx+22]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	48 8b d8	 mov	 rbx, rax
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  000be	48 83 fb ff	 cmp	 rbx, -1

; 1610 : 
; 1611 : 	// Reset getopt since we've alread used it
; 1612 : 	optReset();

  000c2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR optind, 1
  000cc	41 0f 95 c6	 setne	 r14b

; 1613 : 
; 1614 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  000d0	83 25 00 00 00
	00 00		 and	 DWORD PTR opterr, 0
  000d7	eb 26		 jmp	 SHORT $LN14@setupListe
$LL17@setupListe:
  000d9	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  000dc	74 15		 je	 SHORT $LN12@setupListe
  000de	83 f8 50	 cmp	 eax, 80			; 00000050H
  000e1	75 1c		 jne	 SHORT $LN14@setupListe

; 1615 : 	{
; 1616 : 	case 'P':
; 1617 : 		defaultport = optarg;

  000e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR optarg
  000ea	48 89 05 00 00
	00 00		 mov	 QWORD PTR defaultport, rax

; 1618 : 		break;

  000f1	eb 0c		 jmp	 SHORT $LN14@setupListe
$LN12@setupListe:

; 1619 : 
; 1620 : 	case 'L':
; 1621 : 		addListeningSocket(optarg);

  000f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR optarg
  000fa	e8 00 00 00 00	 call	 addListeningSocket
$LN14@setupListe:

; 1613 : 
; 1614 : 	for (opterr = 0; (o = getopt(global_argc, (char* const*)global_argv, (const char*)optstring)) > 0; ) switch (o)

  000ff	e8 00 00 00 00	 call	 getopt
  00104	85 c0		 test	 eax, eax
  00106	7f d1		 jg	 SHORT $LL17@setupListe

; 1622 : 		break;
; 1623 : 
; 1624 : 	default:
; 1625 : 		break;
; 1626 : 	}
; 1627 : 
; 1628 : 
; 1629 : #	ifndef NO_INI_FILE
; 1630 : 	if (maxsockets && !numsockets)

  00108	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR maxsockets, 0
  0010f	74 42		 je	 SHORT $LN34@setupListe
  00111	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR numsockets, 0
  00118	75 39		 jne	 SHORT $LN34@setupListe

; 1631 : 	{
; 1632 : 		if (fn_ini && !readIniFile(INI_FILE_PASS_2))

  0011a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR fn_ini, 0
  00122	74 2f		 je	 SHORT $LN34@setupListe
  00124	b1 02		 mov	 cl, 2
  00126	e8 00 00 00 00	 call	 readIniFile
  0012b	85 c0		 test	 eax, eax
  0012d	75 24		 jne	 SHORT $LN34@setupListe

; 1633 : 		{
; 1634 : #			ifdef INI_FILE
; 1635 : 			if (strcmp(fn_ini, INI_FILE))
; 1636 : #			endif // INI_FILE
; 1637 : 				printerrorf("Warning: Can't read %s: %s\n", fn_ini, strerror(errno));

  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00135	8b 08		 mov	 ecx, DWORD PTR [rax]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  0013d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR fn_ini
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BM@GJMMPBLN@Warning?3?5Can?8t?5read?5?$CFs?3?5?$CFs?6?$AA@
  0014b	4c 8b c0	 mov	 r8, rax
  0014e	e8 00 00 00 00	 call	 printerrorf
$LN34@setupListe:

; 1638 : 		}
; 1639 : 	}
; 1640 : #	endif
; 1641 : 
; 1642 : #	if HAVE_GETIFADDR
; 1643 : 	if (PublicIPProtectionLevel & 1)

  00153	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PublicIPProtectionLevel
  00159	a8 01		 test	 al, 1
  0015b	74 30		 je	 SHORT $LN8@setupListe

; 1644 : 	{
; 1645 : 		int i;
; 1646 : 		for (i = 0; i < numPrivateIPs; i++)

  0015d	85 ff		 test	 edi, edi
  0015f	7e 1d		 jle	 SHORT $LN5@setupListe
  00161	48 8b de	 mov	 rbx, rsi
$LL7@setupListe:

; 1647 : 		{
; 1648 : 			addListeningSocket(privateIPList[i]);

  00164	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00167	e8 00 00 00 00	 call	 addListeningSocket

; 1649 : 			free(privateIPList[i]);

  0016c	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00175	48 8d 5b 08	 lea	 rbx, QWORD PTR [rbx+8]
  00179	48 ff cf	 dec	 rdi
  0017c	75 e6		 jne	 SHORT $LL7@setupListe
$LN5@setupListe:

; 1650 : 		}
; 1651 : 
; 1652 : 		free(privateIPList);

  0017e	48 8b ce	 mov	 rcx, rsi
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  00187	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PublicIPProtectionLevel
$LN8@setupListe:

; 1653 : 	}
; 1654 : #	endif // HAVE_GETIFADDR
; 1655 : 
; 1656 : 	// if -L hasn't been specified on the command line, use default sockets (all IP addresses)
; 1657 : 	// maxsocket results from first pass parsing the arguments
; 1658 : 	if (!maxsockets)

  0018d	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR maxsockets, 0
  00194	75 30		 jne	 SHORT $LN2@setupListe

; 1659 : 	{
; 1660 : #		if HAVE_GETIFADDR
; 1661 : 		if (!(PublicIPProtectionLevel & 1) && haveIPv6Stack) addListeningSocket("::");

  00196	a8 01		 test	 al, 1
  00198	75 2c		 jne	 SHORT $LN2@setupListe
  0019a	45 84 f6	 test	 r14b, r14b
  0019d	74 12		 je	 SHORT $LN3@setupListe
  0019f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_02MOLJINC@?3?3?$AA@
  001a6	e8 00 00 00 00	 call	 addListeningSocket
  001ab	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR PublicIPProtectionLevel
$LN3@setupListe:

; 1662 : 		if (!(PublicIPProtectionLevel & 1) && haveIPv4Stack) addListeningSocket("0.0.0.0");

  001b1	a8 01		 test	 al, 1
  001b3	75 11		 jne	 SHORT $LN2@setupListe
  001b5	40 84 ed	 test	 bpl, bpl
  001b8	74 0c		 je	 SHORT $LN2@setupListe
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_07OHKHACFK@0?40?40?40?$AA@
  001c1	e8 00 00 00 00	 call	 addListeningSocket
$LN2@setupListe:

; 1663 : #		else // !HAVE_GETIFADDR
; 1664 : 		if (haveIPv6Stack) addListeningSocket("::");
; 1665 : 		if (haveIPv4Stack) addListeningSocket("0.0.0.0");
; 1666 : #		endif // !HAVE_GETIFADDR
; 1667 : 	}
; 1668 : 
; 1669 : 	if (!numsockets)

  001c6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR numsockets, 0
  001cd	75 13		 jne	 SHORT $LN1@setupListe

; 1670 : 	{
; 1671 : 		printerrorf("Fatal: Could not listen on any socket.\n");

  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@NMNKDLLC@Fatal?3?5Could?5not?5listen?5on?5any?5s@
  001d6	e8 00 00 00 00	 call	 printerrorf

; 1672 : 		return(!0);

  001db	b8 01 00 00 00	 mov	 eax, 1
  001e0	eb 02		 jmp	 SHORT $LN19@setupListe
$LN1@setupListe:

; 1673 : 	}
; 1674 : 
; 1675 : 	return 0;

  001e2	33 c0		 xor	 eax, eax
$LN19@setupListe:

; 1676 : }

  001e4	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  001e9	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  001ee	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001f2	41 5e		 pop	 r14
  001f4	5f		 pop	 rdi
  001f5	5e		 pop	 rsi
  001f6	c3		 ret	 0
setupListeningSockets ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT main
_TEXT	SEGMENT
main	PROC						; COMDAT

; 1681 : {

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1682 : 	global_argc = argc;
; 1683 : 	global_argv = argv;
; 1684 : 
; 1685 : #	ifdef _NTSERVICE
; 1686 : 	DWORD lasterror = ERROR_SUCCESS;
; 1687 : 
; 1688 : 	if (!StartServiceCtrlDispatcher(NTServiceDispatchTable) && (lasterror = GetLastError()) == ERROR_FAILED_SERVICE_CONTROLLER_CONNECT)

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0000a	3d 27 04 00 00	 cmp	 eax, 1063		; 00000427H
  0000f	75 0c		 jne	 SHORT $LN4@main

; 1689 : 	{
; 1690 : 		IsNTService = FALSE;//如果不把程序设成服务

  00011	c6 05 00 00 00
	00 00		 mov	 BYTE PTR IsNTService, 0

; 1691 : 		return newmain();//如果不安装服务从这里开始

  00018	e8 00 00 00 00	 call	 newmain
$LN4@main:

; 1692 : 	}
; 1693 : 
; 1694 : 	return lasterror;
; 1695 : #	else // !_NTSERVICE
; 1696 : 	return newmain();
; 1697 : #	endif // !_NTSERVICE
; 1698 : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
main	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\vlmcsd.c
;	COMDAT WinStartUp
_TEXT	SEGMENT
argc$ = 96
WinStartUp PROC						; COMDAT

; 1906 : {

$LN14:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 1907 : 	WCHAR **szArgList;
; 1908 : 	int argc;
; 1909 : 	szArgList = CommandLineToArgvW(GetCommandLineW(), &argc);

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCommandLineW
  00018	48 8d 54 24 60	 lea	 rdx, QWORD PTR argc$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CommandLineToArgvW

; 1910 : 
; 1911 : 	int i;
; 1912 : 	char **argv = (char**)vlmcsd_malloc(sizeof(char*)*argc);

  00026	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR argc$[rsp]
  0002b	48 c1 e1 03	 shl	 rcx, 3
  0002f	48 8b f0	 mov	 rsi, rax
  00032	e8 00 00 00 00	 call	 vlmcsd_malloc

; 1913 : 
; 1914 : 	for (i = 0; i < argc; i++)

  00037	8b 4c 24 60	 mov	 ecx, DWORD PTR argc$[rsp]
  0003b	45 33 f6	 xor	 r14d, r14d
  0003e	48 8b e8	 mov	 rbp, rax
  00041	85 c9		 test	 ecx, ecx
  00043	7e 7c		 jle	 SHORT $LN1@WinStartUp
  00045	48 8b f8	 mov	 rdi, rax
  00048	48 2b fe	 sub	 rdi, rsi
$LL3@WinStartUp:

; 1915 : 	{
; 1916 : 		int size = WideCharToMultiByte(CP_UTF8, 0, szArgList[i], -1, argv[i], 0, NULL, NULL);

  0004b	48 83 64 24 38
	00		 and	 QWORD PTR [rsp+56], 0
  00051	48 8b 04 37	 mov	 rax, QWORD PTR [rdi+rsi]
  00055	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  0005b	4c 8b 06	 mov	 r8, QWORD PTR [rsi]
  0005e	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  00063	41 83 c9 ff	 or	 r9d, -1
  00067	33 d2		 xor	 edx, edx
  00069	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  0006e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WideCharToMultiByte
  00079	48 63 d8	 movsxd	 rbx, eax

; 1917 : 		argv[i] = (char*)vlmcsd_malloc(size);

  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 vlmcsd_malloc

; 1918 : 		WideCharToMultiByte(CP_UTF8, 0, szArgList[i], -1, argv[i], size, NULL, NULL);

  00084	48 83 64 24 38
	00		 and	 QWORD PTR [rsp+56], 0
  0008a	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  00090	48 89 04 37	 mov	 QWORD PTR [rdi+rsi], rax
  00094	4c 8b 06	 mov	 r8, QWORD PTR [rsi]
  00097	41 83 c9 ff	 or	 r9d, -1
  0009b	33 d2		 xor	 edx, edx
  0009d	b9 e9 fd 00 00	 mov	 ecx, 65001		; 0000fde9H
  000a2	89 5c 24 28	 mov	 DWORD PTR [rsp+40], ebx
  000a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WideCharToMultiByte
  000b1	8b 4c 24 60	 mov	 ecx, DWORD PTR argc$[rsp]
  000b5	41 ff c6	 inc	 r14d
  000b8	48 8d 76 08	 lea	 rsi, QWORD PTR [rsi+8]
  000bc	44 3b f1	 cmp	 r14d, ecx
  000bf	7c 8a		 jl	 SHORT $LL3@WinStartUp
$LN1@WinStartUp:

; 1919 : 	}
; 1920 : 
; 1921 : 	exit(server_main(argc, argv));

  000c1	89 0d 00 00 00
	00		 mov	 DWORD PTR global_argc, ecx
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NTServiceDispatchTable
  000ce	48 89 2d 00 00
	00 00		 mov	 QWORD PTR global_argv, rbp
  000d5	33 db		 xor	 ebx, ebx
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_StartServiceCtrlDispatcherA
  000dd	85 c0		 test	 eax, eax
  000df	75 1d		 jne	 SHORT $LN7@WinStartUp
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  000e7	8b d8		 mov	 ebx, eax
  000e9	3d 27 04 00 00	 cmp	 eax, 1063		; 00000427H
  000ee	75 0e		 jne	 SHORT $LN7@WinStartUp
  000f0	c6 05 00 00 00
	00 00		 mov	 BYTE PTR IsNTService, 0
  000f7	e8 00 00 00 00	 call	 newmain
  000fc	8b d8		 mov	 ebx, eax
$LN7@WinStartUp:
  000fe	8b cb		 mov	 ecx, ebx
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00106	cc		 int	 3
$LN13@WinStartUp:
WinStartUp ENDP
_TEXT	ENDS
END
