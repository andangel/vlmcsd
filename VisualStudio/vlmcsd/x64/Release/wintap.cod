; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0L@NDMDBMPG@10?410?410?49?$AA@		; `string'
PUBLIC	??_C@_02PJNFELNH@30?$AA@			; `string'
PUBLIC	??_C@_02CEIGAHOJ@1d?$AA@			; `string'
PUBLIC	??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5ad@ ; `string'
PUBLIC	??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5m@ ; `string'
PUBLIC	??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4?5@ ; `string'
PUBLIC	??_C@_03OFAPEBGM@?$CFs?6?$AA@			; `string'
PUBLIC	??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0M@OCLPIPDG@ComponentId?$AA@		; `string'
PUBLIC	??_C@_07OCKMHPIG@tap0801?$AA@			; `string'
PUBLIC	??_C@_07FKBABIOD@tap0901?$AA@			; `string'
PUBLIC	??_C@_0O@LGAJAMKD@TEAMVIEWERVPN?$AA@		; `string'
PUBLIC	??_C@_0BB@BKNOGGLI@NetCfgInstanceId?$AA@	; `string'
PUBLIC	??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Control@ ; `string'
PUBLIC	??_C@_0M@CGLKMMLF@?2Connection?$AA@		; `string'
PUBLIC	??_C@_04FABLJDN@Name?$AA@			; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0M@KLEKCEEC@?2?2?4?2Global?2?$AA@		; `string'
PUBLIC	??_C@_04MFFLHGKN@?4tap?$AA@			; `string'
PUBLIC	??_C@_04PFKDJIIE@?4dgt?$AA@			; `string'
PUBLIC	??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapter@ ; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC?$AA@ ; `string'
PUBLIC	??_C@_0BE@BMEHODCL@?5available?5for?5use?6?$AA@	; `string'
PUBLIC	??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5?$CC@ ; `string'
PUBLIC	??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5threa@ ; `string'
PUBLIC	??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started?6@ ; `string'
PUBLIC	??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5ass@ ; `string'
PUBLIC	??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6?$AA@ ; `string'
EXTRN	__imp_RegCloseKey:PROC
EXTRN	__imp_inet_ntoa:PROC
EXTRN	__imp_inet_addr:PROC
EXTRN	__imp_DeviceIoControl:PROC
EXTRN	__imp_GetIpAddrTable:PROC
EXTRN	__imp_RegOpenKeyExA:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_RegEnumKeyExA:PROC
EXTRN	__imp_strtol:PROC
EXTRN	__imp_RegQueryValueExA:PROC
EXTRN	__imp_WriteFile:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_CreateFileA:PROC
;	COMDAT ??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6?$AA@
CONST	SEGMENT
??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6?$AA@ DB 'IPv4 address'
	DB	' %s assigned', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5ass@
CONST	SEGMENT
??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5ass@ DB 'Warning'
	DB	': IPv4 address %s not assigned', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started?6@
CONST	SEGMENT
??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started?6@ DB '%'
	DB	's %u.%u.%u device "%s" started', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5threa@
CONST	SEGMENT
??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5threa@ DB 'Fatal: Una'
	DB	'ble to start VPN thread: %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5?$CC@
CONST	SEGMENT
??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5?$CC@ DB 'Warning'
	DB	': VPN thread for device "%s" exiting: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6?$AA@ DB 'Fatal'
	DB	': VPN adapter error: %s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BMEHODCL@?5available?5for?5use?6?$AA@
CONST	SEGMENT
??_C@_0BE@BMEHODCL@?5available?5for?5use?6?$AA@ DB ' available for use', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC?$AA@
CONST	SEGMENT
??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC?$AA@ DB ' with name "%s"', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapter@
CONST	SEGMENT
??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapter@ DB 'Fatal: No c'
	DB	'ompatible VPN adapter', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04PFKDJIIE@?4dgt?$AA@
CONST	SEGMENT
??_C@_04PFKDJIIE@?4dgt?$AA@ DB '.dgt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04MFFLHGKN@?4tap?$AA@
CONST	SEGMENT
??_C@_04MFFLHGKN@?4tap?$AA@ DB '.tap', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@KLEKCEEC@?2?2?4?2Global?2?$AA@
CONST	SEGMENT
??_C@_0M@KLEKCEEC@?2?2?4?2Global?2?$AA@ DB '\\.\Global\', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04FABLJDN@Name?$AA@
CONST	SEGMENT
??_C@_04FABLJDN@Name?$AA@ DB 'Name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@CGLKMMLF@?2Connection?$AA@
CONST	SEGMENT
??_C@_0M@CGLKMMLF@?2Connection?$AA@ DB '\Connection', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE10'
	DB	'318}\', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@BKNOGGLI@NetCfgInstanceId?$AA@
CONST	SEGMENT
??_C@_0BB@BKNOGGLI@NetCfgInstanceId?$AA@ DB 'NetCfgInstanceId', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@LGAJAMKD@TEAMVIEWERVPN?$AA@
CONST	SEGMENT
??_C@_0O@LGAJAMKD@TEAMVIEWERVPN?$AA@ DB 'TEAMVIEWERVPN', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKBABIOD@tap0901?$AA@
CONST	SEGMENT
??_C@_07FKBABIOD@tap0901?$AA@ DB 'tap0901', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07OCKMHPIG@tap0801?$AA@
CONST	SEGMENT
??_C@_07OCKMHPIG@tap0801?$AA@ DB 'tap0801', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@OCLPIPDG@ComponentId?$AA@
CONST	SEGMENT
??_C@_0M@OCLPIPDG@ComponentId?$AA@ DB 'ComponentId', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Control@
CONST	SEGMENT
??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Control@ DB 'SYSTEM\Current'
	DB	'ControlSet\Control\Class\{4D36E972-E325-11CE-BFC1-08002BE1031'
	DB	'8}', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6?$AA@ DB 'Registry rea'
	DB	'd error: %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6?$AA@ DB 'between %s and %'
	DB	's', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_03OFAPEBGM@?$CFs?6?$AA@
CONST	SEGMENT
??_C@_03OFAPEBGM@?$CFs?6?$AA@ DB '%s', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4?5@
CONST	SEGMENT
??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4?5@ DB 'Fatal: Fo'
	DB	'r this subnet the IPv4 address must be ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5m@
CONST	SEGMENT
??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5m@ DB 'Fata'
	DB	'l: /%s is not a valid CIDR mask between /8 and /30', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5ad@
CONST	SEGMENT
??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5ad@ DB 'Fatal'
	DB	': %s is not a valid IPv4 address', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02CEIGAHOJ@1d?$AA@
CONST	SEGMENT
??_C@_02CEIGAHOJ@1d?$AA@ DB '1d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PJNFELNH@30?$AA@
CONST	SEGMENT
??_C@_02PJNFELNH@30?$AA@ DB '30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NDMDBMPG@10?410?410?49?$AA@
CONST	SEGMENT
??_C@_0L@NDMDBMPG@10?410?410?49?$AA@ DB '10.10.10.9', 00H ; `string'
szIpAddress DQ	FLAT:??_C@_0L@NDMDBMPG@10?410?410?49?$AA@
szLeaseDuration DQ FLAT:??_C@_02CEIGAHOJ@1d?$AA@
szMask	DQ	FLAT:??_C@_02PJNFELNH@30?$AA@
PUBLIC	startTap
Mask	DD	01H DUP (?)
Mtu	DD	01H DUP (?)
DhcpLeaseDuration DD 01H DUP (?)
Broadcast DD	01H DUP (?)
IpPacket DQ	01H DUP (?)
szTapName DQ	01H DUP (?)
ActiveTapName DQ 01H DUP (?)
Network	DD	01H DUP (?)
DriverVersion DB 010H DUP (?)
	ALIGN	8

TapHandle DQ	01H DUP (?)
DhcpServer DD	01H DUP (?)
IpAddress DD	01H DUP (?)
AdapterClass DQ	01H DUP (?)
Cidr	DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$TapMirror DD imagerel TapMirror
	DD	imagerel TapMirror+208
	DD	imagerel $unwind$TapMirror
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DevCtl DD imagerel DevCtl
	DD	imagerel DevCtl+107
	DD	imagerel $unwind$DevCtl
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$OpenTapHandle DD imagerel OpenTapHandle
	DD	imagerel OpenTapHandle+1192
	DD	imagerel $unwind$OpenTapHandle
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WinErrorExit DD imagerel WinErrorExit
	DD	imagerel WinErrorExit+37
	DD	imagerel $unwind$WinErrorExit
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$parseTapArgument DD imagerel parseTapArgument
	DD	imagerel parseTapArgument+577
	DD	imagerel $unwind$parseTapArgument
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$isAddressAssigned DD imagerel isAddressAssigned
	DD	imagerel isAddressAssigned+186
	DD	imagerel $unwind$isAddressAssigned
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$startTap DD imagerel $LN17
	DD	imagerel $LN17+497
	DD	imagerel $unwind$startTap
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$startTap DD 020a01H
	DD	03006920aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$isAddressAssigned DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$parseTapArgument DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WinErrorExit DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$OpenTapHandle DD 071601H
	DD	08a0116H
	DD	07005f007H
	DD	030036004H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DevCtl DD 020c01H
	DD	03008720cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$TapMirror DD 020601H
	DD	030025206H
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\wintap.c
;	COMDAT startTap
_TEXT	SEGMENT
tapTunCfg$ = 48
tapDhcpCfg$ = 64
argument$dead$ = 96
isCableConnected$ = 96
startTap PROC						; COMDAT

; 306  : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tapArgument

; 307  : 	if (!strcmp(argument, "-")) return;

  00011	8a 01		 mov	 al, BYTE PTR [rcx]
  00013	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JOAMLHOP@?9?$AA@
  00019	75 0f		 jne	 SHORT $LN14@startTap
  0001b	8a 41 01	 mov	 al, BYTE PTR [rcx+1]
  0001e	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JOAMLHOP@?9?$AA@+1
  00024	0f 84 c1 01 00
	00		 je	 $LN1@startTap
$LN14@startTap:

; 308  : 	parseTapArgument(argument);

  0002a	e8 00 00 00 00	 call	 parseTapArgument

; 309  : 
; 310  : 	TapHandle = OpenTapHandle();

  0002f	e8 00 00 00 00	 call	 OpenTapHandle

; 311  : 
; 312  : 	// Get MTU and driver version
; 313  : 	DevCtl(TAP_WIN_IOCTL_GET_MTU, &Mtu, sizeof(Mtu));

  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:Mtu
  0003b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00041	b9 0c 00 22 00	 mov	 ecx, 2228236		; 0022000cH
  00046	48 89 05 00 00
	00 00		 mov	 QWORD PTR TapHandle, rax
  0004d	e8 00 00 00 00	 call	 DevCtl

; 314  : 	DevCtl(TAP_WIN_IOCTL_GET_VERSION, &DriverVersion, sizeof(DriverVersion));

  00052	bb 10 00 00 00	 mov	 ebx, 16
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:DriverVersion
  0005e	44 8b c3	 mov	 r8d, ebx
  00061	b9 08 00 22 00	 mov	 ecx, 2228232		; 00220008H
  00066	e8 00 00 00 00	 call	 DevCtl

; 315  : 
; 316  : 	// Configure TUN mode
; 317  : 	TapConfigTun_t tapTunCfg;
; 318  : 	tapTunCfg.Address.s_addr = BE32(IpAddress);

  0006b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR IpAddress

; 319  : 	tapTunCfg.Network.s_addr = BE32(Network);
; 320  : 	tapTunCfg.Mask.s_addr = BE32(Mask);
; 321  : 	DevCtl(TAP_WIN_IOCTL_CONFIG_TUN, &tapTunCfg, sizeof(tapTunCfg));

  00071	44 8d 43 fc	 lea	 r8d, QWORD PTR [rbx-4]
  00075	0f c8		 bswap	 eax
  00077	48 8d 54 24 30	 lea	 rdx, QWORD PTR tapTunCfg$[rsp]
  0007c	b9 28 00 22 00	 mov	 ecx, 2228264		; 00220028H
  00081	89 44 24 30	 mov	 DWORD PTR tapTunCfg$[rsp], eax
  00085	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Network
  0008b	0f c8		 bswap	 eax
  0008d	89 44 24 34	 mov	 DWORD PTR tapTunCfg$[rsp+4], eax
  00091	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Mask
  00097	0f c8		 bswap	 eax
  00099	89 44 24 38	 mov	 DWORD PTR tapTunCfg$[rsp+8], eax
  0009d	e8 00 00 00 00	 call	 DevCtl

; 322  : 
; 323  : 	// Setup the drivers internal DHCP server
; 324  : 	TapConfigDhcp_t tapDhcpCfg;
; 325  : 	tapDhcpCfg.Address.s_addr = BE32(IpAddress);

  000a2	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR IpAddress
  000a8	8b c1		 mov	 eax, ecx

; 326  : 	tapDhcpCfg.Mask.s_addr = BE32(Mask);
; 327  : 	tapDhcpCfg.DhcpServer.s_addr = BE32(IpAddress + 1);
; 328  : 	tapDhcpCfg.LeaseDuration = DhcpLeaseDuration;
; 329  : 	DevCtl(TAP_WIN_IOCTL_CONFIG_DHCP_MASQ, &tapDhcpCfg, sizeof(tapDhcpCfg));

  000aa	48 8d 54 24 40	 lea	 rdx, QWORD PTR tapDhcpCfg$[rsp]
  000af	44 8b c3	 mov	 r8d, ebx
  000b2	0f c8		 bswap	 eax
  000b4	89 44 24 40	 mov	 DWORD PTR tapDhcpCfg$[rsp], eax
  000b8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR Mask
  000be	0f c8		 bswap	 eax
  000c0	89 44 24 44	 mov	 DWORD PTR tapDhcpCfg$[rsp+4], eax
  000c4	8d 41 01	 lea	 eax, DWORD PTR [rcx+1]
  000c7	b9 1c 00 22 00	 mov	 ecx, 2228252		; 0022001cH
  000cc	0f c8		 bswap	 eax
  000ce	89 44 24 48	 mov	 DWORD PTR tapDhcpCfg$[rsp+8], eax
  000d2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR DhcpLeaseDuration
  000d8	89 44 24 4c	 mov	 DWORD PTR tapDhcpCfg$[rsp+12], eax
  000dc	e8 00 00 00 00	 call	 DevCtl

; 330  : 
; 331  : 	// Connect the virtual network cable
; 332  : 	BOOL isCableConnected = TRUE;
; 333  : 	DevCtl(TAP_WIN_IOCTL_SET_MEDIA_STATUS, &isCableConnected, sizeof(isCableConnected));

  000e1	44 8d 43 f4	 lea	 r8d, QWORD PTR [rbx-12]
  000e5	48 8d 54 24 60	 lea	 rdx, QWORD PTR isCableConnected$[rsp]
  000ea	b9 18 00 22 00	 mov	 ecx, 2228248		; 00220018H
  000ef	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR isCableConnected$[rsp], 1
  000f7	e8 00 00 00 00	 call	 DevCtl

; 334  : 
; 335  : 	// Allocate buffer and start mirror thread
; 336  : 	IpPacket = (IpPacket_t*)vlmcsd_malloc(Mtu);

  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR Mtu
  00102	e8 00 00 00 00	 call	 vlmcsd_malloc

; 337  : 	HANDLE threadHandle = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)TapMirror, NULL, 0, NULL);

  00107	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  0010d	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00112	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:TapMirror
  00119	45 33 c9	 xor	 r9d, r9d
  0011c	33 d2		 xor	 edx, edx
  0011e	33 c9		 xor	 ecx, ecx
  00120	48 89 05 00 00
	00 00		 mov	 QWORD PTR IpPacket, rax
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateThread

; 338  : 
; 339  : 	if (!threadHandle)

  0012d	48 85 c0	 test	 rax, rax
  00130	75 27		 jne	 SHORT $LN6@startTap

; 340  : 	{
; 341  : 		DWORD error = GetLastError();

  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 342  : 		printerrorf("Fatal: Unable to start VPN thread: %s\n", win_strerror(error));

  00138	8b c8		 mov	 ecx, eax
  0013a	8b d8		 mov	 ebx, eax
  0013c	e8 00 00 00 00	 call	 win_strerror
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@NAGFFDOL@Fatal?3?5Unable?5to?5start?5VPN?5threa@
  00148	48 8b d0	 mov	 rdx, rax
  0014b	e8 00 00 00 00	 call	 printerrorf

; 343  : 		exit(error);

  00150	8b cb		 mov	 ecx, ebx
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00158	cc		 int	 3
$LN6@startTap:

; 344  : 	}
; 345  : 
; 346  : 	CloseHandle(threadHandle);

  00159	48 8b c8	 mov	 rcx, rax
  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 347  : 
; 348  : #	ifndef NO_LOG
; 349  : 	logger("%s %u.%u.%u device \"%s\" started\n", AdapterClass, DriverVersion.Major, DriverVersion.Minor, DriverVersion.Build, ActiveTapName);

  00162	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ActiveTapName
  00169	44 8b 0d 04 00
	00 00		 mov	 r9d, DWORD PTR DriverVersion+4
  00170	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR DriverVersion
  00177	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR AdapterClass
  0017e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00183	8b 05 08 00 00
	00		 mov	 eax, DWORD PTR DriverVersion+8
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@OMLABOLI@?$CFs?5?$CFu?4?$CFu?4?$CFu?5device?5?$CC?$CFs?$CC?5started?6@
  00190	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00194	e8 00 00 00 00	 call	 logger

; 350  : #	endif // NO_LOG
; 351  : 
; 352  : 	DWORD i;
; 353  : 	BOOL isAssigned;
; 354  : 
; 355  : 	// Wait up to 4 seconds until the IP address is up and running
; 356  : 	// so vlmcsd can actually bind to and listen on it
; 357  : 	for (i = 0; !((isAssigned = isAddressAssigned())) && i < 20; i++) Sleep(200);

  00199	33 db		 xor	 ebx, ebx
  0019b	e8 00 00 00 00	 call	 isAddressAssigned
  001a0	85 c0		 test	 eax, eax
  001a2	75 34		 jne	 SHORT $LN2@startTap
$LL5@startTap:
  001a4	83 fb 14	 cmp	 ebx, 20
  001a7	73 16		 jae	 SHORT $LN3@startTap
  001a9	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
  001b4	ff c3		 inc	 ebx
  001b6	e8 00 00 00 00	 call	 isAddressAssigned
  001bb	85 c0		 test	 eax, eax
  001bd	74 e5		 je	 SHORT $LL5@startTap
$LN3@startTap:

; 358  : 
; 359  : 	if (!isAssigned)

  001bf	85 c0		 test	 eax, eax
  001c1	75 15		 jne	 SHORT $LN2@startTap

; 360  : 	{
; 361  : 		printerrorf("Warning: IPv4 address %s not assigned\n", szIpAddress);

  001c3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR szIpAddress
  001ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@JFGMNELN@Warning?3?5IPv4?5address?5?$CFs?5not?5ass@
  001d1	e8 00 00 00 00	 call	 printerrorf

; 362  : 	}
; 363  : 	else

  001d6	eb 13		 jmp	 SHORT $LN1@startTap
$LN2@startTap:

; 364  : 	{
; 365  : #		ifndef NO_LOG
; 366  : 		logger("IPv4 address %s assigned\n", szIpAddress);

  001d8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR szIpAddress
  001df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BK@BLPEDMFB@IPv4?5address?5?$CFs?5assigned?6?$AA@
  001e6	e8 00 00 00 00	 call	 logger
$LN1@startTap:

; 367  : #		endif // NO_LOG
; 368  : 	}
; 369  : }

  001eb	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001ef	5b		 pop	 rbx
  001f0	c3		 ret	 0
$LN16@startTap:
startTap ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\wintap.c
;	COMDAT isAddressAssigned
_TEXT	SEGMENT
dwSize$ = 48
isAddressAssigned PROC					; COMDAT

; 39   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 40   : 	PMIB_IPADDRTABLE pIPAddrTable;
; 41   : 	DWORD dwSize = 0;

  0000f	33 f6		 xor	 esi, esi
  00011	89 74 24 30	 mov	 DWORD PTR dwSize$[rsp], esi

; 42   : 	BOOL result = FALSE;
; 43   : 
; 44   : 	pIPAddrTable = (PMIB_IPADDRTABLE)vlmcsd_malloc(sizeof(MIB_IPADDRTABLE));

  00015	8d 4e 1c	 lea	 ecx, QWORD PTR [rsi+28]
  00018	e8 00 00 00 00	 call	 vlmcsd_malloc

; 45   : 	DWORD status = GetIpAddrTable(pIPAddrTable, &dwSize, 0);

  0001d	48 8d 54 24 30	 lea	 rdx, QWORD PTR dwSize$[rsp]
  00022	45 33 c0	 xor	 r8d, r8d
  00025	48 8b c8	 mov	 rcx, rax
  00028	48 8b f8	 mov	 rdi, rax
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetIpAddrTable

; 46   : 	free(pIPAddrTable);

  00031	48 8b cf	 mov	 rcx, rdi
  00034	8b d8		 mov	 ebx, eax
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 47   : 
; 48   : 	if (status != ERROR_INSUFFICIENT_BUFFER) return FALSE;

  0003c	83 fb 7a	 cmp	 ebx, 122		; 0000007aH
  0003f	74 04		 je	 SHORT $LN6@isAddressA
  00041	33 c0		 xor	 eax, eax
  00043	eb 65		 jmp	 SHORT $LN7@isAddressA
$LN6@isAddressA:

; 49   : 	pIPAddrTable = (MIB_IPADDRTABLE *)vlmcsd_malloc(dwSize);

  00045	8b 4c 24 30	 mov	 ecx, DWORD PTR dwSize$[rsp]
  00049	e8 00 00 00 00	 call	 vlmcsd_malloc

; 50   : 
; 51   : 	if (GetIpAddrTable(pIPAddrTable, &dwSize, 0))

  0004e	48 8d 54 24 30	 lea	 rdx, QWORD PTR dwSize$[rsp]
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b c8	 mov	 rcx, rax
  00059	48 8b d8	 mov	 rbx, rax
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetIpAddrTable
  00062	85 c0		 test	 eax, eax
  00064	75 39		 jne	 SHORT $LN15@isAddressA

; 55   : 	}
; 56   : 
; 57   : 	PMIB_IPADDRROW row;
; 58   : 	for (row = pIPAddrTable->table; row < pIPAddrTable->table + pIPAddrTable->dwNumEntries; row++)

  00066	8b 03		 mov	 eax, DWORD PTR [rbx]
  00068	4c 8d 43 04	 lea	 r8, QWORD PTR [rbx+4]
  0006c	48 8d 53 04	 lea	 rdx, QWORD PTR [rbx+4]
  00070	48 8d 0c 40	 lea	 rcx, QWORD PTR [rax+rax*2]
  00074	4d 8d 04 c8	 lea	 r8, QWORD PTR [r8+rcx*8]
  00078	49 3b d0	 cmp	 rdx, r8
  0007b	73 22		 jae	 SHORT $LN15@isAddressA
  0007d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR IpAddress
  00083	0f c8		 bswap	 eax
$LL4@isAddressA:

; 59   : 	{
; 60   : 		if (
; 61   : 			row->dwAddr == BE32(IpAddress) &&
; 62   : 			!(row->wType & (MIB_IPADDR_DELETED | MIB_IPADDR_DISCONNECTED | MIB_IPADDR_TRANSIENT))
; 63   : 			)

  00085	39 02		 cmp	 DWORD PTR [rdx], eax
  00087	75 06		 jne	 SHORT $LN3@isAddressA
  00089	f6 42 16 c8	 test	 BYTE PTR [rdx+22], 200	; 000000c8H
  0008d	74 0b		 je	 SHORT $LN10@isAddressA
$LN3@isAddressA:

; 55   : 	}
; 56   : 
; 57   : 	PMIB_IPADDRROW row;
; 58   : 	for (row = pIPAddrTable->table; row < pIPAddrTable->table + pIPAddrTable->dwNumEntries; row++)

  0008f	48 83 c2 18	 add	 rdx, 24
  00093	49 3b d0	 cmp	 rdx, r8
  00096	73 07		 jae	 SHORT $LN15@isAddressA
  00098	eb eb		 jmp	 SHORT $LL4@isAddressA
$LN10@isAddressA:

; 64   : 		{
; 65   : 			result = TRUE;

  0009a	be 01 00 00 00	 mov	 esi, 1
$LN15@isAddressA:

; 52   : 	{
; 53   : 		free(pIPAddrTable);

  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 54   : 		return FALSE;

  000a8	8b c6		 mov	 eax, esi
$LN7@isAddressA:

; 66   : 			break;
; 67   : 		}
; 68   : 	}
; 69   : 
; 70   : 	free(pIPAddrTable);
; 71   : 	return result;
; 72   : }

  000aa	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000af	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000b4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
isAddressAssigned ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\wintap.c
;	COMDAT parseTapArgument
_TEXT	SEGMENT
next$ = 48
argument$ = 48
parseTapArgument PROC					; COMDAT

; 76   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 77   : 	char* equalsignPosition = strchr(argument, (int)'=');

  00014	ba 3d 00 00 00	 mov	 edx, 61			; 0000003dH
  00019	48 8b d9	 mov	 rbx, rcx
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr

; 78   : 	char* slashPosition = strchr(argument, (int)'/');

  00022	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00027	48 8b cb	 mov	 rcx, rbx
  0002a	48 8b f0	 mov	 rsi, rax
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr

; 79   : 	char* colonPosition = strchr(argument, (int)':');

  00033	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  00038	48 8b cb	 mov	 rcx, rbx
  0003b	48 8b f8	 mov	 rdi, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr

; 80   : 
; 81   : 	szTapName = argument;

  00044	48 89 1d 00 00
	00 00		 mov	 QWORD PTR szTapName, rbx
  0004b	48 8b d0	 mov	 rdx, rax

; 82   : 
; 83   : 	if (equalsignPosition)

  0004e	48 85 f6	 test	 rsi, rsi
  00051	74 10		 je	 SHORT $LN27@parseTapAr

; 84   : 	{
; 85   : 		*equalsignPosition = 0;
; 86   : 		szIpAddress = equalsignPosition + 1;

  00053	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
  00057	c6 06 00	 mov	 BYTE PTR [rsi], 0
  0005a	48 89 0d 00 00
	00 00		 mov	 QWORD PTR szIpAddress, rcx
  00061	eb 07		 jmp	 SHORT $LN11@parseTapAr
$LN27@parseTapAr:
  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR szIpAddress
$LN11@parseTapAr:

; 87   : 	}
; 88   : 
; 89   : 	if (slashPosition)

  0006a	48 85 ff	 test	 rdi, rdi
  0006d	74 0e		 je	 SHORT $LN10@parseTapAr

; 90   : 	{
; 91   : 		*slashPosition = 0;
; 92   : 		szMask = slashPosition + 1;

  0006f	48 8d 47 01	 lea	 rax, QWORD PTR [rdi+1]
  00073	c6 07 00	 mov	 BYTE PTR [rdi], 0
  00076	48 89 05 00 00
	00 00		 mov	 QWORD PTR szMask, rax
$LN10@parseTapAr:

; 93   : 	}
; 94   : 
; 95   : 	if (colonPosition)

  0007d	48 85 d2	 test	 rdx, rdx
  00080	74 0e		 je	 SHORT $LN9@parseTapAr

; 96   : 	{
; 97   : 		*colonPosition = 0;
; 98   : 		szLeaseDuration = colonPosition + 1;

  00082	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00086	c6 02 00	 mov	 BYTE PTR [rdx], 0
  00089	48 89 05 00 00
	00 00		 mov	 QWORD PTR szLeaseDuration, rax
$LN9@parseTapAr:

; 99   : 	}
; 100  : 
; 101  : 	IpAddress = BE32(inet_addr(szIpAddress));

  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_addr

; 102  : 
; 103  : 	if (IpAddress == BE32(INADDR_NONE))

  00096	83 cb ff	 or	 ebx, -1			; ffffffffH
  00099	0f c8		 bswap	 eax
  0009b	89 05 00 00 00
	00		 mov	 DWORD PTR IpAddress, eax
  000a1	3b c3		 cmp	 eax, ebx
  000a3	75 1f		 jne	 SHORT $LN8@parseTapAr

; 104  : 	{
; 105  : 		printerrorf("Fatal: %s is not a valid IPv4 address\n", szIpAddress);

  000a5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR szIpAddress
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CH@DOIKMOID@Fatal?3?5?$CFs?5is?5not?5a?5valid?5IPv4?5ad@
  000b3	e8 00 00 00 00	 call	 printerrorf

; 106  : 		exit(VLMCSD_EINVAL);

  000b8	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  000c3	cc		 int	 3
$LN8@parseTapAr:

; 107  : 	}
; 108  : 
; 109  : 	char* next;
; 110  : 	Cidr = (uint8_t)strtol(szMask, &next, 10);

  000c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR szMask
  000cb	48 8d 54 24 30	 lea	 rdx, QWORD PTR next$[rsp]
  000d0	41 b8 0a 00 00
	00		 mov	 r8d, 10
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtol

; 111  : 
; 112  : 	if (*next || Cidr < 8 || Cidr > 30)

  000dc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR next$[rsp]
  000e1	80 39 00	 cmp	 BYTE PTR [rcx], 0
  000e4	88 05 00 00 00
	00		 mov	 BYTE PTR Cidr, al
  000ea	0f 85 1d 01 00
	00		 jne	 $LN6@parseTapAr
  000f0	2c 08		 sub	 al, 8
  000f2	3c 16		 cmp	 al, 22
  000f4	0f 87 13 01 00
	00		 ja	 $LN6@parseTapAr

; 116  : 	}
; 117  : 
; 118  : 	if (!((DhcpLeaseDuration = timeSpanString2Seconds(szLeaseDuration))))

  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR szLeaseDuration
  00101	e8 00 00 00 00	 call	 timeSpanString2Seconds
  00106	89 05 00 00 00
	00		 mov	 DWORD PTR DhcpLeaseDuration, eax
  0010c	85 c0		 test	 eax, eax
  0010e	75 1b		 jne	 SHORT $LN5@parseTapAr

; 119  : 	{
; 120  : 		printerrorf("Fatal: No valid time span specified in option -%c.\n", 'O');

  00110	8d 50 4f	 lea	 edx, QWORD PTR [rax+79]
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DE@FKNLKBBJ@Fatal?3?5No?5valid?5time?5span?5specif@
  0011a	e8 00 00 00 00	 call	 printerrorf

; 121  : 		exit(VLMCSD_EINVAL);

  0011f	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0012a	cc		 int	 3
$LN5@parseTapAr:

; 122  : 	}
; 123  : 
; 124  : 	Mask = (uint32_t)~(0xffffffff >> Cidr);
; 125  : 	Network = IpAddress & Mask;

  0012b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR IpAddress
  00131	8a 0d 00 00 00
	00		 mov	 cl, BYTE PTR Cidr
  00137	d3 eb		 shr	 ebx, cl

; 126  : 	Broadcast = IpAddress | ~Mask;
; 127  : 	DhcpServer = IpAddress + 1;

  00139	8d 48 01	 lea	 ecx, DWORD PTR [rax+1]
  0013c	f7 d3		 not	 ebx
  0013e	89 0d 00 00 00
	00		 mov	 DWORD PTR DhcpServer, ecx
  00144	8b f3		 mov	 esi, ebx
  00146	89 1d 00 00 00
	00		 mov	 DWORD PTR Mask, ebx
  0014c	f7 d3		 not	 ebx
  0014e	23 f0		 and	 esi, eax
  00150	0b d8		 or	 ebx, eax
  00152	89 1d 00 00 00
	00		 mov	 DWORD PTR Broadcast, ebx
  00158	89 35 00 00 00
	00		 mov	 DWORD PTR Network, esi

; 128  : 
; 129  : 	if (IpAddress <= Network || IpAddress + 1 >= Broadcast)

  0015e	3b c6		 cmp	 eax, esi
  00160	76 08		 jbe	 SHORT $LN3@parseTapAr
  00162	3b cb		 cmp	 ecx, ebx
  00164	0f 82 c2 00 00
	00		 jb	 $LN4@parseTapAr
$LN3@parseTapAr:

; 130  : 	{
; 131  : 		uint32_t lowerIpBE = BE32(Network + 1);

  0016a	ff c6		 inc	 esi

; 132  : 		uint32_t upperIpBE = BE32(Broadcast - 2);

  0016c	83 c3 fe	 add	 ebx, -2			; fffffffeH
  0016f	0f ce		 bswap	 esi

; 133  : 		const char* szLower = vlmcsd_strdup(inet_ntoa(*(struct in_addr*)&lowerIpBE));

  00171	8b ce		 mov	 ecx, esi
  00173	0f cb		 bswap	 ebx
  00175	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  0017b	48 8b c8	 mov	 rcx, rax
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  00184	48 8b f8	 mov	 rdi, rax
  00187	48 85 c0	 test	 rax, rax
  0018a	75 16		 jne	 SHORT $LN14@parseTapAr
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  00193	e8 00 00 00 00	 call	 errorout
  00198	8d 4f 0e	 lea	 ecx, QWORD PTR [rdi+14]
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  001a1	cc		 int	 3
$LN14@parseTapAr:

; 134  : 		const char* szUpper = vlmcsd_strdup(inet_ntoa(*(struct in_addr*)&upperIpBE));

  001a2	8b cb		 mov	 ecx, ebx
  001a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  001aa	48 8b c8	 mov	 rcx, rax
  001ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  001b3	48 8b e8	 mov	 rbp, rax
  001b6	48 85 c0	 test	 rax, rax
  001b9	75 16		 jne	 SHORT $LN21@parseTapAr
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  001c2	e8 00 00 00 00	 call	 errorout
  001c7	8d 4d 0e	 lea	 ecx, QWORD PTR [rbp+14]
  001ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  001d0	cc		 int	 3
$LN21@parseTapAr:

; 135  : 
; 136  : 		printerrorf("Fatal: For this subnet the IPv4 address must be ");

  001d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@CHHGCPLE@Fatal?3?5For?5this?5subnet?5the?5IPv4?5@
  001d8	e8 00 00 00 00	 call	 printerrorf

; 137  : 
; 138  : 		if (lowerIpBE == upperIpBE)
; 139  : 		{
; 140  : 			printerrorf("%s\n", szLower);

  001dd	48 8b d7	 mov	 rdx, rdi
  001e0	3b f3		 cmp	 esi, ebx
  001e2	75 0e		 jne	 SHORT $LN2@parseTapAr
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_03OFAPEBGM@?$CFs?6?$AA@
  001eb	e8 00 00 00 00	 call	 printerrorf

; 141  : 		}
; 142  : 		else

  001f0	eb 0f		 jmp	 SHORT $LN1@parseTapAr
$LN2@parseTapAr:

; 143  : 		{
; 144  : 			printerrorf("between %s and %s\n", szLower, szUpper);

  001f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BD@FPKCLNPH@between?5?$CFs?5and?5?$CFs?6?$AA@
  001f9	4c 8b c5	 mov	 r8, rbp
  001fc	e8 00 00 00 00	 call	 printerrorf
$LN1@parseTapAr:

; 145  : 		}
; 146  : 
; 147  : 		exit(VLMCSD_EINVAL);

  00201	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0020c	cc		 int	 3
$LN6@parseTapAr:

; 113  : 	{
; 114  : 		printerrorf("Fatal: /%s is not a valid CIDR mask between /8 and /30\n", szMask);

  0020d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR szMask
  00214	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DI@JFHCCLJH@Fatal?3?5?1?$CFs?5is?5not?5a?5valid?5CIDR?5m@
  0021b	e8 00 00 00 00	 call	 printerrorf

; 115  : 		exit(VLMCSD_EINVAL);

  00220	b9 57 00 00 00	 mov	 ecx, 87			; 00000057H
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0022b	cc		 int	 3
$LN4@parseTapAr:

; 148  : 	}
; 149  : }

  0022c	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00231	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00236	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0023b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0023f	5f		 pop	 rdi
  00240	c3		 ret	 0
$LN29@parseTapAr:
parseTapArgument ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\wintap.c
;	COMDAT WinErrorExit
_TEXT	SEGMENT
error$ = 48
WinErrorExit PROC					; COMDAT

; 153  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	8b d9		 mov	 ebx, ecx

; 154  : 	printerrorf("Registry read error: %s\n", win_strerror((int)error));

  00008	e8 00 00 00 00	 call	 win_strerror
  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6?$AA@
  00014	48 8b d0	 mov	 rdx, rax
  00017	e8 00 00 00 00	 call	 printerrorf

; 155  : 	exit(error);

  0001c	8b cb		 mov	 ecx, ebx
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00024	cc		 int	 3
$LN3@WinErrorEx:
WinErrorExit ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\wintap.c
;	COMDAT OpenTapHandle
_TEXT	SEGMENT
regSubKey$1 = 64
connectionKey$2 = 72
regData$3 = 80
deviceName$4 = 336
connectionKeyName$5 = 592
subkeyName$ = 848
regDataSize$6 = 1152
type$7 = 1160
subKeySize$ = 1168
regAdapterKey$ = 1176
OpenTapHandle PROC					; COMDAT

; 160  : {

  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 57		 push	 r15
  00007	48 8d ac 24 b0
	fc ff ff	 lea	 rbp, QWORD PTR [rsp-848]
  0000f	48 81 ec 50 04
	00 00		 sub	 rsp, 1104		; 00000450H

; 161  : 	HANDLE handle = INVALID_HANDLE_VALUE;
; 162  : 	HKEY regAdapterKey;
; 163  : 	DWORD regResult;
; 164  : 	if ((regResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, ADAPTER_KEY, 0, KEY_READ | KEY_WOW64_64KEY, &regAdapterKey)) != ERROR_SUCCESS)

  00016	48 8d 85 98 03
	00 00		 lea	 rax, QWORD PTR regAdapterKey$[rbp-256]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EO@PDNJMHLD@SYSTEM?2CurrentControlSet?2Control@
  00024	41 b9 19 01 02
	00		 mov	 r9d, 131353		; 00020119H
  0002a	45 33 c0	 xor	 r8d, r8d
  0002d	48 c7 c1 02 00
	00 80		 mov	 rcx, -2147483646	; ffffffff80000002H
  00034	48 83 cf ff	 or	 rdi, -1
  00038	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExA
  00043	8b d8		 mov	 ebx, eax
  00045	85 c0		 test	 eax, eax
  00047	74 1f		 je	 SHORT $LN19@OpenTapHan

; 165  : 	{
; 166  : 		WinErrorExit(regResult);

  00049	8b c8		 mov	 ecx, eax
  0004b	e8 00 00 00 00	 call	 win_strerror
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6?$AA@
  00057	48 8b d0	 mov	 rdx, rax
  0005a	e8 00 00 00 00	 call	 printerrorf
  0005f	8b cb		 mov	 ecx, ebx
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00067	cc		 int	 3
$LN19@OpenTapHan:

; 167  : 	}
; 168  : 
; 169  : 	char subkeyName[TAP_REGISTRY_DATA_SIZE];
; 170  : 	DWORD i, subKeySize = sizeof(subkeyName);
; 171  : 
; 172  : 	for (i = 0; (regResult = RegEnumKeyEx(regAdapterKey, i, subkeyName, &subKeySize, NULL, NULL, NULL, NULL)) != ERROR_NO_MORE_ITEMS; i++)

  00068	33 f6		 xor	 esi, esi
  0006a	41 bf 00 01 00
	00		 mov	 r15d, 256		; 00000100H
  00070	48 21 74 24 38	 and	 QWORD PTR [rsp+56], rsi
  00075	48 21 74 24 30	 and	 QWORD PTR [rsp+48], rsi
  0007a	48 21 74 24 28	 and	 QWORD PTR [rsp+40], rsi
  0007f	48 21 74 24 20	 and	 QWORD PTR [rsp+32], rsi
  00084	44 89 bd 90 03
	00 00		 mov	 DWORD PTR subKeySize$[rbp-256], r15d
  0008b	33 d2		 xor	 edx, edx
$LN51@OpenTapHan:
  0008d	48 8b 8d 98 03
	00 00		 mov	 rcx, QWORD PTR regAdapterKey$[rbp-256]
  00094	4c 8d 8d 90 03
	00 00		 lea	 r9, QWORD PTR subKeySize$[rbp-256]
  0009b	4c 8d 85 50 02
	00 00		 lea	 r8, QWORD PTR subkeyName$[rbp-256]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegEnumKeyExA
  000a8	8b d8		 mov	 ebx, eax
  000aa	3d 03 01 00 00	 cmp	 eax, 259		; 00000103H
  000af	0f 84 75 03 00
	00		 je	 $LN43@OpenTapHan

; 173  : 	{
; 174  : 		HKEY regSubKey;
; 175  : 		DWORD type, regDataSize;
; 176  : 		char regData[TAP_REGISTRY_DATA_SIZE];
; 177  : 
; 178  : 		if (regResult) WinErrorExit(regResult);

  000b5	85 c0		 test	 eax, eax
  000b7	0f 85 4e 03 00
	00		 jne	 $LN40@OpenTapHan

; 179  : 
; 180  : 		if ((regResult = RegOpenKeyEx(regAdapterKey, subkeyName, 0, KEY_READ | KEY_WOW64_64KEY, &regSubKey)) == ERROR_SUCCESS)

  000bd	48 8b 8d 98 03
	00 00		 mov	 rcx, QWORD PTR regAdapterKey$[rbp-256]
  000c4	48 8d 44 24 40	 lea	 rax, QWORD PTR regSubKey$1[rsp]
  000c9	48 8d 95 50 02
	00 00		 lea	 rdx, QWORD PTR subkeyName$[rbp-256]
  000d0	41 b9 19 01 02
	00		 mov	 r9d, 131353		; 00020119H
  000d6	45 33 c0	 xor	 r8d, r8d
  000d9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExA
  000e4	85 c0		 test	 eax, eax
  000e6	0f 85 b6 02 00
	00		 jne	 $LN5@OpenTapHan

; 181  : 		{
; 182  : 			regDataSize = sizeof(regData);
; 183  : 
; 184  : 			if (RegQueryValueEx(regSubKey, "ComponentId", NULL, &type, (LPBYTE)regData, &regDataSize) == ERROR_SUCCESS)

  000ec	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regSubKey$1[rsp]
  000f1	48 8d 85 80 03
	00 00		 lea	 rax, QWORD PTR regDataSize$6[rbp-256]
  000f8	4c 8d 8d 88 03
	00 00		 lea	 r9, QWORD PTR type$7[rbp-256]
  000ff	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00104	48 8d 44 24 50	 lea	 rax, QWORD PTR regData$3[rsp]
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@OCLPIPDG@ComponentId?$AA@
  00110	45 33 c0	 xor	 r8d, r8d
  00113	44 89 bd 80 03
	00 00		 mov	 DWORD PTR regDataSize$6[rbp-256], r15d
  0011a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExA
  00125	85 c0		 test	 eax, eax
  00127	0f 85 75 02 00
	00		 jne	 $LN5@OpenTapHan

; 185  : 			{
; 186  : 				if (
; 187  : 					type == REG_SZ &&
; 188  : 					(
; 189  : 						!strncmp(regData, "tap0801", sizeof(regData)) ||
; 190  : 						!strncmp(regData, "tap0901", sizeof(regData)) ||
; 191  : 						!strncmp(regData, "TEAMVIEWERVPN", sizeof(regData))
; 192  : 						)
; 193  : 					)

  0012d	83 bd 88 03 00
	00 01		 cmp	 DWORD PTR type$7[rbp-256], 1
  00134	0f 85 68 02 00
	00		 jne	 $LN5@OpenTapHan
  0013a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07OCKMHPIG@tap0801?$AA@
  00141	48 8d 4c 24 50	 lea	 rcx, QWORD PTR regData$3[rsp]
  00146	4d 8b c7	 mov	 r8, r15
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0014f	85 c0		 test	 eax, eax
  00151	74 36		 je	 SHORT $LN11@OpenTapHan
  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07FKBABIOD@tap0901?$AA@
  0015a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR regData$3[rsp]
  0015f	4d 8b c7	 mov	 r8, r15
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00168	85 c0		 test	 eax, eax
  0016a	74 1d		 je	 SHORT $LN11@OpenTapHan
  0016c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@LGAJAMKD@TEAMVIEWERVPN?$AA@
  00173	48 8d 4c 24 50	 lea	 rcx, QWORD PTR regData$3[rsp]
  00178	4d 8b c7	 mov	 r8, r15
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00181	85 c0		 test	 eax, eax
  00183	0f 85 19 02 00
	00		 jne	 $LN5@OpenTapHan
$LN11@OpenTapHan:

; 194  : 				{
; 195  : 					AdapterClass = vlmcsd_strdup(regData);

  00189	48 8d 4c 24 50	 lea	 rcx, QWORD PTR regData$3[rsp]
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  00194	48 85 c0	 test	 rax, rax
  00197	0f 84 56 02 00
	00		 je	 $LN41@OpenTapHan

; 196  : 					regDataSize = sizeof(regData);
; 197  : 
; 198  : 					if (RegQueryValueEx(regSubKey, "NetCfgInstanceId", NULL, &type, (LPBYTE)regData, &regDataSize) == ERROR_SUCCESS && type == REG_SZ)

  0019d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regSubKey$1[rsp]
  001a2	48 89 05 00 00
	00 00		 mov	 QWORD PTR AdapterClass, rax
  001a9	48 8d 85 80 03
	00 00		 lea	 rax, QWORD PTR regDataSize$6[rbp-256]
  001b0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b5	48 8d 44 24 50	 lea	 rax, QWORD PTR regData$3[rsp]
  001ba	4c 8d 8d 88 03
	00 00		 lea	 r9, QWORD PTR type$7[rbp-256]
  001c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@BKNOGGLI@NetCfgInstanceId?$AA@
  001c8	45 33 c0	 xor	 r8d, r8d
  001cb	44 89 bd 80 03
	00 00		 mov	 DWORD PTR regDataSize$6[rbp-256], r15d
  001d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExA
  001dd	85 c0		 test	 eax, eax
  001df	0f 85 b0 01 00
	00		 jne	 $LN47@OpenTapHan
  001e5	83 bd 88 03 00
	00 01		 cmp	 DWORD PTR type$7[rbp-256], 1
  001ec	0f 85 a3 01 00
	00		 jne	 $LN47@OpenTapHan

; 199  : 					{
; 200  : 						HKEY connectionKey;
; 201  : 						char connectionKeyName[TAP_REGISTRY_DATA_SIZE];
; 202  : 
; 203  : 						strncpy(connectionKeyName, NETWORK_CONNECTIONS_KEY "\\", sizeof(connectionKeyName));

  001f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FB@DAALEALL@SYSTEM?2CurrentControlSet?2Control@
  001f9	48 8d 8d 50 01
	00 00		 lea	 rcx, QWORD PTR connectionKeyName$5[rbp-256]
  00200	4d 8b c7	 mov	 r8, r15
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 204  : 						strncat(connectionKeyName, regData, sizeof(connectionKeyName));

  00209	48 8d 54 24 50	 lea	 rdx, QWORD PTR regData$3[rsp]
  0020e	48 8d 8d 50 01
	00 00		 lea	 rcx, QWORD PTR connectionKeyName$5[rbp-256]
  00215	4d 8b c7	 mov	 r8, r15
  00218	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat

; 205  : 						strncat(connectionKeyName, "\\Connection", sizeof(connectionKeyName));

  0021e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@CGLKMMLF@?2Connection?$AA@
  00225	48 8d 8d 50 01
	00 00		 lea	 rcx, QWORD PTR connectionKeyName$5[rbp-256]
  0022c	4d 8b c7	 mov	 r8, r15
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat

; 206  : 
; 207  : 						if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, connectionKeyName, 0, KEY_READ | KEY_WOW64_64KEY, &connectionKey) == ERROR_SUCCESS)

  00235	48 8d 44 24 48	 lea	 rax, QWORD PTR connectionKey$2[rsp]
  0023a	48 8d 95 50 01
	00 00		 lea	 rdx, QWORD PTR connectionKeyName$5[rbp-256]
  00241	41 b9 19 01 02
	00		 mov	 r9d, 131353		; 00020119H
  00247	45 33 c0	 xor	 r8d, r8d
  0024a	48 c7 c1 02 00
	00 80		 mov	 rcx, -2147483646	; ffffffff80000002H
  00251	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExA
  0025c	85 c0		 test	 eax, eax
  0025e	0f 85 20 01 00
	00		 jne	 $LN7@OpenTapHan

; 208  : 						{
; 209  : 							char deviceName[TAP_REGISTRY_DATA_SIZE];
; 210  : 							regDataSize = sizeof(deviceName);
; 211  : 
; 212  : 							if (RegQueryValueEx(connectionKey, "Name", NULL, &type, (LPBYTE)deviceName, &regDataSize) == ERROR_SUCCESS && type == REG_SZ)

  00264	48 8b 4c 24 48	 mov	 rcx, QWORD PTR connectionKey$2[rsp]
  00269	48 8d 85 80 03
	00 00		 lea	 rax, QWORD PTR regDataSize$6[rbp-256]
  00270	4c 8d 8d 88 03
	00 00		 lea	 r9, QWORD PTR type$7[rbp-256]
  00277	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0027c	48 8d 45 50	 lea	 rax, QWORD PTR deviceName$4[rbp-256]
  00280	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04FABLJDN@Name?$AA@
  00287	45 33 c0	 xor	 r8d, r8d
  0028a	44 89 bd 80 03
	00 00		 mov	 DWORD PTR regDataSize$6[rbp-256], r15d
  00291	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExA
  0029c	85 c0		 test	 eax, eax
  0029e	0f 85 e0 00 00
	00		 jne	 $LN7@OpenTapHan
  002a4	83 bd 88 03 00
	00 01		 cmp	 DWORD PTR type$7[rbp-256], 1
  002ab	0f 85 d3 00 00
	00		 jne	 $LN7@OpenTapHan

; 213  : 							{
; 214  : 								if (!strcmp(szTapName, ".") || !strncasecmp(szTapName, deviceName, sizeof(deviceName)))

  002b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR szTapName
  002b8	8a 01		 mov	 al, BYTE PTR [rcx]
  002ba	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01LFCBOECM@?4?$AA@
  002c0	75 0b		 jne	 SHORT $LN49@OpenTapHan
  002c2	8a 41 01	 mov	 al, BYTE PTR [rcx+1]
  002c5	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01LFCBOECM@?4?$AA@+1
  002cb	74 15		 je	 SHORT $LN6@OpenTapHan
$LN49@OpenTapHan:
  002cd	48 8d 55 50	 lea	 rdx, QWORD PTR deviceName$4[rbp-256]
  002d1	4d 8b c7	 mov	 r8, r15
  002d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  002da	85 c0		 test	 eax, eax
  002dc	0f 85 a2 00 00
	00		 jne	 $LN7@OpenTapHan
$LN6@OpenTapHan:

; 215  : 								{
; 216  : 									ActiveTapName = vlmcsd_strdup(deviceName);

  002e2	48 8d 4d 50	 lea	 rcx, QWORD PTR deviceName$4[rbp-256]
  002e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strdup
  002ec	48 85 c0	 test	 rax, rax
  002ef	0f 84 e6 00 00
	00		 je	 $LN42@OpenTapHan

; 217  : 									strncpy(deviceName, USERMODEDEVICEDIR, sizeof(deviceName));

  002f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@KLEKCEEC@?2?2?4?2Global?2?$AA@
  002fc	48 8d 4d 50	 lea	 rcx, QWORD PTR deviceName$4[rbp-256]
  00300	4d 8b c7	 mov	 r8, r15
  00303	48 89 05 00 00
	00 00		 mov	 QWORD PTR ActiveTapName, rax
  0030a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 218  : 									strncat(deviceName, regData, sizeof(deviceName));

  00310	48 8d 54 24 50	 lea	 rdx, QWORD PTR regData$3[rsp]
  00315	48 8d 4d 50	 lea	 rcx, QWORD PTR deviceName$4[rbp-256]
  00319	4d 8b c7	 mov	 r8, r15
  0031c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat

; 219  : 									strncat(deviceName, strcmp(AdapterClass, "TEAMVIEWERVPN") ? TAP_WIN_SUFFIX : ".dgt", sizeof(deviceName));

  00322	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AdapterClass
  00329	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@LGAJAMKD@TEAMVIEWERVPN?$AA@
  00330	e8 00 00 00 00	 call	 strcmp
  00335	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04MFFLHGKN@?4tap?$AA@
  0033c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04PFKDJIIE@?4dgt?$AA@
  00343	85 c0		 test	 eax, eax
  00345	4d 8b c7	 mov	 r8, r15
  00348	48 0f 45 d1	 cmovne	 rdx, rcx
  0034c	48 8d 4d 50	 lea	 rcx, QWORD PTR deviceName$4[rbp-256]
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncat

; 220  : 									handle = CreateFile(deviceName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_SYSTEM, NULL);

  00356	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  0035c	48 8d 4d 50	 lea	 rcx, QWORD PTR deviceName$4[rbp-256]
  00360	45 33 c9	 xor	 r9d, r9d
  00363	45 33 c0	 xor	 r8d, r8d
  00366	ba 00 00 00 c0	 mov	 edx, -1073741824	; c0000000H
  0036b	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR [rsp+40], 4
  00373	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  0037b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateFileA
  00381	48 8b f8	 mov	 rdi, rax
$LN7@OpenTapHan:

; 221  : 								}
; 222  : 							}
; 223  : 						}
; 224  : 
; 225  : 						RegCloseKey(connectionKey);

  00384	48 8b 4c 24 48	 mov	 rcx, QWORD PTR connectionKey$2[rsp]
  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey

; 226  : 					}
; 227  : 
; 228  : 					if (handle == INVALID_HANDLE_VALUE) free(AdapterClass);

  0038f	48 83 ff ff	 cmp	 rdi, -1
  00393	75 0d		 jne	 SHORT $LN5@OpenTapHan
$LN47@OpenTapHan:
  00395	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR AdapterClass
  0039c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@OpenTapHan:

; 229  : 				}
; 230  : 			}
; 231  : 		}
; 232  : 
; 233  : 		RegCloseKey(regSubKey);

  003a2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regSubKey$1[rsp]
  003a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey

; 234  : 		subKeySize = sizeof(subkeyName);

  003ad	44 89 bd 90 03
	00 00		 mov	 DWORD PTR subKeySize$[rbp-256], r15d

; 235  : 		if (handle != INVALID_HANDLE_VALUE) break;

  003b4	48 83 ff ff	 cmp	 rdi, -1
  003b8	75 70		 jne	 SHORT $LN43@OpenTapHan

; 167  : 	}
; 168  : 
; 169  : 	char subkeyName[TAP_REGISTRY_DATA_SIZE];
; 170  : 	DWORD i, subKeySize = sizeof(subkeyName);
; 171  : 
; 172  : 	for (i = 0; (regResult = RegEnumKeyEx(regAdapterKey, i, subkeyName, &subKeySize, NULL, NULL, NULL, NULL)) != ERROR_NO_MORE_ITEMS; i++)

  003ba	48 83 64 24 38
	00		 and	 QWORD PTR [rsp+56], 0
  003c0	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  003c6	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  003cc	ff c6		 inc	 esi
  003ce	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  003d4	8b d6		 mov	 edx, esi
  003d6	e9 b2 fc ff ff	 jmp	 $LN51@OpenTapHan
$LN42@OpenTapHan:

; 215  : 								{
; 216  : 									ActiveTapName = vlmcsd_strdup(deviceName);

  003db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  003e2	e8 00 00 00 00	 call	 errorout
  003e7	b9 0e 00 00 00	 mov	 ecx, 14
  003ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  003f2	cc		 int	 3
$LN41@OpenTapHan:

; 194  : 				{
; 195  : 					AdapterClass = vlmcsd_strdup(regData);

  003f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@PKBKHANO@Fatal?3?5Out?5of?5memory?$AA@
  003fa	e8 00 00 00 00	 call	 errorout
  003ff	b9 0e 00 00 00	 mov	 ecx, 14
  00404	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0040a	cc		 int	 3
$LN40@OpenTapHan:

; 173  : 	{
; 174  : 		HKEY regSubKey;
; 175  : 		DWORD type, regDataSize;
; 176  : 		char regData[TAP_REGISTRY_DATA_SIZE];
; 177  : 
; 178  : 		if (regResult) WinErrorExit(regResult);

  0040b	8b cb		 mov	 ecx, ebx
  0040d	e8 00 00 00 00	 call	 win_strerror
  00412	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@MHDDEOLE@Registry?5read?5error?3?5?$CFs?6?$AA@
  00419	48 8b d0	 mov	 rdx, rax
  0041c	e8 00 00 00 00	 call	 printerrorf
  00421	8b cb		 mov	 ecx, ebx
  00423	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00429	cc		 int	 3
$LN43@OpenTapHan:

; 236  : 	}
; 237  : 
; 238  : 	RegCloseKey(regAdapterKey);

  0042a	48 8b 8d 98 03
	00 00		 mov	 rcx, QWORD PTR regAdapterKey$[rbp-256]
  00431	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey

; 239  : 
; 240  : 	if (handle == INVALID_HANDLE_VALUE)

  00437	48 83 ff ff	 cmp	 rdi, -1
  0043b	75 5a		 jne	 SHORT $LN3@OpenTapHan

; 241  : 	{
; 242  : 		printerrorf("Fatal: No compatible VPN adapter");

  0043d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CB@PJHCNLCC@Fatal?3?5No?5compatible?5VPN?5adapter@
  00444	e8 00 00 00 00	 call	 printerrorf

; 243  : 
; 244  : 		if (!strcmp(szTapName, "."))

  00449	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR szTapName
  00450	8a 02		 mov	 al, BYTE PTR [rdx]
  00452	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01LFCBOECM@?4?$AA@
  00458	75 19		 jne	 SHORT $LN2@OpenTapHan
  0045a	8a 42 01	 mov	 al, BYTE PTR [rdx+1]
  0045d	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01LFCBOECM@?4?$AA@+1
  00463	75 0e		 jne	 SHORT $LN2@OpenTapHan

; 245  : 		{
; 246  : 			printerrorf("s");

  00465	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  0046c	e8 00 00 00 00	 call	 printerrorf

; 247  : 		}
; 248  : 		else

  00471	eb 0c		 jmp	 SHORT $LN1@OpenTapHan
$LN2@OpenTapHan:

; 249  : 		{
; 250  : 			printerrorf(" with name \"%s\"", szTapName);

  00473	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@KFDACIEA@?5with?5name?5?$CC?$CFs?$CC?$AA@
  0047a	e8 00 00 00 00	 call	 printerrorf
$LN1@OpenTapHan:

; 251  : 		}
; 252  : 
; 253  : 		printerrorf(" available for use\n");

  0047f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BE@BMEHODCL@?5available?5for?5use?6?$AA@
  00486	e8 00 00 00 00	 call	 printerrorf

; 254  : 		exit(ERROR_DEVICE_NOT_AVAILABLE);

  0048b	b9 df 10 00 00	 mov	 ecx, 4319		; 000010dfH
  00490	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00496	cc		 int	 3
$LN3@OpenTapHan:

; 255  : 	}
; 256  : 
; 257  : 	return handle;

  00497	48 8b c7	 mov	 rax, rdi

; 258  : }

  0049a	48 81 c4 50 04
	00 00		 add	 rsp, 1104		; 00000450H
  004a1	41 5f		 pop	 r15
  004a3	5f		 pop	 rdi
  004a4	5e		 pop	 rsi
  004a5	5b		 pop	 rbx
  004a6	5d		 pop	 rbp
  004a7	c3		 ret	 0
$LN52@OpenTapHan:
OpenTapHandle ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\wintap.c
;	COMDAT DevCtl
_TEXT	SEGMENT
code$ = 80
data$ = 88
len$ = 96
DevCtl	PROC						; COMDAT

; 262  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	45 89 43 18	 mov	 DWORD PTR [r11+24], r8d
  00007	53		 push	 rbx
  00008	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 263  : 	if (!DeviceIoControl(TapHandle, code, data, len, data, len, &len, NULL))

  0000c	49 83 63 f0 00	 and	 QWORD PTR [r11-16], 0
  00011	49 8d 43 18	 lea	 rax, QWORD PTR [r11+24]
  00015	45 8b c8	 mov	 r9d, r8d
  00018	49 89 43 e8	 mov	 QWORD PTR [r11-24], rax
  0001c	45 89 43 e0	 mov	 DWORD PTR [r11-32], r8d
  00020	49 89 53 d8	 mov	 QWORD PTR [r11-40], rdx
  00024	4c 8b c2	 mov	 r8, rdx
  00027	8b d1		 mov	 edx, ecx
  00029	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR TapHandle
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeviceIoControl
  00036	85 c0		 test	 eax, eax
  00038	75 27		 jne	 SHORT $LN1@DevCtl

; 264  : 	{
; 265  : 		DWORD error = GetLastError();

  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 266  : 		printerrorf("Fatal: VPN adapter error: %s\n", win_strerror(error));

  00040	8b c8		 mov	 ecx, eax
  00042	8b d8		 mov	 ebx, eax
  00044	e8 00 00 00 00	 call	 win_strerror
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@KPKEIBCK@Fatal?3?5VPN?5adapter?5error?3?5?$CFs?6?$AA@
  00050	48 8b d0	 mov	 rdx, rax
  00053	e8 00 00 00 00	 call	 printerrorf

; 267  : 		exit(error);

  00058	8b cb		 mov	 ecx, ebx
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00060	cc		 int	 3
$LN1@DevCtl:

; 268  : 	}
; 269  : 
; 270  : 	return len;

  00061	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]

; 271  : }

  00065	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
$LN5@DevCtl:
DevCtl	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\wintap.c
;	COMDAT TapMirror
_TEXT	SEGMENT
data_unused$ = 64
bytesRead$1 = 72
bytesWritten$2 = 80
TapMirror PROC						; COMDAT

; 275  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 276  : 	while (TRUE)
; 277  : 	{
; 278  : 		DWORD bytesRead, bytesWritten;
; 279  : 		if (!ReadFile(TapHandle, IpPacket, Mtu, &bytesRead, NULL)) break;

  00006	33 db		 xor	 ebx, ebx
  00008	eb 33		 jmp	 SHORT $LN20@TapMirror
$LL4@TapMirror:

; 280  : 
; 281  : 		uint32_t temp = IpPacket->ip_src;

  0000a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR IpPacket

; 282  : 		IpPacket->ip_src = IpPacket->ip_dst;
; 283  : 		IpPacket->ip_dst = temp;
; 284  : 
; 285  : 		if (!WriteFile(TapHandle, IpPacket, bytesRead, &bytesWritten, NULL)) break;

  00011	4c 8d 4c 24 50	 lea	 r9, QWORD PTR bytesWritten$2[rsp]
  00016	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0001b	8b 4a 0c	 mov	 ecx, DWORD PTR [rdx+12]
  0001e	8b 42 10	 mov	 eax, DWORD PTR [rdx+16]
  00021	89 4a 10	 mov	 DWORD PTR [rdx+16], ecx
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR TapHandle
  0002b	89 42 0c	 mov	 DWORD PTR [rdx+12], eax
  0002e	44 8b 44 24 48	 mov	 r8d, DWORD PTR bytesRead$1[rsp]
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile
  00039	85 c0		 test	 eax, eax
  0003b	74 29		 je	 SHORT $LN13@TapMirror
$LN20@TapMirror:

; 276  : 	while (TRUE)
; 277  : 	{
; 278  : 		DWORD bytesRead, bytesWritten;
; 279  : 		if (!ReadFile(TapHandle, IpPacket, Mtu, &bytesRead, NULL)) break;

  0003d	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR Mtu
  00044	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR IpPacket
  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR TapHandle
  00052	4c 8d 4c 24 48	 lea	 r9, QWORD PTR bytesRead$1[rsp]
  00057	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  00062	85 c0		 test	 eax, eax
  00064	75 a4		 jne	 SHORT $LL4@TapMirror
$LN13@TapMirror:

; 286  : 
; 287  : #		if !defined(NO_LOG) && defined(_PEDANTIC)
; 288  : 		if (bytesRead != bytesWritten) logger("Warning: VPN device \"%s\": %u bytes could not be written\n", ActiveTapName, bytesRead - bytesWritten);
; 289  : #		endif // !defined(NO_LOG) && defined(_PEDANTIC)
; 290  : 	}
; 291  : 
; 292  : 	DWORD error = GetLastError();

  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 293  : 
; 294  : #	ifndef NO_LOG
; 295  : 	logger("Warning: VPN thread for device \"%s\" exiting: %s\n", ActiveTapName, win_strerror(error));

  0006c	8b c8		 mov	 ecx, eax
  0006e	8b d8		 mov	 ebx, eax
  00070	e8 00 00 00 00	 call	 win_strerror
  00075	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR ActiveTapName
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DB@GOGKGJOK@Warning?3?5VPN?5thread?5for?5device?5?$CC@
  00083	4c 8b c0	 mov	 r8, rax
  00086	e8 00 00 00 00	 call	 logger

; 296  : #	endif // NO_LOG
; 297  : 
; 298  : 	free(ActiveTapName);

  0008b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ActiveTapName
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 299  : 	CloseHandle(TapHandle);

  00098	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR TapHandle
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 300  : 	exitOnWarningLevel(1);

  000a5	8a 05 00 00 00
	00		 mov	 al, BYTE PTR ExitLevel
  000ab	3c 01		 cmp	 al, 1
  000ad	7c 19		 jl	 SHORT $LN7@TapMirror
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level?5@
  000b6	0f be d0	 movsx	 edx, al
  000b9	e8 00 00 00 00	 call	 printerrorf
  000be	83 c9 ff	 or	 ecx, -1
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  000c7	cc		 int	 3
$LN7@TapMirror:

; 301  : 	return error;

  000c8	8b c3		 mov	 eax, ebx

; 302  : }

  000ca	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ce	5b		 pop	 rbx
  000cf	c3		 ret	 0
$LN21@TapMirror:
TapMirror ENDP
_TEXT	ENDS
END
