; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CA@BBMKAOPO@Fatal?3?5KMSv?$CFhu?4?$CFhu?5unsupported?6?$AA@ ; `string'
PUBLIC	??_C@_0DP@CJEHLGPD@Fatal?3?5Received?5wrong?5RPC?5packet@ ; `string'
PUBLIC	??_C@_0FA@EFGNKFML@Fatal?3?5RPC?5response?5does?5not?5con@ ; `string'
PUBLIC	??_C@_0CN@JIFMCEFK@Fatal?3?5RPC?5response?5requests?5aut@ ; `string'
PUBLIC	??_C@_0EI@BKAOLKDE@Fatal?3?5RPC?5packet?5flags?5RPC_PF_F@ ; `string'
PUBLIC	??_C@_0BG@HLJBDNGA@RPC_PF_CANCEL_PENDING?$AA@	; `string'
PUBLIC	??_C@_0BP@EPFAGCLK@Warning?3?5?$CFs?5should?5not?5be?5set?6?$AA@ ; `string'
PUBLIC	??_C@_0BA@LFBPBNOH@RPC_PF_RESERVED?$AA@		; `string'
PUBLIC	??_C@_0BA@HEJPAFFP@RPC_PF_NOT_EXEC?$AA@		; `string'
PUBLIC	??_C@_0N@HEOOBKKP@RPC_PF_MAYBE?$AA@		; `string'
PUBLIC	??_C@_0O@DHNLACON@RPC_PF_OBJECT?$AA@		; `string'
PUBLIC	??_C@_0CP@HOOBBENO@Fatal?3?5Expected?5RPC?5version?55?40?5@ ; `string'
PUBLIC	??_C@_0EE@GLJICDBO@Warning?3?5RPC_PF_MULTIPLEX?5of?5RPC@ ; `string'
PUBLIC	??_C@_0BB@MIHFLBDG@RPC_PF_MULTIPLEX?$AA@	; `string'
PUBLIC	??_C@_0EG@HDABALOO@Warning?3?5Buggy?5RPC?5of?5Wine?5detec@ ; `string'
PUBLIC	??_C@_0DL@NKMJHEP@Fatal?3?5Sent?5Call?5Id?5?$CFu?5but?5recei@ ; `string'
PUBLIC	??_C@_0CE@JLEJBEGP@?6Fatal?3?5Could?5not?5send?5RPC?5reque@ ; `string'
PUBLIC	??_C@_0CO@NNOGDDAG@?6Fatal?3?5No?5RPC?5response?5received@ ; `string'
PUBLIC	??_C@_0CE@ENNHKCJO@?6Fatal?3?5RPC?5response?5is?5incomple@ ; `string'
PUBLIC	??_C@_0CM@HKIEGAIN@?6Fatal?3?5RPC?5response?5cancel?5coun@ ; `string'
PUBLIC	??_C@_0DB@LCKBGPNI@?6Fatal?3?5RPC?5response?5context?5id?5@ ; `string'
PUBLIC	??_C@_0EA@FIBHBLDN@?6Fatal?3?5NDR?5data?5length?5?$CI?$CFu?$CJ?5doe@ ; `string'
PUBLIC	??_C@_0FD@KCALNIFM@?6Fatal?3?5No?5or?5incomplete?5KMS?5res@ ; `string'
PUBLIC	??_C@_0EK@EDAGGGNP@?6Warning?3?5RPC?5stub?5size?5is?5?$CFu?0?5s@ ; `string'
PUBLIC	??_C@_0EN@IFHPELIC@?6Warning?3?5RPC?5stub?5data?5not?5padd@ ; `string'
PUBLIC	??_C@_0CJ@ELGOCPLL@?6Fatal?3?5Sending?5RPC?5bind?5request@ ; `string'
PUBLIC	??_C@_0DA@NCIGIHDA@?6Fatal?3?5Did?5not?5receive?5a?5respon@ ; `string'
PUBLIC	??_C@_0DG@CDFCGJFH@?6Fatal?3?5Incomplete?5RPC?5bind?5ackn@ ; `string'
PUBLIC	??_C@_0CK@HPNJNCNH@?6Fatal?3?5Expected?5?$CFu?5CTX?5items?5bu@ ; `string'
PUBLIC	??_C@_04EFGMAIMH@BTFN?$AA@			; `string'
PUBLIC	??_C@_05CMNEGGDF@NDR64?$AA@			; `string'
PUBLIC	??_C@_05HMEFADFI@NDR32?$AA@			; `string'
PUBLIC	??_C@_0EA@FALBNLMF@?6Warning?3?5Rejected?5transfer?5synt@ ; `string'
PUBLIC	??_C@_0EO@LKGEJEDI@?6Warning?3?5Rejected?5transfer?5synt@ ; `string'
PUBLIC	??_C@_0DO@PHEPNPBJ@?6Warning?3?5Transfer?5syntax?5?$CFs?5doe@ ; `string'
PUBLIC	??_C@_0FI@PEIELJGO@?6Warning?3?5Rejected?5transfer?5synt@ ; `string'
PUBLIC	??_C@_0ED@ONOBBCGN@?6Warning?3?5BTFN?5did?5not?5respond?5w@ ; `string'
PUBLIC	??_C@_0EC@EDPPOAMK@?6Warning?3?5BTFN?5did?5not?5return?5ex@ ; `string'
PUBLIC	??_C@_09PKGPPFMG@?4?4?4?5BTFN?5?$AA@		; `string'
PUBLIC	??_C@_0GC@NGOEMPDA@?6Fatal?3?5transfer?5syntax?5?$CFs?5retur@ ; `string'
PUBLIC	??_C@_0EJ@PGIIMLOK@?6Fatal?3?5Transfer?5syntax?5of?5RPC?5b@ ; `string'
PUBLIC	??_C@_0DP@BHGLCOFK@?6Fatal?3?5Expected?5transfer?5syntax@ ; `string'
PUBLIC	??_C@_0CM@HGMDMAM@?6Warning?3?5Ack?5reason?5should?5be?50@ ; `string'
PUBLIC	??_C@_0L@DMLPGKA@?4?4?4?5NDR64?5?$AA@		; `string'
PUBLIC	??_C@_0L@DAJIHKCA@?4?4?4?5NDR32?5?$AA@		; `string'
PUBLIC	??_C@_0EF@PFAMEHMF@?6Fatal?3?5Could?5neither?5negotiate?5@ ; `string'
EXTRN	__imp_getsockname:PROC
?WineBugDetected@?1??checkRpcResponseHeader@@9@9 DB 01H DUP (?) ; `checkRpcResponseHeader'::`2'::WineBugDetected
COMM	RpcFlags:DWORD
_DATA	ENDS
;	COMDAT ??_C@_0EF@PFAMEHMF@?6Fatal?3?5Could?5neither?5negotiate?5@
CONST	SEGMENT
??_C@_0EF@PFAMEHMF@?6Fatal?3?5Could?5neither?5negotiate?5@ DB 0aH, 'Fatal'
	DB	': Could neither negotiate NDR32 nor NDR64 with the RPC server'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DAJIHKCA@?4?4?4?5NDR32?5?$AA@
CONST	SEGMENT
??_C@_0L@DAJIHKCA@?4?4?4?5NDR32?5?$AA@ DB '... NDR32 ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMLPGKA@?4?4?4?5NDR64?5?$AA@
CONST	SEGMENT
??_C@_0L@DMLPGKA@?4?4?4?5NDR64?5?$AA@ DB '... NDR64 ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HGMDMAM@?6Warning?3?5Ack?5reason?5should?5be?50@
CONST	SEGMENT
??_C@_0CM@HGMDMAM@?6Warning?3?5Ack?5reason?5should?5be?50@ DB 0aH, 'Warni'
	DB	'ng: Ack reason should be 0 but is %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@BHGLCOFK@?6Fatal?3?5Expected?5transfer?5syntax@
CONST	SEGMENT
??_C@_0DP@BHGLCOFK@?6Fatal?3?5Expected?5transfer?5syntax@ DB 0aH, 'Fatal:'
	DB	' Expected transfer syntax version %u for %s but got %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EJ@PGIIMLOK@?6Fatal?3?5Transfer?5syntax?5of?5RPC?5b@
CONST	SEGMENT
??_C@_0EJ@PGIIMLOK@?6Fatal?3?5Transfer?5syntax?5of?5RPC?5b@ DB 0aH, 'Fata'
	DB	'l: Transfer syntax of RPC bind request and response does not '
	DB	'match', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@NGOEMPDA@?6Fatal?3?5transfer?5syntax?5?$CFs?5retur@
CONST	SEGMENT
??_C@_0GC@NGOEMPDA@?6Fatal?3?5transfer?5syntax?5?$CFs?5retur@ DB 0aH, 'Fa'
	DB	'tal: transfer syntax %s returned an invalid status, neither R'
	DB	'PC_BIND_ACCEPT nor RPC_BIND_NACK', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09PKGPPFMG@?4?4?4?5BTFN?5?$AA@
CONST	SEGMENT
??_C@_09PKGPPFMG@?4?4?4?5BTFN?5?$AA@ DB '... BTFN ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@EDPPOAMK@?6Warning?3?5BTFN?5did?5not?5return?5ex@
CONST	SEGMENT
??_C@_0EC@EDPPOAMK@?6Warning?3?5BTFN?5did?5not?5return?5ex@ DB 0aH, 'Warn'
	DB	'ing: BTFN did not return expected feature mask 0x3 but 0x%X', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@ONOBBCGN@?6Warning?3?5BTFN?5did?5not?5respond?5w@
CONST	SEGMENT
??_C@_0ED@ONOBBCGN@?6Warning?3?5BTFN?5did?5not?5respond?5w@ DB 0aH, 'Warn'
	DB	'ing: BTFN did not respond with RPC_BIND_ACK or RPC_BIND_NACK', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FI@PEIELJGO@?6Warning?3?5Rejected?5transfer?5synt@
CONST	SEGMENT
??_C@_0FI@PEIELJGO@?6Warning?3?5Rejected?5transfer?5synt@ DB 0aH, 'Warnin'
	DB	'g: Rejected transfer syntax %s did not return ack reason RPC_'
	DB	'SYNTAX_UNSUPPORTED', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DO@PHEPNPBJ@?6Warning?3?5Transfer?5syntax?5?$CFs?5doe@
CONST	SEGMENT
??_C@_0DO@PHEPNPBJ@?6Warning?3?5Transfer?5syntax?5?$CFs?5doe@ DB 0aH, 'Wa'
	DB	'rning: Transfer syntax %s does not support KMS activation', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@LKGEJEDI@?6Warning?3?5Rejected?5transfer?5synt@
CONST	SEGMENT
??_C@_0EO@LKGEJEDI@?6Warning?3?5Rejected?5transfer?5synt@ DB 0aH, 'Warnin'
	DB	'g: Rejected transfer syntax %s did not return syntax version '
	DB	'0 but %u', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FALBNLMF@?6Warning?3?5Rejected?5transfer?5synt@
CONST	SEGMENT
??_C@_0EA@FALBNLMF@?6Warning?3?5Rejected?5transfer?5synt@ DB 0aH, 'Warnin'
	DB	'g: Rejected transfer syntax %s did not return NULL Guid', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05HMEFADFI@NDR32?$AA@
CONST	SEGMENT
??_C@_05HMEFADFI@NDR32?$AA@ DB 'NDR32', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMNEGGDF@NDR64?$AA@
CONST	SEGMENT
??_C@_05CMNEGGDF@NDR64?$AA@ DB 'NDR64', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04EFGMAIMH@BTFN?$AA@
CONST	SEGMENT
??_C@_04EFGMAIMH@BTFN?$AA@ DB 'BTFN', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@HPNJNCNH@?6Fatal?3?5Expected?5?$CFu?5CTX?5items?5bu@
CONST	SEGMENT
??_C@_0CK@HPNJNCNH@?6Fatal?3?5Expected?5?$CFu?5CTX?5items?5bu@ DB 0aH, 'F'
	DB	'atal: Expected %u CTX items but got %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@CDFCGJFH@?6Fatal?3?5Incomplete?5RPC?5bind?5ackn@
CONST	SEGMENT
??_C@_0DG@CDFCGJFH@?6Fatal?3?5Incomplete?5RPC?5bind?5ackn@ DB 0aH, 'Fatal'
	DB	': Incomplete RPC bind acknowledgement received', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@NCIGIHDA@?6Fatal?3?5Did?5not?5receive?5a?5respon@
CONST	SEGMENT
??_C@_0DA@NCIGIHDA@?6Fatal?3?5Did?5not?5receive?5a?5respon@ DB 0aH, 'Fata'
	DB	'l: Did not receive a response from server', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@ELGOCPLL@?6Fatal?3?5Sending?5RPC?5bind?5request@
CONST	SEGMENT
??_C@_0CJ@ELGOCPLL@?6Fatal?3?5Sending?5RPC?5bind?5request@ DB 0aH, 'Fatal'
	DB	': Sending RPC bind request failed', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EN@IFHPELIC@?6Warning?3?5RPC?5stub?5data?5not?5padd@
CONST	SEGMENT
??_C@_0EN@IFHPELIC@?6Warning?3?5RPC?5stub?5data?5not?5padd@ DB 0aH, 'Warn'
	DB	'ing: RPC stub data not padded to zeros according to Microsoft'
	DB	' standard', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@EDAGGGNP@?6Warning?3?5RPC?5stub?5size?5is?5?$CFu?0?5s@
CONST	SEGMENT
??_C@_0EK@EDAGGGNP@?6Warning?3?5RPC?5stub?5size?5is?5?$CFu?0?5s@ DB 0aH, 'W'
	DB	'arning: RPC stub size is %u, should be %u (probably incorrect'
	DB	' padding)', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@KCALNIFM@?6Fatal?3?5No?5or?5incomplete?5KMS?5res@
CONST	SEGMENT
??_C@_0FD@KCALNIFM@?6Fatal?3?5No?5or?5incomplete?5KMS?5res@ DB 0aH, 'Fata'
	DB	'l: No or incomplete KMS response received. Required %u bytes '
	DB	'but only got %i', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EA@FIBHBLDN@?6Fatal?3?5NDR?5data?5length?5?$CI?$CFu?$CJ?5doe@
CONST	SEGMENT
??_C@_0EA@FIBHBLDN@?6Fatal?3?5NDR?5data?5length?5?$CI?$CFu?$CJ?5doe@ DB 0aH
	DB	'Fatal: NDR data length (%u) does not match NDR data size (%u)'
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@LCKBGPNI@?6Fatal?3?5RPC?5response?5context?5id?5@
CONST	SEGMENT
??_C@_0DB@LCKBGPNI@?6Fatal?3?5RPC?5response?5context?5id?5@ DB 0aH, 'Fata'
	DB	'l: RPC response context id %u is not bound', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@HKIEGAIN@?6Fatal?3?5RPC?5response?5cancel?5coun@
CONST	SEGMENT
??_C@_0CM@HKIEGAIN@?6Fatal?3?5RPC?5response?5cancel?5coun@ DB 0aH, 'Fatal'
	DB	': RPC response cancel count is not 0', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@ENNHKCJO@?6Fatal?3?5RPC?5response?5is?5incomple@
CONST	SEGMENT
??_C@_0CE@ENNHKCJO@?6Fatal?3?5RPC?5response?5is?5incomple@ DB 0aH, 'Fatal'
	DB	': RPC response is incomplete', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@NNOGDDAG@?6Fatal?3?5No?5RPC?5response?5received@
CONST	SEGMENT
??_C@_0CO@NNOGDDAG@?6Fatal?3?5No?5RPC?5response?5received@ DB 0aH, 'Fatal'
	DB	': No RPC response received from server', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@JLEJBEGP@?6Fatal?3?5Could?5not?5send?5RPC?5reque@
CONST	SEGMENT
??_C@_0CE@JLEJBEGP@?6Fatal?3?5Could?5not?5send?5RPC?5reque@ DB 0aH, 'Fata'
	DB	'l: Could not send RPC request', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@NKMJHEP@Fatal?3?5Sent?5Call?5Id?5?$CFu?5but?5recei@
CONST	SEGMENT
??_C@_0DL@NKMJHEP@Fatal?3?5Sent?5Call?5Id?5?$CFu?5but?5recei@ DB 'Fatal: '
	DB	'Sent Call Id %u but received answer for Call Id %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@HDABALOO@Warning?3?5Buggy?5RPC?5of?5Wine?5detec@
CONST	SEGMENT
??_C@_0EG@HDABALOO@Warning?3?5Buggy?5RPC?5of?5Wine?5detec@ DB 'Warning: B'
	DB	'uggy RPC of Wine detected. Call Id of Response is always 1', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@MIHFLBDG@RPC_PF_MULTIPLEX?$AA@
CONST	SEGMENT
??_C@_0BB@MIHFLBDG@RPC_PF_MULTIPLEX?$AA@ DB 'RPC_PF_MULTIPLEX', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@GLJICDBO@Warning?3?5RPC_PF_MULTIPLEX?5of?5RPC@
CONST	SEGMENT
??_C@_0EE@GLJICDBO@Warning?3?5RPC_PF_MULTIPLEX?5of?5RPC@ DB 'Warning: RPC'
	DB	'_PF_MULTIPLEX of RPC request and response should match', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HOOBBENO@Fatal?3?5Expected?5RPC?5version?55?40?5@
CONST	SEGMENT
??_C@_0CP@HOOBBENO@Fatal?3?5Expected?5RPC?5version?55?40?5@ DB 'Fatal: Ex'
	DB	'pected RPC version 5.0 and got %u.%u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@DHNLACON@RPC_PF_OBJECT?$AA@
CONST	SEGMENT
??_C@_0O@DHNLACON@RPC_PF_OBJECT?$AA@ DB 'RPC_PF_OBJECT', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HEOOBKKP@RPC_PF_MAYBE?$AA@
CONST	SEGMENT
??_C@_0N@HEOOBKKP@RPC_PF_MAYBE?$AA@ DB 'RPC_PF_MAYBE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HEJPAFFP@RPC_PF_NOT_EXEC?$AA@
CONST	SEGMENT
??_C@_0BA@HEJPAFFP@RPC_PF_NOT_EXEC?$AA@ DB 'RPC_PF_NOT_EXEC', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@LFBPBNOH@RPC_PF_RESERVED?$AA@
CONST	SEGMENT
??_C@_0BA@LFBPBNOH@RPC_PF_RESERVED?$AA@ DB 'RPC_PF_RESERVED', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@EPFAGCLK@Warning?3?5?$CFs?5should?5not?5be?5set?6?$AA@
CONST	SEGMENT
??_C@_0BP@EPFAGCLK@Warning?3?5?$CFs?5should?5not?5be?5set?6?$AA@ DB 'Warn'
	DB	'ing: %s should not be set', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HLJBDNGA@RPC_PF_CANCEL_PENDING?$AA@
CONST	SEGMENT
??_C@_0BG@HLJBDNGA@RPC_PF_CANCEL_PENDING?$AA@ DB 'RPC_PF_CANCEL_PENDING', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@BKAOLKDE@Fatal?3?5RPC?5packet?5flags?5RPC_PF_F@
CONST	SEGMENT
??_C@_0EI@BKAOLKDE@Fatal?3?5RPC?5packet?5flags?5RPC_PF_F@ DB 'Fatal: RPC '
	DB	'packet flags RPC_PF_FIRST and RPC_PF_LAST are not both set.', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@JIFMCEFK@Fatal?3?5RPC?5response?5requests?5aut@
CONST	SEGMENT
??_C@_0CN@JIFMCEFK@Fatal?3?5RPC?5response?5requests?5aut@ DB 'Fatal: RPC '
	DB	'response requests authentication', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@EFGNKFML@Fatal?3?5RPC?5response?5does?5not?5con@
CONST	SEGMENT
??_C@_0FA@EFGNKFML@Fatal?3?5RPC?5response?5does?5not?5con@ DB 'Fatal: RPC'
	DB	' response does not conform to Microsoft''s limited support of'
	DB	' DCE RPC', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DP@CJEHLGPD@Fatal?3?5Received?5wrong?5RPC?5packet@
CONST	SEGMENT
??_C@_0DP@CJEHLGPD@Fatal?3?5Received?5wrong?5RPC?5packet@ DB 'Fatal: Rece'
	DB	'ived wrong RPC packet type. Expected %u but got %u', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BBMKAOPO@Fatal?3?5KMSv?$CFhu?4?$CFhu?5unsupported?6?$AA@
CONST	SEGMENT
??_C@_0CA@BBMKAOPO@Fatal?3?5KMSv?$CFhu?4?$CFhu?5unsupported?6?$AA@ DB 'Fa'
	DB	'tal: KMSv%hu.%hu unsupported', 0aH, 00H	; `string'
CallId	DD	02H
TransferSyntaxNDR64 DB 033H
	DB	05H
	DB	071H
	DB	071H
	DB	0baH
	DB	0beH
	DB	037H
	DB	049H
	DB	083H
	DB	019H
	DB	0b5H
	DB	0dbH
	DB	0efH
	DB	09cH
	DB	0ccH
	DB	036H
InterfaceUuid DB 075H
	DB	021H
	DB	0c8H
	DB	051H
	DB	04eH
	DB	084H
	DB	050H
	DB	047H
	DB	0b0H
	DB	0d8H
	DB	0ecH
	DB	025H
	DB	055H
	DB	055H
	DB	0bcH
	DB	06H
_Actions DB	0cH
	ORG $+7
	DQ	FLAT:checkRpcBindSize
	DQ	FLAT:rpcBind
	DB	02H
	ORG $+7
	DQ	FLAT:checkRpcRequestSize
	DQ	FLAT:rpcRequest
	DB	0fH
	ORG $+7
	DQ	FLAT:checkRpcBindSize
	DQ	FLAT:rpcBind
TransferSyntaxNDR32 DB 04H
	DB	05dH
	DB	088H
	DB	08aH
	DB	0ebH
	DB	01cH
	DB	0c9H
	DB	011H
	DB	09fH
	DB	0e8H
	DB	08H
	DB	00H
	DB	02bH
	DB	010H
	DB	048H
	DB	060H
BindTimeFeatureNegotiation DB 02cH
	DB	01cH
	DB	0b7H
	DB	06cH
	DB	012H
	DB	098H
	DB	040H
	DB	045H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_Versions DD	0fcH
	ORG $+4
	DQ	FLAT:CreateResponseV4
	DD	0104H
	ORG $+4
	DQ	FLAT:CreateResponseV6
	DD	0104H
	ORG $+4
	DQ	FLAT:CreateResponseV6
PUBLIC	rpcServer
;	COMDAT pdata
pdata	SEGMENT
$pdata$rpcBind DD imagerel rpcBind
	DD	imagerel rpcBind+673
	DD	imagerel $unwind$rpcBind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rpcRequest DD imagerel rpcRequest
	DD	imagerel rpcRequest+333
	DD	imagerel $unwind$rpcRequest
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$checkRpcRequestSize DD imagerel checkRpcRequestSize
	DD	imagerel checkRpcRequestSize+137
	DD	imagerel $unwind$checkRpcRequestSize
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$rpcServer DD imagerel $LN38
	DD	imagerel $LN38+502
	DD	imagerel $unwind$rpcServer
;	COMDAT xdata
xdata	SEGMENT
$unwind$rpcServer DD 0b2101H
	DD	06f6421H
	DD	06e3421H
	DD	0680121H
	DD	0e010f012H
	DD	0700cc00eH
	DD	0500bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$checkRpcRequestSize DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rpcRequest DD 0c1d01H
	DD	0b741dH
	DD	0a641dH
	DD	09541dH
	DD	08341dH
	DD	0f019321dH
	DD	0c015e017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$rpcBind DD 0d1f01H
	DD	021641fH
	DD	01f541fH
	DD	01e341fH
	DD	018011fH
	DD	0e016f018H
	DD	0c012d014H
	DD	07010H
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\rpc.c
;	COMDAT rpcServer
_TEXT	SEGMENT
NdrCtx$ = 64
rpcRequestHeader$ = 72
responseBuffer$1 = 96
requestBuffer$2 = 528
sock$ = 880
rpcAssocGroup$ = 888
ipstr$ = 896
Ndr64Ctx$ = 904
rpcServer PROC						; COMDAT

; 614  : {

$LN38:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	55		 push	 rbp
  0000b	57		 push	 rdi
  0000c	41 54		 push	 r12
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 8d ac 24 c0
	fd ff ff	 lea	 rbp, QWORD PTR [rsp-576]
  0001a	48 81 ec 40 03
	00 00		 sub	 rsp, 832		; 00000340H

; 615  : 	RPC_HEADER  rpcRequestHeader;
; 616  : 	WORD NdrCtx = RPC_INVALID_CTX, Ndr64Ctx = RPC_INVALID_CTX;

  00021	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00026	4d 8b f0	 mov	 r14, r8
  00029	44 8b fa	 mov	 r15d, edx
  0002c	66 89 44 24 40	 mov	 WORD PTR NdrCtx$[rsp], ax
  00031	66 89 85 88 02
	00 00		 mov	 WORD PTR Ndr64Ctx$[rbp-256], ax
  00038	48 8b f1	 mov	 rsi, rcx

; 617  : 
; 618  : 	randomNumberInit();

  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTickCount
  00041	8b c8		 mov	 ecx, eax
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_srand

; 619  : 
; 620  : 	while (_recv(sock, &rpcRequestHeader, sizeof(rpcRequestHeader)))

  00049	45 33 c9	 xor	 r9d, r9d
  0004c	48 8d 54 24 48	 lea	 rdx, QWORD PTR rpcRequestHeader$[rsp]
  00051	45 8d 41 10	 lea	 r8d, QWORD PTR [r9+16]
  00055	48 8b ce	 mov	 rcx, rsi
  00058	e8 00 00 00 00	 call	 sendrecv
  0005d	45 33 e4	 xor	 r12d, r12d
  00060	e9 6d 01 00 00	 jmp	 $LN36@rpcServer
$LL18@rpcServer:

; 621  : 	{
; 622  : 		//int_fast8_t  _st;
; 623  : 		unsigned int request_len, response_len;
; 624  : 		uint_fast8_t _a;
; 625  : 
; 626  : #if defined(_PEDANTIC) && !defined(NO_LOG)
; 627  : 		checkRpcHeader(&rpcRequestHeader, rpcRequestHeader.PacketType, &logger);
; 628  : #endif // defined(_PEDANTIC) && !defined(NO_LOG)
; 629  : 
; 630  : 		switch (rpcRequestHeader.PacketType)

  00065	8a 44 24 4a	 mov	 al, BYTE PTR rpcRequestHeader$[rsp+2]
  00069	84 c0		 test	 al, al
  0006b	74 16		 je	 SHORT $LN13@rpcServer
  0006d	3c 0b		 cmp	 al, 11
  0006f	74 0d		 je	 SHORT $LN14@rpcServer
  00071	3c 0e		 cmp	 al, 14
  00073	0f 85 61 01 00
	00		 jne	 $LN26@rpcServer

; 634  : 		case RPC_PT_ALTERCONTEXT_REQ: _a = 2; break;

  00079	40 b7 02	 mov	 dil, 2
  0007c	eb 08		 jmp	 SHORT $LN15@rpcServer
$LN14@rpcServer:

; 631  : 		{
; 632  : 		case RPC_PT_BIND_REQ:         _a = 0; break;

  0007e	41 8a fc	 mov	 dil, r12b
  00081	eb 03		 jmp	 SHORT $LN15@rpcServer
$LN13@rpcServer:

; 633  : 		case RPC_PT_REQUEST:          _a = 1; break;

  00083	40 b7 01	 mov	 dil, 1
$LN15@rpcServer:

; 635  : 		default: return;
; 636  : 		}
; 637  : 
; 638  : 		request_len = LE16(rpcRequestHeader.FragLength) - sizeof(rpcRequestHeader);

  00086	0f b7 5c 24 50	 movzx	 ebx, WORD PTR rpcRequestHeader$[rsp+8]
  0008b	83 eb 10	 sub	 ebx, 16

; 639  : 
; 640  : 		BYTE requestBuffer[MAX_REQUEST_SIZE + sizeof(RPC_RESPONSE64)];
; 641  : 		BYTE responseBuffer[MAX_RESPONSE_SIZE + sizeof(RPC_HEADER) + sizeof(RPC_RESPONSE64)];
; 642  : 
; 643  : 		RPC_HEADER *rpcResponseHeader = (RPC_HEADER *)responseBuffer;
; 644  : 		RPC_RESPONSE* rpcResponse = (RPC_RESPONSE*)(responseBuffer + sizeof(rpcRequestHeader));
; 645  : 
; 646  : 		// The request is larger than the buffer size
; 647  : 		if (request_len > MAX_REQUEST_SIZE + sizeof(RPC_REQUEST64)) return;

  0008e	81 fb 1c 01 00
	00		 cmp	 ebx, 284		; 0000011cH
  00094	0f 87 40 01 00
	00		 ja	 $LN26@rpcServer

; 648  : 
; 649  : 		// Unable to receive the complete request
; 650  : 		if (!_recv(sock, requestBuffer, request_len)) return;

  0009a	48 8d 95 10 01
	00 00		 lea	 rdx, QWORD PTR requestBuffer$2[rbp-256]
  000a1	45 33 c9	 xor	 r9d, r9d
  000a4	44 8b c3	 mov	 r8d, ebx
  000a7	48 8b ce	 mov	 rcx, rsi
  000aa	e8 00 00 00 00	 call	 sendrecv
  000af	84 c0		 test	 al, al
  000b1	0f 84 23 01 00
	00		 je	 $LN26@rpcServer

; 651  : 
; 652  : #       if !defined(SIMPLE_RPC) && defined(_PEDANTIC)
; 653  : 		if (rpcRequestHeader.PacketType == RPC_PT_REQUEST && (rpcRequestHeader.VersionMajor != 5 || rpcRequestHeader.VersionMinor != 0))
; 654  : 		{
; 655  : 			response_len = SendError((RPC_RESPONSE64*)rpcResponse, RPC_NCA_PROTO_ERROR);
; 656  : 		}
; 657  : 		else
; 658  : #		endif // !defined(SIMPLE_RPC) && defined(_PEDANTIC)
; 659  : 		{
; 660  : 			BYTE isValid = (BYTE)_Actions[_a].CheckRequest(requestBuffer, request_len, &NdrCtx, &Ndr64Ctx);

  000b7	40 0f b6 c7	 movzx	 eax, dil
  000bb	8b d3		 mov	 edx, ebx
  000bd	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:_Actions
  000c4	48 8d 3c 40	 lea	 rdi, QWORD PTR [rax+rax*2]
  000c8	4c 8d 8d 88 02
	00 00		 lea	 r9, QWORD PTR Ndr64Ctx$[rbp-256]
  000cf	4c 8d 44 24 40	 lea	 r8, QWORD PTR NdrCtx$[rsp]
  000d4	48 8d 8d 10 01
	00 00		 lea	 rcx, QWORD PTR requestBuffer$2[rbp-256]
  000db	ff 54 fb 08	 call	 QWORD PTR [rbx+rdi*8+8]

; 661  : 			if (rpcRequestHeader.PacketType != RPC_PT_REQUEST && !isValid) return;

  000df	8a 54 24 4a	 mov	 dl, BYTE PTR rpcRequestHeader$[rsp+2]
  000e3	84 d2		 test	 dl, dl
  000e5	74 08		 je	 SHORT $LN8@rpcServer
  000e7	84 c0		 test	 al, al
  000e9	0f 84 eb 00 00
	00		 je	 $LN26@rpcServer
$LN8@rpcServer:

; 662  : 
; 663  : 			// Unable to create a valid response from request
; 664  : 			if (!((response_len = _Actions[_a].GetResponse(requestBuffer, rpcResponse, rpcAssocGroup, sock, &NdrCtx, &Ndr64Ctx, rpcRequestHeader.PacketType != RPC_PT_REQUEST ? rpcRequestHeader.PacketType : isValid, ipstr)))) return;

  000ef	0f b6 c8	 movzx	 ecx, al
  000f2	0f b6 c2	 movzx	 eax, dl
  000f5	84 d2		 test	 dl, dl
  000f7	0f 45 c8	 cmovne	 ecx, eax
  000fa	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  000ff	48 8d 85 88 02
	00 00		 lea	 rax, QWORD PTR Ndr64Ctx$[rbp-256]
  00106	88 4c 24 30	 mov	 BYTE PTR [rsp+48], cl
  0010a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0010f	48 8d 44 24 40	 lea	 rax, QWORD PTR NdrCtx$[rsp]
  00114	48 8d 54 24 70	 lea	 rdx, QWORD PTR responseBuffer$1[rsp+16]
  00119	48 8d 8d 10 01
	00 00		 lea	 rcx, QWORD PTR requestBuffer$2[rbp-256]
  00120	4c 8b ce	 mov	 r9, rsi
  00123	45 8b c7	 mov	 r8d, r15d
  00126	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012b	ff 54 fb 10	 call	 QWORD PTR [rbx+rdi*8+16]
  0012f	44 8b c0	 mov	 r8d, eax
  00132	85 c0		 test	 eax, eax
  00134	0f 84 a0 00 00
	00		 je	 $LN26@rpcServer

; 665  : 		}
; 666  : 
; 667  : 		memcpy(rpcResponseHeader, &rpcRequestHeader, sizeof(RPC_HEADER));

  0013a	0f 10 44 24 48	 movups	 xmm0, XMMWORD PTR rpcRequestHeader$[rsp]
  0013f	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR responseBuffer$1[rsp], xmm0

; 668  : 
; 669  : #       ifndef SIMPLE_RPC
; 670  : 		if (response_len == 32)

  00145	83 f8 20	 cmp	 eax, 32			; 00000020H
  00148	75 29		 jne	 SHORT $LN6@rpcServer

; 671  : 		{
; 672  : 			createRpcHeader(rpcResponseHeader, RPC_PT_FAULT, 0);

  0014a	66 c7 44 24 61
	00 03		 mov	 WORD PTR responseBuffer$1[rsp+1], 768 ; 00000300H
  00151	c6 44 24 60 05	 mov	 BYTE PTR responseBuffer$1[rsp], 5
  00156	66 44 89 64 24
	6a		 mov	 WORD PTR responseBuffer$1[rsp+10], r12w
  0015c	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR responseBuffer$1[rsp+4], 16
  00164	c7 44 24 6c 02
	00 00 00	 mov	 DWORD PTR responseBuffer$1[rsp+12], 2

; 673  : 			rpcResponseHeader->PacketFlags = RPC_PF_FIRST | RPC_PF_LAST | RPC_PF_NOT_EXEC;

  0016c	c6 44 24 63 23	 mov	 BYTE PTR responseBuffer$1[rsp+3], 35 ; 00000023H

; 674  : 		}
; 675  : 		else

  00171	eb 1e		 jmp	 SHORT $LN4@rpcServer
$LN6@rpcServer:

; 676  : #		endif // SIMPLE_RPC
; 677  : 		{
; 678  : 			response_len += sizeof(RPC_HEADER);
; 679  : 			rpcResponseHeader->PacketType = _Actions[_a].ResponsePacketType;

  00173	8a 04 fb	 mov	 al, BYTE PTR [rbx+rdi*8]

; 680  : 
; 681  : 			if (rpcResponseHeader->PacketType == RPC_PT_ALTERCONTEXT_ACK)

  00176	0f b6 4c 24 63	 movzx	 ecx, BYTE PTR responseBuffer$1[rsp+3]
  0017b	41 83 c0 10	 add	 r8d, 16
  0017f	3c 0f		 cmp	 al, 15
  00181	88 44 24 62	 mov	 BYTE PTR responseBuffer$1[rsp+2], al
  00185	b8 03 00 00 00	 mov	 eax, 3
  0018a	0f 44 c8	 cmove	 ecx, eax
  0018d	88 4c 24 63	 mov	 BYTE PTR responseBuffer$1[rsp+3], cl
$LN4@rpcServer:

; 682  : 			{
; 683  : 				rpcResponseHeader->PacketFlags = RPC_PF_FIRST | RPC_PF_LAST;
; 684  : 			}
; 685  : 		}
; 686  : 
; 687  : 		rpcResponseHeader->FragLength = LE16((WORD)response_len);
; 688  : 
; 689  : 		if (!_send(sock, responseBuffer, response_len)) return;

  00191	48 8d 54 24 60	 lea	 rdx, QWORD PTR responseBuffer$1[rsp]
  00196	41 b1 01	 mov	 r9b, 1
  00199	48 8b ce	 mov	 rcx, rsi
  0019c	66 44 89 44 24
	68		 mov	 WORD PTR responseBuffer$1[rsp+8], r8w
  001a2	e8 00 00 00 00	 call	 sendrecv
  001a7	84 c0		 test	 al, al
  001a9	74 2f		 je	 SHORT $LN26@rpcServer

; 690  : 
; 691  : 		if (DisconnectImmediately && (rpcResponseHeader->PacketType == RPC_PT_RESPONSE || rpcResponseHeader->PacketType == RPC_PT_FAULT))

  001ab	44 38 25 00 00
	00 00		 cmp	 BYTE PTR DisconnectImmediately, r12b
  001b2	74 0a		 je	 SHORT $LN2@rpcServer
  001b4	8a 44 24 62	 mov	 al, BYTE PTR responseBuffer$1[rsp+2]
  001b8	2c 02		 sub	 al, 2
  001ba	3c 01		 cmp	 al, 1
  001bc	76 1c		 jbe	 SHORT $LN26@rpcServer
$LN2@rpcServer:

; 619  : 
; 620  : 	while (_recv(sock, &rpcRequestHeader, sizeof(rpcRequestHeader)))

  001be	45 33 c9	 xor	 r9d, r9d
  001c1	48 8d 54 24 48	 lea	 rdx, QWORD PTR rpcRequestHeader$[rsp]
  001c6	48 8b ce	 mov	 rcx, rsi
  001c9	45 8d 41 10	 lea	 r8d, QWORD PTR [r9+16]
  001cd	e8 00 00 00 00	 call	 sendrecv
$LN36@rpcServer:
  001d2	84 c0		 test	 al, al
  001d4	0f 85 8b fe ff
	ff		 jne	 $LL18@rpcServer
$LN26@rpcServer:

; 692  : 			return;
; 693  : 	}
; 694  : }

  001da	4c 8d 9c 24 40
	03 00 00	 lea	 r11, QWORD PTR [rsp+832]
  001e2	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  001e6	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  001ea	49 8b e3	 mov	 rsp, r11
  001ed	41 5f		 pop	 r15
  001ef	41 5e		 pop	 r14
  001f1	41 5c		 pop	 r12
  001f3	5f		 pop	 rdi
  001f4	5d		 pop	 rbp
  001f5	c3		 ret	 0
rpcServer ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\rpc.c
;	COMDAT checkRpcRequestSize
_TEXT	SEGMENT
Request$ = 48
requestSize$ = 56
NdrCtx$ = 64
Ndr64Ctx$ = 72
checkRpcRequestSize PROC				; COMDAT

; 181  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 182  : 	WORD Ctx = LE16(Request->ContextId);
; 183  : 
; 184  : #	if defined(_PEDANTIC) && !defined(NO_LOG)
; 185  : 	CheckRpcRequest(Request, requestSize, NdrCtx, Ndr64Ctx, Ctx);
; 186  : #	endif // defined(_PEDANTIC) && !defined(NO_LOG)
; 187  : 
; 188  : 	// Anything that is smaller than a v4 request is illegal
; 189  : 	if (requestSize < sizeof(REQUEST_V4) + (Ctx != *Ndr64Ctx ? sizeof(RPC_REQUEST) : sizeof(RPC_REQUEST64))) return 0;

  00004	45 0f b7 11	 movzx	 r10d, WORD PTR [r9]
  00008	b8 10 00 00 00	 mov	 eax, 16
  0000d	44 8b da	 mov	 r11d, edx
  00010	66 44 39 51 04	 cmp	 WORD PTR [rcx+4], r10w
  00015	44 8d 40 08	 lea	 r8d, QWORD PTR [rax+8]
  00019	44 0f 45 c0	 cmovne	 r8d, eax
  0001d	49 81 c0 fc 00
	00 00		 add	 r8, 252			; 000000fcH
  00024	4d 3b d8	 cmp	 r11, r8
  00027	72 59		 jb	 SHORT $LN8@checkRpcRe

; 190  : 
; 191  : 	// Get KMS major version
; 192  : 	uint16_t majorIndex, minor;
; 193  : 	DWORD version;
; 194  : 
; 195  : #	ifndef SIMPLE_RPC
; 196  : 
; 197  : 	if (Ctx != *Ndr64Ctx)

  00029	66 44 39 51 04	 cmp	 WORD PTR [rcx+4], r10w
  0002e	74 05		 je	 SHORT $LN4@checkRpcRe

; 198  : 	{
; 199  : 		version = LE32(*(DWORD*)Request->Ndr.Data);

  00030	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]

; 200  : 	}
; 201  : 	else

  00033	eb 03		 jmp	 SHORT $LN3@checkRpcRe
$LN4@checkRpcRe:

; 202  : 	{
; 203  : 		version = LE32(*(DWORD*)Request->Ndr64.Data);

  00035	8b 41 18	 mov	 eax, DWORD PTR [rcx+24]
$LN3@checkRpcRe:

; 204  : 	}
; 205  : 
; 206  : #	else // SIMPLE_RPC
; 207  : 
; 208  : 	version = LE32(*(DWORD*)Request->Ndr.Data);
; 209  : 
; 210  : #	endif // SIMPLE_RPC
; 211  : 
; 212  : 	majorIndex = (uint16_t)(version >> 16) - 4;

  00038	8b c8		 mov	 ecx, eax
  0003a	41 b9 04 00 00
	00		 mov	 r9d, 4
  00040	c1 e9 10	 shr	 ecx, 16
  00043	66 41 2b c9	 sub	 cx, r9w

; 213  : 	minor = (uint16_t)(version & 0xffff);
; 214  : 
; 215  : 	// Only KMS v4, v5 and v6 are supported
; 216  : 	if (majorIndex >= vlmcsd_countof(_Versions) || minor)

  00047	66 83 f9 03	 cmp	 cx, 3
  0004b	73 1f		 jae	 SHORT $LN1@checkRpcRe
  0004d	33 d2		 xor	 edx, edx
  0004f	66 85 c0	 test	 ax, ax
  00052	75 18		 jne	 SHORT $LN1@checkRpcRe

; 222  : 	}
; 223  : 
; 224  : 	// Could check for equality but allow bigger requests to support buggy RPC clients (e.g. wine)
; 225  : 	// Buffer overrun is check by caller.
; 226  : 	return (requestSize >= _Versions[majorIndex].RequestSize);

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_Versions
  0005b	0f b7 c9	 movzx	 ecx, cx
  0005e	48 03 c9	 add	 rcx, rcx
  00061	44 3b 1c c8	 cmp	 r11d, DWORD PTR [rax+rcx*8]
  00065	0f 93 c2	 setae	 dl
  00068	8b c2		 mov	 eax, edx
  0006a	eb 18		 jmp	 SHORT $LN6@checkRpcRe
$LN1@checkRpcRe:

; 217  : 	{
; 218  : #		ifndef NO_LOG
; 219  : 		logger("Fatal: KMSv%hu.%hu unsupported\n", (unsigned short)majorIndex + 4, (unsigned short)minor);

  0006c	0f b7 d1	 movzx	 edx, cx
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@BBMKAOPO@Fatal?3?5KMSv?$CFhu?4?$CFhu?5unsupported?6?$AA@
  00076	44 0f b7 c0	 movzx	 r8d, ax
  0007a	41 03 d1	 add	 edx, r9d
  0007d	e8 00 00 00 00	 call	 logger
$LN8@checkRpcRe:

; 220  : #		endif // NO_LOG
; 221  : 		return 0;

  00082	33 c0		 xor	 eax, eax
$LN6@checkRpcRe:

; 227  : }

  00084	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00088	c3		 ret	 0
checkRpcRequestSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\rpc.c
;	COMDAT SendError
_TEXT	SEGMENT
Response$ = 8
nca_error$dead$ = 16
SendError PROC						; COMDAT

; 232  : 	Response->Error.Code = nca_error;
; 233  : 	Response->Error.Padding = 0;

  00000	33 d2		 xor	 edx, edx
  00002	48 c7 41 08 03
	00 01 1c	 mov	 QWORD PTR [rcx+8], 469827587 ; 1c010003H

; 234  : 	Response->AllocHint = LE32(32);

  0000a	8d 42 20	 lea	 eax, QWORD PTR [rdx+32]

; 235  : 	Response->ContextId = 0;

  0000d	66 89 51 04	 mov	 WORD PTR [rcx+4], dx
  00011	89 01		 mov	 DWORD PTR [rcx], eax

; 236  : 	return 32;
; 237  : }

  00013	c3		 ret	 0
SendError ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\rpc.c
;	COMDAT rpcRequest
_TEXT	SEGMENT
Request$ = 64
Response$ = 72
RpcAssocGroup_unused$ = 80
sock_unused$ = 88
NdrCtx$ = 96
Ndr64Ctx$ = 104
isValid$ = 112
ipstr$ = 120
rpcRequest PROC						; COMDAT

; 248  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 249  : 	int ResponseSize; // <0 = Errorcode (HRESULT)
; 250  : 	BYTE* requestData;
; 251  : 	BYTE* responseData;
; 252  : 	BYTE* pRpcReturnCode;
; 253  : 	int len;
; 254  : 
; 255  : #	ifndef SIMPLE_RPC
; 256  : 
; 257  : 	WORD Ctx = LE16(Request->ContextId);
; 258  : 
; 259  : 	if (Ctx == *NdrCtx)

  0001d	48 8b 44 24 60	 mov	 rax, QWORD PTR NdrCtx$[rsp]
  00022	0f b7 69 04	 movzx	 ebp, WORD PTR [rcx+4]
  00026	4c 8b 7c 24 68	 mov	 r15, QWORD PTR Ndr64Ctx$[rsp]
  0002b	48 8b fa	 mov	 rdi, rdx
  0002e	4c 8b f1	 mov	 r14, rcx
  00031	66 3b 28	 cmp	 bp, WORD PTR [rax]
  00034	75 0a		 jne	 SHORT $LN12@rpcRequest

; 260  : 	{
; 261  : 		requestData = (BYTE*)&Request->Ndr.Data;

  00036	48 83 c1 10	 add	 rcx, 16

; 262  : 		responseData = (BYTE*)&Response->Ndr.Data;

  0003a	48 83 c2 14	 add	 rdx, 20
  0003e	eb 12		 jmp	 SHORT $LN9@rpcRequest
$LN12@rpcRequest:

; 263  : 	}
; 264  : 	else if (Ctx == *Ndr64Ctx)

  00040	66 41 3b 2f	 cmp	 bp, WORD PTR [r15]
  00044	0f 85 d1 00 00
	00		 jne	 $LN10@rpcRequest

; 265  : 	{
; 266  : 		requestData = (BYTE*)&Request->Ndr64.Data;

  0004a	48 83 c1 18	 add	 rcx, 24

; 267  : 		responseData = (BYTE*)&Response->Ndr64.Data;

  0004e	48 83 c2 20	 add	 rdx, 32			; 00000020H
$LN9@rpcRequest:

; 272  : 	}
; 273  : 
; 274  : #	else // SIMPLE_RPC
; 275  : 
; 276  : 	requestData = (BYTE*)&Request->Ndr.Data;
; 277  : 	responseData = (BYTE*)&Response->Ndr.Data;
; 278  : 
; 279  : #	endif // SIMPLE_RPC
; 280  : 
; 281  : 	ResponseSize = 0x8007000D; // Invalid Data
; 282  : 
; 283  : 	if (isValid)

  00052	33 f6		 xor	 esi, esi
  00054	bb 0d 00 07 80	 mov	 ebx, -2147024883	; ffffffff8007000dH
  00059	44 8d 66 04	 lea	 r12d, QWORD PTR [rsi+4]
  0005d	40 38 74 24 70	 cmp	 BYTE PTR isValid$[rsp], sil
  00062	74 26		 je	 SHORT $LN7@rpcRequest

; 284  : 	{
; 285  : 		uint16_t majorIndex = LE16(((WORD*)requestData)[1]) - 4;

  00064	0f b7 41 02	 movzx	 eax, WORD PTR [rcx+2]

; 286  : 		if (!((ResponseSize = _Versions[majorIndex].CreateResponse(requestData, responseData, ipstr)))) ResponseSize = 0x8007000D;

  00068	4c 8b 44 24 78	 mov	 r8, QWORD PTR ipstr$[rsp]
  0006d	66 41 2b c4	 sub	 ax, r12w
  00071	44 0f b7 c8	 movzx	 r9d, ax
  00075	48 8d 05 08 00
	00 00		 lea	 rax, OFFSET FLAT:_Versions+8
  0007c	4d 03 c9	 add	 r9, r9
  0007f	42 ff 14 c8	 call	 QWORD PTR [rax+r9*8]
  00083	85 c0		 test	 eax, eax
  00085	0f 44 c3	 cmove	 eax, ebx
  00088	8b d8		 mov	 ebx, eax
$LN7@rpcRequest:

; 287  : 	}
; 288  : 
; 289  : #	ifndef SIMPLE_RPC
; 290  : 
; 291  : 	if (Ctx != *Ndr64Ctx)

  0008a	66 41 3b 2f	 cmp	 bp, WORD PTR [r15]
  0008e	74 21		 je	 SHORT $LN6@rpcRequest

; 292  : 	{
; 293  : 
; 294  : #	endif // !SIMPLE_RPC
; 295  : 		if (ResponseSize < 0)

  00090	85 db		 test	 ebx, ebx
  00092	79 0b		 jns	 SHORT $LN5@rpcRequest

; 296  : 		{
; 297  : 			Response->Ndr.DataSizeMax = Response->Ndr.DataLength = 0;

  00094	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi

; 298  : 			len = sizeof(Response->Ndr) - sizeof(Response->Ndr.DataSizeIs);

  00098	bd 08 00 00 00	 mov	 ebp, 8

; 299  : 		}
; 300  : 		else

  0009d	eb 3b		 jmp	 SHORT $LN1@rpcRequest
$LN5@rpcRequest:

; 301  : 		{
; 302  : 			Response->Ndr.DataSizeMax = LE32(0x00020000);

  0009f	c7 47 0c 00 00
	02 00		 mov	 DWORD PTR [rdi+12], 131072 ; 00020000H

; 303  : 			Response->Ndr.DataLength = Response->Ndr.DataSizeIs = LE32(ResponseSize);

  000a6	89 5f 10	 mov	 DWORD PTR [rdi+16], ebx
  000a9	89 5f 08	 mov	 DWORD PTR [rdi+8], ebx

; 304  : 			len = ResponseSize + sizeof(Response->Ndr);

  000ac	8d 6b 0c	 lea	 ebp, DWORD PTR [rbx+12]

; 305  : 		}
; 306  : 
; 307  : #	ifndef SIMPLE_RPC
; 308  : 
; 309  : 	}
; 310  : 	else

  000af	eb 29		 jmp	 SHORT $LN1@rpcRequest
$LN6@rpcRequest:

; 311  : 	{
; 312  : 		if (ResponseSize < 0)

  000b1	85 db		 test	 ebx, ebx
  000b3	79 0f		 jns	 SHORT $LN2@rpcRequest

; 313  : 		{
; 314  : 			Response->Ndr64.DataSizeMax = Response->Ndr64.DataLength = 0;

  000b5	48 89 77 08	 mov	 QWORD PTR [rdi+8], rsi
  000b9	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 315  : 			len = sizeof(Response->Ndr64) - sizeof(Response->Ndr64.DataSizeIs);

  000bd	bd 10 00 00 00	 mov	 ebp, 16

; 316  : 		}
; 317  : 		else

  000c2	eb 16		 jmp	 SHORT $LN1@rpcRequest
$LN2@rpcRequest:

; 318  : 		{
; 319  : 			Response->Ndr64.DataSizeMax = LE64(0x00020000ULL);
; 320  : 			Response->Ndr64.DataLength = Response->Ndr64.DataSizeIs = LE64((uint64_t)ResponseSize);

  000c4	48 63 c3	 movsxd	 rax, ebx
  000c7	48 c7 47 10 00
	00 02 00	 mov	 QWORD PTR [rdi+16], 131072 ; 00020000H

; 321  : 			len = ResponseSize + sizeof(Response->Ndr64);

  000cf	8d 6b 18	 lea	 ebp, DWORD PTR [rbx+24]
  000d2	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax
  000d6	48 89 47 08	 mov	 QWORD PTR [rdi+8], rax
$LN1@rpcRequest:

; 322  : 		}
; 323  : 	}
; 324  : 
; 325  : #	endif // !SIMPLE_RPC
; 326  : 
; 327  : 	pRpcReturnCode = ((BYTE*)&Response->Ndr) + len;
; 328  : 	UA32(pRpcReturnCode) = ResponseSize < 0 ? LE32(ResponseSize) : 0;

  000da	85 db		 test	 ebx, ebx
  000dc	48 63 cd	 movsxd	 rcx, ebp
  000df	8b c6		 mov	 eax, esi
  000e1	0f 48 c3	 cmovs	 eax, ebx

; 329  : 	len += sizeof(DWORD);
; 330  : 
; 331  : 	// Pad zeros to 32-bit align (seems not neccassary but Windows RPC does it this way)
; 332  : 	int pad = ((~len & 3) + 1) & 3;
; 333  : 	memset(pRpcReturnCode + sizeof(DWORD), 0, pad);

  000e4	48 83 c1 0c	 add	 rcx, 12
  000e8	41 03 ec	 add	 ebp, r12d
  000eb	89 44 39 fc	 mov	 DWORD PTR [rcx+rdi-4], eax
  000ef	8b dd		 mov	 ebx, ebp
  000f1	48 03 cf	 add	 rcx, rdi
  000f4	f7 d3		 not	 ebx
  000f6	33 d2		 xor	 edx, edx
  000f8	ff c3		 inc	 ebx
  000fa	83 e3 03	 and	 ebx, 3
  000fd	4c 63 c3	 movsxd	 r8, ebx
  00100	e8 00 00 00 00	 call	 memset

; 334  : 	len += pad;

  00105	03 eb		 add	 ebp, ebx

; 335  : 
; 336  : 	Response->AllocHint = LE32(len);

  00107	89 2f		 mov	 DWORD PTR [rdi], ebp

; 337  : 	Response->ContextId = Request->ContextId;

  00109	41 0f b7 46 04	 movzx	 eax, WORD PTR [r14+4]

; 338  : 
; 339  : 	*((WORD*)&Response->CancelCount) = 0; // CancelCount + Pad1

  0010e	66 89 77 06	 mov	 WORD PTR [rdi+6], si
  00112	66 89 47 04	 mov	 WORD PTR [rdi+4], ax

; 340  : 
; 341  : 	return len + 8;

  00116	8d 45 08	 lea	 eax, DWORD PTR [rbp+8]
  00119	eb 13		 jmp	 SHORT $LN13@rpcRequest
$LN10@rpcRequest:

; 268  : 	}
; 269  : 	else
; 270  : 	{
; 271  : 		return SendError(Response, RPC_NCA_UNK_IF);

  0011b	33 f6		 xor	 esi, esi
  0011d	48 c7 42 08 03
	00 01 1c	 mov	 QWORD PTR [rdx+8], 469827587 ; 1c010003H
  00125	8d 46 20	 lea	 eax, QWORD PTR [rsi+32]
  00128	66 89 72 04	 mov	 WORD PTR [rdx+4], si
  0012c	89 02		 mov	 DWORD PTR [rdx], eax
$LN13@rpcRequest:

; 342  : }

  0012e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00133	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00138	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0013d	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  00142	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00146	41 5f		 pop	 r15
  00148	41 5e		 pop	 r14
  0014a	41 5c		 pop	 r12
  0014c	c3		 ret	 0
rpcRequest ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\rpc.c
;	COMDAT checkRpcBindSize
_TEXT	SEGMENT
Request$ = 8
RequestSize$ = 16
NdrCtx_unused$ = 24
Ndr64Ctx_unused$ = 32
checkRpcBindSize PROC					; COMDAT

; 410  : {

  00000	44 8b c2	 mov	 r8d, edx

; 411  : 	if (RequestSize < sizeof(RPC_BIND_REQUEST)) return FALSE;

  00003	83 fa 38	 cmp	 edx, 56			; 00000038H
  00006	73 03		 jae	 SHORT $LN2@checkRpcBi
  00008	33 c0		 xor	 eax, eax

; 416  : 
; 417  : #if defined(_PEDANTIC) && !defined(NO_LOG)
; 418  : 	CheckRpcBindRequest(Request, RequestSize);
; 419  : #endif // defined(_PEDANTIC) && !defined(NO_LOG)
; 420  : 
; 421  : 	return TRUE;
; 422  : }

  0000a	c3		 ret	 0
$LN2@checkRpcBi:

; 412  : 
; 413  : 	unsigned int numCtxItems = LE32(Request->NumCtxItems);
; 414  : 
; 415  : 	if (RequestSize < sizeof(RPC_BIND_REQUEST) - sizeof(Request->CtxItems[0]) + numCtxItems * sizeof(Request->CtxItems[0])) return FALSE;

  0000b	8b 41 08	 mov	 eax, DWORD PTR [rcx+8]
  0000e	48 6b d0 2c	 imul	 rdx, rax, 44		; 0000002cH
  00012	33 c0		 xor	 eax, eax
  00014	48 83 c2 0c	 add	 rdx, 12
  00018	4c 3b c2	 cmp	 r8, rdx
  0001b	0f 93 c0	 setae	 al

; 416  : 
; 417  : #if defined(_PEDANTIC) && !defined(NO_LOG)
; 418  : 	CheckRpcBindRequest(Request, RequestSize);
; 419  : #endif // defined(_PEDANTIC) && !defined(NO_LOG)
; 420  : 
; 421  : 	return TRUE;
; 422  : }

  0001e	c3		 ret	 0
checkRpcBindSize ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\rpc.c
;	COMDAT rpcBind
_TEXT	SEGMENT
addr$ = 64
Request$ = 240
Response$ = 248
socklen$ = 256
RpcAssocGroup$ = 256
sock$ = 264
NdrCtx$ = 272
Ndr64Ctx$ = 280
packetType$ = 288
ipstr_unused$ = 296
rpcBind	PROC						; COMDAT

; 433  : {

  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  0000f	57		 push	 rdi
  00010	41 54		 push	 r12
  00012	41 55		 push	 r13
  00014	41 56		 push	 r14
  00016	41 57		 push	 r15
  00018	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 434  : 	unsigned int i;
; 435  : 	DWORD numCtxItems = LE32(Request->NumCtxItems);

  0001f	44 8b 71 08	 mov	 r14d, DWORD PTR [rcx+8]

; 436  : 	int_fast8_t IsNDR64possible = FALSE;

  00023	45 33 e4	 xor	 r12d, r12d

; 437  : 	uint_fast8_t portNumberSize;
; 438  : 
; 439  : 	socklen_t socklen;
; 440  : 	struct sockaddr_storage addr;
; 441  : 
; 442  : 	// M$ RPC does not do this. Pad bytes contain apparently random data
; 443  : 	// memset(Response->SecondaryAddress, 0, sizeof(Response->SecondaryAddress));
; 444  : 
; 445  : 	socklen = sizeof addr;
; 446  : 
; 447  : 	if (
; 448  : 		packetType == RPC_PT_ALTERCONTEXT_REQ ||
; 449  : 		getsockname(sock, (struct sockaddr*)&addr, &socklen) ||
; 450  : 		getnameinfo((struct sockaddr*)&addr, socklen, NULL, 0, (char*)Response->SecondaryAddress, sizeof(Response->SecondaryAddress), NI_NUMERICSERV))

  00026	80 bc 24 20 01
	00 00 0e	 cmp	 BYTE PTR packetType$[rsp], 14
  0002e	45 8d 6c 24 01	 lea	 r13d, QWORD PTR [r12+1]
  00033	41 8b e8	 mov	 ebp, r8d
  00036	48 8b da	 mov	 rbx, rdx
  00039	48 8b f9	 mov	 rdi, rcx
  0003c	45 8a fc	 mov	 r15b, r12b
  0003f	c7 40 18 80 00
	00 00		 mov	 DWORD PTR [rax+24], 128	; 00000080H
  00046	74 64		 je	 SHORT $LN18@rpcBind
  00048	4c 8d 40 18	 lea	 r8, QWORD PTR [rax+24]
  0004c	48 8d 54 24 40	 lea	 rdx, QWORD PTR addr$[rsp]
  00051	49 8b c9	 mov	 rcx, r9
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getsockname
  0005a	85 c0		 test	 eax, eax
  0005c	75 4e		 jne	 SHORT $LN18@rpcBind
  0005e	8b 94 24 00 01
	00 00		 mov	 edx, DWORD PTR socklen$[rsp]
  00065	c7 44 24 30 08
	00 00 00	 mov	 DWORD PTR [rsp+48], 8
  0006d	48 8d 73 0a	 lea	 rsi, QWORD PTR [rbx+10]
  00071	48 8d 4c 24 40	 lea	 rcx, QWORD PTR addr$[rsp]
  00076	45 33 c9	 xor	 r9d, r9d
  00079	45 33 c0	 xor	 r8d, r8d
  0007c	c7 44 24 28 06
	00 00 00	 mov	 DWORD PTR [rsp+40], 6
  00084	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getnameinfo
  0008f	85 c0		 test	 eax, eax
  00091	75 19		 jne	 SHORT $LN18@rpcBind

; 454  : 	}
; 455  : 	else
; 456  : 	{
; 457  : 		portNumberSize = (uint_fast8_t)strlen((char*)Response->SecondaryAddress) + 1;

  00093	48 83 ca ff	 or	 rdx, -1
$LL31@rpcBind:
  00097	48 ff c2	 inc	 rdx
  0009a	44 38 24 16	 cmp	 BYTE PTR [rsi+rdx], r12b
  0009e	75 f7		 jne	 SHORT $LL31@rpcBind
  000a0	41 02 d5	 add	 dl, r13b

; 458  : 		Response->SecondaryAddressLength = LE16(portNumberSize);

  000a3	0f b6 c2	 movzx	 eax, dl
  000a6	66 89 43 08	 mov	 WORD PTR [rbx+8], ax
  000aa	eb 08		 jmp	 SHORT $LN17@rpcBind
$LN18@rpcBind:

; 451  : 	{
; 452  : 		portNumberSize = 0;

  000ac	41 8a d4	 mov	 dl, r12b

; 453  : 		Response->SecondaryAddressLength = 0;

  000af	66 44 89 63 08	 mov	 WORD PTR [rbx+8], r12w
$LN17@rpcBind:

; 459  : 	}
; 460  : 
; 461  : 	Response->MaxXmitFrag = Request->MaxXmitFrag;

  000b4	0f b7 07	 movzx	 eax, WORD PTR [rdi]

; 462  : 	Response->MaxRecvFrag = Request->MaxRecvFrag;
; 463  : 	Response->AssocGroup = LE32(RpcAssocGroup);
; 464  : 
; 465  : 	// This is really ugly (but efficient) code to support padding after the secondary address field
; 466  : 	if (portNumberSize < 3)

  000b7	be 03 00 00 00	 mov	 esi, 3
  000bc	66 89 03	 mov	 WORD PTR [rbx], ax
  000bf	0f b7 47 02	 movzx	 eax, WORD PTR [rdi+2]
  000c3	89 6b 04	 mov	 DWORD PTR [rbx+4], ebp
  000c6	66 89 43 02	 mov	 WORD PTR [rbx+2], ax
  000ca	40 3a d6	 cmp	 dl, sil
  000cd	73 04		 jae	 SHORT $LN16@rpcBind

; 467  : 	{
; 468  : 		Response = (RPC_BIND_RESPONSE*)((BYTE*)Response - 4);

  000cf	48 83 eb 04	 sub	 rbx, 4
$LN16@rpcBind:

; 469  : 	}
; 470  : 
; 471  : 	Response->NumResults = Request->NumCtxItems;

  000d3	8b 47 08	 mov	 eax, DWORD PTR [rdi+8]
  000d6	89 43 10	 mov	 DWORD PTR [rbx+16], eax

; 472  : 
; 473  : #	ifndef SIMPLE_RPC
; 474  : 
; 475  : 	for (i = 0; i < numCtxItems; i++)

  000d9	45 85 f6	 test	 r14d, r14d
  000dc	0f 84 83 01 00
	00		 je	 $LN8@rpcBind
  000e2	4c 8b 8c 24 18
	01 00 00	 mov	 r9, QWORD PTR Ndr64Ctx$[rsp]
  000ea	4c 8b 94 24 10
	01 00 00	 mov	 r10, QWORD PTR NdrCtx$[rsp]
  000f2	48 8d 4f 0c	 lea	 rcx, QWORD PTR [rdi+12]
  000f6	4d 8b c6	 mov	 r8, r14
$LL15@rpcBind:

; 476  : 	{
; 477  : 		const struct CtxItem* ctxItem = &Request->CtxItems[i];
; 478  : 		if (IsEqualGUID((GUID*)TransferSyntaxNDR32, &ctxItem->TransferSyntax))

  000f9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR32
  00100	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]
  00104	75 14		 jne	 SHORT $LN12@rpcBind
  00106	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR32+8
  0010d	48 3b 41 20	 cmp	 rax, QWORD PTR [rcx+32]
  00111	75 07		 jne	 SHORT $LN12@rpcBind

; 479  : 		{
; 480  : 			/*if (packetType == RPC_PT_BIND_REQ)*/
; 481  : 			*NdrCtx = LE16(ctxItem->ContextId);

  00113	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00116	66 41 89 02	 mov	 WORD PTR [r10], ax
$LN12@rpcBind:

; 482  : 		}
; 483  : 
; 484  : 		if (UseServerRpcNDR64 && IsEqualGUID((GUID*)TransferSyntaxNDR64, &ctxItem->TransferSyntax))

  0011a	44 38 25 00 00
	00 00		 cmp	 BYTE PTR UseServerRpcNDR64, r12b
  00121	74 24		 je	 SHORT $LN14@rpcBind
  00123	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR64
  0012a	48 3b 41 18	 cmp	 rax, QWORD PTR [rcx+24]
  0012e	75 17		 jne	 SHORT $LN14@rpcBind
  00130	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR64+8
  00137	48 3b 41 20	 cmp	 rax, QWORD PTR [rcx+32]
  0013b	75 0a		 jne	 SHORT $LN14@rpcBind

; 485  : 		{
; 486  : 			IsNDR64possible = TRUE;
; 487  : 
; 488  : 			/*if (packetType == RPC_PT_BIND_REQ)*/
; 489  : 			*Ndr64Ctx = LE16(ctxItem->ContextId);

  0013d	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00140	45 8a fd	 mov	 r15b, r13b
  00143	66 41 89 01	 mov	 WORD PTR [r9], ax
$LN14@rpcBind:

; 472  : 
; 473  : #	ifndef SIMPLE_RPC
; 474  : 
; 475  : 	for (i = 0; i < numCtxItems; i++)

  00147	48 83 c1 2c	 add	 rcx, 44			; 0000002cH
  0014b	4d 2b c5	 sub	 r8, r13
  0014e	75 a9		 jne	 SHORT $LL15@rpcBind

; 490  : 		}
; 491  : 	}
; 492  : 
; 493  : #	endif // !SIMPLE_RPC
; 494  : 
; 495  : 	for (i = 0; i < numCtxItems; i++)

  00150	45 85 f6	 test	 r14d, r14d
  00153	0f 84 0c 01 00
	00		 je	 $LN8@rpcBind
  00159	4c 8d 47 24	 lea	 r8, QWORD PTR [rdi+36]
  0015d	48 8d 4b 28	 lea	 rcx, QWORD PTR [rbx+40]
  00161	4d 8b de	 mov	 r11, r14
  00164	48 83 c7 10	 add	 rdi, 16
  00168	bb 02 00 00 00	 mov	 ebx, 2
$LL10@rpcBind:

; 496  : 	{
; 497  : 		struct CtxResults* result = Response->Results+i;
; 498  : 		const GUID* ctxTransferSyntax = &Request->CtxItems[i].TransferSyntax;
; 499  : 
; 500  : #		ifndef SIMPLE_RPC
; 501  : 		WORD nackReason = RPC_ABSTRACTSYNTAX_UNSUPPORTED;
; 502  : #		endif // !SIMPLE_RPC
; 503  : 
; 504  : 		memset(&result->TransferSyntax, 0, sizeof(GUID));

  0016d	33 c0		 xor	 eax, eax
  0016f	45 0f b7 cd	 movzx	 r9d, r13w
  00173	48 89 41 f0	 mov	 QWORD PTR [rcx-16], rax
  00177	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 505  : 
; 506  : #		ifndef SIMPLE_RPC
; 507  : 		int isInterfaceUUID = IsEqualGUID(&Request->CtxItems[i].InterfaceUUID, (GUID*)InterfaceUuid);

  0017b	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0017e	48 2b 05 00 00
	00 00		 sub	 rax, QWORD PTR InterfaceUuid
  00185	75 0b		 jne	 SHORT $LN30@rpcBind
  00187	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0018b	48 2b 05 08 00
	00 00		 sub	 rax, QWORD PTR InterfaceUuid+8
$LN30@rpcBind:
  00192	48 85 c0	 test	 rax, rax
  00195	45 8b d4	 mov	 r10d, r12d
  00198	41 0f 94 c2	 sete	 r10b

; 508  : 		if (isInterfaceUUID) nackReason = RPC_SYNTAX_UNSUPPORTED;

  0019c	45 85 d2	 test	 r10d, r10d
  0019f	74 35		 je	 SHORT $LN6@rpcBind
  001a1	44 8b cb	 mov	 r9d, ebx

; 509  : #		else // SIMPLE_RPC
; 510  : #		define isInterfaceUUID TRUE
; 511  : #		endif // SIMPLE_RPC
; 512  : 
; 513  : 		if (isInterfaceUUID && !IsNDR64possible && IsEqualGUID((GUID*)TransferSyntaxNDR32, ctxTransferSyntax))

  001a4	45 84 ff	 test	 r15b, r15b
  001a7	75 2d		 jne	 SHORT $LN6@rpcBind
  001a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR32
  001b0	49 3b 00	 cmp	 rax, QWORD PTR [r8]
  001b3	75 21		 jne	 SHORT $LN6@rpcBind
  001b5	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR32+8
  001bc	49 3b 40 08	 cmp	 rax, QWORD PTR [r8+8]
  001c0	75 14		 jne	 SHORT $LN6@rpcBind

; 514  : 		{
; 515  : 			result->SyntaxVersion = LE32(2);

  001c2	89 19		 mov	 DWORD PTR [rcx], ebx

; 516  : 			result->AckResult = result->AckReason = RPC_BIND_ACCEPT;

  001c4	44 89 61 ec	 mov	 DWORD PTR [rcx-20], r12d

; 517  : 			memcpy(&result->TransferSyntax, TransferSyntaxNDR32, sizeof(GUID));

  001c8	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR TransferSyntaxNDR32
$LN33@rpcBind:
  001cf	f3 0f 7f 41 f0	 movdqu	 XMMWORD PTR [rcx-16], xmm0

; 518  : 			continue;

  001d4	eb 7a		 jmp	 SHORT $LN9@rpcBind
$LN6@rpcBind:

; 519  : 		}
; 520  : 
; 521  : #		ifndef SIMPLE_RPC
; 522  : 
; 523  : 		if (IsEqualGUID((GUID*)TransferSyntaxNDR64, ctxTransferSyntax))

  001d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR64
  001dd	49 3b 00	 cmp	 rax, QWORD PTR [r8]
  001e0	75 34		 jne	 SHORT $LN3@rpcBind
  001e2	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR TransferSyntaxNDR64+8
  001e9	49 3b 40 08	 cmp	 rax, QWORD PTR [r8+8]
  001ed	75 27		 jne	 SHORT $LN3@rpcBind

; 524  : 		{
; 525  : 			if (!UseServerRpcNDR64) nackReason = RPC_SYNTAX_UNSUPPORTED;

  001ef	44 38 25 00 00
	00 00		 cmp	 BYTE PTR UseServerRpcNDR64, r12b
  001f6	75 04		 jne	 SHORT $LN4@rpcBind
  001f8	44 0f b7 cb	 movzx	 r9d, bx
$LN4@rpcBind:

; 526  : 
; 527  : 			if (isInterfaceUUID && IsNDR64possible)

  001fc	45 85 d2	 test	 r10d, r10d
  001ff	74 15		 je	 SHORT $LN3@rpcBind
  00201	45 84 ff	 test	 r15b, r15b
  00204	74 10		 je	 SHORT $LN3@rpcBind

; 528  : 			{
; 529  : 				result->SyntaxVersion = LE32(1);

  00206	44 89 29	 mov	 DWORD PTR [rcx], r13d

; 530  : 				result->AckResult = result->AckReason = RPC_BIND_ACCEPT;

  00209	44 89 61 ec	 mov	 DWORD PTR [rcx-20], r12d

; 531  : 				memcpy(&result->TransferSyntax, TransferSyntaxNDR64, sizeof(GUID));

  0020d	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR TransferSyntaxNDR64

; 532  : 				continue;

  00214	eb b9		 jmp	 SHORT $LN33@rpcBind
$LN3@rpcBind:

; 533  : 			}
; 534  : 		}
; 535  : 
; 536  : 		if (!memcmp(BindTimeFeatureNegotiation, ctxTransferSyntax, 8))

  00216	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR BindTimeFeatureNegotiation
  0021d	49 3b 00	 cmp	 rax, QWORD PTR [r8]
  00220	75 22		 jne	 SHORT $LN1@rpcBind

; 537  : 		{
; 538  : 			nackReason = RPC_SYNTAX_UNSUPPORTED;
; 539  : 
; 540  : 			if (UseServerRpcBTFN)

  00222	44 38 25 00 00
	00 00		 cmp	 BYTE PTR UseServerRpcBTFN, r12b
  00229	44 0f b7 cb	 movzx	 r9d, bx
  0022d	74 15		 je	 SHORT $LN1@rpcBind

; 541  : 			{
; 542  : 				result->SyntaxVersion = 0;

  0022f	44 89 21	 mov	 DWORD PTR [rcx], r12d

; 543  : 				result->AckResult = RPC_BIND_ACK;

  00232	66 89 71 ec	 mov	 WORD PTR [rcx-20], si

; 544  : 
; 545  : 				// Features requested are actually encoded in the GUID
; 546  : 				result->AckReason =
; 547  : 					((WORD*)(ctxTransferSyntax))[4] &
; 548  : 					(RPC_BTFN_SEC_CONTEXT_MULTIPLEX | RPC_BTFN_KEEP_ORPHAN);

  00236	41 0f b7 40 08	 movzx	 eax, WORD PTR [r8+8]
  0023b	66 23 c6	 and	 ax, si
  0023e	66 89 41 ee	 mov	 WORD PTR [rcx-18], ax

; 549  : 
; 550  : 				continue;

  00242	eb 0c		 jmp	 SHORT $LN9@rpcBind
$LN1@rpcBind:

; 551  : 			}
; 552  : 		}
; 553  : 
; 554  : #		endif // !SIMPLE_RPC
; 555  : 
; 556  : 		result->SyntaxVersion = 0;

  00244	44 89 21	 mov	 DWORD PTR [rcx], r12d

; 557  : 		result->AckResult = RPC_BIND_NACK;

  00247	66 89 59 ec	 mov	 WORD PTR [rcx-20], bx

; 558  : #		ifndef SIMPLE_RPC
; 559  : 		result->AckReason = nackReason;

  0024b	66 44 89 49 ee	 mov	 WORD PTR [rcx-18], r9w
$LN9@rpcBind:

; 490  : 		}
; 491  : 	}
; 492  : 
; 493  : #	endif // !SIMPLE_RPC
; 494  : 
; 495  : 	for (i = 0; i < numCtxItems; i++)

  00250	48 83 c7 2c	 add	 rdi, 44			; 0000002cH
  00254	48 83 c1 18	 add	 rcx, 24
  00258	49 83 c0 2c	 add	 r8, 44			; 0000002cH
  0025c	4d 2b dd	 sub	 r11, r13
  0025f	0f 85 08 ff ff
	ff		 jne	 $LL10@rpcBind
$LN8@rpcBind:

; 560  : #		else // SIMPLE_RPC
; 561  : #		undef isInterfaceUUID
; 562  : 		result->AckReason = RPC_SYNTAX_UNSUPPORTED;
; 563  : #		endif // SIMPLE_RPC
; 564  : 	}
; 565  : 
; 566  : 	//if (!_st) return 0;
; 567  : 
; 568  : 	return sizeof(RPC_BIND_RESPONSE) + numCtxItems * sizeof(struct CtxResults) - (portNumberSize < 3 ? 4 : 0);

  00265	40 3a d6	 cmp	 dl, sil

; 569  : }

  00268	4c 8d 9c 24 c0
	00 00 00	 lea	 r11, QWORD PTR [rsp+192]
  00270	41 8b c6	 mov	 eax, r14d
  00273	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  00277	49 8b 6b 38	 mov	 rbp, QWORD PTR [r11+56]
  0027b	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  0027f	48 1b c9	 sbb	 rcx, rcx
  00282	48 8d 04 40	 lea	 rax, QWORD PTR [rax+rax*2]
  00286	48 c1 e0 03	 shl	 rax, 3
  0028a	83 e1 04	 and	 ecx, 4
  0028d	48 2b c1	 sub	 rax, rcx
  00290	48 83 c0 14	 add	 rax, 20
  00294	49 8b e3	 mov	 rsp, r11
  00297	41 5f		 pop	 r15
  00299	41 5e		 pop	 r14
  0029b	41 5d		 pop	 r13
  0029d	41 5c		 pop	 r12
  0029f	5f		 pop	 rdi
  002a0	c3		 ret	 0
rpcBind	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\rpc.c
;	COMDAT createRpcHeader
_TEXT	SEGMENT
header$ = 8
packetType$dead$ = 16
size$dead$ = 24
createRpcHeader PROC					; COMDAT

; 598  : 	header->PacketType = packetType;
; 599  : 	header->PacketFlags = RPC_PF_FIRST | RPC_PF_LAST;
; 600  : 	header->VersionMajor = 5;

  00000	c7 01 05 00 03
	03		 mov	 DWORD PTR [rcx], 50528261 ; 03030005H

; 601  : 	header->VersionMinor = 0;
; 602  : 	header->AuthLength = 0;
; 603  : 	header->DataRepresentation = BE32(0x10000000); // Little endian, ASCII charset, IEEE floating point

  00006	48 c7 41 04 10
	00 00 00	 mov	 QWORD PTR [rcx+4], 16

; 604  : 	header->CallId = LE32(CallId);

  0000e	c7 41 0c 02 00
	00 00		 mov	 DWORD PTR [rcx+12], 2

; 605  : 	header->FragLength = LE16(size);
; 606  : }

  00015	c3		 ret	 0
createRpcHeader ENDP
_TEXT	ENDS
END
