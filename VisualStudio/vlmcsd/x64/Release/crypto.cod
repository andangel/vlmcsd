; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	AesKeyV4
PUBLIC	AesKeyV6
PUBLIC	AesKeyV5
AesKeyV4 DB	05H
	DB	03dH
	DB	083H
	DB	07H
	DB	0f9H
	DB	0e5H
	DB	0f0H
	DB	088H
	DB	0ebH
	DB	05eH
	DB	0a6H
	DB	068H
	DB	06cH
	DB	0f0H
	DB	037H
	DB	0c7H
	DB	0e4H
	DB	0efH
	DB	0d2H
	DB	0d6H
SBox	DB	063H
	DB	07cH
	DB	077H
	DB	07bH
	DB	0f2H
	DB	06bH
	DB	06fH
	DB	0c5H
	DB	030H
	DB	01H
	DB	067H
	DB	02bH
	DB	0feH
	DB	0d7H
	DB	0abH
	DB	076H
	DB	0caH
	DB	082H
	DB	0c9H
	DB	07dH
	DB	0faH
	DB	059H
	DB	047H
	DB	0f0H
	DB	0adH
	DB	0d4H
	DB	0a2H
	DB	0afH
	DB	09cH
	DB	0a4H
	DB	072H
	DB	0c0H
	DB	0b7H
	DB	0fdH
	DB	093H
	DB	026H
	DB	036H
	DB	03fH
	DB	0f7H
	DB	0ccH
	DB	034H
	DB	0a5H
	DB	0e5H
	DB	0f1H
	DB	071H
	DB	0d8H
	DB	031H
	DB	015H
	DB	04H
	DB	0c7H
	DB	023H
	DB	0c3H
	DB	018H
	DB	096H
	DB	05H
	DB	09aH
	DB	07H
	DB	012H
	DB	080H
	DB	0e2H
	DB	0ebH
	DB	027H
	DB	0b2H
	DB	075H
	DB	09H
	DB	083H
	DB	02cH
	DB	01aH
	DB	01bH
	DB	06eH
	DB	05aH
	DB	0a0H
	DB	052H
	DB	03bH
	DB	0d6H
	DB	0b3H
	DB	029H
	DB	0e3H
	DB	02fH
	DB	084H
	DB	053H
	DB	0d1H
	DB	00H
	DB	0edH
	DB	020H
	DB	0fcH
	DB	0b1H
	DB	05bH
	DB	06aH
	DB	0cbH
	DB	0beH
	DB	039H
	DB	04aH
	DB	04cH
	DB	058H
	DB	0cfH
	DB	0d0H
	DB	0efH
	DB	0aaH
	DB	0fbH
	DB	043H
	DB	04dH
	DB	033H
	DB	085H
	DB	045H
	DB	0f9H
	DB	02H
	DB	07fH
	DB	050H
	DB	03cH
	DB	09fH
	DB	0a8H
	DB	051H
	DB	0a3H
	DB	040H
	DB	08fH
	DB	092H
	DB	09dH
	DB	038H
	DB	0f5H
	DB	0bcH
	DB	0b6H
	DB	0daH
	DB	021H
	DB	010H
	DB	0ffH
	DB	0f3H
	DB	0d2H
	DB	0cdH
	DB	0cH
	DB	013H
	DB	0ecH
	DB	05fH
	DB	097H
	DB	044H
	DB	017H
	DB	0c4H
	DB	0a7H
	DB	07eH
	DB	03dH
	DB	064H
	DB	05dH
	DB	019H
	DB	073H
	DB	060H
	DB	081H
	DB	04fH
	DB	0dcH
	DB	022H
	DB	02aH
	DB	090H
	DB	088H
	DB	046H
	DB	0eeH
	DB	0b8H
	DB	014H
	DB	0deH
	DB	05eH
	DB	0bH
	DB	0dbH
	DB	0e0H
	DB	032H
	DB	03aH
	DB	0aH
	DB	049H
	DB	06H
	DB	024H
	DB	05cH
	DB	0c2H
	DB	0d3H
	DB	0acH
	DB	062H
	DB	091H
	DB	095H
	DB	0e4H
	DB	079H
	DB	0e7H
	DB	0c8H
	DB	037H
	DB	06dH
	DB	08dH
	DB	0d5H
	DB	04eH
	DB	0a9H
	DB	06cH
	DB	056H
	DB	0f4H
	DB	0eaH
	DB	065H
	DB	07aH
	DB	0aeH
	DB	08H
	DB	0baH
	DB	078H
	DB	025H
	DB	02eH
	DB	01cH
	DB	0a6H
	DB	0b4H
	DB	0c6H
	DB	0e8H
	DB	0ddH
	DB	074H
	DB	01fH
	DB	04bH
	DB	0bdH
	DB	08bH
	DB	08aH
	DB	070H
	DB	03eH
	DB	0b5H
	DB	066H
	DB	048H
	DB	03H
	DB	0f6H
	DB	0eH
	DB	061H
	DB	035H
	DB	057H
	DB	0b9H
	DB	086H
	DB	0c1H
	DB	01dH
	DB	09eH
	DB	0e1H
	DB	0f8H
	DB	098H
	DB	011H
	DB	069H
	DB	0d9H
	DB	08eH
	DB	094H
	DB	09bH
	DB	01eH
	DB	087H
	DB	0e9H
	DB	0ceH
	DB	055H
	DB	028H
	DB	0dfH
	DB	08cH
	DB	0a1H
	DB	089H
	DB	0dH
	DB	0bfH
	DB	0e6H
	DB	042H
	DB	068H
	DB	041H
	DB	099H
	DB	02dH
	DB	0fH
	DB	0b0H
	DB	054H
	DB	0bbH
	DB	016H
AesKeyV6 DB	0a9H
	DB	04aH
	DB	041H
	DB	095H
	DB	0e2H
	DB	01H
	DB	043H
	DB	02dH
	DB	09bH
	DB	0cbH
	DB	046H
	DB	04H
	DB	05H
	DB	0d8H
	DB	04aH
	DB	021H
AesKeyV5 DB	0cdH
	DB	07eH
	DB	079H
	DB	06fH
	DB	02aH
	DB	0b2H
	DB	05dH
	DB	0cbH
	DB	055H
	DB	0ffH
	DB	0c8H
	DB	0efH
	DB	083H
	DB	064H
	DB	0c4H
	DB	070H
?RCon@?1??AesInitKey@@9@9 DD 00H			; `AesInitKey'::`2'::RCon
	DD	01000000H
	DD	02000000H
	DD	04000000H
	DD	08000000H
	DD	010000000H
	DD	020000000H
	DD	040000000H
	DD	080000000H
	DD	01b000000H
	DD	036000000H
	ORG $+1
SBoxR	DB	052H
	DB	09H
	DB	06aH
	DB	0d5H
	DB	030H
	DB	036H
	DB	0a5H
	DB	038H
	DB	0bfH
	DB	040H
	DB	0a3H
	DB	09eH
	DB	081H
	DB	0f3H
	DB	0d7H
	DB	0fbH
	DB	07cH
	DB	0e3H
	DB	039H
	DB	082H
	DB	09bH
	DB	02fH
	DB	0ffH
	DB	087H
	DB	034H
	DB	08eH
	DB	043H
	DB	044H
	DB	0c4H
	DB	0deH
	DB	0e9H
	DB	0cbH
	DB	054H
	DB	07bH
	DB	094H
	DB	032H
	DB	0a6H
	DB	0c2H
	DB	023H
	DB	03dH
	DB	0eeH
	DB	04cH
	DB	095H
	DB	0bH
	DB	042H
	DB	0faH
	DB	0c3H
	DB	04eH
	DB	08H
	DB	02eH
	DB	0a1H
	DB	066H
	DB	028H
	DB	0d9H
	DB	024H
	DB	0b2H
	DB	076H
	DB	05bH
	DB	0a2H
	DB	049H
	DB	06dH
	DB	08bH
	DB	0d1H
	DB	025H
	DB	072H
	DB	0f8H
	DB	0f6H
	DB	064H
	DB	086H
	DB	068H
	DB	098H
	DB	016H
	DB	0d4H
	DB	0a4H
	DB	05cH
	DB	0ccH
	DB	05dH
	DB	065H
	DB	0b6H
	DB	092H
	DB	06cH
	DB	070H
	DB	048H
	DB	050H
	DB	0fdH
	DB	0edH
	DB	0b9H
	DB	0daH
	DB	05eH
	DB	015H
	DB	046H
	DB	057H
	DB	0a7H
	DB	08dH
	DB	09dH
	DB	084H
	DB	090H
	DB	0d8H
	DB	0abH
	DB	00H
	DB	08cH
	DB	0bcH
	DB	0d3H
	DB	0aH
	DB	0f7H
	DB	0e4H
	DB	058H
	DB	05H
	DB	0b8H
	DB	0b3H
	DB	045H
	DB	06H
	DB	0d0H
	DB	02cH
	DB	01eH
	DB	08fH
	DB	0caH
	DB	03fH
	DB	0fH
	DB	02H
	DB	0c1H
	DB	0afH
	DB	0bdH
	DB	03H
	DB	01H
	DB	013H
	DB	08aH
	DB	06bH
	DB	03aH
	DB	091H
	DB	011H
	DB	041H
	DB	04fH
	DB	067H
	DB	0dcH
	DB	0eaH
	DB	097H
	DB	0f2H
	DB	0cfH
	DB	0ceH
	DB	0f0H
	DB	0b4H
	DB	0e6H
	DB	073H
	DB	096H
	DB	0acH
	DB	074H
	DB	022H
	DB	0e7H
	DB	0adH
	DB	035H
	DB	085H
	DB	0e2H
	DB	0f9H
	DB	037H
	DB	0e8H
	DB	01cH
	DB	075H
	DB	0dfH
	DB	06eH
	DB	047H
	DB	0f1H
	DB	01aH
	DB	071H
	DB	01dH
	DB	029H
	DB	0c5H
	DB	089H
	DB	06fH
	DB	0b7H
	DB	062H
	DB	0eH
	DB	0aaH
	DB	018H
	DB	0beH
	DB	01bH
	DB	0fcH
	DB	056H
	DB	03eH
	DB	04bH
	DB	0c6H
	DB	0d2H
	DB	079H
	DB	020H
	DB	09aH
	DB	0dbH
	DB	0c0H
	DB	0feH
	DB	078H
	DB	0cdH
	DB	05aH
	DB	0f4H
	DB	01fH
	DB	0ddH
	DB	0a8H
	DB	033H
	DB	088H
	DB	07H
	DB	0c7H
	DB	031H
	DB	0b1H
	DB	012H
	DB	010H
	DB	059H
	DB	027H
	DB	080H
	DB	0ecH
	DB	05fH
	DB	060H
	DB	051H
	DB	07fH
	DB	0a9H
	DB	019H
	DB	0b5H
	DB	04aH
	DB	0dH
	DB	02dH
	DB	0e5H
	DB	07aH
	DB	09fH
	DB	093H
	DB	0c9H
	DB	09cH
	DB	0efH
	DB	0a0H
	DB	0e0H
	DB	03bH
	DB	04dH
	DB	0aeH
	DB	02aH
	DB	0f5H
	DB	0b0H
	DB	0c8H
	DB	0ebH
	DB	0bbH
	DB	03cH
	DB	083H
	DB	053H
	DB	099H
	DB	061H
	DB	017H
	DB	02bH
	DB	04H
	DB	07eH
	DB	0baH
	DB	077H
	DB	0d6H
	DB	026H
	DB	0e1H
	DB	069H
	DB	014H
	DB	063H
	DB	055H
	DB	021H
	DB	0cH
	DB	07dH
PUBLIC	AesDecryptCbc
PUBLIC	AesDecryptBlock
PUBLIC	AesEncryptCbc
PUBLIC	AesCmacV4
PUBLIC	AesEncryptBlock
PUBLIC	AesInitKey
PUBLIC	MixColumnsR
PUBLIC	XorBlock
EXTRN	__chkstk:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	strcmp:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesDecryptCbc DD imagerel $LN30
	DD	imagerel $LN30+102
	DD	imagerel $unwind$AesDecryptCbc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesDecryptBlock DD imagerel $LN49
	DD	imagerel $LN49+228
	DD	imagerel $unwind$AesDecryptBlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesEncryptCbc DD imagerel $LN30
	DD	imagerel $LN30+162
	DD	imagerel $unwind$AesEncryptCbc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ShiftRowsR DD imagerel ShiftRowsR
	DD	imagerel ShiftRowsR+54
	DD	imagerel $unwind$ShiftRowsR
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesCmacV4 DD imagerel $LN20
	DD	imagerel $LN20+181
	DD	imagerel $unwind$AesCmacV4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesEncryptBlock DD imagerel $LN58
	DD	imagerel $LN58+357
	DD	imagerel $unwind$AesEncryptBlock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MixColumns DD imagerel MixColumns
	DD	imagerel MixColumns+143
	DD	imagerel $unwind$MixColumns
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ShiftRows DD imagerel ShiftRows
	DD	imagerel ShiftRows+47
	DD	imagerel $unwind$ShiftRows
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$AesInitKey DD imagerel $LN22
	DD	imagerel $LN22+248
	DD	imagerel $unwind$AesInitKey
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$MixColumnsR DD imagerel $LN11
	DD	imagerel $LN11+762
	DD	imagerel $unwind$MixColumnsR
;	COMDAT xdata
xdata	SEGMENT
$unwind$MixColumnsR DD 091501H
	DD	0f0112215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesInitKey DD 081201H
	DD	095412H
	DD	083412H
	DD	0e00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ShiftRows DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$MixColumns DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesEncryptBlock DD 0c1d01H
	DD	09741dH
	DD	08641dH
	DD	07541dH
	DD	06341dH
	DD	0f019121dH
	DD	0c015e017H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesCmacV4 DD 091701H
	DD	0246417H
	DD	0235417H
	DD	0223417H
	DD	0200117H
	DD	07010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ShiftRowsR DD 010401H
	DD	02204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesEncryptCbc DD 0a1901H
	DD	097419H
	DD	086419H
	DD	075419H
	DD	063419H
	DD	0e0153219H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesDecryptBlock DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$AesDecryptCbc DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT XorBlock
_TEXT	SEGMENT
in$ = 8
out$ = 16
XorBlock PROC						; COMDAT

; 41   : 	/*UAA64( out, 0 ) ^= UAA64( in, 0 );
; 42   : 	UAA64( out, 1 ) ^= UAA64( in, 1 );*/
; 43   : 
; 44   : 	uint_fast8_t i;
; 45   : 
; 46   : 	for (i = 0; i < AES_BLOCK_WORDS; i++)

  00000	48 2b ca	 sub	 rcx, rdx
  00003	41 b8 04 00 00
	00		 mov	 r8d, 4
$LL3@XorBlock:

; 47   : 	{
; 48   : 		((DWORD*)out)[i] ^= ((DWORD*)in)[i];

  00009	8b 04 11	 mov	 eax, DWORD PTR [rcx+rdx]
  0000c	31 02		 xor	 DWORD PTR [rdx], eax
  0000e	48 8d 52 04	 lea	 rdx, QWORD PTR [rdx+4]
  00012	49 ff c8	 dec	 r8
  00015	75 f2		 jne	 SHORT $LL3@XorBlock

; 49   : 	}
; 50   : }

  00017	c3		 ret	 0
XorBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT MixColumnsR
_TEXT	SEGMENT
tv632 = 0
state$ = 96
tv562 = 104
tv591 = 112
tv619 = 120
MixColumnsR PROC					; COMDAT

; 80   : {

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 18	 sub	 rsp, 24
  00015	48 8b c1	 mov	 rax, rcx

; 81   : 	uint_fast8_t i = 0;

  00018	48 c7 04 24 04
	00 00 00	 mov	 QWORD PTR tv632[rsp], 4
  00020	41 b8 01 01 01
	01		 mov	 r8d, 16843009		; 01010101H
$LL3@MixColumns:

; 82   : 	for (; i < AES_BLOCK_WORDS; i++)
; 83   : 	{
; 84   : 		#if defined(_CRYPTO_OPENSSL) && defined(_OPENSSL_SOFTWARE) && defined(_USE_AES_FROM_OPENSSL) //Always byte swap regardless of endianess
; 85   : 			DWORD word = BS32(((DWORD *) state)[i]);
; 86   : 			((DWORD *) state)[i] = BS32(MulE(word) ^ ROR32(MulB(word), 8) ^ ROR32(MulD(word), 16) ^ ROR32(Mul9(word), 24));
; 87   : 		#else
; 88   : 			DWORD word = LE32(((DWORD *) state)[i]);

  00026	8b 08		 mov	 ecx, DWORD PTR [rax]

; 89   : 			((DWORD *) state)[i] = LE32(MulE(word) ^ ROR32(MulB(word), 8) ^ ROR32(MulD(word), 16) ^ ROR32(Mul9(word), 24));

  00028	8b e9		 mov	 ebp, ecx
  0002a	44 8b f9	 mov	 r15d, ecx
  0002d	41 81 e7 1f ff
	ff ff		 and	 r15d, -225		; ffffff1fH
  00034	c1 ed 07	 shr	 ebp, 7
  00037	45 03 ff	 add	 r15d, r15d
  0003a	8b c5		 mov	 eax, ebp
  0003c	8b dd		 mov	 ebx, ebp
  0003e	41 23 c0	 and	 eax, r8d
  00041	81 e3 01 01 01
	00		 and	 ebx, 65793		; 00010101H
  00047	89 44 24 78	 mov	 DWORD PTR tv619[rsp], eax
  0004b	6b d0 1b	 imul	 edx, eax, 27
  0004e	44 8b e2	 mov	 r12d, edx
  00051	89 54 24 68	 mov	 DWORD PTR tv562[rsp], edx
  00055	6b f3 1b	 imul	 esi, ebx, 27
  00058	41 d1 ec	 shr	 r12d, 1
  0005b	8b fe		 mov	 edi, esi
  0005d	44 33 e1	 xor	 r12d, ecx
  00060	d1 ef		 shr	 edi, 1
  00062	33 f9		 xor	 edi, ecx
  00064	41 c1 ec 06	 shr	 r12d, 6
  00068	45 23 e0	 and	 r12d, r8d
  0006b	c1 ef 06	 shr	 edi, 6
  0006e	81 e7 01 01 01
	00		 and	 edi, 65793		; 00010101H
  00074	45 6b f4 1b	 imul	 r14d, r12d, 27
  00078	44 89 74 24 70	 mov	 DWORD PTR tv591[rsp], r14d
  0007d	41 d1 ee	 shr	 r14d, 1
  00080	41 8b c6	 mov	 eax, r14d
  00083	33 c2		 xor	 eax, edx
  00085	8b d5		 mov	 edx, ebp
  00087	83 e5 01	 and	 ebp, 1
  0008a	d1 e8		 shr	 eax, 1
  0008c	81 e2 01 01 00
	00		 and	 edx, 257		; 00000101H
  00092	33 c1		 xor	 eax, ecx
  00094	44 6b dd 1b	 imul	 r11d, ebp, 27
  00098	c1 e8 05	 shr	 eax, 5
  0009b	45 8b d3	 mov	 r10d, r11d
  0009e	41 23 c0	 and	 eax, r8d
  000a1	41 d1 ea	 shr	 r10d, 1
  000a4	44 33 d1	 xor	 r10d, ecx
  000a7	41 c1 ea 06	 shr	 r10d, 6
  000ab	41 83 e2 01	 and	 r10d, 1
  000af	44 6b c2 1b	 imul	 r8d, edx, 27
  000b3	44 6b e8 1b	 imul	 r13d, eax, 27
  000b7	8b c1		 mov	 eax, ecx
  000b9	45 8b c8	 mov	 r9d, r8d
  000bc	25 3f ff ff ff	 and	 eax, -193		; ffffff3fH
  000c1	41 d1 e9	 shr	 r9d, 1
  000c4	44 33 f8	 xor	 r15d, eax
  000c7	44 33 c9	 xor	 r9d, ecx
  000ca	41 c1 e7 02	 shl	 r15d, 2
  000ce	41 c1 e9 06	 shr	 r9d, 6
  000d2	44 33 f9	 xor	 r15d, ecx
  000d5	41 81 e1 01 01
	00 00		 and	 r9d, 257		; 00000101H
  000dc	41 c1 e7 10	 shl	 r15d, 16
  000e0	69 ca 00 00 6c
	00		 imul	 ecx, edx, 7077888	; 006c0000H
  000e6	81 e1 ff ff fd
	fd		 and	 ecx, -33685505		; fdfdffffH
  000ec	41 69 c1 00 00
	36 00		 imul	 eax, r9d, 3538944	; 00360000H
  000f3	33 c8		 xor	 ecx, eax
  000f5	69 c2 00 00 36
	00		 imul	 eax, edx, 3538944	; 00360000H
  000fb	48 8b 54 24 60	 mov	 rdx, QWORD PTR state$[rsp]
  00100	33 c8		 xor	 ecx, eax
  00102	81 e1 00 00 fe
	fe		 and	 ecx, -16908288		; fefe0000H
  00108	44 33 f9	 xor	 r15d, ecx
  0010b	41 8b cd	 mov	 ecx, r13d
  0010e	41 6b c1 1b	 imul	 eax, r9d, 27
  00112	d1 e8		 shr	 eax, 1
  00114	41 33 c0	 xor	 eax, r8d
  00117	44 8b 44 24 70	 mov	 r8d, DWORD PTR tv591[rsp]
  0011c	d1 e8		 shr	 eax, 1
  0011e	41 33 c8	 xor	 ecx, r8d
  00121	33 02		 xor	 eax, DWORD PTR [rdx]
  00123	c1 e8 05	 shr	 eax, 5
  00126	25 01 01 00 00	 and	 eax, 257		; 00000101H
  0012b	69 c0 00 00 1b
	00		 imul	 eax, eax, 1769472	; 001b0000H
  00131	44 33 f8	 xor	 r15d, eax
  00134	41 69 c1 00 00
	1b 00		 imul	 eax, r9d, 1769472	; 001b0000H
  0013b	44 8b 0a	 mov	 r9d, DWORD PTR [rdx]
  0013e	41 33 c9	 xor	 ecx, r9d
  00141	44 33 f8	 xor	 r15d, eax
  00144	d1 e9		 shr	 ecx, 1
  00146	69 d5 00 00 00
	6c		 imul	 edx, ebp, 1811939328	; 6c000000H
  0014c	41 8b c0	 mov	 eax, r8d
  0014f	33 44 24 68	 xor	 eax, DWORD PTR tv562[rsp]
  00153	25 00 00 7f 7f	 and	 eax, 2139029504		; 7f7f0000H
  00158	0f ba f2 19	 btr	 edx, 25
  0015c	33 c8		 xor	 ecx, eax
  0015e	8b 44 24 68	 mov	 eax, DWORD PTR tv562[rsp]
  00162	41 33 c1	 xor	 eax, r9d
  00165	d1 e9		 shr	 ecx, 1
  00167	25 00 00 3f 3f	 and	 eax, 1061093376		; 3f3f0000H
  0016c	33 c8		 xor	 ecx, eax
  0016e	41 8b c1	 mov	 eax, r9d
  00171	25 00 00 1f 1f	 and	 eax, 522125312		; 1f1f0000H
  00176	d1 e9		 shr	 ecx, 1
  00178	33 c8		 xor	 ecx, eax
  0017a	c1 e9 0d	 shr	 ecx, 13
  0017d	44 0b f9	 or	 r15d, ecx
  00180	41 8b cd	 mov	 ecx, r13d
  00183	41 69 c2 00 00
	00 36		 imul	 eax, r10d, 905969664	; 36000000H
  0018a	33 d0		 xor	 edx, eax
  0018c	41 8b c1	 mov	 eax, r9d
  0018f	c1 e0 19	 shl	 eax, 25
  00192	33 d0		 xor	 edx, eax
  00194	81 e2 00 00 00
	fe		 and	 edx, -33554432		; fe000000H
  0019a	41 6b c2 1b	 imul	 eax, r10d, 27
  0019e	44 8b 54 24 68	 mov	 r10d, DWORD PTR tv562[rsp]
  001a3	d1 e8		 shr	 eax, 1
  001a5	41 33 c3	 xor	 eax, r11d
  001a8	41 33 ca	 xor	 ecx, r10d
  001ab	d1 e8		 shr	 eax, 1
  001ad	41 33 c9	 xor	 ecx, r9d
  001b0	41 33 c1	 xor	 eax, r9d
  001b3	d1 e9		 shr	 ecx, 1
  001b5	c1 e8 05	 shr	 eax, 5
  001b8	83 e0 01	 and	 eax, 1
  001bb	69 c0 00 00 00
	1b		 imul	 eax, eax, 452984832	; 1b000000H
  001c1	33 d0		 xor	 edx, eax
  001c3	41 8b c1	 mov	 eax, r9d
  001c6	c1 e0 03	 shl	 eax, 3
  001c9	41 33 c1	 xor	 eax, r9d
  001cc	c1 e0 18	 shl	 eax, 24
  001cf	33 d0		 xor	 edx, eax
  001d1	69 c5 00 00 00
	1b		 imul	 eax, ebp, 452984832	; 1b000000H
  001d7	33 d0		 xor	 edx, eax
  001d9	41 8b c0	 mov	 eax, r8d
  001dc	41 33 c1	 xor	 eax, r9d
  001df	25 00 7f 7f 7f	 and	 eax, 2139062016		; 7f7f7f00H
  001e4	33 c8		 xor	 ecx, eax
  001e6	41 8b c2	 mov	 eax, r10d
  001e9	25 00 3f 3f 3f	 and	 eax, 1061109504		; 3f3f3f00H
  001ee	d1 e9		 shr	 ecx, 1
  001f0	33 c8		 xor	 ecx, eax
  001f2	41 8b c1	 mov	 eax, r9d
  001f5	25 00 1f 1f 1f	 and	 eax, 522133248		; 1f1f1f00H
  001fa	d1 e9		 shr	 ecx, 1
  001fc	33 c8		 xor	 ecx, eax
  001fe	c1 e9 05	 shr	 ecx, 5
  00201	0b d1		 or	 edx, ecx
  00203	41 8b ca	 mov	 ecx, r10d
  00206	44 33 fa	 xor	 r15d, edx
  00209	69 c7 00 36 00
	00		 imul	 eax, edi, 13824		; 00003600H
  0020f	69 d3 00 6c 00
	00		 imul	 edx, ebx, 27648		; 00006c00H
  00215	81 e2 ff fd fd
	fd		 and	 edx, -33686017		; fdfdfdffH
  0021b	33 d0		 xor	 edx, eax
  0021d	81 e2 00 fe fe
	fe		 and	 edx, -16843264		; fefefe00H
  00223	6b c7 1b	 imul	 eax, edi, 27
  00226	d1 e8		 shr	 eax, 1
  00228	33 c6		 xor	 eax, esi
  0022a	d1 e8		 shr	 eax, 1
  0022c	41 33 c1	 xor	 eax, r9d
  0022f	c1 e8 05	 shr	 eax, 5
  00232	25 01 01 01 00	 and	 eax, 65793		; 00010101H
  00237	69 c0 00 1b 00
	00		 imul	 eax, eax, 6912		; 00001b00H
  0023d	33 d0		 xor	 edx, eax
  0023f	41 8b c1	 mov	 eax, r9d
  00242	25 1f 1f ff ff	 and	 eax, -57569		; ffff1f1fH
  00247	c1 e0 03	 shl	 eax, 3
  0024a	41 33 c1	 xor	 eax, r9d
  0024d	c1 e0 08	 shl	 eax, 8
  00250	33 d0		 xor	 edx, eax
  00252	0f ba f1 17	 btr	 ecx, 23
  00256	41 33 ce	 xor	 ecx, r14d
  00259	41 8b c5	 mov	 eax, r13d
  0025c	41 33 c1	 xor	 eax, r9d
  0025f	81 e1 00 00 80
	3f		 and	 ecx, 1065353216		; 3f800000H
  00265	c1 e8 02	 shr	 eax, 2
  00268	33 c8		 xor	 ecx, eax
  0026a	41 8b c1	 mov	 eax, r9d
  0026d	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  00272	d1 e9		 shr	 ecx, 1
  00274	33 c8		 xor	 ecx, eax
  00276	c1 e9 15	 shr	 ecx, 21
  00279	0b d1		 or	 edx, ecx
  0027b	44 33 fa	 xor	 r15d, edx
  0027e	41 6b c4 36	 imul	 eax, r12d, 54		; 00000036H
  00282	6b 4c 24 78 6c	 imul	 ecx, DWORD PTR tv619[rsp], 108 ; 0000006cH
  00287	81 e1 fd fd fd
	fd		 and	 ecx, -33686019		; fdfdfdfdH
  0028d	33 c8		 xor	 ecx, eax
  0028f	6b 44 24 78 36	 imul	 eax, DWORD PTR tv619[rsp], 54 ; 00000036H
  00294	33 c8		 xor	 ecx, eax
  00296	43 8d 04 09	 lea	 eax, DWORD PTR [r9+r9]
  0029a	33 c8		 xor	 ecx, eax
  0029c	41 8b c1	 mov	 eax, r9d
  0029f	41 81 e1 3f 3f
	3f ff		 and	 r9d, -12632257		; ff3f3f3fH
  002a6	25 1f 1f 1f ff	 and	 eax, -14737633		; ff1f1f1fH
  002ab	81 e1 fe fe fe
	fe		 and	 ecx, -16843010		; fefefefeH
  002b1	03 c0		 add	 eax, eax
  002b3	44 33 f9	 xor	 r15d, ecx
  002b6	41 33 c1	 xor	 eax, r9d
  002b9	c1 e0 02	 shl	 eax, 2
  002bc	44 33 f8	 xor	 r15d, eax
  002bf	48 8b 44 24 60	 mov	 rax, QWORD PTR state$[rsp]
  002c4	45 33 fd	 xor	 r15d, r13d
  002c7	45 33 f8	 xor	 r15d, r8d
  002ca	41 b8 01 01 01
	01		 mov	 r8d, 16843009		; 01010101H
  002d0	45 33 fa	 xor	 r15d, r10d
  002d3	44 89 38	 mov	 DWORD PTR [rax], r15d
  002d6	48 83 c0 04	 add	 rax, 4
  002da	48 ff 0c 24	 dec	 QWORD PTR tv632[rsp]
  002de	48 89 44 24 60	 mov	 QWORD PTR state$[rsp], rax
  002e3	0f 85 3d fd ff
	ff		 jne	 $LL3@MixColumns

; 90   : 		#endif
; 91   : 	}
; 92   : }

  002e9	48 83 c4 18	 add	 rsp, 24
  002ed	41 5f		 pop	 r15
  002ef	41 5e		 pop	 r14
  002f1	41 5d		 pop	 r13
  002f3	41 5c		 pop	 r12
  002f5	5f		 pop	 rdi
  002f6	5e		 pop	 rsi
  002f7	5d		 pop	 rbp
  002f8	5b		 pop	 rbx
  002f9	c3		 ret	 0
MixColumnsR ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT SubDword
_TEXT	SEGMENT
v$ = 8
SubDword PROC						; COMDAT

; 96   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 97   : 	BYTE *b = (BYTE *)&v;
; 98   : 	uint_fast8_t i = 0;

  00004	ba 04 00 00 00	 mov	 edx, 4
  00009	48 8d 4c 24 08	 lea	 rcx, QWORD PTR v$[rsp]
$LL3@SubDword:

; 99   : 
; 100  : 	for (; i < sizeof(DWORD); i++) b[i] = SBox[b[i]];

  0000e	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00011	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:SBox
  00018	42 8a 04 00	 mov	 al, BYTE PTR [rax+r8]
  0001c	88 01		 mov	 BYTE PTR [rcx], al
  0001e	48 ff c1	 inc	 rcx
  00021	48 ff ca	 dec	 rdx
  00024	75 e8		 jne	 SHORT $LL3@SubDword

; 101  : 
; 102  : 	return v;

  00026	8b 44 24 08	 mov	 eax, DWORD PTR v$[rsp]

; 103  : }

  0002a	c3		 ret	 0
SubDword ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT AesInitKey
_TEXT	SEGMENT
Ctx$ = 64
Key$ = 72
v$ = 80
IsV6$ = 80
RijndaelKeyBytes$ = 88
AesInitKey PROC						; COMDAT

; 107  : {

$LN22:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 56		 push	 r14
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	41 8a f0	 mov	 sil, r8b

; 108  : 	int RijndaelKeyDwords = RijndaelKeyBytes / sizeof(DWORD);

  00015	4d 63 c1	 movsxd	 r8, r9d
  00018	48 8b d9	 mov	 rbx, rcx
  0001b	49 8b f8	 mov	 rdi, r8
  0001e	48 c1 ef 02	 shr	 rdi, 2

; 109  : 	Ctx->rounds = (uint_fast8_t)(RijndaelKeyDwords + 6);

  00022	8d 47 06	 lea	 eax, DWORD PTR [rdi+6]
  00025	88 81 c0 00 00
	00		 mov	 BYTE PTR [rcx+192], al

; 110  : 
; 111  : 	static const DWORD RCon[] = {
; 112  : 		0x00000000, 0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000,
; 113  : 		0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000 };
; 114  : 
; 115  : 	uint_fast8_t  i;
; 116  : 	DWORD  temp;
; 117  : 
; 118  : 	memcpy(Ctx->Key, Key, RijndaelKeyBytes);

  0002b	e8 00 00 00 00	 call	 memcpy

; 119  : 
; 120  : 	for ( i = (uint_fast8_t)RijndaelKeyDwords; i < ( Ctx->rounds + 1 ) << 2; i++ )

  00030	0f b6 8b c0 00
	00 00		 movzx	 ecx, BYTE PTR [rbx+192]
  00037	8d 0c 8d 04 00
	00 00		 lea	 ecx, DWORD PTR [rcx*4+4]
  0003e	40 0f b6 d7	 movzx	 edx, dil
  00042	44 8a cf	 mov	 r9b, dil
  00045	3b d1		 cmp	 edx, ecx
  00047	0f 8d 84 00 00
	00		 jge	 $LN3@AesInitKey
  0004d	4c 63 df	 movsxd	 r11, edi
  00050	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:__ImageBase
$LL5@AesInitKey:

; 121  : 	{
; 122  : 		temp = Ctx->Key[ i - 1 ];
; 123  : 
; 124  : 		if ( ( i % RijndaelKeyDwords ) == 0 )

  00057	8b c2		 mov	 eax, edx
  00059	45 0f b6 d1	 movzx	 r10d, r9b
  0005d	46 8b 44 93 fc	 mov	 r8d, DWORD PTR [rbx+r10*4-4]
  00062	99		 cdq
  00063	f7 ff		 idiv	 edi
  00065	48 63 e8	 movsxd	 rbp, eax
  00068	85 d2		 test	 edx, edx
  0006a	75 3c		 jne	 SHORT $LN2@AesInitKey

; 125  : 			temp = BE32( SubDword( ROR32( BE32(temp), 24)  ) ^ RCon[ i / RijndaelKeyDwords ] );

  0006c	41 0f c8	 bswap	 r8d
  0006f	48 8d 54 24 50	 lea	 rdx, QWORD PTR v$[rsp]
  00074	41 c1 c0 08	 rol	 r8d, 8
  00078	44 89 44 24 50	 mov	 DWORD PTR v$[rsp], r8d
  0007d	41 b8 04 00 00
	00		 mov	 r8d, 4
$LL10@AesInitKey:
  00083	0f b6 0a	 movzx	 ecx, BYTE PTR [rdx]
  00086	42 8a 84 31 00
	00 00 00	 mov	 al, BYTE PTR SBox[rcx+r14]
  0008e	88 02		 mov	 BYTE PTR [rdx], al
  00090	48 ff c2	 inc	 rdx
  00093	49 ff c8	 dec	 r8
  00096	75 eb		 jne	 SHORT $LL10@AesInitKey
  00098	45 8b 84 ae 00
	00 00 00	 mov	 r8d, DWORD PTR ?RCon@?1??AesInitKey@@9@9[r14+rbp*4]
  000a0	44 33 44 24 50	 xor	 r8d, DWORD PTR v$[rsp]
  000a5	41 0f c8	 bswap	 r8d
$LN2@AesInitKey:

; 126  : 
; 127  : 		Ctx->Key[ i ] = Ctx->Key[ i - RijndaelKeyDwords ] ^ temp;

  000a8	41 fe c1	 inc	 r9b
  000ab	49 8b c2	 mov	 rax, r10
  000ae	49 2b c3	 sub	 rax, r11
  000b1	41 0f b6 d1	 movzx	 edx, r9b
  000b5	8b 0c 83	 mov	 ecx, DWORD PTR [rbx+rax*4]
  000b8	41 33 c8	 xor	 ecx, r8d
  000bb	42 89 0c 93	 mov	 DWORD PTR [rbx+r10*4], ecx
  000bf	0f b6 83 c0 00
	00 00		 movzx	 eax, BYTE PTR [rbx+192]
  000c6	8d 04 85 04 00
	00 00		 lea	 eax, DWORD PTR [rax*4+4]
  000cd	3b d0		 cmp	 edx, eax
  000cf	7c 86		 jl	 SHORT $LL5@AesInitKey
$LN3@AesInitKey:

; 128  : 	}
; 129  : 
; 130  : 	if ( IsV6 )

  000d1	40 84 f6	 test	 sil, sil
  000d4	74 0f		 je	 SHORT $LN1@AesInitKey

; 131  : 	{
; 132  : 		BYTE *_p = (BYTE *)Ctx->Key;
; 133  : 
; 134  : 		_p[ 4 * 16 ] ^= 0x73;

  000d6	80 73 40 73	 xor	 BYTE PTR [rbx+64], 115	; 00000073H

; 135  : 		_p[ 6 * 16 ] ^= 0x09;

  000da	80 73 60 09	 xor	 BYTE PTR [rbx+96], 9

; 136  : 		_p[ 8 * 16 ] ^= 0xE4;

  000de	80 b3 80 00 00
	00 e4		 xor	 BYTE PTR [rbx+128], 228	; 000000e4H
$LN1@AesInitKey:

; 137  : 	}
; 138  : }

  000e5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ea	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ef	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f3	41 5e		 pop	 r14
  000f5	5f		 pop	 rdi
  000f6	5e		 pop	 rsi
  000f7	c3		 ret	 0
AesInitKey ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT SubBytes
_TEXT	SEGMENT
block$ = 8
SubBytes PROC						; COMDAT

; 144  : 	uint_fast8_t i;
; 145  : 
; 146  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)

  00000	ba 10 00 00 00	 mov	 edx, 16
$LL3@SubBytes:

; 147  : 		block[i] = SBox[ block[i] ];

  00005	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00008	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:SBox
  0000f	42 8a 04 00	 mov	 al, BYTE PTR [rax+r8]
  00013	88 01		 mov	 BYTE PTR [rcx], al
  00015	48 ff c1	 inc	 rcx
  00018	48 ff ca	 dec	 rdx
  0001b	75 e8		 jne	 SHORT $LL3@SubBytes

; 148  : }

  0001d	c3		 ret	 0
SubBytes ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT ShiftRows
_TEXT	SEGMENT
bIn$ = 0
state$ = 32
ShiftRows PROC						; COMDAT

; 152  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 153  : 	BYTE bIn[AES_BLOCK_BYTES];
; 154  : 	uint_fast8_t i;
; 155  : 
; 156  : 	memcpy(bIn, state, AES_BLOCK_BYTES);

  00004	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]

; 157  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)

  00007	45 32 c0	 xor	 r8b, r8b
  0000a	f3 0f 7f 04 24	 movdqu	 XMMWORD PTR bIn$[rsp], xmm0
$LL3@ShiftRows:

; 158  : 	{
; 159  : 		state[i] = bIn[(i + ((i & 3) << 2)) & 0xf];

  0000f	41 0f b6 c0	 movzx	 eax, r8b
  00013	41 fe c0	 inc	 r8b
  00016	8d 14 80	 lea	 edx, DWORD PTR [rax+rax*4]
  00019	83 e2 0f	 and	 edx, 15
  0001c	8a 04 14	 mov	 al, BYTE PTR bIn$[rsp+rdx]
  0001f	88 01		 mov	 BYTE PTR [rcx], al
  00021	48 ff c1	 inc	 rcx
  00024	41 80 f8 10	 cmp	 r8b, 16
  00028	72 e5		 jb	 SHORT $LL3@ShiftRows

; 160  : 	}
; 161  : };

  0002a	48 83 c4 18	 add	 rsp, 24
  0002e	c3		 ret	 0
ShiftRows ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT MixColumns
_TEXT	SEGMENT
state$ = 8
MixColumns PROC						; COMDAT

; 165  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0000a	48 8b d9	 mov	 rbx, rcx

; 166  : 	uint_fast8_t i = 0;

  0000d	bf 04 00 00 00	 mov	 edi, 4
$LL3@MixColumns:

; 167  : 	for (; i < AES_BLOCK_WORDS; i++)
; 168  : 	{
; 169  : 		DWORD word = LE32(((DWORD *) state)[i]);

  00012	44 8b 1b	 mov	 r11d, DWORD PTR [rbx]

; 170  : 		((DWORD *) state)[i] = LE32(Mul2(word) ^ ROR32(Mul3(word), 8) ^ ROR32(word, 16) ^ ROR32(word, 24));

  00015	41 8b d3	 mov	 edx, r11d
  00018	45 8b d3	 mov	 r10d, r11d
  0001b	41 c1 c2 10	 rol	 r10d, 16
  0001f	c1 ea 07	 shr	 edx, 7
  00022	47 8d 04 1b	 lea	 r8d, DWORD PTR [r11+r11]
  00026	45 33 c3	 xor	 r8d, r11d
  00029	8b c2		 mov	 eax, edx
  0002b	83 e2 01	 and	 edx, 1
  0002e	25 01 01 01 01	 and	 eax, 16843009		; 01010101H
  00033	41 c1 e0 18	 shl	 r8d, 24
  00037	44 6b c8 1b	 imul	 r9d, eax, 27
  0003b	41 8b c3	 mov	 eax, r11d
  0003e	41 8b c9	 mov	 ecx, r9d
  00041	c1 c0 08	 rol	 eax, 8
  00044	44 33 d0	 xor	 r10d, eax
  00047	41 33 cb	 xor	 ecx, r11d
  0004a	d1 e9		 shr	 ecx, 1
  0004c	69 c2 00 00 00
	1b		 imul	 eax, edx, 452984832	; 1b000000H
  00052	44 33 c0	 xor	 r8d, eax
  00055	41 8b c3	 mov	 eax, r11d
  00058	25 00 7f 7f 7f	 and	 eax, 2139062016		; 7f7f7f00H
  0005d	41 81 e3 7f 7f
	7f ff		 and	 r11d, -8421505		; ff7f7f7fH
  00064	33 c8		 xor	 ecx, eax
  00066	45 03 db	 add	 r11d, r11d
  00069	c1 e9 07	 shr	 ecx, 7
  0006c	44 0b c1	 or	 r8d, ecx
  0006f	45 33 d0	 xor	 r10d, r8d
  00072	45 33 d3	 xor	 r10d, r11d
  00075	45 33 d1	 xor	 r10d, r9d
  00078	44 89 13	 mov	 DWORD PTR [rbx], r10d
  0007b	48 8d 5b 04	 lea	 rbx, QWORD PTR [rbx+4]
  0007f	48 ff cf	 dec	 rdi
  00082	75 8e		 jne	 SHORT $LL3@MixColumns

; 171  : 	}
; 172  : }

  00084	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00089	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
  0008e	c3		 ret	 0
MixColumns ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT AesEncryptBlock
_TEXT	SEGMENT
bIn$1 = 0
Ctx$ = 48
block$ = 56
AesEncryptBlock PROC					; COMDAT

; 176  : {

$LN58:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 54		 push	 r12
  00015	41 56		 push	 r14
  00017	41 57		 push	 r15
  00019	48 83 ec 10	 sub	 rsp, 16
  0001d	0f b6 b1 c0 00
	00 00		 movzx	 esi, BYTE PTR [rcx+192]
  00024	4c 8b da	 mov	 r11, rdx
  00027	48 8b f9	 mov	 rdi, rcx

; 177  : 	uint_fast8_t  i;
; 178  : 
; 179  : 	for ( i = 0 ;; i += 4 )

  0002a	32 db		 xor	 bl, bl
  0002c	41 bc 04 00 00
	00		 mov	 r12d, 4
  00032	44 8d 3c b5 fc
	ff ff ff	 lea	 r15d, DWORD PTR [rsi*4-4]
$LL4@AesEncrypt:

; 180  : 	{
; 181  : 		AddRoundKey(block, &Ctx->Key[ i ]);

  0003a	44 0f b6 c3	 movzx	 r8d, bl
  0003e	49 8b d3	 mov	 rdx, r11
  00041	49 8b cc	 mov	 rcx, r12
  00044	49 c1 e0 02	 shl	 r8, 2
  00048	4d 2b c3	 sub	 r8, r11
  0004b	4c 03 c7	 add	 r8, rdi
$LL9@AesEncrypt:
  0004e	41 8b 04 10	 mov	 eax, DWORD PTR [r8+rdx]
  00052	31 02		 xor	 DWORD PTR [rdx], eax
  00054	49 03 d4	 add	 rdx, r12
  00057	48 ff c9	 dec	 rcx
  0005a	75 f2		 jne	 SHORT $LL9@AesEncrypt

; 182  : 		SubBytes(block);

  0005c	49 8b cb	 mov	 rcx, r11
  0005f	ba 10 00 00 00	 mov	 edx, 16
$LL14@AesEncrypt:
  00064	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00067	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:SBox
  0006e	42 8a 04 00	 mov	 al, BYTE PTR [rax+r8]
  00072	88 01		 mov	 BYTE PTR [rcx], al
  00074	48 ff c1	 inc	 rcx
  00077	48 ff ca	 dec	 rdx
  0007a	75 e8		 jne	 SHORT $LL14@AesEncrypt

; 183  : 		ShiftRows(block);

  0007c	41 0f 10 03	 movups	 xmm0, XMMWORD PTR [r11]
  00080	4d 8b c3	 mov	 r8, r11
  00083	f3 0f 7f 04 24	 movdqu	 XMMWORD PTR bIn$1[rsp], xmm0
$LL19@AesEncrypt:
  00088	0f b6 c2	 movzx	 eax, dl
  0008b	fe c2		 inc	 dl
  0008d	8d 0c 80	 lea	 ecx, DWORD PTR [rax+rax*4]
  00090	83 e1 0f	 and	 ecx, 15
  00093	8a 04 0c	 mov	 al, BYTE PTR bIn$1[rsp+rcx]
  00096	41 88 00	 mov	 BYTE PTR [r8], al
  00099	49 ff c0	 inc	 r8
  0009c	80 fa 10	 cmp	 dl, 16
  0009f	72 e7		 jb	 SHORT $LL19@AesEncrypt

; 184  : 
; 185  : 		if ( i >= ( Ctx->rounds - 1 ) << 2 ) break;

  000a1	0f b6 c3	 movzx	 eax, bl
  000a4	41 3b c7	 cmp	 eax, r15d
  000a7	7d 7c		 jge	 SHORT $LN39@AesEncrypt

; 186  : 
; 187  : 		MixColumns(block);

  000a9	4d 8b f3	 mov	 r14, r11
  000ac	49 8b ec	 mov	 rbp, r12
$LL24@AesEncrypt:
  000af	45 8b 16	 mov	 r10d, DWORD PTR [r14]
  000b2	41 8b ca	 mov	 ecx, r10d
  000b5	45 8b ca	 mov	 r9d, r10d
  000b8	c1 e9 07	 shr	 ecx, 7
  000bb	41 c1 c1 10	 rol	 r9d, 16
  000bf	43 8d 14 12	 lea	 edx, DWORD PTR [r10+r10]
  000c3	8b c1		 mov	 eax, ecx
  000c5	83 e1 01	 and	 ecx, 1
  000c8	41 33 d2	 xor	 edx, r10d
  000cb	25 01 01 01 01	 and	 eax, 16843009		; 01010101H
  000d0	c1 e2 18	 shl	 edx, 24
  000d3	44 6b c0 1b	 imul	 r8d, eax, 27
  000d7	41 8b c2	 mov	 eax, r10d
  000da	c1 c0 08	 rol	 eax, 8
  000dd	44 33 c8	 xor	 r9d, eax
  000e0	69 c1 00 00 00
	1b		 imul	 eax, ecx, 452984832	; 1b000000H
  000e6	41 8b c8	 mov	 ecx, r8d
  000e9	41 33 ca	 xor	 ecx, r10d
  000ec	33 d0		 xor	 edx, eax
  000ee	41 8b c2	 mov	 eax, r10d
  000f1	d1 e9		 shr	 ecx, 1
  000f3	25 00 7f 7f 7f	 and	 eax, 2139062016		; 7f7f7f00H
  000f8	41 81 e2 7f 7f
	7f ff		 and	 r10d, -8421505		; ff7f7f7fH
  000ff	33 c8		 xor	 ecx, eax
  00101	45 03 d2	 add	 r10d, r10d
  00104	c1 e9 07	 shr	 ecx, 7
  00107	0b d1		 or	 edx, ecx
  00109	44 33 ca	 xor	 r9d, edx
  0010c	45 33 ca	 xor	 r9d, r10d
  0010f	45 33 c8	 xor	 r9d, r8d
  00112	45 89 0e	 mov	 DWORD PTR [r14], r9d
  00115	4d 03 f4	 add	 r14, r12
  00118	48 ff cd	 dec	 rbp
  0011b	75 92		 jne	 SHORT $LL24@AesEncrypt

; 177  : 	uint_fast8_t  i;
; 178  : 
; 179  : 	for ( i = 0 ;; i += 4 )

  0011d	41 02 dc	 add	 bl, r12b
  00120	e9 15 ff ff ff	 jmp	 $LL4@AesEncrypt
$LN39@AesEncrypt:

; 188  : 	}
; 189  : 
; 190  : 	AddRoundKey(block, &Ctx->Key[ Ctx->rounds << 2 ]);

  00125	8b c6		 mov	 eax, esi
  00127	c1 e0 02	 shl	 eax, 2
  0012a	48 63 c8	 movsxd	 rcx, eax
  0012d	48 8d 14 8f	 lea	 rdx, QWORD PTR [rdi+rcx*4]
  00131	49 8b cc	 mov	 rcx, r12
  00134	49 2b d3	 sub	 rdx, r11
$LL29@AesEncrypt:
  00137	42 8b 04 1a	 mov	 eax, DWORD PTR [rdx+r11]
  0013b	41 31 03	 xor	 DWORD PTR [r11], eax
  0013e	4d 03 dc	 add	 r11, r12
  00141	48 ff c9	 dec	 rcx
  00144	75 f1		 jne	 SHORT $LL29@AesEncrypt

; 191  : }

  00146	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0014b	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00150	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00155	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0015a	48 83 c4 10	 add	 rsp, 16
  0015e	41 5f		 pop	 r15
  00160	41 5e		 pop	 r14
  00162	41 5c		 pop	 r12
  00164	c3		 ret	 0
AesEncryptBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT AesCmacV4
_TEXT	SEGMENT
mac$ = 32
Ctx$ = 48
Message$ = 272
MessageSize$ = 280
MacOut$ = 288
AesCmacV4 PROC						; COMDAT

; 195  : {

$LN20:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 00 01
	00 00		 sub	 rsp, 256		; 00000100H
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	48 8b f9	 mov	 rdi, rcx
  0001d	49 8b e8	 mov	 rbp, r8

; 196  :     size_t i;
; 197  :     BYTE mac[AES_BLOCK_BYTES];
; 198  :     AesCtx Ctx;
; 199  : 
; 200  :     AesInitKey(&Ctx, AesKeyV4, FALSE, V4_KEY_BYTES);

  00020	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:AesKeyV4
  00027	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Ctx$[rsp]
  0002c	41 b9 14 00 00
	00		 mov	 r9d, 20
  00032	45 33 c0	 xor	 r8d, r8d
  00035	e8 00 00 00 00	 call	 AesInitKey

; 201  : 
; 202  :     memset(mac, 0, sizeof(mac));

  0003a	33 c0		 xor	 eax, eax

; 203  :     memset(Message + MessageSize, 0, AES_BLOCK_BYTES);
; 204  :     Message[MessageSize] = 0x80;
; 205  : 
; 206  :     for (i = 0; i <= MessageSize; i += AES_BLOCK_BYTES)

  0003c	33 db		 xor	 ebx, ebx
  0003e	48 89 04 37	 mov	 QWORD PTR [rdi+rsi], rax
  00042	48 89 44 37 08	 mov	 QWORD PTR [rdi+rsi+8], rax
  00047	48 89 44 24 20	 mov	 QWORD PTR mac$[rsp], rax
  0004c	48 89 44 24 28	 mov	 QWORD PTR mac$[rsp+8], rax
  00051	48 8d 44 24 20	 lea	 rax, QWORD PTR mac$[rsp]
  00056	c6 04 37 80	 mov	 BYTE PTR [rdi+rsi], 128	; 00000080H
  0005a	48 2b f8	 sub	 rdi, rax
$LL3@AesCmacV4:

; 207  :     {
; 208  :         XorBlock(Message + i, mac);

  0005d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR mac$[rsp]
  00062	4c 8d 04 1f	 lea	 r8, QWORD PTR [rdi+rbx]
  00066	ba 04 00 00 00	 mov	 edx, 4
$LL8@AesCmacV4:
  0006b	41 8b 04 08	 mov	 eax, DWORD PTR [r8+rcx]
  0006f	31 01		 xor	 DWORD PTR [rcx], eax
  00071	48 8d 49 04	 lea	 rcx, QWORD PTR [rcx+4]
  00075	48 ff ca	 dec	 rdx
  00078	75 f1		 jne	 SHORT $LL8@AesCmacV4

; 209  :         AesEncryptBlock(&Ctx, mac);

  0007a	48 8d 54 24 20	 lea	 rdx, QWORD PTR mac$[rsp]
  0007f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR Ctx$[rsp]
  00084	e8 00 00 00 00	 call	 AesEncryptBlock
  00089	48 83 c3 10	 add	 rbx, 16
  0008d	48 3b de	 cmp	 rbx, rsi
  00090	76 cb		 jbe	 SHORT $LL3@AesCmacV4

; 210  :     }
; 211  : 
; 212  :     memcpy(MacOut, mac, AES_BLOCK_BYTES);

  00092	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR mac$[rsp]

; 213  : }

  00097	4c 8d 9c 24 00
	01 00 00	 lea	 r11, QWORD PTR [rsp+256]
  0009f	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  000a3	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  000a7	f3 0f 7f 45 00	 movdqu	 XMMWORD PTR [rbp], xmm0
  000ac	49 8b 6b 18	 mov	 rbp, QWORD PTR [r11+24]
  000b0	49 8b e3	 mov	 rsp, r11
  000b3	5f		 pop	 rdi
  000b4	c3		 ret	 0
AesCmacV4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT ShiftRowsR
_TEXT	SEGMENT
b$ = 0
state$ = 32
ShiftRowsR PROC						; COMDAT

; 259  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 260  : 	BYTE b[AES_BLOCK_BYTES];
; 261  : 	uint_fast8_t i;
; 262  : 
; 263  : 	memcpy(b, state, AES_BLOCK_BYTES);

  00004	0f 10 01	 movups	 xmm0, XMMWORD PTR [rcx]

; 264  : 
; 265  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)

  00007	45 32 c0	 xor	 r8b, r8b
  0000a	f3 0f 7f 04 24	 movdqu	 XMMWORD PTR b$[rsp], xmm0
$LL3@ShiftRowsR:

; 266  : 		state[i] = b[(i - ((i & 0x3) << 2)) & 0xf];

  0000f	41 0f b6 c0	 movzx	 eax, r8b
  00013	41 fe c0	 inc	 r8b
  00016	8b d0		 mov	 edx, eax
  00018	83 e2 03	 and	 edx, 3
  0001b	c1 e2 02	 shl	 edx, 2
  0001e	2b c2		 sub	 eax, edx
  00020	83 e0 0f	 and	 eax, 15
  00023	8a 04 04	 mov	 al, BYTE PTR b$[rsp+rax]
  00026	88 01		 mov	 BYTE PTR [rcx], al
  00028	48 ff c1	 inc	 rcx
  0002b	41 80 f8 10	 cmp	 r8b, 16
  0002f	72 de		 jb	 SHORT $LL3@ShiftRowsR

; 267  : }

  00031	48 83 c4 18	 add	 rsp, 24
  00035	c3		 ret	 0
ShiftRowsR ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT SubBytesR
_TEXT	SEGMENT
block$ = 8
SubBytesR PROC						; COMDAT

; 272  : 	uint_fast8_t i;
; 273  : 
; 274  : 	for (i = 0; i < AES_BLOCK_BYTES; i++)

  00000	ba 10 00 00 00	 mov	 edx, 16
$LL3@SubBytesR:

; 275  : 	{
; 276  : 		block[i] = GetSBoxR( block[i] );

  00005	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00008	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:SBoxR
  0000f	42 8a 04 00	 mov	 al, BYTE PTR [rax+r8]
  00013	88 01		 mov	 BYTE PTR [rcx], al
  00015	48 ff c1	 inc	 rcx
  00018	48 ff ca	 dec	 rdx
  0001b	75 e8		 jne	 SHORT $LL3@SubBytesR

; 277  : 	}
; 278  : }

  0001d	c3		 ret	 0
SubBytesR ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT AesEncryptCbc
_TEXT	SEGMENT
Ctx$ = 48
iv$dead$ = 56
data$ = 64
len$ = 72
AesEncryptCbc PROC					; COMDAT

; 282  : {

$LN30:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0000b	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000f	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  00013	41 56		 push	 r14
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 283  : 	// Pad up to blocksize inclusive
; 284  : 	size_t i;
; 285  : 	uint_fast8_t pad = (~*len & (AES_BLOCK_BYTES - 1)) + 1;

  00019	41 8a 01	 mov	 al, BYTE PTR [r9]

; 286  : 
; 287  : 	#if defined(__GNUC__) && (__GNUC__ == 4 && __GNUC_MINOR__ == 8) // gcc 4.8 memset bug https://gcc.gnu.org/bugzilla/show_bug.cgi?id=56977
; 288  : 		for (i = 0; i < pad; i++) data[*len + i] = pad;
; 289  : 	#else
; 290  : 		memset(data + *len, pad, pad);

  0001c	49 8b 19	 mov	 rbx, QWORD PTR [r9]
  0001f	48 8b e9	 mov	 rbp, rcx
  00022	f6 d0		 not	 al
  00024	4a 8d 0c 03	 lea	 rcx, QWORD PTR [rbx+r8]
  00028	4d 8b f0	 mov	 r14, r8
  0002b	24 0f		 and	 al, 15
  0002d	49 8b f1	 mov	 rsi, r9
  00030	fe c0		 inc	 al
  00032	0f b6 f8	 movzx	 edi, al
  00035	0f b6 d0	 movzx	 edx, al
  00038	44 8b c7	 mov	 r8d, edi
  0003b	e8 00 00 00 00	 call	 memset

; 291  : 	#endif
; 292  : 	*len += pad;

  00040	48 03 df	 add	 rbx, rdi

; 293  : 
; 294  : 	if ( iv ) XorBlock(iv, data);
; 295  : 	AesEncryptBlock(Ctx, data);

  00043	49 8b d6	 mov	 rdx, r14
  00046	48 8b cd	 mov	 rcx, rbp
  00049	48 89 1e	 mov	 QWORD PTR [rsi], rbx
  0004c	e8 00 00 00 00	 call	 AesEncryptBlock

; 296  : 
; 297  : 	for (i = *len - AES_BLOCK_BYTES; i; i -= AES_BLOCK_BYTES)

  00051	48 83 c3 f0	 add	 rbx, -16
  00055	74 30		 je	 SHORT $LN1@AesEncrypt
$LL3@AesEncrypt:

; 298  : 	{
; 299  : 		XorBlock(data, data + AES_BLOCK_BYTES);

  00057	49 8d 56 10	 lea	 rdx, QWORD PTR [r14+16]
  0005b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00061	48 8b ca	 mov	 rcx, rdx
  00064	4c 2b f2	 sub	 r14, rdx
$LL14@AesEncrypt:
  00067	41 8b 04 0e	 mov	 eax, DWORD PTR [r14+rcx]
  0006b	31 01		 xor	 DWORD PTR [rcx], eax
  0006d	48 8d 49 04	 lea	 rcx, QWORD PTR [rcx+4]
  00071	49 ff c8	 dec	 r8
  00074	75 f1		 jne	 SHORT $LL14@AesEncrypt

; 300  : 		data += AES_BLOCK_BYTES;
; 301  : 		AesEncryptBlock(Ctx, data);

  00076	48 8b cd	 mov	 rcx, rbp
  00079	4c 8b f2	 mov	 r14, rdx
  0007c	e8 00 00 00 00	 call	 AesEncryptBlock
  00081	48 83 eb 10	 sub	 rbx, 16
  00085	75 d0		 jne	 SHORT $LL3@AesEncrypt
$LN1@AesEncrypt:

; 302  : 	}
; 303  : }

  00087	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008c	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00091	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00096	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	41 5e		 pop	 r14
  000a1	c3		 ret	 0
AesEncryptCbc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT AesDecryptBlock
_TEXT	SEGMENT
b$1 = 32
Ctx$ = 64
block$ = 72
AesDecryptBlock PROC					; COMDAT

; 307  : {

$LN49:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 308  : 	uint_fast8_t  i;
; 309  : 
; 310  : 	AddRoundKey(block, &Ctx->Key[ Ctx->rounds << 2 ]);

  0000f	0f b6 81 c0 00
	00 00		 movzx	 eax, BYTE PTR [rcx+192]
  00016	48 8b fa	 mov	 rdi, rdx
  00019	48 8b f1	 mov	 rsi, rcx
  0001c	c1 e0 02	 shl	 eax, 2
  0001f	4c 8b c7	 mov	 r8, rdi
  00022	41 b9 04 00 00
	00		 mov	 r9d, 4
  00028	48 98		 cdqe
  0002a	48 8d 14 81	 lea	 rdx, QWORD PTR [rcx+rax*4]
  0002e	48 2b d7	 sub	 rdx, rdi
$LL9@AesDecrypt:
  00031	42 8b 04 02	 mov	 eax, DWORD PTR [rdx+r8]
  00035	41 31 00	 xor	 DWORD PTR [r8], eax
  00038	4d 8d 40 04	 lea	 r8, QWORD PTR [r8+4]
  0003c	49 ff c9	 dec	 r9
  0003f	75 f0		 jne	 SHORT $LL9@AesDecrypt

; 311  : 
; 312  : 	for ( i = ( Ctx->rounds - 1 ) << 2 ;; i -= 4 )

  00041	8a 99 c0 00 00
	00		 mov	 bl, BYTE PTR [rcx+192]
  00047	fe cb		 dec	 bl
  00049	c0 e3 02	 shl	 bl, 2
$LL4@AesDecrypt:

; 313  : 	{
; 314  : 		ShiftRowsR(block);

  0004c	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]
  0004f	32 d2		 xor	 dl, dl
  00051	4c 8b c7	 mov	 r8, rdi
  00054	f3 0f 7f 44 24
	20		 movdqu	 XMMWORD PTR b$1[rsp], xmm0
$LL14@AesDecrypt:
  0005a	0f b6 c2	 movzx	 eax, dl
  0005d	fe c2		 inc	 dl
  0005f	8b c8		 mov	 ecx, eax
  00061	83 e1 03	 and	 ecx, 3
  00064	c1 e1 02	 shl	 ecx, 2
  00067	2b c1		 sub	 eax, ecx
  00069	83 e0 0f	 and	 eax, 15
  0006c	8a 44 04 20	 mov	 al, BYTE PTR b$1[rsp+rax]
  00070	41 88 00	 mov	 BYTE PTR [r8], al
  00073	49 ff c0	 inc	 r8
  00076	80 fa 10	 cmp	 dl, 16
  00079	72 df		 jb	 SHORT $LL14@AesDecrypt

; 315  : 		SubBytesR(block);

  0007b	48 8b cf	 mov	 rcx, rdi
  0007e	ba 10 00 00 00	 mov	 edx, 16
$LL19@AesDecrypt:
  00083	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00086	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:SBoxR
  0008d	42 8a 04 00	 mov	 al, BYTE PTR [rax+r8]
  00091	88 01		 mov	 BYTE PTR [rcx], al
  00093	48 ff c1	 inc	 rcx
  00096	48 ff ca	 dec	 rdx
  00099	75 e8		 jne	 SHORT $LL19@AesDecrypt

; 316  : 		AddRoundKey(block, &Ctx->Key[ i ]);

  0009b	44 0f b6 c3	 movzx	 r8d, bl
  0009f	48 8b cf	 mov	 rcx, rdi
  000a2	ba 04 00 00 00	 mov	 edx, 4
  000a7	49 c1 e0 02	 shl	 r8, 2
  000ab	4c 2b c7	 sub	 r8, rdi
  000ae	4c 03 c6	 add	 r8, rsi
$LL24@AesDecrypt:
  000b1	41 8b 04 08	 mov	 eax, DWORD PTR [r8+rcx]
  000b5	31 01		 xor	 DWORD PTR [rcx], eax
  000b7	48 8d 49 04	 lea	 rcx, QWORD PTR [rcx+4]
  000bb	48 ff ca	 dec	 rdx
  000be	75 f1		 jne	 SHORT $LL24@AesDecrypt

; 317  : 
; 318  : 		if ( i == 0 ) break;

  000c0	84 db		 test	 bl, bl
  000c2	74 10		 je	 SHORT $LN33@AesDecrypt

; 319  : 
; 320  : 		MixColumnsR(block);

  000c4	48 8b cf	 mov	 rcx, rdi
  000c7	e8 00 00 00 00	 call	 MixColumnsR
  000cc	80 c3 fc	 add	 bl, 252			; 000000fcH
  000cf	e9 78 ff ff ff	 jmp	 $LL4@AesDecrypt
$LN33@AesDecrypt:

; 321  : 	}
; 322  : }

  000d4	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000d9	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000de	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e2	5f		 pop	 rdi
  000e3	c3		 ret	 0
AesDecryptBlock ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\crypto.c
;	COMDAT AesDecryptCbc
_TEXT	SEGMENT
Ctx$ = 48
iv$dead$ = 56
data$ = 64
len$dead$ = 72
AesDecryptCbc PROC					; COMDAT

; 326  : {

$LN30:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 327  : 	BYTE  *cc;
; 328  : 
; 329  : 	for (cc = data + len - AES_BLOCK_BYTES; cc > data; cc -= AES_BLOCK_BYTES)

  0000f	49 8d 98 f0 00
	00 00		 lea	 rbx, QWORD PTR [r8+240]
  00016	49 8b f8	 mov	 rdi, r8
  00019	48 8b f1	 mov	 rsi, rcx
  0001c	49 3b d8	 cmp	 rbx, r8
  0001f	76 2b		 jbe	 SHORT $LN2@AesDecrypt
$LL4@AesDecrypt:

; 330  : 	{
; 331  : 		AesDecryptBlock(Ctx, cc);

  00021	48 8b d3	 mov	 rdx, rbx
  00024	48 8b ce	 mov	 rcx, rsi
  00027	e8 00 00 00 00	 call	 AesDecryptBlock
  0002c	48 8b d3	 mov	 rdx, rbx
  0002f	41 b8 04 00 00
	00		 mov	 r8d, 4

; 332  : 		XorBlock(cc - AES_BLOCK_BYTES, cc);

$LL9@AesDecrypt:
  00035	8b 42 f0	 mov	 eax, DWORD PTR [rdx-16]
  00038	31 02		 xor	 DWORD PTR [rdx], eax
  0003a	48 8d 52 04	 lea	 rdx, QWORD PTR [rdx+4]
  0003e	49 ff c8	 dec	 r8
  00041	75 f2		 jne	 SHORT $LL9@AesDecrypt

; 327  : 	BYTE  *cc;
; 328  : 
; 329  : 	for (cc = data + len - AES_BLOCK_BYTES; cc > data; cc -= AES_BLOCK_BYTES)

  00043	48 83 eb 10	 sub	 rbx, 16
  00047	48 3b df	 cmp	 rbx, rdi
  0004a	77 d5		 ja	 SHORT $LL4@AesDecrypt
$LN2@AesDecrypt:

; 333  : 	}
; 334  : 
; 335  : 	AesDecryptBlock(Ctx, cc);

  0004c	48 8b d3	 mov	 rdx, rbx
  0004f	48 8b ce	 mov	 rcx, rsi

; 336  : 	if ( iv ) XorBlock(iv, cc);
; 337  : }

  00052	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00057	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0005c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00060	5f		 pop	 rdi

; 333  : 	}
; 334  : 
; 335  : 	AesDecryptBlock(Ctx, cc);

  00061	e9 00 00 00 00	 jmp	 AesDecryptBlock
AesDecryptCbc ENDP
_TEXT	ENDS
END
