; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@		; `string'
PUBLIC	??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@	; `string'
PUBLIC	??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@MAEBPPDA@Connecting?5to?5?$CFs?5?$CI?$CFs?$CJ?5?4?4?4?5?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMGEJMIK@Connecting?5to?5?$CFs?5?4?4?4?5?$AA@ ; `string'
PUBLIC	??_C@_0M@DODJIFLM@successful?6?$AA@		; `string'
PUBLIC	??_C@_09OGKCMDDI@Timed?5out?$AA@		; `string'
PUBLIC	??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@		; `string'
PUBLIC	??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5add@ ; `string'
PUBLIC	??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addres@ ; `string'
PUBLIC	??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6?$AA@ ; `string'
PUBLIC	??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_08LMOPGBBD@accepted?$AA@			; `string'
PUBLIC	??_C@_06IKJOPBFO@closed?$AA@			; `string'
PUBLIC	??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5re@ ; `string'
PUBLIC	??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6?$AA@		; `string'
EXTRN	__imp_CreateThread:PROC
EXTRN	__imp_GetAdaptersAddresses:PROC
EXTRN	__imp_getpeername:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_ioctlsocket:PROC
EXTRN	__imp_connect:PROC
EXTRN	__imp_getaddrinfo:PROC
EXTRN	__imp_select:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_ReleaseSemaphore:PROC
EXTRN	__imp_printf:PROC
EXTRN	__imp_setsockopt:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp_bind:PROC
EXTRN	__imp_socket:PROC
EXTRN	__imp_freeaddrinfo:PROC
EXTRN	__imp__snprintf:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp___WSAFDIsSet:PROC
EXTRN	__imp_closesocket:PROC
EXTRN	__imp___iob_func:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_listen:PROC
EXTRN	__imp_getnameinfo:PROC
EXTRN	__imp_accept:PROC
;	COMDAT ??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6?$AA@ DB 'Fatal: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5re@
CONST	SEGMENT
??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5re@ DB 'Client with'
	DB	' public IP address rejected', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6?$AA@
CONST	SEGMENT
??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6?$AA@ DB '%s conn'
	DB	'ection %s: %s.', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06IKJOPBFO@closed?$AA@
CONST	SEGMENT
??_C@_06IKJOPBFO@closed?$AA@ DB 'closed', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08LMOPGBBD@accepted?$AA@
CONST	SEGMENT
??_C@_08LMOPGBBD@accepted?$AA@ DB 'accepted', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6?$AA@ DB 'Listening on %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6?$AA@ DB 'Warning: %'
	DB	's error. %s', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addres@
CONST	SEGMENT
??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addres@ DB 'WARNING: C'
	DB	'ould not get IP address from interface list: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5add@
CONST	SEGMENT
??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5add@ DB 'FATAL: Cou'
	DB	'ld not get network address list: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_07KJFPOMFC@?$CFs?3?5?$CFs?6?$AA@ DB '%s: %s', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09OGKCMDDI@Timed?5out?$AA@
CONST	SEGMENT
??_C@_09OGKCMDDI@Timed?5out?$AA@ DB 'Timed out', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DODJIFLM@successful?6?$AA@
CONST	SEGMENT
??_C@_0M@DODJIFLM@successful?6?$AA@ DB 'successful', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMGEJMIK@Connecting?5to?5?$CFs?5?4?4?4?5?$AA@
CONST	SEGMENT
??_C@_0BG@GMGEJMIK@Connecting?5to?5?$CFs?5?4?4?4?5?$AA@ DB 'Connecting to'
	DB	' %s ... ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MAEBPPDA@Connecting?5to?5?$CFs?5?$CI?$CFs?$CJ?5?4?4?4?5?$AA@
CONST	SEGMENT
??_C@_0BL@MAEBPPDA@Connecting?5to?5?$CFs?5?$CI?$CFs?$CJ?5?4?4?4?5?$AA@ DB 'C'
	DB	'onnecting to %s (%s) ... ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6?$AA@ DB 'Warning: %s: %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@
CONST	SEGMENT
??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@ DB '[%s]:%s', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@
CONST	SEGMENT
??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@ DB '%s:%s', 00H	; `string'
?fIP@?2??serveClient@@9@9 DQ FLAT:??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6?$AA@ ; `serveClient'::`3'::fIP
?cClosed@?2??serveClient@@9@9 DQ FLAT:??_C@_06IKJOPBFO@closed?$AA@ ; `serveClient'::`3'::cClosed
?cAccepted@?2??serveClient@@9@9 DQ FLAT:??_C@_08LMOPGBBD@accepted?$AA@ ; `serveClient'::`3'::cAccepted
?fIPv6@?1??ip2str@@9@9 DQ FLAT:??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@ ; `ip2str'::`2'::fIPv6
?fIPv4@?1??ip2str@@9@9 DQ FLAT:??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@ ; `ip2str'::`2'::fIPv4
PUBLIC	runServer
PUBLIC	serveClientAsync
PUBLIC	closeAllListeningSockets
PUBLIC	checkProtocolStack
PUBLIC	addListeningSocket
PUBLIC	getPrivateIPAddresses
PUBLIC	sendrecv
PUBLIC	gai_strerrorA
;	COMDAT pdata
pdata	SEGMENT
$pdata$runServer DD imagerel $LN88
	DD	imagerel $LN88+557
	DD	imagerel $unwind$runServer
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serveClientAsync DD imagerel $LN14
	DD	imagerel $LN14+203
	DD	imagerel $unwind$serveClientAsync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serveClientAsyncWinThreads DD imagerel serveClientAsyncWinThreads
	DD	imagerel serveClientAsyncWinThreads+170
	DD	imagerel $unwind$serveClientAsyncWinThreads
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serveClientThreadProc DD imagerel serveClientThreadProc
	DD	imagerel serveClientThreadProc+78
	DD	imagerel $unwind$serveClientThreadProc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wait_sem DD imagerel wait_sem
	DD	imagerel wait_sem+46
	DD	imagerel $unwind$wait_sem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$post_sem DD imagerel post_sem
	DD	imagerel post_sem+50
	DD	imagerel $unwind$post_sem
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$serveClient DD imagerel serveClient
	DD	imagerel serveClient+394
	DD	imagerel $unwind$serveClient
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$closeAllListeningSockets DD imagerel $LN11
	DD	imagerel $LN11+64
	DD	imagerel $unwind$closeAllListeningSockets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$network_accept_any DD imagerel network_accept_any
	DD	imagerel network_accept_any+244
	DD	imagerel $unwind$network_accept_any
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$checkProtocolStack DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$checkProtocolStack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$addListeningSocket DD imagerel $LN49
	DD	imagerel $LN49+567
	DD	imagerel $unwind$addListeningSocket
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$listenOnAddress DD imagerel listenOnAddress
	DD	imagerel listenOnAddress+412
	DD	imagerel $unwind$listenOnAddress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getPrivateIPAddresses DD imagerel $LN76
	DD	imagerel $LN76+533
	DD	imagerel $unwind$getPrivateIPAddresses
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$allowSocketReuse DD imagerel allowSocketReuse
	DD	imagerel allowSocketReuse+49
	DD	imagerel $unwind$allowSocketReuse
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$getSocketList DD imagerel getSocketList
	DD	imagerel getSocketList+338
	DD	imagerel $unwind$getSocketList
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$ip2str DD imagerel ip2str
	DD	imagerel ip2str+59
	DD	imagerel $unwind$ip2str
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sendrecv DD imagerel $LN13
	DD	imagerel $LN13+129
	DD	imagerel $unwind$sendrecv
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gai_strerrorA DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$gai_strerrorA
;	COMDAT xdata
xdata	SEGMENT
$unwind$gai_strerrorA DD 020601H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sendrecv DD 0a1801H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$ip2str DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getSocketList DD 0450d2901H
	DD	015c429H
	DD	014741fH
	DD	0136417H
	DD	0123413H
	DD	0d20a430fH
	DD	0e004f006H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$allowSocketReuse DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getPrivateIPAddresses DD 081201H
	DD	0103412H
	DD	0f00e9212H
	DD	0700ae00cH
	DD	050086009H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$listenOnAddress DD 071301H
	DD	01d6413H
	DD	01c3413H
	DD	0180113H
	DD	0700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$addListeningSocket DD 091801H
	DD	0203418H
	DD	01a0118H
	DD	0e00af00cH
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$checkProtocolStack DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$network_accept_any DD 050d01H
	DD	04a340dH
	DD	048010dH
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$closeAllListeningSockets DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serveClient DD 071401H
	DD	02e3414H
	DD	02a0114H
	DD	060077008H
	DD	05006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$post_sem DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wait_sem DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serveClientThreadProc DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serveClientAsyncWinThreads DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$serveClientAsync DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$runServer DD 071201H
	DD	04b6412H
	DD	04a3412H
	DD	0480112H
	DD	0700bH
; Function compile flags: /Ogspy
; File c:\program files (x86)\microsoft sdks\windows\v7.1a\include\ws2tcpip.h
;	COMDAT gai_strerrorA
_TEXT	SEGMENT
ecode$ = 80
gai_strerrorA PROC					; COMDAT

; 604  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 605  :     DWORD dwMsgLen;
; 606  :     static char buff[GAI_STRERROR_BUFFER_SIZE + 1];
; 607  : 
; 608  :     dwMsgLen = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM
; 609  :                              |FORMAT_MESSAGE_IGNORE_INSERTS
; 610  :                              |FORMAT_MESSAGE_MAX_WIDTH_MASK,
; 611  :                               NULL,
; 612  :                               ecode,
; 613  :                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
; 614  :                               (LPSTR)buff,
; 615  :                               GAI_STRERROR_BUFFER_SIZE,
; 616  :                               NULL);

  00006	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  0000c	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  00012	44 8b c1	 mov	 r8d, ecx
  00015	44 89 4c 24 28	 mov	 DWORD PTR [rsp+40], r9d
  0001a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?buff@?1??gai_strerrorA@@9@9 ; `gai_strerrorA'::`2'::buff
  00021	33 d2		 xor	 edx, edx
  00023	b9 ff 12 00 00	 mov	 ecx, 4863		; 000012ffH
  00028	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageA

; 617  : 
; 618  :     return buff;

  00033	48 8b c3	 mov	 rax, rbx

; 619  : }

  00036	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
gai_strerrorA ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT sendrecv
_TEXT	SEGMENT
sock$ = 64
data$ = 72
len$ = 80
do_send$ = 88
sendrecv PROC						; COMDAT

; 57   : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 58   : 	int n;
; 59   : 	sendrecv_t  f = do_send
; 60   : 		? (sendrecv_t)send
; 61   : 		: (sendrecv_t)recv;

  00018	4c 8b 35 00 00
	00 00		 mov	 r14, QWORD PTR __imp_recv
  0001f	45 84 c9	 test	 r9b, r9b
  00022	41 8b f8	 mov	 edi, r8d
  00025	4c 0f 45 35 00
	00 00 00	 cmovne	 r14, QWORD PTR __imp_send
  0002d	48 8b ea	 mov	 rbp, rdx
  00030	4c 8b f9	 mov	 r15, rcx
$LL5@sendrecv:

; 62   : 
; 63   : 	do
; 64   : 	{
; 65   : 		n = f(sock, data, len, 0);

  00033	45 33 c9	 xor	 r9d, r9d
  00036	44 8b c7	 mov	 r8d, edi
  00039	48 8b d5	 mov	 rdx, rbp
  0003c	49 8b cf	 mov	 rcx, r15
  0003f	41 ff d6	 call	 r14
  00042	48 63 f0	 movsxd	 rsi, eax

; 66   : 	} while (
; 67   : 		(n < 0 && socket_errno == SOCKET_EINTR) || (n > 0 && (data += n, (len -= n) > 0)));

  00045	85 c0		 test	 eax, eax
  00047	79 0d		 jns	 SHORT $LN2@sendrecv
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0004f	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  00054	74 dd		 je	 SHORT $LL5@sendrecv
$LN2@sendrecv:
  00056	85 f6		 test	 esi, esi
  00058	7e 09		 jle	 SHORT $LN1@sendrecv
  0005a	2b fe		 sub	 edi, esi
  0005c	48 03 ee	 add	 rbp, rsi
  0005f	85 ff		 test	 edi, edi
  00061	7f d0		 jg	 SHORT $LL5@sendrecv
$LN1@sendrecv:

; 68   : 
; 69   : 	return !len;
; 70   : }

  00063	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00068	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0006d	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00072	85 ff		 test	 edi, edi
  00074	0f 94 c0	 sete	 al
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	41 5f		 pop	 r15
  0007d	41 5e		 pop	 r14
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
sendrecv ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT ip2str
_TEXT	SEGMENT
result$ = 64
socketAddress$ = 72
$T1 = 80
$T2 = 88
ip2str	PROC						; COMDAT

; 74   : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 75   : 	static const char *const fIPv4 = "%s:%s";
; 76   : 	static const char *const fIPv6 = "[%s]:%s";
; 77   : 	char ipAddress[64], portNumber[8];
; 78   : 
; 79   : 	if (getnameinfo
; 80   : 	(
; 81   : 		socketAddress,
; 82   : 		socketLength,
; 83   : 		ipAddress,
; 84   : 		sizeof(ipAddress),
; 85   : 		portNumber,
; 86   : 		sizeof(portNumber),
; 87   : 		NI_NUMERICHOST | NI_NUMERICSERV
; 88   : 	))
; 89   : 	{
; 90   : 		return FALSE;
; 91   : 	}
; 92   : 
; 93   : 	if ((unsigned int)vlmcsd_snprintf(result, resultLength, socketAddress->sa_family == AF_INET6 ? fIPv6 : fIPv4, ipAddress, portNumber) > resultLength) return FALSE;

  00004	66 83 3a 17	 cmp	 WORD PTR [rdx], 23
  00008	49 8b c0	 mov	 rax, r8
  0000b	4c 8d 15 00 00
	00 00		 lea	 r10, OFFSET FLAT:??_C@_05CCMOGDN@?$CFs?3?$CFs?$AA@
  00012	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00017	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_07OHCDBLND@?$FL?$CFs?$FN?3?$CFs?$AA@
  0001e	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00023	4d 0f 45 c2	 cmovne	 r8, r10
  00027	4c 8b c8	 mov	 r9, rax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__snprintf
  00030	83 f8 40	 cmp	 eax, 64			; 00000040H
  00033	0f 96 c0	 setbe	 al

; 94   : 	return TRUE;
; 95   : }

  00036	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003a	c3		 ret	 0
ip2str	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT getSocketList
_TEXT	SEGMENT
hints$ = 0
saList$ = 80
addr$ = 88
len$ = 96
getSocketList PROC					; COMDAT

; 99   : {

  00000	40 55		 push	 rbp
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8d 6c 24 40	 lea	 rbp, QWORD PTR [rsp+64]
  0000f	48 89 5d 50	 mov	 QWORD PTR [rbp+80], rbx
  00013	48 89 75 58	 mov	 QWORD PTR [rbp+88], rsi

; 100  : 	int status;
; 101  : 	char *szHost, *szPort;
; 102  : 	size_t len = strlen(addr) + 1;
; 103  : 
; 104  : 	// Don't alloca too much
; 105  : 	if (len > 264) return FALSE;
; 106  : 
; 107  : 	char *addrcopy = (char*)alloca(len);

  00017	49 8d 40 0f	 lea	 rax, QWORD PTR [r8+15]
  0001b	48 89 7d 60	 mov	 QWORD PTR [rbp+96], rdi
  0001f	4c 8b f2	 mov	 r14, rdx
  00022	4c 8b f9	 mov	 r15, rcx
  00025	4c 89 65 68	 mov	 QWORD PTR [rbp+104], r12
  00029	49 3b c0	 cmp	 rax, r8
  0002c	77 0a		 ja	 SHORT $LN16@getSocketL
  0002e	48 b8 f0 ff ff
	ff ff ff ff 0f	 mov	 rax, 1152921504606846960 ; 0ffffffffffffff0H
$LN16@getSocketL:
  00038	48 83 e0 f0	 and	 rax, -16
  0003c	e8 00 00 00 00	 call	 __chkstk
  00041	48 2b e0	 sub	 rsp, rax
  00044	48 8d 7c 24 40	 lea	 rdi, QWORD PTR [rsp+64]

; 108  : 	memcpy(addrcopy, addr, len);

  00049	48 8b cf	 mov	 rcx, rdi
  0004c	e8 00 00 00 00	 call	 memcpy

; 109  : 
; 110  : 	parseAddress(addrcopy, &szHost, &szPort);

  00051	48 8b 35 00 00
	00 00		 mov	 rsi, QWORD PTR defaultport
  00058	bb 3a 00 00 00	 mov	 ebx, 58			; 0000003aH
  0005d	8b d3		 mov	 edx, ebx
  0005f	48 8b cf	 mov	 rcx, rdi
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr
  00068	8b d3		 mov	 edx, ebx
  0006a	48 8b cf	 mov	 rcx, rdi
  0006d	4c 8b e0	 mov	 r12, rax
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strchr
  00076	ba 5d 00 00 00	 mov	 edx, 93			; 0000005dH
  0007b	48 8b cf	 mov	 rcx, rdi
  0007e	48 8b d8	 mov	 rbx, rax
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strrchr
  00087	80 3f 5b	 cmp	 BYTE PTR [rdi], 91	; 0000005bH
  0008a	75 17		 jne	 SHORT $LN11@getSocketL
  0008c	48 85 c0	 test	 rax, rax
  0008f	74 12		 je	 SHORT $LN11@getSocketL
  00091	c6 00 00	 mov	 BYTE PTR [rax], 0
  00094	48 ff c7	 inc	 rdi
  00097	80 78 01 3a	 cmp	 BYTE PTR [rax+1], 58	; 0000003aH
  0009b	75 17		 jne	 SHORT $LN8@getSocketL
  0009d	48 8d 70 02	 lea	 rsi, QWORD PTR [rax+2]
  000a1	eb 11		 jmp	 SHORT $LN8@getSocketL
$LN11@getSocketL:
  000a3	48 85 db	 test	 rbx, rbx
  000a6	74 0c		 je	 SHORT $LN8@getSocketL
  000a8	49 3b dc	 cmp	 rbx, r12
  000ab	75 07		 jne	 SHORT $LN8@getSocketL
  000ad	c6 03 00	 mov	 BYTE PTR [rbx], 0
  000b0	48 8d 73 01	 lea	 rsi, QWORD PTR [rbx+1]
$LN8@getSocketL:

; 111  : 
; 112  : 	struct addrinfo hints;
; 113  : 
; 114  : 	memset(&hints, 0, sizeof(struct addrinfo));

  000b4	33 d2		 xor	 edx, edx
  000b6	48 8d 4d 00	 lea	 rcx, QWORD PTR hints$[rbp]
  000ba	44 8d 42 30	 lea	 r8d, QWORD PTR [rdx+48]
  000be	e8 00 00 00 00	 call	 memset

; 115  : 
; 116  : 	hints.ai_family = AddressFamily;

  000c3	83 65 04 00	 and	 DWORD PTR hints$[rbp+4], 0

; 117  : 	hints.ai_socktype = SOCK_STREAM;
; 118  : 	hints.ai_protocol = IPPROTO_TCP;
; 119  : 	hints.ai_flags = flags;
; 120  : 
; 121  : 	if ((status = getaddrinfo(szHost, szPort, &hints, saList)))

  000c7	4c 8d 45 00	 lea	 r8, QWORD PTR hints$[rbp]
  000cb	4d 8b cf	 mov	 r9, r15
  000ce	48 8b d6	 mov	 rdx, rsi
  000d1	48 8b cf	 mov	 rcx, rdi
  000d4	c7 45 08 01 00
	00 00		 mov	 DWORD PTR hints$[rbp+8], 1
  000db	c7 45 0c 06 00
	00 00		 mov	 DWORD PTR hints$[rbp+12], 6
  000e2	c7 45 00 05 00
	00 00		 mov	 DWORD PTR hints$[rbp], 5
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getaddrinfo
  000ef	85 c0		 test	 eax, eax
  000f1	74 43		 je	 SHORT $LN1@getSocketL

; 122  : 	{
; 123  : 		printerrorf("Warning: %s: %s\n", addr, gai_strerror(status));

  000f3	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  000f9	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  000ff	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?buff@?1??gai_strerrorA@@9@9 ; `gai_strerrorA'::`2'::buff
  00106	44 89 4c 24 28	 mov	 DWORD PTR [rsp+40], r9d
  0010b	44 8b c0	 mov	 r8d, eax
  0010e	33 d2		 xor	 edx, edx
  00110	b9 ff 12 00 00	 mov	 ecx, 4863		; 000012ffH
  00115	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageA
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6?$AA@
  00127	4c 8b c3	 mov	 r8, rbx
  0012a	49 8b d6	 mov	 rdx, r14
  0012d	e8 00 00 00 00	 call	 printerrorf

; 124  : 		return FALSE;

  00132	32 c0		 xor	 al, al
  00134	eb 02		 jmp	 SHORT $LN6@getSocketL
$LN1@getSocketL:

; 125  : 	}
; 126  : 
; 127  : 	return TRUE;

  00136	b0 01		 mov	 al, 1
$LN6@getSocketL:

; 128  : }

  00138	48 8b 5d 50	 mov	 rbx, QWORD PTR [rbp+80]
  0013c	48 8b 75 58	 mov	 rsi, QWORD PTR [rbp+88]
  00140	48 8b 7d 60	 mov	 rdi, QWORD PTR [rbp+96]
  00144	4c 8b 65 68	 mov	 r12, QWORD PTR [rbp+104]
  00148	48 8d 65 30	 lea	 rsp, QWORD PTR [rbp+48]
  0014c	41 5f		 pop	 r15
  0014e	41 5e		 pop	 r14
  00150	5d		 pop	 rbp
  00151	c3		 ret	 0
getSocketList ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT isPrivateIPAddress
_TEXT	SEGMENT
addr$ = 8
length$ = 16
isPrivateIPAddress PROC					; COMDAT

; 172  : 	union v6addr
; 173  : 	{
; 174  : 		uint8_t bytes[16];
; 175  : 		uint16_t words[8];
; 176  : 		uint32_t dwords[4];
; 177  : 		uint64_t qwords[2];
; 178  : 	};
; 179  : 
; 180  : 	if (addr == NULL) return FALSE;
; 181  : 
; 182  : 	switch (addr->sa_family)

  00000	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  00003	83 f8 02	 cmp	 eax, 2
  00006	74 43		 je	 SHORT $LN4@isPrivateI
  00008	83 f8 17	 cmp	 eax, 23
  0000b	75 2e		 jne	 SHORT $LN17@isPrivateI

; 183  : 	{
; 184  : 	case AF_INET6:
; 185  : 	{
; 186  : 		union v6addr* ipv6addr = (union v6addr*)&((struct sockaddr_in6*)addr)->sin6_addr;
; 187  : 
; 188  : 		if
; 189  : 			(
; 190  : 			(ipv6addr->qwords[0] != 0 || BE64(ipv6addr->qwords[1]) != 1) && // ::1 IPv6 localhost
; 191  : 				(BE16(ipv6addr->words[0]) & 0xe000) == 0x2000 // !2000::/3
; 192  : 				)

  0000d	48 83 79 08 00	 cmp	 QWORD PTR [rcx+8], 0
  00012	75 0d		 jne	 SHORT $LN6@isPrivateI
  00014	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00018	48 0f c8	 bswap	 rax
  0001b	48 83 f8 01	 cmp	 rax, 1
  0001f	74 1d		 je	 SHORT $LN7@isPrivateI
$LN6@isPrivateI:
  00021	0f b7 41 08	 movzx	 eax, WORD PTR [rcx+8]
  00025	b9 00 e0 00 00	 mov	 ecx, 57344		; 0000e000H
  0002a	66 c1 c8 08	 ror	 ax, 8
  0002e	66 23 c1	 and	 ax, cx
  00031	b9 00 20 00 00	 mov	 ecx, 8192		; 00002000H
  00036	66 3b c1	 cmp	 ax, cx
  00039	75 03		 jne	 SHORT $LN7@isPrivateI
$LN17@isPrivateI:

; 193  : 		{
; 194  : 			return FALSE;

  0003b	32 c0		 xor	 al, al

; 226  : }

  0003d	c3		 ret	 0
$LN7@isPrivateI:

; 195  : 		}
; 196  : 
; 197  : 		if (length) *length = sizeof(struct sockaddr_in6);

  0003e	48 85 d2	 test	 rdx, rdx
  00041	74 58		 je	 SHORT $LN2@isPrivateI
  00043	c7 02 1c 00 00
	00		 mov	 DWORD PTR [rdx], 28

; 198  : 		break;

  00049	eb 50		 jmp	 SHORT $LN2@isPrivateI
$LN4@isPrivateI:

; 199  : 	}
; 200  : 
; 201  : 	case AF_INET:
; 202  : 	{
; 203  : 		uint32_t ipv4addr = BE32(((struct sockaddr_in*)addr)->sin_addr.s_addr);

  0004b	8b 41 04	 mov	 eax, DWORD PTR [rcx+4]
  0004e	0f c8		 bswap	 eax

; 204  : 
; 205  : 		if
; 206  : 			(
; 207  : 			(ipv4addr & 0xff000000) != 0x7f000000 && // 127.x.x.x localhost
; 208  : 				(ipv4addr & 0xffff0000) != 0xc0a80000 && // 192.168.x.x private routeable
; 209  : 				(ipv4addr & 0xffff0000) != 0xa9fe0000 && // 169.254.x.x link local
; 210  : 				(ipv4addr & 0xff000000) != 0x0a000000 && // 10.x.x.x private routeable
; 211  : 				(ipv4addr & 0xfff00000) != 0xac100000    // 172.16-31.x.x private routeable
; 212  : 				)

  00050	44 8b c0	 mov	 r8d, eax
  00053	41 81 e0 00 00
	00 ff		 and	 r8d, -16777216		; ff000000H
  0005a	41 81 f8 00 00
	00 7f		 cmp	 r8d, 2130706432		; 7f000000H
  00061	74 2d		 je	 SHORT $LN3@isPrivateI
  00063	8b c8		 mov	 ecx, eax
  00065	81 e1 00 00 ff
	ff		 and	 ecx, -65536		; ffff0000H
  0006b	81 f9 00 00 a8
	c0		 cmp	 ecx, -1062731776	; c0a80000H
  00071	74 1d		 je	 SHORT $LN3@isPrivateI
  00073	81 f9 00 00 fe
	a9		 cmp	 ecx, -1442971648	; a9fe0000H
  00079	74 15		 je	 SHORT $LN3@isPrivateI
  0007b	41 81 f8 00 00
	00 0a		 cmp	 r8d, 167772160		; 0a000000H
  00082	74 0c		 je	 SHORT $LN3@isPrivateI
  00084	25 00 00 f0 ff	 and	 eax, -1048576		; fff00000H
  00089	3d 00 00 10 ac	 cmp	 eax, -1408237568	; ac100000H
  0008e	75 ab		 jne	 SHORT $LN17@isPrivateI
$LN3@isPrivateI:

; 213  : 		{
; 214  : 			return FALSE;
; 215  : 		}
; 216  : 
; 217  : 		if (length) *length = sizeof(struct sockaddr_in);

  00090	48 85 d2	 test	 rdx, rdx
  00093	74 06		 je	 SHORT $LN2@isPrivateI
  00095	c7 02 10 00 00
	00		 mov	 DWORD PTR [rdx], 16
$LN2@isPrivateI:

; 218  : 		break;
; 219  : 	}
; 220  : 
; 221  : 	default:
; 222  : 		return FALSE;
; 223  : 	}
; 224  : 
; 225  : 	return TRUE;

  0009b	b0 01		 mov	 al, 1

; 226  : }

  0009d	c3		 ret	 0
isPrivateIPAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT allowSocketReuse
_TEXT	SEGMENT
s$ = 64
socketOption$ = 72
allowSocketReuse PROC					; COMDAT

; 299  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 300  : #	if !__CYGWIN__
; 301  : 
; 302  : 	BOOL socketOption = TRUE;
; 303  : 
; 304  : #	if !_WIN32
; 305  : #	define VLMCSD_SOCKET_OPTION SO_REUSEADDR
; 306  : #	else // _WIN32
; 307  : #	define VLMCSD_SOCKET_OPTION SO_EXCLUSIVEADDRUSE
; 308  : #	endif // _WIN32
; 309  : 
; 310  : 	if (setsockopt(s, SOL_SOCKET, VLMCSD_SOCKET_OPTION, (sockopt_t)&socketOption, sizeof(socketOption)))

  00004	4c 8d 4c 24 48	 lea	 r9, QWORD PTR socketOption$[rsp]
  00009	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0000e	41 b8 fb ff ff
	ff		 mov	 r8d, -5
  00014	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR socketOption$[rsp], 1
  0001c	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 311  : 	{
; 312  : #		ifdef _PEDANTIC
; 313  : 		printerrorf("Warning: Socket option SO_REUSEADDR unsupported: %s\n", vlmcsd_strerror(socket_errno));
; 314  : #		endif // _PEDANTIC
; 315  : 	}
; 316  : 
; 317  : #	undef VLMCSD_SOCKET_OPTION
; 318  : #	endif // !__CYGWIN__
; 319  : 
; 320  : 	return 0;

  0002a	32 c0		 xor	 al, al

; 321  : }

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	c3		 ret	 0
allowSocketReuse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT getPrivateIPAddresses
_TEXT	SEGMENT
firstAdapter$1$ = 64
numAddresses$ = 128
ipAddresses$ = 136
outBufLen$ = 144
length$1 = 152
length$2 = 152
getPrivateIPAddresses PROC				; COMDAT

; 390  : {

$LN76:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	55		 push	 rbp
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	41 56		 push	 r14
  0000c	41 57		 push	 r15
  0000e	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00012	48 8b f1	 mov	 rsi, rcx

; 391  : #	if _WIN32
; 392  : 
; 393  : 	PIP_ADAPTER_ADDRESSES firstAdapter, currentAdapter;
; 394  : 
; 395  : 	DWORD dwRetVal;
; 396  : 	ULONG outBufLen = 16384;

  00015	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  0001a	4c 8b fa	 mov	 r15, rdx
  0001d	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 397  : 	ULONG flags = GAA_FLAG_SKIP_MULTICAST | GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_DNS_SERVER | GAA_FLAG_SKIP_FRIENDLY_NAME;
; 398  : 
; 399  : 	firstAdapter = (PIP_ADAPTER_ADDRESSES)vlmcsd_malloc(outBufLen);

  00020	e8 00 00 00 00	 call	 vlmcsd_malloc

; 400  : 
; 401  : 	if ((dwRetVal = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, firstAdapter, &outBufLen)) == ERROR_BUFFER_OVERFLOW)

  00025	45 33 c0	 xor	 r8d, r8d
  00028	48 8b d8	 mov	 rbx, rax
  0002b	41 8d 68 2e	 lea	 ebp, QWORD PTR [r8+46]
  0002f	48 89 44 24 40	 mov	 QWORD PTR firstAdapter$1$[rsp], rax
  00034	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR outBufLen$[rsp]
  0003c	33 c9		 xor	 ecx, ecx
  0003e	8b d5		 mov	 edx, ebp
  00040	4c 8b cb	 mov	 r9, rbx
  00043	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetAdaptersAddresses
  0004e	8b f8		 mov	 edi, eax
  00050	83 f8 6f	 cmp	 eax, 111		; 0000006fH
  00053	75 3c		 jne	 SHORT $LN19@getPrivate

; 402  : 	{
; 403  : 		free(firstAdapter);

  00055	48 8b cb	 mov	 rcx, rbx
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 404  : 		firstAdapter = (PIP_ADAPTER_ADDRESSES)vlmcsd_malloc(outBufLen);

  0005e	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR outBufLen$[rsp]
  00065	e8 00 00 00 00	 call	 vlmcsd_malloc

; 405  : 		dwRetVal = GetAdaptersAddresses(AF_UNSPEC, flags, NULL, firstAdapter, &outBufLen);

  0006a	45 33 c0	 xor	 r8d, r8d
  0006d	8b d5		 mov	 edx, ebp
  0006f	48 8b d8	 mov	 rbx, rax
  00072	48 89 44 24 40	 mov	 QWORD PTR firstAdapter$1$[rsp], rax
  00077	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR outBufLen$[rsp]
  0007f	4c 8b cb	 mov	 r9, rbx
  00082	33 c9		 xor	 ecx, ecx
  00084	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetAdaptersAddresses
  0008f	8b f8		 mov	 edi, eax
$LN19@getPrivate:

; 406  : 	}
; 407  : 
; 408  : 	if (dwRetVal != NO_ERROR)

  00091	85 ff		 test	 edi, edi
  00093	74 1f		 je	 SHORT $LN18@getPrivate

; 409  : 	{
; 410  : 		printerrorf("FATAL: Could not get network address list: %s\n", vlmcsd_strerror(dwRetVal));

  00095	8b cf		 mov	 ecx, edi
  00097	e8 00 00 00 00	 call	 win_strerror
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@HEAGFLOL@FATAL?3?5Could?5not?5get?5network?5add@
  000a3	48 8b d0	 mov	 rdx, rax
  000a6	e8 00 00 00 00	 call	 printerrorf

; 411  : 		exit(dwRetVal);

  000ab	8b cf		 mov	 ecx, edi
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  000b3	cc		 int	 3
$LN18@getPrivate:

; 412  : 	}
; 413  : 
; 414  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  000b4	83 26 00	 and	 DWORD PTR [rsi], 0
  000b7	4c 8b cb	 mov	 r9, rbx
  000ba	48 85 db	 test	 rbx, rbx
  000bd	74 3b		 je	 SHORT $LN15@getPrivate
$LL17@getPrivate:

; 415  : 	{
; 416  : 		PIP_ADAPTER_UNICAST_ADDRESS currentAddress;
; 417  : 		int length;
; 418  : 
; 419  : 		if (currentAdapter->OperStatus != IfOperStatusUp) continue;

  000bf	41 83 79 68 01	 cmp	 DWORD PTR [r9+104], 1
  000c4	75 2b		 jne	 SHORT $LN16@getPrivate

; 420  : 
; 421  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  000c6	4d 8b 51 18	 mov	 r10, QWORD PTR [r9+24]
  000ca	eb 20		 jmp	 SHORT $LN73@getPrivate
$LL13@getPrivate:

; 422  : 		{
; 423  : 			if (isPrivateIPAddress(currentAddress->Address.lpSockaddr, &length)) (*numAddresses)++;

  000cc	49 8b 4a 10	 mov	 rcx, QWORD PTR [r10+16]
  000d0	48 85 c9	 test	 rcx, rcx
  000d3	74 13		 je	 SHORT $LN12@getPrivate
  000d5	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR length$2[rsp]
  000dd	e8 00 00 00 00	 call	 isPrivateIPAddress
  000e2	84 c0		 test	 al, al
  000e4	74 02		 je	 SHORT $LN12@getPrivate
  000e6	ff 06		 inc	 DWORD PTR [rsi]
$LN12@getPrivate:

; 420  : 
; 421  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  000e8	4d 8b 52 08	 mov	 r10, QWORD PTR [r10+8]
$LN73@getPrivate:
  000ec	4d 85 d2	 test	 r10, r10
  000ef	75 db		 jne	 SHORT $LL13@getPrivate
$LN16@getPrivate:

; 412  : 	}
; 413  : 
; 414  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  000f1	4d 8b 49 08	 mov	 r9, QWORD PTR [r9+8]
  000f5	4d 85 c9	 test	 r9, r9
  000f8	75 c5		 jne	 SHORT $LL17@getPrivate
$LN15@getPrivate:

; 424  : 		}
; 425  : 	}
; 426  : 
; 427  : 	*ipAddresses = (char**)vlmcsd_malloc(*numAddresses * sizeof(char*));

  000fa	48 63 0e	 movsxd	 rcx, DWORD PTR [rsi]
  000fd	48 c1 e1 03	 shl	 rcx, 3
  00101	e8 00 00 00 00	 call	 vlmcsd_malloc

; 428  : 
; 429  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  00106	83 26 00	 and	 DWORD PTR [rsi], 0
  00109	48 8b eb	 mov	 rbp, rbx
  0010c	49 89 07	 mov	 QWORD PTR [r15], rax
  0010f	48 85 db	 test	 rbx, rbx
  00112	0f 84 e0 00 00
	00		 je	 $LN7@getPrivate
  00118	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?buff@?1??gai_strerrorA@@9@9 ; `gai_strerrorA'::`2'::buff
$LL9@getPrivate:

; 430  : 	{
; 431  : 		PIP_ADAPTER_UNICAST_ADDRESS currentAddress;
; 432  : 		int length;
; 433  : 
; 434  : 		if (currentAdapter->OperStatus != IfOperStatusUp) continue;

  0011f	83 7d 68 01	 cmp	 DWORD PTR [rbp+104], 1
  00123	0f 85 bd 00 00
	00		 jne	 $LN8@getPrivate

; 435  : 
; 436  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  00129	48 8b 7d 18	 mov	 rdi, QWORD PTR [rbp+24]
  0012d	e9 ab 00 00 00	 jmp	 $LN74@getPrivate
$LL5@getPrivate:

; 437  : 		{
; 438  : 			if (!isPrivateIPAddress(currentAddress->Address.lpSockaddr, &length)) continue;

  00132	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00136	48 85 c9	 test	 rcx, rcx
  00139	0f 84 9a 00 00
	00		 je	 $LN4@getPrivate
  0013f	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR length$1[rsp]
  00147	e8 00 00 00 00	 call	 isPrivateIPAddress
  0014c	84 c0		 test	 al, al
  0014e	0f 84 85 00 00
	00		 je	 $LN4@getPrivate

; 439  : 
; 440  : 			char *ipAddress = (char*)vlmcsd_malloc(64);

  00154	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00159	e8 00 00 00 00	 call	 vlmcsd_malloc

; 441  : 			int error = getnameinfo(currentAddress->Address.lpSockaddr, currentAddress->Address.iSockaddrLength, ipAddress, 64, NULL, 0, NI_NUMERICHOST);

  0015e	8b 57 18	 mov	 edx, DWORD PTR [rdi+24]
  00161	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00165	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR [rsp+48], 2
  0016d	83 64 24 28 00	 and	 DWORD PTR [rsp+40], 0
  00172	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00178	4c 8b c0	 mov	 r8, rax
  0017b	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00181	4c 8b f0	 mov	 r14, rax
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getnameinfo

; 442  : 
; 443  : 			if (error)

  0018a	85 c0		 test	 eax, eax
  0018c	74 3c		 je	 SHORT $LN1@getPrivate

; 444  : 			{
; 445  : 				printerrorf("WARNING: Could not get IP address from interface list: %s\n", gai_strerror(error));

  0018e	48 83 64 24 30
	00		 and	 QWORD PTR [rsp+48], 0
  00194	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  0019a	44 8b c0	 mov	 r8d, eax
  0019d	33 d2		 xor	 edx, edx
  0019f	b9 ff 12 00 00	 mov	 ecx, 4863		; 000012ffH
  001a4	c7 44 24 28 00
	04 00 00	 mov	 DWORD PTR [rsp+40], 1024 ; 00000400H
  001ac	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  001b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageA
  001b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DL@MGEENDOJ@WARNING?3?5Could?5not?5get?5IP?5addres@
  001be	48 8b d3	 mov	 rdx, rbx
  001c1	e8 00 00 00 00	 call	 printerrorf

; 446  : 				*ipAddress = 0;

  001c6	41 c6 06 00	 mov	 BYTE PTR [r14], 0
$LN1@getPrivate:

; 447  : 			}
; 448  : 
; 449  : 			(*ipAddresses)[(*numAddresses)++] = ipAddress;

  001ca	48 63 16	 movsxd	 rdx, DWORD PTR [rsi]
  001cd	49 8b 07	 mov	 rax, QWORD PTR [r15]
  001d0	4c 89 34 d0	 mov	 QWORD PTR [rax+rdx*8], r14
  001d4	8d 42 01	 lea	 eax, DWORD PTR [rdx+1]
  001d7	89 06		 mov	 DWORD PTR [rsi], eax
$LN4@getPrivate:

; 435  : 
; 436  : 		for (currentAddress = currentAdapter->FirstUnicastAddress; currentAddress != NULL; currentAddress = currentAddress->Next)

  001d9	48 8b 7f 08	 mov	 rdi, QWORD PTR [rdi+8]
$LN74@getPrivate:
  001dd	48 85 ff	 test	 rdi, rdi
  001e0	0f 85 4c ff ff
	ff		 jne	 $LL5@getPrivate
$LN8@getPrivate:

; 428  : 
; 429  : 	for (currentAdapter = firstAdapter, *numAddresses = 0; currentAdapter != NULL; currentAdapter = currentAdapter->Next)

  001e6	48 8b 6d 08	 mov	 rbp, QWORD PTR [rbp+8]
  001ea	48 85 ed	 test	 rbp, rbp
  001ed	0f 85 2c ff ff
	ff		 jne	 $LL9@getPrivate
  001f3	48 8b 5c 24 40	 mov	 rbx, QWORD PTR firstAdapter$1$[rsp]
$LN7@getPrivate:

; 450  : 		}
; 451  : 	}
; 452  : 
; 453  : 	free(firstAdapter);

  001f8	48 8b cb	 mov	 rcx, rbx
  001fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 454  : 
; 455  : #	else // !_WIN32
; 456  : 
; 457  : 	struct ifaddrs *addrs, *addr;
; 458  : 
; 459  : 	if (getifaddrs(&addrs))
; 460  : 	{
; 461  : 		printerrorf("FATAL: Could not get network address list: %s\n", vlmcsd_strerror(errno));
; 462  : 		exit(errno);
; 463  : 	}
; 464  : 
; 465  : 	socklen_t length;
; 466  : 
; 467  : 	for (addr = addrs, *numAddresses = 0; addr != NULL; addr = addr->ifa_next)
; 468  : 	{
; 469  : 		if (!isPrivateIPAddress(addr->ifa_addr, &length)) continue;
; 470  : 		(*numAddresses)++;
; 471  : 	}
; 472  : 
; 473  : 	*ipAddresses = (char**)vlmcsd_malloc(*numAddresses * sizeof(char*));
; 474  : 
; 475  : 	for (addr = addrs, *numAddresses = 0; addr != NULL; addr = addr->ifa_next)
; 476  : 	{
; 477  : 		if (!isPrivateIPAddress(addr->ifa_addr, &length)) continue;
; 478  : 
; 479  : 		char *ipAddress = (char*)vlmcsd_malloc(64);
; 480  : 		int error = getnameinfo(addr->ifa_addr, length, ipAddress, 64, NULL, 0, NI_NUMERICHOST);
; 481  : 
; 482  : 		if (error)
; 483  : 		{
; 484  : 			printerrorf("WARNING: Could not get IP address from interface list: %s\n", gai_strerror(error));
; 485  : 			*ipAddress = 0;
; 486  : 		}
; 487  : 
; 488  : #		if __UCLIBC__ || __gnu_hurd__
; 489  : 
; 490  : 		size_t adrlen = strlen(ipAddress);
; 491  : 
; 492  : 		if
; 493  : 			(
; 494  : 				addr->ifa_addr->sa_family == AF_INET6 &&
; 495  : 				adrlen > 5 &&
; 496  : 				!strchr(ipAddress, '%') &&
; 497  : 				(BE16(*(uint16_t*)&((struct sockaddr_in6*)addr->ifa_addr)->sin6_addr) & 0xffc0) == 0xfe80
; 498  : 				)
; 499  : 		{
; 500  : 			size_t ifnamelen = strlen(addr->ifa_name);
; 501  : 			char* workaroundIpAddress = (char*)vlmcsd_malloc(adrlen + ifnamelen + 2);
; 502  : 			strcpy(workaroundIpAddress, ipAddress);
; 503  : 			strcat(workaroundIpAddress, "%");
; 504  : 			strcat(workaroundIpAddress, addr->ifa_name);
; 505  : 			(*ipAddresses)[(*numAddresses)++] = workaroundIpAddress;
; 506  : 			free(ipAddress);
; 507  : 		}
; 508  : 		else
; 509  : 		{
; 510  : 			(*ipAddresses)[(*numAddresses)++] = ipAddress;
; 511  : 		}
; 512  : #		else // !(__UCLIBC__ || __gnu_hurd__)
; 513  : 
; 514  : 		(*ipAddresses)[(*numAddresses)++] = ipAddress;
; 515  : 
; 516  : #		endif // !(__UCLIBC__ || __gnu_hurd__)
; 517  : 	}
; 518  : 
; 519  : 	freeifaddrs(addrs);
; 520  : 
; 521  : #	endif // !_WIN32
; 522  : }

  00201	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  00209	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0020d	41 5f		 pop	 r15
  0020f	41 5e		 pop	 r14
  00211	5f		 pop	 rdi
  00212	5e		 pop	 rsi
  00213	5d		 pop	 rbp
  00214	c3		 ret	 0
$LN75@getPrivate:
getPrivateIPAddresses ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT listenOnAddress
_TEXT	SEGMENT
ipstr$ = 64
ipAddress$1 = 128
socketOption$ = 208
ai$ = 208
socketOption$2 = 216
portNumber$3 = 216
s$ = 216
listenOnAddress PROC					; COMDAT

; 530  : {

  00000	4c 8b dc	 mov	 r11, rsp
  00003	49 89 5b 18	 mov	 QWORD PTR [r11+24], rbx
  00007	49 89 73 20	 mov	 QWORD PTR [r11+32], rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H

; 531  : 	int error;
; 532  : 	char ipstr[64];
; 533  : 
; 534  : 	ip2str(ipstr, sizeof(ipstr), ai->ai_addr, (socklen_t)ai->ai_addrlen);

  00013	48 8b 59 20	 mov	 rbx, QWORD PTR [rcx+32]
  00017	48 8b f2	 mov	 rsi, rdx
  0001a	8b 51 10	 mov	 edx, DWORD PTR [rcx+16]
  0001d	49 8d 43 10	 lea	 rax, QWORD PTR [r11+16]
  00021	48 8b f9	 mov	 rdi, rcx
  00024	c7 44 24 30 0a
	00 00 00	 mov	 DWORD PTR [rsp+48], 10
  0002c	4d 8d 43 b8	 lea	 r8, QWORD PTR [r11-72]
  00030	48 8b cb	 mov	 rcx, rbx
  00033	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00039	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  00041	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getnameinfo
  0004c	85 c0		 test	 eax, eax
  0004e	75 1d		 jne	 SHORT $LN9@listenOnAd
  00050	4c 8d 8c 24 d8
	00 00 00	 lea	 r9, QWORD PTR portNumber$3[rsp]
  00058	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR ipAddress$1[rsp]
  00060	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ipstr$[rsp]
  00065	48 8b d3	 mov	 rdx, rbx
  00068	e8 00 00 00 00	 call	 ip2str
$LN9@listenOnAd:

; 535  : 
; 536  : 	//*s = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
; 537  : 	*s = socket(ai->ai_family, SOCK_STREAM, IPPROTO_TCP);

  0006d	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
  00070	bb 01 00 00 00	 mov	 ebx, 1
  00075	44 8d 43 05	 lea	 r8d, QWORD PTR [rbx+5]
  00079	8b d3		 mov	 edx, ebx
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket
  00081	48 89 06	 mov	 QWORD PTR [rsi], rax

; 538  : 
; 539  : 	if (*s == INVALID_SOCKET)

  00084	48 83 f8 ff	 cmp	 rax, -1
  00088	75 39		 jne	 SHORT $LN4@listenOnAd

; 540  : 	{
; 541  : 		error = socket_errno;

  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError

; 542  : 		printerrorf("Warning: %s error. %s\n", ai->ai_family == AF_INET6 ? cIPv6 : cIPv4, vlmcsd_strerror(error));

  00090	8b c8		 mov	 ecx, eax
  00092	8b d8		 mov	 ebx, eax
  00094	e8 00 00 00 00	 call	 win_strerror
  00099	83 7f 04 17	 cmp	 DWORD PTR [rdi+4], 23
  0009d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04EMGFNKGN@IPv4?$AA@
  000a4	4c 8b c0	 mov	 r8, rax
  000a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04HOFDLIOP@IPv6?$AA@
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6?$AA@
  000b5	48 0f 44 d0	 cmove	 rdx, rax
  000b9	e8 00 00 00 00	 call	 printerrorf

; 543  : 		return error;

  000be	e9 c2 00 00 00	 jmp	 $LN18@listenOnAd
$LN4@listenOnAd:

; 544  : 	}
; 545  : 
; 546  : #	if !defined(_WIN32) && !defined(NO_SIGHUP)
; 547  : 
; 548  : 	int flags = fcntl(*s, F_GETFD, 0);
; 549  : 
; 550  : 	if (flags != -1)
; 551  : 	{
; 552  : 		flags |= FD_CLOEXEC;
; 553  : 		fcntl(*s, F_SETFD, flags);
; 554  : 	}
; 555  : #	ifdef _PEDANTIC
; 556  : 	else
; 557  : 	{
; 558  : 		printerrorf("Warning: Could not set FD_CLOEXEC flag on %s: %s\n", ipstr, vlmcsd_strerror(errno));
; 559  : 	}
; 560  : #	endif // _PEDANTIC
; 561  : 
; 562  : #	endif // !defined(_WIN32) && !defined(NO_SIGHUP)
; 563  : 
; 564  : 	BOOL socketOption = TRUE;
; 565  : 
; 566  : #	ifdef IPV6_V6ONLY
; 567  : 	if (ai->ai_family == AF_INET6 && setsockopt(*s, IPPROTO_IPV6, IPV6_V6ONLY, (sockopt_t)&socketOption, sizeof(socketOption)))

  000c3	83 7f 04 17	 cmp	 DWORD PTR [rdi+4], 23
  000c7	89 9c 24 d0 00
	00 00		 mov	 DWORD PTR socketOption$[rsp], ebx
  000ce	75 22		 jne	 SHORT $LN3@listenOnAd
  000d0	ba 29 00 00 00	 mov	 edx, 41			; 00000029H
  000d5	4c 8d 8c 24 d0
	00 00 00	 lea	 r9, QWORD PTR socketOption$[rsp]
  000dd	48 8b c8	 mov	 rcx, rax
  000e0	44 8d 42 f2	 lea	 r8d, QWORD PTR [rdx-14]
  000e4	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt
$LN3@listenOnAd:

; 568  : 	{
; 569  : #		ifdef _PEDANTIC
; 570  : #		if defined(_WIN32) || defined(__CYGWIN__)
; 571  : 		//		if (IsWindowsVistaOrGreater()) //Doesn't work with older version of MingW32-w64 toolchain
; 572  : 		if ((GetVersion() & 0xff) > 5)
; 573  : 		{
; 574  : #		endif // _WIN32
; 575  : 			printerrorf("Warning: %s does not support socket option IPV6_V6ONLY: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 576  : #		if defined(_WIN32) || defined(__CYGWIN__)
; 577  : 		}
; 578  : #		endif // _WIN32
; 579  : #		endif // _PEDANTIC
; 580  : 	}
; 581  : #	endif
; 582  : 
; 583  : 	allowSocketReuse(*s);

  000f2	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  000f5	4c 8d 8c 24 d8
	00 00 00	 lea	 r9, QWORD PTR socketOption$2[rsp]
  000fd	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00102	41 b8 fb ff ff
	ff		 mov	 r8d, -5
  00108	89 9c 24 d8 00
	00 00		 mov	 DWORD PTR socketOption$2[rsp], ebx
  0010f	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 584  : 
; 585  : #	if HAVE_FREEBIND
; 586  : #	if (defined(IP_NONLOCALOK) || __FreeBSD_kernel__ || __FreeBSD__) && !defined(IPV6_BINDANY)
; 587  : #	define IPV6_BINDANY 64
; 588  : #	endif // (defined(IP_NONLOCALOK) || __FreeBSD_kernel__ || __FreeBSD__) && !defined(IPV6_BINDANY)
; 589  : 
; 590  : 	if (freebind)
; 591  : 	{
; 592  : #		if defined(IP_FREEBIND) // Linux
; 593  : 		if (setsockopt(*s, IPPROTO_IP, IP_FREEBIND, (sockopt_t)&socketOption, sizeof(socketOption)))
; 594  : 		{
; 595  : 			printerrorf("Warning: Cannot use FREEBIND on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 596  : 		}
; 597  : #		endif // defined(IP_FREEBIND)
; 598  : 
; 599  : #		if defined(IP_BINDANY) // FreeBSD IPv4
; 600  : 		if (ai->ai_family == AF_INET && setsockopt(*s, IPPROTO_IP, IP_BINDANY, (sockopt_t)&socketOption, sizeof(socketOption)))
; 601  : 		{
; 602  : 			printerrorf("Warning: Cannot use BINDANY on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 603  : 		}
; 604  : #		endif // defined(IP_BINDANY)
; 605  : 
; 606  : #		if defined(IPV6_BINDANY) // FreeBSD IPv6
; 607  : 		if (ai->ai_family == AF_INET6 && setsockopt(*s, IPPROTO_IP, IPV6_BINDANY, (sockopt_t)&socketOption, sizeof(socketOption)))
; 608  : 		{
; 609  : #			ifdef _PEDANTIC // FreeBSD defines the symbol but doesn't have BINDANY in IPv6 (Kame stack doesn't have it)
; 610  : 			printerrorf("Warning: Cannot use BINDANY on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 611  : #			endif
; 612  : 		}
; 613  : #		endif // defined(IPV6_BINDANY)
; 614  : 
; 615  : #		if defined(IP_NONLOCALOK) && !defined(IP_BINDANY) // FreeBSD with GNU userspace IPv4
; 616  : 		if (ai->ai_family == AF_INET && setsockopt(*s, IPPROTO_IP, IP_NONLOCALOK, (sockopt_t)&socketOption, sizeof(socketOption)))
; 617  : 		{
; 618  : 			printerrorf("Warning: Cannot use BINDANY on %s: %s\n", ipstr, vlmcsd_strerror(socket_errno));
; 619  : 		}
; 620  : #		endif // defined(IP_NONLOCALOK) && !defined(IP_BINDANY)
; 621  : 	}
; 622  : 
; 623  : #	endif // HAVE_FREEBIND
; 624  : 
; 625  : 	if (bind(*s, ai->ai_addr, (int)ai->ai_addrlen) || listen(*s, SOMAXCONN))

  0011d	44 8b 47 10	 mov	 r8d, DWORD PTR [rdi+16]
  00121	48 8b 57 20	 mov	 rdx, QWORD PTR [rdi+32]
  00125	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  0012e	85 c0		 test	 eax, eax
  00130	75 27		 jne	 SHORT $LN1@listenOnAd
  00132	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  00135	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  00140	85 c0		 test	 eax, eax
  00142	75 15		 jne	 SHORT $LN1@listenOnAd

; 631  : 	}
; 632  : 
; 633  : #	ifndef NO_LOG
; 634  : 	logger("Listening on %s\n", ipstr);

  00144	48 8d 54 24 40	 lea	 rdx, QWORD PTR ipstr$[rsp]
  00149	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6?$AA@
  00150	e8 00 00 00 00	 call	 logger

; 635  : #	endif
; 636  : 
; 637  : 	return 0;

  00155	33 c0		 xor	 eax, eax
  00157	eb 2e		 jmp	 SHORT $LN5@listenOnAd
$LN1@listenOnAd:

; 626  : 	{
; 627  : 		error = socket_errno;

  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError

; 628  : 		printerrorf("Warning: %s: %s\n", ipstr, vlmcsd_strerror(error));

  0015f	8b c8		 mov	 ecx, eax
  00161	8b d8		 mov	 ebx, eax
  00163	e8 00 00 00 00	 call	 win_strerror
  00168	48 8d 54 24 40	 lea	 rdx, QWORD PTR ipstr$[rsp]
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6?$AA@
  00174	4c 8b c0	 mov	 r8, rax
  00177	e8 00 00 00 00	 call	 printerrorf

; 629  : 		socketclose(*s);

  0017c	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0017f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
$LN18@listenOnAd:

; 630  : 		return error;

  00185	8b c3		 mov	 eax, ebx
$LN5@listenOnAd:

; 638  : }

  00187	4c 8d 9c 24 c0
	00 00 00	 lea	 r11, QWORD PTR [rsp+192]
  0018f	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  00193	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  00197	49 8b e3	 mov	 rsp, r11
  0019a	5f		 pop	 rdi
  0019b	c3		 ret	 0
listenOnAddress ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT addListeningSocket
_TEXT	SEGMENT
portNumber$1 = 64
ipstr$2 = 80
ipAddress$3 = 144
addr$ = 256
socketOption$4 = 264
socketOption$5 = 272
aiList$ = 280
addListeningSocket PROC					; COMDAT

; 643  : {

$LN49:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d 6c 24 c9	 lea	 rbp, QWORD PTR [rsp-55]
  00011	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H

; 644  : 	struct addrinfo *aiList, *ai;
; 645  : 	int result = FALSE;
; 646  : 	SOCKET *s = SocketList + numsockets;

  00018	48 63 35 00 00
	00 00		 movsxd	 rsi, DWORD PTR numsockets
  0001f	4c 8b 35 00 00
	00 00		 mov	 r14, QWORD PTR SocketList
  00026	45 33 ff	 xor	 r15d, r15d

; 647  : 
; 648  : 	if (getSocketList(&aiList, addr, AI_PASSIVE | AI_NUMERICHOST, AF_UNSPEC))

  00029	49 83 c8 ff	 or	 r8, -1
$LL45@addListeni:
  0002d	49 ff c0	 inc	 r8
  00030	46 38 3c 01	 cmp	 BYTE PTR [rcx+r8], r15b
  00034	75 f7		 jne	 SHORT $LL45@addListeni
  00036	49 ff c0	 inc	 r8
  00039	49 81 f8 08 01
	00 00		 cmp	 r8, 264			; 00000108H
  00040	0f 87 be 01 00
	00		 ja	 $LN7@addListeni
  00046	48 8b d1	 mov	 rdx, rcx
  00049	48 8d 4d 7f	 lea	 rcx, QWORD PTR aiList$[rbp-153]
  0004d	e8 00 00 00 00	 call	 getSocketList
  00052	84 c0		 test	 al, al
  00054	0f 84 aa 01 00
	00		 je	 $LN7@addListeni

; 649  : 	{
; 650  : 		for (ai = aiList; ai; ai = ai->ai_next)

  0005a	48 8b 5d 7f	 mov	 rbx, QWORD PTR aiList$[rbp-153]
  0005e	48 85 db	 test	 rbx, rbx
  00061	0f 84 94 01 00
	00		 je	 $LN4@addListeni
$LL6@addListeni:

; 651  : 		{
; 652  : 			// struct sockaddr_in* addr4 = (struct sockaddr_in*)sa->ai_addr;
; 653  : 			// struct sockaddr_in6* addr6 = (struct sockaddr_in6*)sa->ai_addr;
; 654  : 
; 655  : 			if (numsockets >= FD_SETSIZE)

  00067	83 3d 00 00 00
	00 40		 cmp	 DWORD PTR numsockets, 64 ; 00000040H
  0006e	0f 8d 83 01 00
	00		 jge	 $LN46@addListeni

; 656  : 			{
; 657  : #ifdef _PEDANTIC // Do not report this error in normal builds to keep file size low
; 658  : 				printerrorf("Warning: Cannot listen on %s. Your OS only supports %u listening sockets in an FD_SET.\n", addr, FD_SETSIZE);
; 659  : #endif
; 660  : 				break;
; 661  : 			}
; 662  : 
; 663  : 			if (!listenOnAddress(ai, s))

  00074	48 8b 7b 20	 mov	 rdi, QWORD PTR [rbx+32]
  00078	8b 53 10	 mov	 edx, DWORD PTR [rbx+16]
  0007b	48 8d 45 a7	 lea	 rax, QWORD PTR portNumber$1[rbp-153]
  0007f	c7 44 24 30 0a
	00 00 00	 mov	 DWORD PTR [rsp+48], 10
  00087	4c 8d 45 f7	 lea	 r8, QWORD PTR ipAddress$3[rbp-153]
  0008b	48 8b cf	 mov	 rcx, rdi
  0008e	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  00094	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  0009c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getnameinfo
  000a7	85 c0		 test	 eax, eax
  000a9	75 14		 jne	 SHORT $LN25@addListeni
  000ab	4c 8d 4d a7	 lea	 r9, QWORD PTR portNumber$1[rbp-153]
  000af	4c 8d 45 f7	 lea	 r8, QWORD PTR ipAddress$3[rbp-153]
  000b3	48 8d 4d b7	 lea	 rcx, QWORD PTR ipstr$2[rbp-153]
  000b7	48 8b d7	 mov	 rdx, rdi
  000ba	e8 00 00 00 00	 call	 ip2str
$LN25@addListeni:
  000bf	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  000c2	ba 01 00 00 00	 mov	 edx, 1
  000c7	44 8d 42 05	 lea	 r8d, QWORD PTR [rdx+5]
  000cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket
  000d1	49 89 04 f6	 mov	 QWORD PTR [r14+rsi*8], rax
  000d5	48 83 f8 ff	 cmp	 rax, -1
  000d9	75 39		 jne	 SHORT $LN20@addListeni
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000e1	8b c8		 mov	 ecx, eax
  000e3	8b f8		 mov	 edi, eax
  000e5	e8 00 00 00 00	 call	 win_strerror
  000ea	83 7b 04 17	 cmp	 DWORD PTR [rbx+4], 23
  000ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04EMGFNKGN@IPv4?$AA@
  000f5	4c 8b c0	 mov	 r8, rax
  000f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04HOFDLIOP@IPv6?$AA@
  000ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@CLCPPOBA@Warning?3?5?$CFs?5error?4?5?$CFs?6?$AA@
  00106	48 0f 44 d0	 cmove	 rdx, rax
  0010a	e8 00 00 00 00	 call	 printerrorf
  0010f	e9 ba 00 00 00	 jmp	 $LN21@addListeni
$LN20@addListeni:
  00114	83 7b 04 17	 cmp	 DWORD PTR [rbx+4], 23
  00118	c7 45 6f 01 00
	00 00		 mov	 DWORD PTR socketOption$4[rbp-153], 1
  0011f	75 1e		 jne	 SHORT $LN19@addListeni
  00121	ba 29 00 00 00	 mov	 edx, 41			; 00000029H
  00126	4c 8d 4d 6f	 lea	 r9, QWORD PTR socketOption$4[rbp-153]
  0012a	48 8b c8	 mov	 rcx, rax
  0012d	44 8d 42 f2	 lea	 r8d, QWORD PTR [rdx-14]
  00131	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt
$LN19@addListeni:
  0013f	49 8b 0c f6	 mov	 rcx, QWORD PTR [r14+rsi*8]
  00143	4c 8d 4d 77	 lea	 r9, QWORD PTR socketOption$5[rbp-153]
  00147	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0014c	41 b8 fb ff ff
	ff		 mov	 r8d, -5
  00152	c7 45 77 01 00
	00 00		 mov	 DWORD PTR socketOption$5[rbp-153], 1
  00159	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00161	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt
  00167	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  0016b	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0016f	49 8b 0c f6	 mov	 rcx, QWORD PTR [r14+rsi*8]
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  00179	85 c0		 test	 eax, eax
  0017b	75 25		 jne	 SHORT $LN17@addListeni
  0017d	49 8b 0c f6	 mov	 rcx, QWORD PTR [r14+rsi*8]
  00181	ba ff ff ff 7f	 mov	 edx, 2147483647		; 7fffffffH
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  0018c	85 c0		 test	 eax, eax
  0018e	75 12		 jne	 SHORT $LN17@addListeni
  00190	48 8d 55 b7	 lea	 rdx, QWORD PTR ipstr$2[rbp-153]
  00194	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@LMJPNEIG@Listening?5on?5?$CFs?6?$AA@
  0019b	e8 00 00 00 00	 call	 logger
  001a0	eb 30		 jmp	 SHORT $LN44@addListeni
$LN17@addListeni:
  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  001a8	8b c8		 mov	 ecx, eax
  001aa	8b f8		 mov	 edi, eax
  001ac	e8 00 00 00 00	 call	 win_strerror
  001b1	48 8d 55 b7	 lea	 rdx, QWORD PTR ipstr$2[rbp-153]
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@NNGIJDIP@Warning?3?5?$CFs?3?5?$CFs?6?$AA@
  001bc	4c 8b c0	 mov	 r8, rax
  001bf	e8 00 00 00 00	 call	 printerrorf
  001c4	49 8b 0c f6	 mov	 rcx, QWORD PTR [r14+rsi*8]
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
$LN21@addListeni:
  001ce	85 ff		 test	 edi, edi
  001d0	75 0e		 jne	 SHORT $LN2@addListeni
$LN44@addListeni:

; 664  : 			{
; 665  : 				numsockets++;

  001d2	ff 05 00 00 00
	00		 inc	 DWORD PTR numsockets

; 666  : 				result = TRUE;

  001d8	41 bf 01 00 00
	00		 mov	 r15d, 1

; 667  : 			}
; 668  : 			else

  001de	eb 0a		 jmp	 SHORT $LN5@addListeni
$LN2@addListeni:

; 669  : 			{
; 670  : 				exitOnWarningLevel(1);

  001e0	8a 05 00 00 00
	00		 mov	 al, BYTE PTR ExitLevel
  001e6	3c 01		 cmp	 al, 1
  001e8	7d 34		 jge	 SHORT $LN40@addListeni
$LN5@addListeni:

; 649  : 	{
; 650  : 		for (ai = aiList; ai; ai = ai->ai_next)

  001ea	48 8b 5b 28	 mov	 rbx, QWORD PTR [rbx+40]
  001ee	48 85 db	 test	 rbx, rbx
  001f1	0f 85 70 fe ff
	ff		 jne	 $LL6@addListeni
$LN46@addListeni:

; 669  : 			{
; 670  : 				exitOnWarningLevel(1);

  001f7	48 8b 5d 7f	 mov	 rbx, QWORD PTR aiList$[rbp-153]
$LN4@addListeni:

; 671  : 			}
; 672  : 		}
; 673  : 
; 674  : 		freeaddrinfo(aiList);

  001fb	48 8b cb	 mov	 rcx, rbx
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_freeaddrinfo
$LN7@addListeni:

; 675  : 	}
; 676  : 	return result;

  00204	41 8b c7	 mov	 eax, r15d

; 677  : }

  00207	48 8b 9c 24 00
	01 00 00	 mov	 rbx, QWORD PTR [rsp+256]
  0020f	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00216	41 5f		 pop	 r15
  00218	41 5e		 pop	 r14
  0021a	5f		 pop	 rdi
  0021b	5e		 pop	 rsi
  0021c	5d		 pop	 rbp
  0021d	c3		 ret	 0
$LN40@addListeni:

; 669  : 			{
; 670  : 				exitOnWarningLevel(1);

  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CP@NEIJGKGH@Fatal?3?5Exiting?5on?5warning?5level?5@
  00225	0f be d0	 movsx	 edx, al
  00228	e8 00 00 00 00	 call	 printerrorf
  0022d	83 c9 ff	 or	 ecx, -1
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  00236	cc		 int	 3
$LN48@addListeni:
addListeningSocket ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT checkProtocolStack
_TEXT	SEGMENT
addressfamily$ = 48
checkProtocolStack PROC					; COMDAT

; 682  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 683  : 	SOCKET s; // = INVALID_SOCKET;
; 684  : 
; 685  : 	s = socket(addressfamily, SOCK_STREAM, 0);

  00006	45 33 c0	 xor	 r8d, r8d
  00009	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  0000d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket

; 686  : 	int_fast8_t success = (s != INVALID_SOCKET);
; 687  : 
; 688  : 	socketclose(s);

  00013	48 8b c8	 mov	 rcx, rax
  00016	48 8b d8	 mov	 rbx, rax
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  0001f	48 83 fb ff	 cmp	 rbx, -1
  00023	0f 95 c0	 setne	 al

; 689  : 	return success;
; 690  : }

  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
checkProtocolStack ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT network_accept_any
_TEXT	SEGMENT
ListeningSocketsList$ = 48
network_accept_any PROC					; COMDAT

; 695  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 81 ec 40 02
	00 00		 sub	 rsp, 576		; 00000240H

; 696  : 	fd_set ListeningSocketsList;
; 697  : 	SOCKET maxSocket, sock;
; 698  : 	int i;
; 699  : 	int status;
; 700  : 
; 701  : 	FD_ZERO(&ListeningSocketsList);
; 702  : 	maxSocket = 0;
; 703  : 
; 704  : 	for (i = 0; i < numsockets; i++)

  0000d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numsockets
  00013	33 c9		 xor	 ecx, ecx
  00015	45 33 c0	 xor	 r8d, r8d
  00018	89 4c 24 30	 mov	 DWORD PTR ListeningSocketsList$[rsp], ecx
  0001c	85 c0		 test	 eax, eax
  0001e	7e 4b		 jle	 SHORT $LN18@network_ac
  00020	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR SocketList
  00027	44 8b d8	 mov	 r11d, eax
$LL20@network_ac:

; 705  : 	{
; 706  : 		FD_SET(SocketList[i], &ListeningSocketsList);

  0002a	33 d2		 xor	 edx, edx
  0002c	85 c9		 test	 ecx, ecx
  0002e	74 10		 je	 SHORT $LN26@network_ac
  00030	4d 8b 11	 mov	 r10, QWORD PTR [r9]
$LL14@network_ac:
  00033	4c 39 54 d4 38	 cmp	 QWORD PTR ListeningSocketsList$[rsp+rdx*8+8], r10
  00038	74 06		 je	 SHORT $LN26@network_ac
  0003a	ff c2		 inc	 edx
  0003c	3b d1		 cmp	 edx, ecx
  0003e	72 f3		 jb	 SHORT $LL14@network_ac
$LN26@network_ac:
  00040	3b d1		 cmp	 edx, ecx
  00042	75 17		 jne	 SHORT $LN16@network_ac
  00044	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00047	73 12		 jae	 SHORT $LN16@network_ac
  00049	49 8b 01	 mov	 rax, QWORD PTR [r9]
  0004c	48 89 44 d4 38	 mov	 QWORD PTR ListeningSocketsList$[rsp+rdx*8+8], rax
  00051	8b 4c 24 30	 mov	 ecx, DWORD PTR ListeningSocketsList$[rsp]
  00055	ff c1		 inc	 ecx
  00057	89 4c 24 30	 mov	 DWORD PTR ListeningSocketsList$[rsp], ecx
$LN16@network_ac:

; 707  : 		if (SocketList[i] > maxSocket) maxSocket = SocketList[i];

  0005b	4d 39 01	 cmp	 QWORD PTR [r9], r8
  0005e	4d 0f 47 01	 cmova	 r8, QWORD PTR [r9]
  00062	49 83 c1 08	 add	 r9, 8
  00066	49 ff cb	 dec	 r11
  00069	75 bf		 jne	 SHORT $LL20@network_ac
$LN18@network_ac:

; 708  : 	}
; 709  : 
; 710  : 	status = select((int)maxSocket + 1, &ListeningSocketsList, NULL, NULL, NULL);// 

  0006b	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  00071	41 8d 48 01	 lea	 ecx, DWORD PTR [r8+1]
  00075	48 8d 54 24 30	 lea	 rdx, QWORD PTR ListeningSocketsList$[rsp]
  0007a	45 33 c9	 xor	 r9d, r9d
  0007d	45 33 c0	 xor	 r8d, r8d
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_select

; 711  : 
; 712  : 	if (status < 0) return INVALID_SOCKET;// INVALID_SOCKET

  00086	85 c0		 test	 eax, eax
  00088	78 34		 js	 SHORT $LN37@network_ac

; 713  : 
; 714  : 	sock = INVALID_SOCKET;
; 715  : 
; 716  : 	for (i = 0; i < numsockets; i++)

  0008a	33 db		 xor	 ebx, ebx
  0008c	39 1d 00 00 00
	00		 cmp	 DWORD PTR numsockets, ebx
  00092	7e 2a		 jle	 SHORT $LN37@network_ac
  00094	33 ff		 xor	 edi, edi
$LL6@network_ac:

; 717  : 	{
; 718  : 		if (FD_ISSET(SocketList[i], &ListeningSocketsList))

  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR SocketList
  0009d	48 8d 54 24 30	 lea	 rdx, QWORD PTR ListeningSocketsList$[rsp]
  000a2	48 8b 0c 0f	 mov	 rcx, QWORD PTR [rdi+rcx]
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___WSAFDIsSet
  000ac	85 c0		 test	 eax, eax
  000ae	75 23		 jne	 SHORT $LN27@network_ac

; 713  : 
; 714  : 	sock = INVALID_SOCKET;
; 715  : 
; 716  : 	for (i = 0; i < numsockets; i++)

  000b0	ff c3		 inc	 ebx
  000b2	48 83 c7 08	 add	 rdi, 8
  000b6	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR numsockets
  000bc	7c d8		 jl	 SHORT $LL6@network_ac
$LN37@network_ac:

; 726  : 		return INVALID_SOCKET;

  000be	48 83 c8 ff	 or	 rax, -1
$LN1@network_ac:

; 729  : }

  000c2	48 8b 9c 24 50
	02 00 00	 mov	 rbx, QWORD PTR [rsp+592]
  000ca	48 81 c4 40 02
	00 00		 add	 rsp, 576		; 00000240H
  000d1	5f		 pop	 rdi
  000d2	c3		 ret	 0
$LN27@network_ac:

; 719  : 		{
; 720  : 			sock = SocketList[i];

  000d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SocketList
  000da	48 63 cb	 movsxd	 rcx, ebx
  000dd	48 8b 0c c8	 mov	 rcx, QWORD PTR [rax+rcx*8]

; 721  : 			break;
; 722  : 		}
; 723  : 	}
; 724  : 
; 725  : 	if (sock == INVALID_SOCKET)

  000e1	48 83 f9 ff	 cmp	 rcx, -1
  000e5	74 d7		 je	 SHORT $LN37@network_ac

; 727  : 	else
; 728  : 		return accept(sock, NULL, NULL);

  000e7	45 33 c0	 xor	 r8d, r8d
  000ea	33 d2		 xor	 edx, edx
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_accept
  000f2	eb ce		 jmp	 SHORT $LN1@network_ac
network_accept_any ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT closeAllListeningSockets
_TEXT	SEGMENT
closeAllListeningSockets PROC				; COMDAT

; 734  : {

$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 735  : #	ifdef SIMPLE_SOCKETS
; 736  : 
; 737  : 	socketclose(s_server);
; 738  : 
; 739  : #	else // !SIMPLE_SOCKETS
; 740  : 
; 741  : 	int i;
; 742  : 
; 743  : 	for (i = 0; i < numsockets; i++)

  0000a	33 db		 xor	 ebx, ebx
  0000c	39 1d 00 00 00
	00		 cmp	 DWORD PTR numsockets, ebx
  00012	7e 21		 jle	 SHORT $LN1@closeAllLi
  00014	8b fb		 mov	 edi, ebx
$LL3@closeAllLi:

; 744  : 	{
; 745  : 		socketclose(SocketList[i]);

  00016	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR SocketList
  0001d	48 8b 0c 0f	 mov	 rcx, QWORD PTR [rdi+rcx]
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  00027	ff c3		 inc	 ebx
  00029	48 8d 7f 08	 lea	 rdi, QWORD PTR [rdi+8]
  0002d	3b 1d 00 00 00
	00		 cmp	 ebx, DWORD PTR numsockets
  00033	7c e1		 jl	 SHORT $LL3@closeAllLi
$LN1@closeAllLi:

; 746  : 	}
; 747  : 
; 748  : #endif // !SIMPLE_SOCKETS
; 749  : }

  00035	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5f		 pop	 rdi
  0003f	c3		 ret	 0
closeAllListeningSockets ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT serveClient
_TEXT	SEGMENT
portNumber$1 = 64
ipstr$ = 80
addr$ = 144
ipAddress$2 = 272
s_client$ = 368
RpcAssocGroup$ = 376
to$ = 384
len$ = 392
serveClient PROC					; COMDAT

; 754  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 8d 6c 24 b0	 lea	 rbp, QWORD PTR [rsp-80]
  0000d	48 81 ec 50 01
	00 00		 sub	 rsp, 336		; 00000150H

; 755  : #	if !defined(NO_TIMEOUT) && !__minix__
; 756  : 
; 757  : #	ifndef _WIN32 // Standard Posix timeout structure
; 758  : 
; 759  : 	struct timeval to;
; 760  : 	to.tv_sec = ServerTimeout;
; 761  : 	to.tv_usec = 0;
; 762  : 
; 763  : #else // Windows requires a DWORD with milliseconds
; 764  : 
; 765  : 	DWORD to = ServerTimeout * 1000;

  00014	69 05 00 00 00
	00 e8 03 00 00	 imul	 eax, DWORD PTR ServerTimeout, 1000 ; 000003e8H
  0001e	8b f2		 mov	 esi, edx

; 766  : 
; 767  : #	endif // _WIN32
; 768  : 
; 769  : #	if !defined(NO_LOG) && defined(_PEDANTIC)
; 770  : 
; 771  : 	int result =
; 772  : 		setsockopt(s_client, SOL_SOCKET, SO_RCVTIMEO, (sockopt_t)&to, sizeof(to)) ||
; 773  : 		setsockopt(s_client, SOL_SOCKET, SO_SNDTIMEO, (sockopt_t)&to, sizeof(to));
; 774  : 
; 775  : 	if (result) logger("Warning: Set timeout failed: %s\n", vlmcsd_strerror(socket_errno));
; 776  : 
; 777  : #	else // !(!defined(NO_LOG) && defined(_PEDANTIC))
; 778  : 
; 779  : 	setsockopt(s_client, SOL_SOCKET, SO_RCVTIMEO, (sockopt_t)&to, sizeof(to));

  00020	bf ff ff 00 00	 mov	 edi, 65535		; 0000ffffH
  00025	4c 8d 8d 80 00
	00 00		 lea	 r9, QWORD PTR to$[rbp-256]
  0002c	41 b8 06 10 00
	00		 mov	 r8d, 4102		; 00001006H
  00032	8b d7		 mov	 edx, edi
  00034	48 8b d9	 mov	 rbx, rcx
  00037	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0003f	89 85 80 00 00
	00		 mov	 DWORD PTR to$[rbp-256], eax
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 780  : 	setsockopt(s_client, SOL_SOCKET, SO_SNDTIMEO, (sockopt_t)&to, sizeof(to));

  0004b	4c 8d 8d 80 00
	00 00		 lea	 r9, QWORD PTR to$[rbp-256]
  00052	41 b8 05 10 00
	00		 mov	 r8d, 4101		; 00001005H
  00058	8b d7		 mov	 edx, edi
  0005a	48 8b cb	 mov	 rcx, rbx
  0005d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setsockopt

; 781  : 
; 782  : #   endif // !(!defined(NO_LOG) && defined(_PEDANTIC))
; 783  : 
; 784  : #	endif // !defined(NO_TIMEOUT) && !__minix__
; 785  : 
; 786  : 	char ipstr[64];
; 787  : 	socklen_t len;
; 788  : 	struct sockaddr_storage addr;
; 789  : 
; 790  : 	len = sizeof(addr);
; 791  : 
; 792  : 	if (getpeername(s_client, (struct sockaddr*)&addr, &len) ||
; 793  : 		!ip2str(ipstr, sizeof(ipstr), (struct sockaddr*)&addr, len))

  0006b	4c 8d 85 88 00
	00 00		 lea	 r8, QWORD PTR len$[rbp-256]
  00072	48 8d 55 90	 lea	 rdx, QWORD PTR addr$[rbp-256]
  00076	48 8b cb	 mov	 rcx, rbx
  00079	c7 85 88 00 00
	00 80 00 00 00	 mov	 DWORD PTR len$[rbp-256], 128 ; 00000080H
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getpeername
  00089	85 c0		 test	 eax, eax
  0008b	0f 85 dd 00 00
	00		 jne	 $LN4@serveClien
  00091	8b 95 88 00 00
	00		 mov	 edx, DWORD PTR len$[rbp-256]
  00097	48 8d 44 24 40	 lea	 rax, QWORD PTR portNumber$1[rsp]
  0009c	c7 44 24 30 0a
	00 00 00	 mov	 DWORD PTR [rsp+48], 10
  000a4	4c 8d 45 10	 lea	 r8, QWORD PTR ipAddress$2[rbp-256]
  000a8	48 8d 4d 90	 lea	 rcx, QWORD PTR addr$[rbp-256]
  000ac	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  000b2	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR [rsp+40], 8
  000ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getnameinfo
  000c5	85 c0		 test	 eax, eax
  000c7	0f 85 a1 00 00
	00		 jne	 $LN4@serveClien
  000cd	4c 8d 4c 24 40	 lea	 r9, QWORD PTR portNumber$1[rsp]
  000d2	4c 8d 45 10	 lea	 r8, QWORD PTR ipAddress$2[rbp-256]
  000d6	48 8d 55 90	 lea	 rdx, QWORD PTR addr$[rbp-256]
  000da	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ipstr$[rsp]
  000df	e8 00 00 00 00	 call	 ip2str
  000e4	84 c0		 test	 al, al
  000e6	0f 84 82 00 00
	00		 je	 $LN4@serveClien

; 799  : 		return;
; 800  : 	}
; 801  : 
; 802  : 
; 803  : #	ifndef NO_LOG
; 804  : 	const char *const connection_type = addr.ss_family == AF_INET6 ? cIPv6 : cIPv4;

  000ec	66 83 7d 90 17	 cmp	 WORD PTR addr$[rbp-256], 23
  000f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_04HOFDLIOP@IPv6?$AA@
  000f8	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:??_C@_04EMGFNKGN@IPv4?$AA@
  000ff	48 0f 44 f8	 cmove	 rdi, rax

; 805  : 	static const char *const cAccepted = "accepted";
; 806  : 	static const char *const cClosed = "closed";
; 807  : 	static const char *const fIP = "%s connection %s: %s.\n";
; 808  : 
; 809  : 	logger(fIP, connection_type, cAccepted, ipstr);

  00103	4c 8d 4c 24 50	 lea	 r9, QWORD PTR ipstr$[rsp]
  00108	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_08LMOPGBBD@accepted?$AA@
  0010f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6?$AA@
  00116	48 8b d7	 mov	 rdx, rdi
  00119	e8 00 00 00 00	 call	 logger

; 810  : #endif // NO_LOG
; 811  : 
; 812  : #	if !defined(NO_PRIVATE_IP_DETECT)
; 813  : 
; 814  : 	if (!(PublicIPProtectionLevel & 2) || isPrivateIPAddress((struct sockaddr*)&addr, NULL))

  0011e	f6 05 00 00 00
	00 02		 test	 BYTE PTR PublicIPProtectionLevel, 2
  00125	74 1d		 je	 SHORT $LN2@serveClien
  00127	48 8d 4d 90	 lea	 rcx, QWORD PTR addr$[rbp-256]
  0012b	33 d2		 xor	 edx, edx
  0012d	e8 00 00 00 00	 call	 isPrivateIPAddress
  00132	84 c0		 test	 al, al
  00134	75 0e		 jne	 SHORT $LN2@serveClien

; 817  : 	}
; 818  : #	ifndef NO_LOG
; 819  : 	else
; 820  : 	{
; 821  : 		logger("Client with public IP address rejected\n");

  00136	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CI@MHIGHDIH@Client?5with?5public?5IP?5address?5re@
  0013d	e8 00 00 00 00	 call	 logger
  00142	eb 0f		 jmp	 SHORT $LN1@serveClien
$LN2@serveClien:

; 815  : 	{
; 816  : 		rpcServer(s_client, RpcAssocGroup, ipstr);

  00144	4c 8d 44 24 50	 lea	 r8, QWORD PTR ipstr$[rsp]
  00149	8b d6		 mov	 edx, esi
  0014b	48 8b cb	 mov	 rcx, rbx
  0014e	e8 00 00 00 00	 call	 rpcServer
$LN1@serveClien:

; 822  : 	}
; 823  : #	endif // NO_LOG
; 824  : 
; 825  : #   else // defined(NO_PRIVATE_IP_DETECT)
; 826  : 
; 827  : 	rpcServer(s_client, RpcAssocGroup, ipstr);
; 828  : 
; 829  : #	endif // defined(NO_PRIVATE_IP_DETECT)
; 830  : 
; 831  : #	ifndef NO_LOG
; 832  : 	logger(fIP, connection_type, cClosed, ipstr);

  00153	4c 8d 4c 24 50	 lea	 r9, QWORD PTR ipstr$[rsp]
  00158	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_06IKJOPBFO@closed?$AA@
  0015f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BH@BBMMHHHK@?$CFs?5connection?5?$CFs?3?5?$CFs?4?6?$AA@
  00166	48 8b d7	 mov	 rdx, rdi
  00169	e8 00 00 00 00	 call	 logger
$LN4@serveClien:

; 794  : 	{
; 795  : #		if !defined(NO_LOG) && defined(_PEDANTIC)
; 796  : 		logger("Fatal: Cannot determine client's IP address: %s\n", vlmcsd_strerror(errno));
; 797  : #		endif // !defined(NO_LOG) && defined(_PEDANTIC)
; 798  : 		socketclose(s_client);

  0016e	48 8b cb	 mov	 rcx, rbx
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 833  : #	endif // NO_LOG
; 834  : 
; 835  : 	socketclose(s_client);
; 836  : }

  00177	48 8b 9c 24 70
	01 00 00	 mov	 rbx, QWORD PTR [rsp+368]
  0017f	48 81 c4 50 01
	00 00		 add	 rsp, 336		; 00000150H
  00186	5f		 pop	 rdi
  00187	5e		 pop	 rsi
  00188	5d		 pop	 rbp
  00189	c3		 ret	 0
serveClient ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT post_sem
_TEXT	SEGMENT
post_sem PROC						; COMDAT

; 841  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 842  : #if !defined(NO_LIMIT) && !__minix__
; 843  : 	if (!InetdMode && MaxTasks != SEM_VALUE_MAX)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  0000b	75 20		 jne	 SHORT $LN1@post_sem
  0000d	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR MaxTasks, 2147483647 ; 7fffffffH
  00017	74 14		 je	 SHORT $LN1@post_sem

; 844  : 	{
; 845  : 		semaphore_post(MaxTaskSemaphore);

  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR MaxTaskSemaphore
  00020	45 33 c0	 xor	 r8d, r8d
  00023	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
$LN1@post_sem:

; 846  : 	}
; 847  : #endif // !defined(NO_LIMIT) && !__minix__
; 848  : }

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
post_sem ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT wait_sem
_TEXT	SEGMENT
wait_sem PROC						; COMDAT

; 852  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 853  : #if !defined(NO_LIMIT) && !__minix__
; 854  : 	if (!InetdMode && MaxTasks != SEM_VALUE_MAX)

  00004	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  0000b	75 1c		 jne	 SHORT $LN1@wait_sem
  0000d	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR MaxTasks, 2147483647 ; 7fffffffH
  00017	74 10		 je	 SHORT $LN1@wait_sem

; 855  : 	{
; 856  : 		semaphore_wait(MaxTaskSemaphore);

  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR MaxTaskSemaphore
  00020	83 ca ff	 or	 edx, -1			; ffffffffH
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
$LN1@wait_sem:

; 857  : 	}
; 858  : #endif // !defined(NO_LIMIT) && !__minix__
; 859  : }

  00029	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002d	c3		 ret	 0
wait_sem ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT serveClientThreadProc
_TEXT	SEGMENT
clData$ = 48
serveClientThreadProc PROC				; COMDAT

; 869  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 870  : 	serveClient(clData->socket, clData->RpcAssocGroup);

  00006	8b 51 08	 mov	 edx, DWORD PTR [rcx+8]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0000f	e8 00 00 00 00	 call	 serveClient

; 871  : 	free(clData);

  00014	48 8b cb	 mov	 rcx, rbx
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 872  : 	post_sem();

  0001d	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  00024	75 20		 jne	 SHORT $LN3@serveClien
  00026	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR MaxTasks, 2147483647 ; 7fffffffH
  00030	74 14		 je	 SHORT $LN3@serveClien
  00032	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR MaxTaskSemaphore
  00039	45 33 c0	 xor	 r8d, r8d
  0003c	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
$LN3@serveClien:

; 873  : 
; 874  : 	return 0;

  00046	33 c0		 xor	 eax, eax

; 875  : }

  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5b		 pop	 rbx
  0004d	c3		 ret	 0
serveClientThreadProc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT serveClientAsyncWinThreads
_TEXT	SEGMENT
thr_CLData$ = 64
serveClientAsyncWinThreads PROC				; COMDAT

; 884  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 885  : 	wait_sem();

  00006	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	75 1c		 jne	 SHORT $LN5@serveClien
  00012	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR MaxTasks, 2147483647 ; 7fffffffH
  0001c	74 10		 je	 SHORT $LN5@serveClien
  0001e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR MaxTaskSemaphore
  00025	83 ca ff	 or	 edx, -1			; ffffffffH
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
$LN5@serveClien:

; 886  : 
; 887  : 	HANDLE h = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)serveClientThreadProc, thr_CLData, 0, NULL);

  0002e	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  00034	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  00039	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:serveClientThreadProc
  00040	4c 8b cb	 mov	 r9, rbx
  00043	33 d2		 xor	 edx, edx
  00045	33 c9		 xor	 ecx, ecx
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateThread

; 888  : 
; 889  : 	if (h)

  0004d	48 85 c0	 test	 rax, rax
  00050	74 11		 je	 SHORT $LN2@serveClien

; 890  : 	{
; 891  : 		CloseHandle(h);

  00052	48 8b c8	 mov	 rcx, rax
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 892  : 		return NO_ERROR;

  0005b	33 c0		 xor	 eax, eax

; 900  : 	}
; 901  : }

  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5b		 pop	 rbx
  00062	c3		 ret	 0
$LN2@serveClien:

; 893  : 	}
; 894  : 	else
; 895  : 	{
; 896  : 		socketclose(thr_CLData->socket);

  00063	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 897  : 		free(thr_CLData);

  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 898  : 		post_sem();

  00075	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  0007c	75 20		 jne	 SHORT $LN8@serveClien
  0007e	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR MaxTasks, 2147483647 ; 7fffffffH
  00088	74 14		 je	 SHORT $LN8@serveClien
  0008a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR MaxTaskSemaphore
  00091	45 33 c0	 xor	 r8d, r8d
  00094	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
$LN8@serveClien:

; 900  : 	}
; 901  : }

  0009e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a2	5b		 pop	 rbx

; 899  : 		return GetLastError();

  000a3	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_GetLastError
serveClientAsyncWinThreads ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT serveClientAsync
_TEXT	SEGMENT
s_client$ = 64
RpcAssocGroup$ = 72
serveClientAsync PROC					; COMDAT

; 989  : {

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 8b d9	 mov	 rbx, rcx

; 990  : #ifndef USE_THREADS // fork() implementation
; 991  : 
; 992  : 	return ServeClientAsyncFork(s_client, RpcAssocGroup);
; 993  : 
; 994  : #else // threads implementation
; 995  : 
; 996  : 	PCLDATA thr_CLData = (PCLDATA)vlmcsd_malloc(sizeof(CLDATA));

  00012	b9 10 00 00 00	 mov	 ecx, 16
  00017	8b fa		 mov	 edi, edx
  00019	e8 00 00 00 00	 call	 vlmcsd_malloc
  0001e	48 8b f0	 mov	 rsi, rax

; 997  : 	thr_CLData->socket = s_client;

  00021	48 89 18	 mov	 QWORD PTR [rax], rbx

; 998  : 	thr_CLData->RpcAssocGroup = RpcAssocGroup;
; 999  : 
; 1000 : #if defined(_WIN32) || defined (__CYGWIN__) // Windows threads
; 1001 : 
; 1002 : 	return serveClientAsyncWinThreads(thr_CLData);

  00024	33 db		 xor	 ebx, ebx
  00026	89 78 08	 mov	 DWORD PTR [rax+8], edi
  00029	38 1d 00 00 00
	00		 cmp	 BYTE PTR InetdMode, bl
  0002f	bf ff ff ff 7f	 mov	 edi, 2147483647		; 7fffffffH
  00034	75 18		 jne	 SHORT $LN7@serveClien
  00036	39 3d 00 00 00
	00		 cmp	 DWORD PTR MaxTasks, edi
  0003c	74 10		 je	 SHORT $LN7@serveClien
  0003e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR MaxTaskSemaphore
  00045	83 ca ff	 or	 edx, -1			; ffffffffH
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
$LN7@serveClien:
  0004e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:serveClientThreadProc
  00055	4c 8b ce	 mov	 r9, rsi
  00058	33 d2		 xor	 edx, edx
  0005a	33 c9		 xor	 ecx, ecx
  0005c	48 89 5c 24 28	 mov	 QWORD PTR [rsp+40], rbx
  00061	89 5c 24 20	 mov	 DWORD PTR [rsp+32], ebx
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateThread
  0006b	48 85 c0	 test	 rax, rax
  0006e	74 0b		 je	 SHORT $LN4@serveClien
  00070	48 8b c8	 mov	 rcx, rax
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00079	eb 3e		 jmp	 SHORT $LN3@serveClien
$LN4@serveClien:
  0007b	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  00084	48 8b ce	 mov	 rcx, rsi
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  0008d	38 1d 00 00 00
	00		 cmp	 BYTE PTR InetdMode, bl
  00093	75 1c		 jne	 SHORT $LN10@serveClien
  00095	39 3d 00 00 00
	00		 cmp	 DWORD PTR MaxTasks, edi
  0009b	74 14		 je	 SHORT $LN10@serveClien
  0009d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR MaxTaskSemaphore
  000a4	45 33 c0	 xor	 r8d, r8d
  000a7	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
$LN10@serveClien:
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  000b7	8b d8		 mov	 ebx, eax
$LN3@serveClien:

; 1003 : 
; 1004 : #else // Posix Threads
; 1005 : 
; 1006 : 	return ServeClientAsyncPosixThreads(thr_CLData);
; 1007 : 
; 1008 : #endif // Posix Threads
; 1009 : 
; 1010 : #endif // USE_THREADS
; 1011 : }

  000b9	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000be	8b c3		 mov	 eax, ebx
  000c0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c9	5f		 pop	 rdi
  000ca	c3		 ret	 0
serveClientAsync ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\apple\desktop\vlmcsd\src\network.c
;	COMDAT runServer
_TEXT	SEGMENT
ListeningSocketsList$1 = 48
runServer PROC						; COMDAT

; 1017 : {

$LN88:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 40 02
	00 00		 sub	 rsp, 576		; 00000240H

; 1018 : 	DWORD RpcAssocGroup = rand32();

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00018	8b d8		 mov	 ebx, eax
  0001a	c1 e3 0f	 shl	 ebx, 15
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00023	0b d8		 or	 ebx, eax
  00025	c1 e3 02	 shl	 ebx, 2
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  0002e	8b f0		 mov	 esi, eax
  00030	83 e6 03	 and	 esi, 3
  00033	0b f3		 or	 esi, ebx

; 1019 : 
; 1020 : 	// If compiled for inetd-only mode just serve the stdin socket
; 1021 : #ifdef NO_SOCKETS
; 1022 : 	serveClient(STDIN_FILENO, RpcAssocGroup);
; 1023 : 	return 0;
; 1024 : #else
; 1025 : // In inetd mode just handle the stdin socket
; 1026 : 	if (InetdMode)

  00035	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  0003c	74 10		 je	 SHORT $LL6@runServer

; 1027 : 	{
; 1028 : 		serveClient(STDIN_FILENO, RpcAssocGroup);

  0003e	8b d6		 mov	 edx, esi
  00040	33 c9		 xor	 ecx, ecx
  00042	e8 00 00 00 00	 call	 serveClient
$LN86@runServer:

; 1029 : 		return 0;

  00047	33 c0		 xor	 eax, eax
  00049	e9 f3 00 00 00	 jmp	 $LN5@runServer
$LL6@runServer:

; 1030 : 	}
; 1031 : 
; 1032 : 	for (;;)
; 1033 : 	{
; 1034 : 		int error;
; 1035 : 		SOCKET s_client;
; 1036 : 
; 1037 : #		ifdef SIMPLE_SOCKETS
; 1038 : 		if ((s_client = accept(s_server, NULL, NULL)) == INVALID_SOCKET)
; 1039 : #		else // Standalone mode fully featured sockets
; 1040 : 		if ((s_client = network_accept_any()) == INVALID_SOCKET)

  0004e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR numsockets
  00054	33 c9		 xor	 ecx, ecx
  00056	45 33 c9	 xor	 r9d, r9d
  00059	89 4c 24 30	 mov	 DWORD PTR ListeningSocketsList$1[rsp], ecx
  0005d	85 c0		 test	 eax, eax
  0005f	7e 4b		 jle	 SHORT $LN27@runServer
  00061	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR SocketList
  00068	44 8b d8	 mov	 r11d, eax
$LL29@runServer:
  0006b	33 d2		 xor	 edx, edx
  0006d	85 c9		 test	 ecx, ecx
  0006f	74 10		 je	 SHORT $LN50@runServer
  00071	4d 8b 10	 mov	 r10, QWORD PTR [r8]
$LL23@runServer:
  00074	4c 39 54 d4 38	 cmp	 QWORD PTR ListeningSocketsList$1[rsp+rdx*8+8], r10
  00079	74 06		 je	 SHORT $LN50@runServer
  0007b	ff c2		 inc	 edx
  0007d	3b d1		 cmp	 edx, ecx
  0007f	72 f3		 jb	 SHORT $LL23@runServer
$LN50@runServer:
  00081	3b d1		 cmp	 edx, ecx
  00083	75 17		 jne	 SHORT $LN25@runServer
  00085	83 f9 40	 cmp	 ecx, 64			; 00000040H
  00088	73 12		 jae	 SHORT $LN25@runServer
  0008a	49 8b 00	 mov	 rax, QWORD PTR [r8]
  0008d	48 89 44 d4 38	 mov	 QWORD PTR ListeningSocketsList$1[rsp+rdx*8+8], rax
  00092	8b 4c 24 30	 mov	 ecx, DWORD PTR ListeningSocketsList$1[rsp]
  00096	ff c1		 inc	 ecx
  00098	89 4c 24 30	 mov	 DWORD PTR ListeningSocketsList$1[rsp], ecx
$LN25@runServer:
  0009c	4d 39 08	 cmp	 QWORD PTR [r8], r9
  0009f	4d 0f 47 08	 cmova	 r9, QWORD PTR [r8]
  000a3	49 83 c0 08	 add	 r8, 8
  000a7	49 ff cb	 dec	 r11
  000aa	75 bf		 jne	 SHORT $LL29@runServer
$LN27@runServer:
  000ac	48 83 64 24 20
	00		 and	 QWORD PTR [rsp+32], 0
  000b2	41 8d 49 01	 lea	 ecx, DWORD PTR [r9+1]
  000b6	48 8d 54 24 30	 lea	 rdx, QWORD PTR ListeningSocketsList$1[rsp]
  000bb	45 33 c9	 xor	 r9d, r9d
  000be	45 33 c0	 xor	 r8d, r8d
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_select
  000c7	85 c0		 test	 eax, eax
  000c9	78 33		 js	 SHORT $LN71@runServer
  000cb	33 db		 xor	 ebx, ebx
  000cd	33 ff		 xor	 edi, edi
  000cf	39 1d 00 00 00
	00		 cmp	 DWORD PTR numsockets, ebx
  000d5	7e 27		 jle	 SHORT $LN71@runServer
$LL15@runServer:
  000d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR SocketList
  000de	48 8d 54 24 30	 lea	 rdx, QWORD PTR ListeningSocketsList$1[rsp]
  000e3	48 8b 0c d9	 mov	 rcx, QWORD PTR [rcx+rbx*8]
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___WSAFDIsSet
  000ed	85 c0		 test	 eax, eax
  000ef	75 65		 jne	 SHORT $LN51@runServer
  000f1	ff c7		 inc	 edi
  000f3	48 ff c3	 inc	 rbx
  000f6	3b 3d 00 00 00
	00		 cmp	 edi, DWORD PTR numsockets
  000fc	7c d9		 jl	 SHORT $LL15@runServer
$LN71@runServer:

; 1041 : #		endif // Standalone mode fully featured sockets
; 1042 : 		{
; 1043 : 			error = socket_errno;

  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00104	8b d8		 mov	 ebx, eax

; 1044 : 			if (error == SOCKET_EINTR || error == SOCKET_ECONNABORTED) continue;

  00106	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  0010b	0f 84 3d ff ff
	ff		 je	 $LL6@runServer
  00111	3d 45 27 00 00	 cmp	 eax, 10053		; 00002745H
  00116	0f 84 32 ff ff
	ff		 je	 $LL6@runServer

; 1045 : 
; 1046 : #			ifdef _NTSERVICE
; 1047 : 			if (ServiceShutdown) return 0;

  0011c	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ServiceShutdown, 0
  00123	0f 85 1e ff ff
	ff		 jne	 $LN86@runServer

; 1048 : #			endif
; 1049 : 
; 1050 : #			ifndef NO_LOG
; 1051 : 			logger("Fatal: %s\n", vlmcsd_strerror(error));

  00129	8b c8		 mov	 ecx, eax
  0012b	e8 00 00 00 00	 call	 win_strerror
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0L@DGCMIMNM@Fatal?3?5?$CFs?6?$AA@
  00137	48 8b d0	 mov	 rdx, rax
  0013a	e8 00 00 00 00	 call	 logger

; 1052 : #			endif
; 1053 : 
; 1054 : 			return error;

  0013f	8b c3		 mov	 eax, ebx
$LN5@runServer:

; 1072 : #	endif // NO_SOCKETS
; 1073 : }

  00141	4c 8d 9c 24 40
	02 00 00	 lea	 r11, QWORD PTR [rsp+576]
  00149	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0014d	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00151	49 8b e3	 mov	 rsp, r11
  00154	5f		 pop	 rdi
  00155	c3		 ret	 0
$LN51@runServer:

; 1030 : 	}
; 1031 : 
; 1032 : 	for (;;)
; 1033 : 	{
; 1034 : 		int error;
; 1035 : 		SOCKET s_client;
; 1036 : 
; 1037 : #		ifdef SIMPLE_SOCKETS
; 1038 : 		if ((s_client = accept(s_server, NULL, NULL)) == INVALID_SOCKET)
; 1039 : #		else // Standalone mode fully featured sockets
; 1040 : 		if ((s_client = network_accept_any()) == INVALID_SOCKET)

  00156	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR SocketList
  0015d	48 8b 0c d8	 mov	 rcx, QWORD PTR [rax+rbx*8]
  00161	48 83 f9 ff	 cmp	 rcx, -1
  00165	74 97		 je	 SHORT $LN71@runServer
  00167	45 33 c0	 xor	 r8d, r8d
  0016a	33 d2		 xor	 edx, edx
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_accept
  00172	48 8b f8	 mov	 rdi, rax
  00175	48 83 f8 ff	 cmp	 rax, -1
  00179	74 83		 je	 SHORT $LN71@runServer

; 1055 : 		}
; 1056 : 
; 1057 : 		RpcAssocGroup++;
; 1058 : 
; 1059 : #		if !defined(NO_LOG) && defined(_PEDANTIC)
; 1060 : 		if ((error = serveClientAsync(s_client, RpcAssocGroup)))
; 1061 : 		{
; 1062 : #			ifdef USE_THREADS
; 1063 : 			logger("Warning: Could not create client thread: %s\n", vlmcsd_strerror(error));
; 1064 : #			else // !USE_THREADS
; 1065 : 			logger("Warning: Could not fork client: %s\n", vlmcsd_strerror(error));
; 1066 : #			endif // !USE_THREADS
; 1067 : 		}
; 1068 : #		else // NO_LOG || !_PEDANTIC
; 1069 : 		serveClientAsync(s_client, RpcAssocGroup);

  0017b	b9 10 00 00 00	 mov	 ecx, 16
  00180	ff c6		 inc	 esi
  00182	e8 00 00 00 00	 call	 vlmcsd_malloc
  00187	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  0018e	48 89 38	 mov	 QWORD PTR [rax], rdi
  00191	89 70 08	 mov	 DWORD PTR [rax+8], esi
  00194	48 8b d8	 mov	 rbx, rax
  00197	75 1c		 jne	 SHORT $LN38@runServer
  00199	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR MaxTasks, 2147483647 ; 7fffffffH
  001a3	74 10		 je	 SHORT $LN38@runServer
  001a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR MaxTaskSemaphore
  001ac	83 ca ff	 or	 edx, -1			; ffffffffH
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
$LN38@runServer:
  001b5	48 83 64 24 28
	00		 and	 QWORD PTR [rsp+40], 0
  001bb	83 64 24 20 00	 and	 DWORD PTR [rsp+32], 0
  001c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:serveClientThreadProc
  001c7	4c 8b cb	 mov	 r9, rbx
  001ca	33 d2		 xor	 edx, edx
  001cc	33 c9		 xor	 ecx, ecx
  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateThread
  001d4	48 85 c0	 test	 rax, rax
  001d7	74 0e		 je	 SHORT $LN35@runServer
  001d9	48 8b c8	 mov	 rcx, rax
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  001e2	e9 67 fe ff ff	 jmp	 $LL6@runServer
$LN35@runServer:
  001e7	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  001f0	48 8b cb	 mov	 rcx, rbx
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
  001f9	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR InetdMode, 0
  00200	75 20		 jne	 SHORT $LN41@runServer
  00202	81 3d 00 00 00
	00 ff ff ff 7f	 cmp	 DWORD PTR MaxTasks, 2147483647 ; 7fffffffH
  0020c	74 14		 je	 SHORT $LN41@runServer
  0020e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR MaxTaskSemaphore
  00215	45 33 c0	 xor	 r8d, r8d
  00218	41 8d 50 01	 lea	 edx, QWORD PTR [r8+1]
  0021c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReleaseSemaphore
$LN41@runServer:
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError

; 1070 : #		endif // NO_LOG || !_PEDANTIC
; 1071 : 	}

  00228	e9 21 fe ff ff	 jmp	 $LL6@runServer
runServer ENDP
_TEXT	ENDS
END
